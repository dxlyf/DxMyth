(function(r,S){typeof exports=="object"&&typeof module<"u"?S(exports):typeof define=="function"&&define.amd?define(["exports"],S):(r=typeof globalThis<"u"?globalThis:r||self,S((r.dxMyth=r.dxMyth||{},r.dxMyth.tapable={})))})(this,function(r){"use strict";const S=()=>{console.warn("Hook.context is deprecated and will be removed")};class d{interceptors;taps;name;constructor(t){this.name=t,this.taps=[],this.interceptors=[]}_tap(t,e,o){if(typeof e=="string")e={name:e.trim()};else if(typeof e!="object"||e===null)throw new Error("Invalid tap options");if(typeof e.name!="string"||e.name==="")throw new Error("Missing name for tap");typeof e.context<"u"&&S(),e=Object.assign({type:t,fn:o},e),e=this._runRegisterInterceptors(e),this._insert(e)}tap(t,e){this._tap("sync",t,e)}tapAsync(t,e){this._tap("async",t,e)}tapPromise(t,e){this._tap("promise",t,e)}_runRegisterInterceptors(t){for(const e of this.interceptors)if(e.register){const o=e.register(t);o!==void 0&&(t=o)}return t}withOptions(t){const e=o=>Object.assign({},t,typeof o=="string"?{name:o}:o);return{name:this.name,tap:(o,s)=>this.tap(e(o),s),tapAsync:(o,s)=>this.tapAsync(e(o),s),tapPromise:(o,s)=>this.tapPromise(e(o),s),intercept:o=>this.intercept(o),isUsed:()=>this.isUsed(),withOptions:o=>this.withOptions(e(o))}}isUsed(){return this.taps.length>0||this.interceptors.length>0}intercept(t){if(this.interceptors.push(Object.assign({},t)),t.register)for(let e=0;e<this.taps.length;e++){let o=t.register(this.taps[e]);o&&(this.taps[e]=o)}}callIntercept(t,e=[],o){if(!(this.interceptors.length<=0))for(const s of this.interceptors)s[t]&&typeof s[t]=="function"&&(s.context&&o?s[t](o,...e):s[t](...e))}needContext(){return this.taps.some(t=>t.context!==void 0)}_insert(t){let e;typeof t.before=="string"?e=new Set([t.before]):Array.isArray(t.before)&&(e=new Set(t.before));let o=0;typeof t.stage=="number"&&(o=t.stage);let s=this.taps.length;for(;s>0;){s--;const n=this.taps[s];this.taps[s+1]=n;const m=n.stage||0;if(e){if(e.has(n.name)){e.delete(n.name);continue}if(e.size>0)continue}if(!(m>o)){s++;break}}this.taps[s]=t}callTapsSeries(t,e,o){const s=this.needContext(),n=s?{}:void 0;this.callIntercept("call",e,s?n:void 0);const m=this.taps,P=m.length;let y=0;const x=l=>l?(this.callIntercept("error",e,n||void 0),o(l),!0):!1,H=l=>y>=P||(t==="Bail"||t==="Loop")&&l!==void 0?(t=="Waterfall"&&(l=e[0]),l!==void 0?this.callIntercept("result",[l],n||void 0):this.callIntercept("done"),o(null,t=="Normal"?void 0:l),!0):!1,i=(l,u)=>{if(x(l))return;if(t=="Loop"&&u!==void 0){y=0,i(null);return}if(t==="Waterfall"&&u!==void 0&&(e[0]=u),H(u))return;const p=m[y];y===0&&t=="Loop"&&this.callIntercept("loop",e,s?n:void 0),this.callIntercept("tap",[p],n||void 0),y++;try{switch(p.type){case"sync":p.context?u=p.fn(n,...e):u=p.fn(...e);break;case"async":p.context?p.fn(n,...e,i):p.fn(...e,i);return;case"promise":let h;p.context?h=p.fn(n,...e):h=p.fn(...e),h&&typeof h.then=="function"&&typeof h.catch=="function"?h.then(A=>{i(null,A)}).catch(A=>{i(A)}):i(`Tap function (tapPromise) did not return promise (returned ' + _promise${y} + ')');
`);return}}catch(h){i(h);return}i(null,u)};i(null)}callTapsLooping(t,e){this.callTapsSeries("Loop",t,(o,s)=>{if(o){e(o);return}e()})}callTapsParallel(t,e,o,s){if(this.taps.length<=1){this.callTapsSeries(t,o,s);return}let n=this.taps.length,m=this.taps,P=0,y=n,x=new Array(n);const H=this.needContext(),i=H?{}:void 0;this.callIntercept("call",o,H?i:void 0);let l=!1;const u=a=>{l||(this.callIntercept("error",o,i||void 0),s(a),l=!0)},p=a=>{l||(t=="Waterfall"&&(a=o[0]),a!==void 0?this.callIntercept("result",[a],i||void 0):this.callIntercept("done"),s(null,t=="Normal"?void 0:a),l=!0)},h=a=>(c,w)=>{if(!l){if(x[a]={err:c,result:w},y--,c){u(c);return}if(t=="Bail"&&w!==void 0){p(w);return}if(y<=0){p(w);return}}},A=a=>{let c=m[a],w;this.callIntercept("tap",[c],i||void 0);try{switch(c.type){case"sync":c.context?w=c.fn(i,...o):w=c.fn(...o),h(a)(null,w);break;case"async":c.context?c.fn(i,...o,h(a+1)):c.fn(...o,h(a));return;case"promise":let k;c.context?k=c.fn(i,...o):k=c.fn(...o),k&&typeof k.then=="function"&&typeof k.catch=="function"?k.then(v=>{h(a)(null,v)}).catch(v=>{u(v)}):u(`Tap function (tapPromise) did not return promise (returned ' + _promise${P} + ')');
`);return}}catch(k){u(k);return}h(a)(null,w)};(()=>{let a=0;for(;a<e&&n>0;)A(P+a),a++,n--;P+=a})()}}class b extends d{constructor(t){super(t)}call(...t){this.callTapsSeries("Normal",t,e=>{if(e)throw e})}callAsync(...t){let e=t.pop();this.callTapsSeries("Normal",t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsSeries("Normal",t,(s,n)=>{if(s){o(s);return}e(n)})})}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}class E extends d{constructor(t){super(t)}call(...t){let e;return this.callTapsSeries("Bail",t,(o,s)=>{if(o)throw o;e=s}),e}callAsync(...t){let e=t.pop();this.callTapsSeries("Bail",t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsSeries("Bail",t,(s,n)=>{if(s){o(s);return}e(n)})})}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}class B extends d{constructor(t){super(t)}call(...t){let e;return this.callTapsSeries("Waterfall",t,(o,s)=>{if(o)throw o;e=s}),e}callAsync(...t){let e=t.pop();this.callTapsSeries("Waterfall",t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsSeries("Waterfall",t,(s,n)=>{if(s){o(s);return}e(n)})})}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}class _ extends d{constructor(t){super(t)}call(...t){let e;return this.callTapsLooping(t,(o,s)=>{if(o)throw o;e=s}),e}callAsync(...t){let e=t.pop();this.callTapsLooping(t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsLooping(t,(s,n)=>{if(s){o(s);return}e(n)})})}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}class I extends d{maxParallel=10;constructor(t){super(t)}call(...t){throw new Error("call is not supported on a AsyncSeriesBailHook")}callAsync(...t){let e=t.pop();this.callTapsParallel("Normal",this.maxParallel,t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsParallel("Normal",this.maxParallel,t,(s,n)=>{if(s){o(s);return}e(n)})})}}class g extends d{maxParallel=10;constructor(t){super(t)}call(...t){throw new Error("call is not supported on a AsyncSeriesBailHook")}callAsync(...t){let e=t.pop();this.callTapsParallel("Bail",this.maxParallel,t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsParallel("Bail",this.maxParallel,t,(s,n)=>{if(s){o(s);return}e(n)})})}}class L extends d{constructor(t){super(t)}call(...t){throw new Error("call is not supported on a AsyncSeriesHook")}callAsync(...t){let e=t.pop();this.callTapsSeries("Normal",t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsSeries("Normal",t,(s,n)=>{if(s){o(s);return}e(n)})})}}class C extends d{constructor(t){super(t)}call(...t){throw new Error("call is not supported on a AsyncSeriesBailHook")}callAsync(...t){let e=t.pop();this.callTapsSeries("Bail",t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsSeries("Bail",t,(s,n)=>{if(s){o(s);return}e(n)})})}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}class O extends d{constructor(t){super(t)}call(...t){throw new Error("Method not implemented.")}callAsync(...t){let e=t.pop();this.callTapsLooping(t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsLooping(t,(s,n)=>{if(s){o(s);return}e(n)})})}}class W extends d{constructor(t){super(t)}call(...t){throw new Error("call is not supported on a SyncHook")}callAsync(...t){let e=t.pop();this.callTapsSeries("Waterfall",t,e)}promise(...t){return new Promise((e,o)=>{this.callTapsSeries("Waterfall",t,(s,n)=>{if(s){o(s);return}e(n)})})}}const M=(f,t)=>t;class N{_map;name;_factory;_interceptors;constructor(t,e){this._map=new Map,this.name=e,this._factory=t,this._interceptors=[]}get(t){return this._map.get(t)}for(t){const e=this.get(t);if(e!==void 0)return e;let o=this._factory(t);const s=this._interceptors;for(let n=0;n<s.length;n++){let m=s[n];m.factory&&(o=m.factory(t,o))}return this._map.set(t,o),o}intercept(t){this._interceptors.push(Object.assign({factory:M},t))}}class T{hooks;name;constructor(t,e){this.hooks=t,this.name=e}tap(t,e){for(const o of this.hooks)o.tap(t,e)}tapAsync(t,e){for(const o of this.hooks)o.tapAsync(t,e)}tapPromise(t,e){for(const o of this.hooks)o.tapPromise(t,e)}isUsed(){for(const t of this.hooks)if(t.isUsed())return!0;return!1}intercept(t){for(const e of this.hooks)e.intercept(t)}withOptions(t){return new T(this.hooks.map(e=>e.withOptions(t)),this.name)}}r.AsyncParallelBailHook=g,r.AsyncParallelHook=I,r.AsyncSeriesBailHook=C,r.AsyncSeriesHook=L,r.AsyncSeriesLoopHook=O,r.AsyncSeriesWaterfallHook=W,r.Hook=d,r.HookMap=N,r.MultiHook=T,r.SyncBailHook=E,r.SyncHook=b,r.SyncLoopHook=_,r.SyncWaterfallHook=B,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});
