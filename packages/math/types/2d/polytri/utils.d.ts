/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
declare var EPSILON: number;
/**
 * @private
 * @enum {number}
 * @readonly
 */
declare var Orientation: {
    CW: number;
    CCW: number;
    COLLINEAR: number;
};
/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
declare function orient2d(pa: any, pb: any, pc: any): number;
/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
declare function inScanArea(pa: any, pb: any, pc: any, pd: any): boolean;
/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
declare function isAngleObtuse(pa: any, pb: any, pc: any): boolean;
export { orient2d, inScanArea, isAngleObtuse, Orientation, EPSILON, };
