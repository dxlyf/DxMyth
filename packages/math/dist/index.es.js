function jo(r, e, n) {
  return r[0] = e, r[1] = n, r;
}
function $f(r, e, n, i, s) {
  let o = e, a = n, h = Math.sqrt(o * o + a * a);
  if (h === 0 || !Number.isFinite(h))
    return !1;
  let c = i / h;
  return e *= c, n *= c, r[0] = e, r[1] = n, !0;
}
function Yg(r, e) {
  return r[0] = e, r[1] = e, r;
}
function ec(r, e, n) {
  return r[0] = e[0] + n[0], r[1] = e[1] + n[1], r;
}
function Pr(r, e, n) {
  return r[0] = e[0] - n[0], r[1] = e[1] - n[1], r;
}
function qs(r, e, n) {
  return r[0] = e[0] * n[0], r[1] = e[1] * n[1], r;
}
function nc(r, e, n) {
  return r[0] = e[0] * n, r[1] = e[1] * n, r;
}
function Ir(r, e, n) {
  return r[0] = e[0] / n[0], r[1] = e[1] / n[1], r;
}
function nh(r, e) {
  return r[0] * e[0] + r[1] * e[1];
}
function ol(r, e) {
  return r[0] * e[1] - r[1] * e[0];
}
function Vf(r, e) {
  return Math.sqrt((r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]));
}
function Uf(r, e) {
  return (r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]);
}
function Wf(r) {
  return r[0] * r[0] + r[1] * r[1];
}
function xo(r) {
  return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
}
function jf(r, e) {
  return Math.abs(r[0] - e[0]) + Math.abs(r[1] - e[1]);
}
function Yf(r, e) {
  return Math.max(Math.abs(r[0] - e[0]), Math.abs(r[1] - e[1]));
}
function ih(r, e) {
  const n = xo(e);
  return r[0] = e[0] / n, r[1] = e[1] / n, r;
}
function al(r, e, n, i) {
  return r[0] = e[0] + (n[0] - e[0]) * i, r[1] = e[1] + (n[1] - e[1]) * i, r;
}
function Hf(r, e, n, i) {
  i = i < 0 ? 0 : i > 1 ? 1 : i;
  const s = i * i * (3 - 2 * i);
  return al(r, e, n, s);
}
function Xf(r) {
  return Math.atan2(r[1], r[0]);
}
function Zf(r, e) {
  return Math.acos(nh(r, e) / (xo(r) * xo(e)));
}
function Hg(r, e = [0, 0]) {
  return Math.atan2(r[1] - e[1], r[0] - e[0]);
}
function Gf(r, e) {
  return Math.atan2(ol(e, r), nh(r, e));
}
function ic(r, e) {
  return r[0] = -e[1], r[1] = e[0], r;
}
function Jf(r, e, n) {
  const i = 2 * (e[0] * n[0] + e[1] * n[1]);
  return r[0] = e[0] - i * n[0], r[1] = e[1] - i * n[1], r;
}
function Xg(r, e, n, i, s) {
  const o = ih(O.default(), n), a = ih(O.default(), e), h = i / s, c = -a.dot(o), l = Math.sqrt(1 - c * c), u = h * l;
  if (u > 1)
    return null;
  const f = Math.sqrt(1 - u * u);
  return a.multiplyScalar(h).add(o.multiplyScalar(h * c - f)), r[0] = a[0], r[1] = a[1], r;
}
function Qf(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function Kf(r, e) {
  return r[0] = Math.abs(e[0]), r[1] = Math.abs(e[1]), r;
}
function t0(r, e) {
  return r[0] = Math.round(e[0]), r[1] = Math.round(e[1]), r;
}
function e0(r, e) {
  return r[0] = Math.floor(e[0]), r[1] = Math.floor(e[1]), r;
}
function n0(r, e) {
  return r[0] = Math.ceil(e[0]), r[1] = Math.ceil(e[1]), r;
}
function i0(r, e, n) {
  return r[0] = Math.min(e[0], n[0]), r[1] = Math.min(e[1], n[1]), r;
}
function s0(r, e, n) {
  return r[0] = Math.max(e[0], n[0]), r[1] = Math.max(e[1], n[1]), r;
}
function r0(r, e, n, i) {
  return r[0] = Math.max(n[0], Math.min(i[0], e[0])), r[1] = Math.max(n[1], Math.min(i[1], e[1])), r;
}
function o0(r, e) {
  return r[0] = e[0] - Math.floor(e[0]), r[1] = e[1] - Math.floor(e[1]), r;
}
function a0(r, e, n) {
  return r[0] = e[0] - n[0] * Math.floor(e[0] / n[0]), r[1] = e[1] - n[1] * Math.floor(e[1] / n[1]), r;
}
function Zg(r, e, n) {
  return r[0] = e[0] - n[0] * Math.ceil(e[0] / n[0]), r[1] = e[1] - n[1] * Math.ceil(e[1] / n[1]), r;
}
function h0(r, e, n) {
  const i = Math.cos(n), s = Math.sin(n), o = e[0], a = e[1];
  return r[0] = o * i - a * s, r[1] = o * s + a * i, r;
}
function c0(r, e, n, i) {
  const s = Math.cos(i), o = Math.sin(i), a = e[0] - n[0], h = e[1] - n[1];
  return r[0] = a * s - h * o + n[0], r[1] = a * o + h * s + n[1], r;
}
function l0(r, e, n, i) {
  return r[0] = e[0] * n, r[1] = e[1] * i, r;
}
function u0(r, e, n, i) {
  return r[0] = (e[0] - n[0]) * i[0] + n[0], r[1] = (e[1] - n[1]) * i[1] + n[1], r;
}
function f0(r, e, n, i) {
  return r[0] = e[0] + n, r[1] = e[1] + i, r;
}
function d0(r, e, n) {
  return r[0] = e[0] * n[0] + e[1] * n[2] + n[4], r[1] = e[0] * n[1] + e[1] * n[3] + n[5], r;
}
function p0(r, e, n) {
  return r[0] = e[0] * n[0] + e[1] * n[4] + n[8], r[1] = e[0] * n[1] + e[1] * n[5] + n[9], r;
}
function Gg(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function Jg(r) {
  return r[0] === 0 && r[1] === 0;
}
function Qg(r, e, n = 1e-6) {
  return Math.abs(r[0] - e[0]) < n && Math.abs(r[1] - e[1]) < n;
}
let O = class extends Float32Array {
  static BYTE_LENGTH = 2 * Float32Array.BYTES_PER_ELEMENT;
  static create(e, n) {
    return new this(e, n);
  }
  static from(e) {
    return this.create(e[0], e[1]);
  }
  static fromPoint(e) {
    return this.create(e.x, e.y);
  }
  static fromRotation(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.create(n, i);
  }
  static default() {
    return this.create(0, 0);
  }
  static zero() {
    return this.create(0, 0);
  }
  static splat(e) {
    return this.create(e, e);
  }
  static makeZeroArray(e) {
    return Array.from({ length: e }, () => this.zero());
  }
  static set = jo;
  static setXY = jo;
  static add = ec;
  static sub = Pr;
  static mul = qs;
  static mulScalar = nc;
  static multiply = qs;
  static div = Ir;
  static divide = Ir;
  static dot = nh;
  static cross = ol;
  static distance = Vf;
  static distanceSquared = Uf;
  static lengthSquared = Wf;
  static length = xo;
  static manhattanDistance = jf;
  static chebyshevDistance = Yf;
  static normalize = ih;
  static lerp = al;
  static smoonthStep = Hf;
  static angle = Xf;
  static angleTo = Zf;
  static angleBetweenPI2 = Gf;
  static perpendicular = ic;
  static perp = ic;
  static reflect = Jf;
  static negate = Qf;
  static abs = Kf;
  static round = t0;
  static floor = e0;
  static ceil = n0;
  static min = i0;
  static max = s0;
  static clamp = r0;
  static fractal = o0;
  static floorMod = a0;
  static rotate = h0;
  static rotateAround = c0;
  static scale = l0;
  static scaleAround = u0;
  static translate = f0;
  static transformMat2d = d0;
  static transformMat3d = p0;
  static equals = Gg;
  static isZero = Jg;
  static equalsEpsilon = Qg;
  constructor(...e) {
    e.length === 0 ? super(2) : Array.isArray(e[0]) ? super(e[0]) : super(e);
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this;
  }
  clone() {
    return this.constructor.create(this[0], this[1]);
  }
  set(e, n) {
    return Array.isArray(e) ? (super.set(e, n), this) : jo(this, e, n);
  }
  setXY(e, n) {
    return jo(this, e, n);
  }
  setLength(e) {
    return $f(this, this.x, this.y, e), this;
  }
  setLengthFromPoint(e, n, i) {
    return $f(this, e, n, i), this;
  }
  setRotation(e) {
    return this.setXY(Math.cos(e), Math.sin(e));
  }
  splat(e) {
    return Yg(this, e);
  }
  add(e) {
    return ec(this, this, e);
  }
  addVectors(e, n) {
    return ec(this, e, n);
  }
  subtract(e) {
    return Pr(this, this, e);
  }
  sub(e) {
    return Pr(this, this, e);
  }
  subVectors(e, n) {
    return Pr(this, e, n);
  }
  subtractVectors(e, n) {
    return Pr(this, e, n);
  }
  mul(e) {
    return qs(this, this, e);
  }
  multiply(e) {
    return qs(this, this, e);
  }
  multiplyVectors(e, n) {
    return qs(this, e, n);
  }
  mulVectors(e, n) {
    return qs(this, e, n);
  }
  mulScalar(e) {
    return nc(this, this, e);
  }
  multiplyScalar(e) {
    return nc(this, this, e);
  }
  div(e) {
    return Ir(this, this, e);
  }
  divide(e) {
    return Ir(this, this, e);
  }
  divideVectors(e, n) {
    return Ir(this, e, n);
  }
  dot(e) {
    return nh(this, e);
  }
  cross(e) {
    return ol(this, e);
  }
  distance(e) {
    return Vf(this, e);
  }
  distanceSquared(e) {
    return Uf(this, e);
  }
  magnitudeSquared() {
    return Wf(this);
  }
  magnitude() {
    return xo(this);
  }
  manhattanDistance(e) {
    return jf(this, e);
  }
  chebyshevDistance(e) {
    return Yf(this, e);
  }
  normalize() {
    return ih(this, this);
  }
  lerp(e, n) {
    return al(this, this, e, n);
  }
  smoonthStep(e, n) {
    return Hf(this, this, e, n);
  }
  angle() {
    return Xf(this);
  }
  angleTo(e) {
    return Zf(this, e);
  }
  angleToOrigin(e) {
    return Hg(this, e);
  }
  angleBetween(e, n) {
    return Gf(e, n);
  }
  perp() {
    return ic(this, this);
  }
  ccw() {
    return this.setXY(this.y, -this.x);
  }
  cw() {
    return this.setXY(-this.y, this.x);
  }
  reflect(e) {
    return Jf(this, this, e);
  }
  refract(e, n, i, s) {
    return Xg(this, e, n, i, s);
  }
  negate() {
    return Qf(this, this);
  }
  abs() {
    return Kf(this, this);
  }
  round() {
    return t0(this, this);
  }
  floor() {
    return e0(this, this);
  }
  ceil() {
    return n0(this, this);
  }
  min(e) {
    return i0(this, this, e);
  }
  max(e) {
    return s0(this, this, e);
  }
  clamp(e, n) {
    return r0(this, this, e, n);
  }
  fractal() {
    return o0(this, this);
  }
  modDown(e) {
    return a0(this, this, e);
  }
  modUp(e) {
    return Zg(this, this, e);
  }
  rotate(e) {
    return h0(this, this, e);
  }
  rotateAround(e, n) {
    return c0(this, this, e, n);
  }
  scale(e, n) {
    return l0(this, this, e, n);
  }
  scaleAround(e, n) {
    return u0(this, this, e, n);
  }
  translate(e, n) {
    return f0(this, this, e, n);
  }
  transformMat2d(e) {
    return d0(this, this, e);
  }
  applyMatrix2D(e) {
    return this.transformMat2d(e);
  }
  applyMatrix3D(e) {
    return this.transformMat3d(e);
  }
  transformMat3d(e) {
    return p0(this, this, e);
  }
  isFinite() {
    return isFinite(this.x) && isFinite(this.y);
  }
  isZero() {
    return this.x === 0 && this.y === 0;
  }
  equals(e) {
    return this[0] === e[0] && this[1] === e[1];
  }
  equalsEpsilon(e, n = 1e-6) {
    return Math.abs(this[0] - e[0]) < n && Math.abs(this[1] - e[1]) < n;
  }
  canNormalize() {
    return this.isFinite() && (this.x !== 0 || this.y !== 0);
  }
  toZero(e) {
    let n = this;
    return n[0] + e[0] == n[0] ? e[0] = 0 : n[0] + e[0] == e[0] && (n[0] = 0), n[1] + e[1] == n[1] ? e[1] = 0 : n[1] + e[1] == e[1] && (n[1] = 0), this;
  }
  toArray() {
    return [this[0], this[1]];
  }
};
const Kg = Math.PI * 2;
function sc(r, e, n, i, s, o, a) {
  return r[0] = e, r[1] = n, r[2] = i, r[3] = s, r[4] = o, r[5] = a, r;
}
function rc(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
}
function y0(r, e, n) {
  const i = e[0], s = e[2], o = e[4], a = e[1], h = e[3], c = e[5];
  return r[0] = i, r[1] = a, r[2] = s, r[3] = h, r[4] = o + i * n[0] + s * n[1], r[5] = c + a * n[0] + h * n[1], r;
}
function x0(r, e, n) {
  const i = e[0], s = e[2], o = e[4], a = e[1], h = e[3], c = e[5], l = Math.cos(n), u = Math.sin(n);
  return r[0] = i * l + s * u, r[1] = a * l + h * u, r[2] = i * -u + s * l, r[3] = a * u + h * l, r[4] = o, r[5] = c, r;
}
function m0(r, e, n) {
  const i = e[0], s = e[2], o = e[4], a = e[1], h = e[3], c = e[5], l = n[0], u = n[1];
  return r[0] = i * l, r[1] = a * l, r[2] = s * u, r[3] = h * u, r[4] = o, r[5] = c, r;
}
function g0(r, e) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = e[0], r[5] = e[1], r;
}
function w0(r, e) {
  const n = Math.cos(e), i = Math.sin(e);
  return r[0] = n, r[1] = i, r[2] = -i, r[3] = n, r[4] = 0, r[5] = 0, r;
}
function b0(r, e) {
  const n = e[0], i = e[1];
  return r[0] = n, r[1] = 0, r[2] = 0, r[3] = i, r[4] = 0, r[5] = 0, r;
}
function t2(r, e) {
  const n = Math.tan(e[0]), i = Math.tan(e[1]);
  return r[0] = 1, r[1] = i, r[2] = n, r[3] = 1, r[4] = 0, r[5] = 0, r;
}
function v0(r, e, n, i) {
  const s = Math.cos(n), o = Math.sin(n);
  return r[0] = s * i[0], r[1] = o * i[0], r[2] = -o * i[1], r[3] = s * i[1], r[4] = e[0], r[5] = e[1], r;
}
function e2(r, e, n, i, s) {
  const o = Math.cos(n), a = Math.sin(n), h = e[0] + s[0], c = e[1] + s[1];
  return r[0] = o * i[0], r[1] = a * i[0], r[2] = -a * i[1], r[3] = o * i[1], r[4] = h - (s[0] * r[0] + s[1] * r[2]), r[5] = c - (s[0] * r[1] + s[1] * r[3]), r;
}
function n2(r, e, n, i, s, o) {
  const a = Math.cos(i), h = Math.sin(i), c = Math.tan(n[0]), l = Math.tan(n[1]), u = e[0] + o[0], f = e[1] + o[1];
  return r[0] = (a + c * h) * s[0], r[1] = (l * h + a) * s[0], r[2] = (-h + c * a) * s[1], r[3] = (l * -h + a) * s[1], r[4] = u - (o[0] * r[0] + o[1] * r[2]), r[5] = f - (o[0] * r[1] + o[1] * r[3]), r;
}
function i2(r, e, n, i, s, o) {
  const a = Math.cos(n), h = Math.sin(n), c = e[0] + s[0], l = e[1] + s[1], u = o[0] + s[0], f = o[1] + s[1];
  return r[0] = a * i[0], r[1] = h * i[0], r[2] = -h * i[1], r[3] = a * i[1], r[4] = c - (u * r[0] + f * r[2]), r[5] = l - (u * r[1] + f * r[3]), r;
}
function s2(r, e, n, i, s, o, a) {
  const h = Math.cos(i), c = Math.sin(i), l = Math.tan(n[0]), u = Math.tan(n[1]), f = e[0] + o[0], d = e[1] + o[1], p = a[0] + o[0], y = a[1] + o[1];
  return r[0] = (h + l * c) * s[0], r[1] = (u * h + c) * s[0], r[2] = (-c + l * h) * s[1], r[3] = (u * -c + h) * s[1], r[4] = f - (p * r[0] + y * r[2]), r[5] = d - (p * r[1] + y * r[3]), r;
}
function r2(r, e, n, i, s, o, a) {
  const h = Math.cos(i + n[1]), c = Math.sin(i + n[1]), l = -Math.sin(i - n[0]), u = Math.cos(i - n[0]), f = o[0], d = o[1], p = e[0], y = e[1], x = a[0] + f, m = a[1] + d;
  return r[0] = h * s[0], r[1] = c * s[0], r[2] = l * s[1], r[3] = u * s[1], r[4] = p - (x * r[0] + m * r[2]) + f, r[5] = y - (x * r[1] + m * r[3]) + d, r;
}
function M0(r, e) {
  return r[0] = e[4], r[1] = e[5], r;
}
function sh(r) {
  return Math.atan2(r[1], r[0]);
}
function _0(r, e) {
  return r[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), r[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), r;
}
function S0(r, e) {
  const n = Math.cos(sh(e)), i = Math.sin(sh(e));
  return r[0] = e[4] + n * e[2] * -e[4] - i * e[3] * -e[5], r[1] = e[5] + i * e[2] * -e[4] + n * e[3] * -e[5], r;
}
function o2(r, e) {
  let i = r[0], s = r[1], o = r[2], a = r[3], h = r[4], c = r[5], l = e.origin.x, u = e.origin.y, f = e.pivot.x, d = e.pivot.y, p = Math.hypot(i, s), y = Math.hypot(o, a);
  p < 1e-6 && (p = 0), y < 1e-6 && (y = 0), i * a - s * o < 0 && (p > y ? (y *= -1, o *= -1, a *= -1) : (p *= -1, i *= -1, s *= -1));
  let m = Math.atan2(s, i), g = 0, w = 0;
  if (p > 1e-6 && y > 1e-6) {
    const I = i / p, b = s / p, v = o / y, _ = a / y;
    g = Math.atan(I * v + b * _), w = Math.atan(I * b + v * _);
  }
  const M = i * (f + l) + o * (d + u), S = s * (f + l) + a * (d + u), E = h + M - l, A = c + S - u;
  e.position.setXY(E, A), e.skew.set(g, w), e.scale.set(p, y), e.rotation = m;
}
function a2(r) {
  const e = r[0], n = r[1], i = r[2], s = r[3], o = r[4], a = r[5], h = o, c = a;
  let l = Math.sqrt(e * e + n * n), u = Math.sqrt(i * i + s * s), f = Math.atan2(n, e);
  return e * s - n * i < 0 && (l > u ? u = -u : l = -l), {
    position: { x: h, y: c },
    rotation: f,
    scale: { x: l, y: u }
  };
}
function Yo(r, e, n) {
  const i = e[0], s = e[1], o = e[2], a = e[3], h = e[4], c = e[5], l = n[0], u = n[1], f = n[2], d = n[3], p = n[4], y = n[5];
  return r[0] = i * l + o * u, r[1] = s * l + a * u, r[2] = i * f + o * d, r[3] = s * f + a * d, r[4] = i * p + o * y + h, r[5] = s * p + a * y + c, r;
}
function T0(r, e) {
  const n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], h = e[5], c = n * o - i * s;
  if (!c)
    return null;
  const l = 1 / c;
  return r[0] = o * l, r[1] = -i * l, r[2] = -s * l, r[3] = n * l, r[4] = (s * h - o * a) * l, r[5] = (i * a - n * h) * l, r;
}
function hl(r, e, n) {
  const i = n[0], s = n[1];
  return r[0] = e[0] * i + e[2] * s + e[4], r[1] = e[1] * i + e[3] * s + e[5], r;
}
function E0(r, e, n) {
  for (let i = 0; i < n.length; i += 2)
    hl(r[i], e, n[i]);
  return r;
}
function z0(r) {
  return r[0] === 1 && r[1] === 0 && r[2] === 0 && r[3] === 1 && r[4] === 0 && r[5] === 0;
}
function h2(r) {
  return r[4] !== 0 || r[5] !== 0;
}
function A0(r) {
  return r[0] !== 1 || r[1] !== 0 || r[2] !== 0 || r[3] !== 1;
}
function C0(r) {
  return r[0] !== 1 || r[3] !== 1;
}
class ue extends Float32Array {
  static IENTITY_MATRIX = new ue();
  static default() {
    return new this();
  }
  // 列主序
  static fromColumns(e, n, i, s, o, a) {
    return sc(new this(), e, n, i, s, o, a);
  }
  static fromRows(e, n, i, s, o, a) {
    return sc(new this(), e, s, n, o, i, a);
  }
  static fromMatrix2D(e) {
    const n = this.default();
    return n.set(e), n;
  }
  static fromSinCos(e, n) {
    return this.fromRows(n, e, -e, n, 0, 0);
  }
  static fromScale(e, n) {
    return this.fromRows(e, 0, 0, n, 0, 0);
  }
  static fromTranslate(e, n) {
    return this.fromRows(1, 0, e, 1, n, 0);
  }
  static fromRotation(e) {
    return this.fromSinCos(Math.sin(e), Math.cos(e));
  }
  static fromAngle(e) {
    return this.fromRotation(e * Math.PI / 180);
  }
  static identity = rc;
  static multiply = Yo;
  static invert = T0;
  static translate = y0;
  static scale = m0;
  static rotation = x0;
  static makeTranslation = g0;
  static makeRotation = w0;
  static makeScale = b0;
  static makeTranslationRotationScale = v0;
  static makeTranslationRotationScaleOrigin = e2;
  static makeTranslationSkewRotationScaleOrigin = n2;
  static makeTranslationRotationScaleOriginPivot = i2;
  static makeTranslationSkewRotationScaleOriginPivot = s2;
  static extractTranslation = M0;
  static extractRotation = sh;
  static extractScale = _0;
  static extractOrigin = S0;
  static decomposeTKRSPO = o2;
  static decompose = a2;
  static mapPoint = hl;
  static mapPoints = E0;
  static hasTranslation = h2;
  static hasRotation = A0;
  static hasScale = C0;
  static hasIdentity = z0;
  constructor() {
    super(6), rc(this);
  }
  get a() {
    return this[0];
  }
  set a(e) {
    this[0] = e;
  }
  get b() {
    return this[1];
  }
  set b(e) {
    this[1] = e;
  }
  get c() {
    return this[2];
  }
  set c(e) {
    this[2] = e;
  }
  get d() {
    return this[3];
  }
  set d(e) {
    this[3] = e;
  }
  get e() {
    return this[4];
  }
  set e(e) {
    this[4] = e;
  }
  get f() {
    return this[5];
  }
  set f(e) {
    this[5] = e;
  }
  get tx() {
    return this[4];
  }
  set tx(e) {
    this[4] = e;
  }
  get ty() {
    return this[5];
  }
  set ty(e) {
    this[5] = e;
  }
  copy(e) {
    return sc(this, e[0], e[1], e[2], e[3], e[4], e[5]), this;
  }
  clone() {
    return this.constructor.default().copy(this);
  }
  identity() {
    return rc(this);
  }
  multiplyMatrices(e, n) {
    return Yo(this, e, n);
  }
  premultiply(e) {
    return Yo(this, e, this);
  }
  multiply(e) {
    return Yo(this, this, e);
  }
  invert() {
    return T0(this, this);
  }
  translate(e) {
    return y0(this, this, e);
  }
  rotate(e) {
    return x0(this, this, e);
  }
  scale(e) {
    return m0(this, this, e);
  }
  makeTranslation(e) {
    return g0(this, e);
  }
  makeRotation(e) {
    return w0(this, e);
  }
  makeScale(e) {
    return b0(this, e);
  }
  makeSkew(e) {
    return t2(this, e);
  }
  makeTRS(e, n, i) {
    return v0(this, e, n, i);
  }
  makeTKRSOP(e, n, i, s, o, a) {
    return r2(this, e, n, i, s, o, a);
  }
  extractTranslation(e) {
    return M0(e, this);
  }
  extractRotation() {
    return sh(this);
  }
  extractScale(e) {
    return _0(e, this);
  }
  extractOrigin(e) {
    return S0(e, this);
  }
  preScale(e, n) {
    return this.multiplyMatrices(this, ue.fromScale(e, n));
  }
  postScale(e, n) {
    return this.multiplyMatrices(ue.fromScale(e, n), this);
  }
  preRotate(e) {
    return this.multiplyMatrices(this, ue.fromRotation(e));
  }
  preRotateDegrees(e) {
    return this.preRotate(e * Math.PI / 180);
  }
  postRotate(e) {
    return this.multiplyMatrices(ue.fromRotation(e), this);
  }
  postRotateDegrees(e) {
    return this.postRotate(e * Math.PI / 180);
  }
  preTranslate(e, n) {
    return this.multiplyMatrices(this, ue.fromTranslate(e, n));
  }
  postTranslate(e, n) {
    return this.multiplyMatrices(ue.fromTranslate(e, n), this);
  }
  mapPoint(e, n = e) {
    return hl(n, this, e);
  }
  mapPoints(e, n = e) {
    return E0(n, this, e);
  }
  hasIdentity() {
    return z0(this);
  }
  hasRotation() {
    return A0(this);
  }
  hasScale() {
    return C0(this);
  }
  decompose(e) {
    const n = this.a, i = this.b, s = this.c, o = this.d, a = e.pivot, h = -Math.atan2(-s, o), c = Math.atan2(i, n), l = Math.abs(h + c);
    l < 1e-5 || Math.abs(Kg - l) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = h, e.skew.y = c), e.scale.x = Math.sqrt(n * n + i * i), e.scale.y = Math.sqrt(s * s + o * o);
    const u = a.x + e.origin.x, f = a.y + e.origin.y;
    return e.position.x = this.tx + (u * n + f * s) - e.origin.x, e.position.y = this.ty + (u * i + f * o) - e.origin.y, e;
  }
  toMatrix3x3(e = !0) {
    return e ? new Float32Array([
      this.a,
      this.b,
      0,
      this.c,
      this.d,
      0,
      this.tx,
      this.ty,
      1
    ]) : new Float32Array([
      this.a,
      this.c,
      this.tx,
      this.b,
      this.d,
      this.ty,
      0,
      0,
      1
    ]);
  }
}
function oc(r) {
  return r[0] = 1, r[3] = 0, r[6] = 0, r[1] = 0, r[4] = 1, r[7] = 0, r[2] = 0, r[5] = 0, r[8] = 1, r;
}
function Ho(r, e, n) {
  const i = e[0], s = e[3], o = e[6], a = e[1], h = e[4], c = e[7], l = e[2], u = e[5], f = e[8], d = n[0], p = n[3], y = n[6], x = n[1], m = n[4], g = n[7], w = n[2], M = n[5], S = n[8];
  return r[0] = i * d + s * x + o * w, r[1] = a * d + h * x + c * w, r[2] = l * y + u * x + f * w, r[3] = i * p + s * m + o * M, r[4] = a * p + h * m + c * M, r[5] = l * p + u * m + f * M, r[6] = i * y + s * g + o * S, r[7] = a * y + h * g + c * S, r[8] = l * y + u * g + f * S, r;
}
function c2(r, e, n) {
  const i = e[0], s = e[3], o = e[6], a = e[1], h = e[4], c = e[7], l = e[2], u = e[5], f = e[8];
  return r[0] = i, r[1] = a, r[2] = l, r[3] = s, r[4] = h, r[5] = u, r[6] = i * n[0] + s * n[1] + o, r[7] = a * n[0] + h * n[1] + c, r[8] = f, r;
}
function l2(r, e, n) {
  const i = Math.sin(n), s = Math.cos(n), o = e[0], a = e[3], h = e[6], c = e[1], l = e[4], u = e[7], f = e[2], d = e[5], p = e[8];
  return r[0] = o * s + a * i, r[1] = c * s + l * i, r[2] = f * s + d * i, r[3] = o * -i + a * s, r[4] = c * -i + l * s, r[5] = f * -i + d * s, r[6] = h, r[7] = u, r[8] = p, r;
}
function u2(r, e, n) {
  const i = n[0], s = n[1], o = e[0], a = e[3], h = e[6], c = e[1], l = e[4], u = e[7], f = e[2], d = e[5], p = e[8];
  return r[0] = o * i, r[1] = c * i, r[2] = f * i, r[3] = a * s, r[4] = l * s, r[5] = d * s, r[6] = h, r[7] = u, r[8] = p, r;
}
function P0(r, e) {
  return r[0] = 1, r[3] = 0, r[6] = e[0], r[1] = 0, r[4] = 1, r[7] = e[1], r[2] = 0, r[5] = 0, r[8] = 1, r;
}
function I0(r, e) {
  const n = Math.sin(e), i = Math.cos(e);
  return r[0] = i, r[3] = -n, r[6] = 0, r[1] = n, r[4] = i, r[7] = 0, r[2] = 0, r[5] = 0, r[8] = 1, r;
}
function k0(r, e) {
  return r[0] = e[0], r[3] = 0, r[6] = 0, r[1] = 0, r[4] = e[1], r[7] = 0, r[2] = 0, r[5] = 0, r[8] = 1, r;
}
function R0(r, e) {
  return r[0] = 1, r[3] = Math.tan(e[0]), r[6] = 0, r[1] = Math.tan(e[1]), r[4] = 1, r[7] = 0, r[2] = 0, r[5] = 0, r[8] = 1, r;
}
function f2(r, e, n) {
  return r[0] = 2 / e, r[3] = 0, r[6] = -1, r[1] = 0, r[4] = -2 / n, r[7] = 1, r[2] = 0, r[5] = 0, r[8] = 1, r;
}
function O0(r, e, n, i) {
  const s = Math.sin(n), o = Math.cos(n);
  return r[0] = i[0] * o, r[3] = i[1] * -s, r[6] = e[0], r[1] = i[0] * s, r[4] = i[1] * o, r[7] = e[1], r[2] = 0, r[5] = 0, r[8] = 1, r;
}
function d2(r, e, n, i, s) {
  const o = Math.cos(n), a = Math.sin(n), h = i[0], c = i[1], l = e[0] + s[0], u = e[1] + s[1];
  return r[0] = o * h, r[1] = a * h, r[2] = 0, r[3] = -a * c, r[4] = o * c, r[5] = 0, r[6] = l - (s[0] * r[0] + s[1] * r[3]), r[7] = u - (s[0] * r[1] + s[1] * r[4]), r[8] = 1, r;
}
function p2(r, e, n, i, s, o) {
  const a = Math.cos(n), h = Math.sin(n), c = i[0], l = i[1], u = e[0] + s[0], f = e[1] + s[1], d = o[0] + s[0], p = o[1] + s[1];
  return r[0] = a * c, r[1] = h * c, r[2] = 0, r[3] = -h * l, r[4] = a * l, r[5] = 0, r[6] = u - (d * r[0] + p * r[3]), r[7] = f - (d * r[1] + p * r[4]), r[8] = 1, r;
}
function y2(r, e, n, i, s, o, a) {
  const h = Math.cos(i), c = Math.sin(i), l = s[0], u = s[1], f = Math.tan(n[0]), d = Math.tan(n[1]), p = e[0] + o[0], y = e[1] + o[1], x = a[0] + o[0], m = a[1] + o[1];
  return r[0] = (h + f * c) * l, r[1] = (d * c + h) * l, r[2] = 0, r[3] = (-c + f * h) * u, r[4] = (d * -c + h) * u, r[5] = 0, r[6] = p - (x * r[0] + m * r[3]), r[7] = y - (x * r[1] + m * r[4]), r[8] = 1, r;
}
function x2(r, e) {
  return r[0] = e[6], r[1] = e[7], r;
}
function m2(r) {
  return Math.atan2(r[3], r[0]);
}
function g2(r, e) {
  return r[0] = Math.sqrt(e[0] * e[0] + e[3] * e[3]), r[1] = Math.sqrt(e[1] * e[1] + e[4] * e[4]), r;
}
function w2(r, e) {
  const n = e[0], i = e[3], s = e[6], o = e[1], a = e[4], h = e[7], c = e[2], l = e[5], u = e[8];
  let f = n, d = i, p = s, y = o, x = a, m = h, g = c, w = l, M = u, S = 0, E = 0;
  return Math.abs(f) >= Math.abs(y) && Math.abs(f) >= Math.abs(g) ? (E = 1 / f, f *= E, d *= E, p *= E, y *= E, x *= E, m *= E, g *= E, w *= E, M *= E, S = f, f = 1, y -= d, x -= d, m -= d, g -= p, w -= p, M -= p) : Math.abs(y) >= Math.abs(f) && Math.abs(y) >= Math.abs(g) ? (E = 1 / y, f *= E, d *= E, p *= E, y *= E, x *= E, m *= E, g *= E, w *= E, M *= E, S = -y, y = 0, d -= x, p -= m, w -= m, M -= m) : (E = 1 / g, f *= E, d *= E, p *= E, y *= E, x *= E, m *= E, g *= E, w *= E, M *= E, S = g, g = 0, p -= w, d -= w, m -= w, x -= w), r[0] = f, r[3] = d, r[6] = p, r[1] = y, r[4] = x, r[7] = m, r[2] = g, r[5] = w, r[8] = M, S;
}
function L0(r, e) {
  const n = e[0], i = e[3], s = e[6], o = e[1], a = e[4], h = e[7], c = e[2], l = e[5], u = e[8];
  return r[0] = a * u - h * l, r[3] = -o * u + h * c, r[6] = o * l - a * c, r[1] = -i * u + s * l, r[4] = n * u - s * c, r[7] = -n * l + i * c, r[2] = i * h - s * a, r[5] = -n * h + s * o, r[8] = n * a - i * o, r;
}
function B0(r) {
  const e = r[0], n = r[3], i = r[6], s = r[1], o = r[4], a = r[7], h = r[2], c = r[5], l = r[8];
  return e * (o * l - c * a) - n * (s * l - a * h) + i * (s * c - o * h);
}
function F0(r, e) {
  const n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = u * a - h * l, d = -u * o + h * c, p = l * o - a * c;
  let y = n * f + i * d + s * p;
  return y ? (y = 1 / y, r[0] = f * y, r[1] = (-u * i + s * l) * y, r[2] = (h * i - s * a) * y, r[3] = d * y, r[4] = (u * n - s * c) * y, r[5] = (-h * n + s * o) * y, r[6] = p * y, r[7] = (-l * n + i * c) * y, r[8] = (a * n - i * o) * y, r) : null;
}
function N0(r, e) {
  const n = e[0], i = e[3], s = e[6], o = e[1], a = e[4], h = e[7], c = e[2], l = e[5], u = e[8];
  r[0] = n, r[1] = o, r[2] = c, r[3] = i, r[4] = a, r[5] = l, r[6] = s, r[7] = h, r[8] = u;
}
function b2(r) {
  return r[6] !== 0 || r[7] !== 0 || r[8] !== 1;
}
function v2(r) {
  return r[0] !== 1 || r[3] !== 0 || r[6] !== 0 || r[1] !== 0 || r[4] !== 1 || r[7] !== 0 || r[2] !== 0 || r[5] !== 0 || r[8] !== 1;
}
function M2(r) {
  return r[0] !== 1 || r[3] !== 0 || r[6] !== 0 || r[1] !== 0 || r[4] !== 1 || r[7] !== 0 || r[2] !== 0 || r[5] !== 0 || r[8] !== 1;
}
function _2(r) {
  return r[0] !== 1 || r[3] !== 0 || r[6] !== 0 || r[1] !== 0 || r[4] !== 1 || r[7] !== 0 || r[2] !== 0 || r[5] !== 0 || r[8] !== 1;
}
function S2(r, e, n, i, s, o, a, h, c, l) {
  return r[0] = e, r[3] = n, r[6] = i, r[1] = s, r[4] = o, r[7] = a, r[2] = h, r[5] = c, r[8] = l, r;
}
function cl(r, e, n) {
  let i = n[0], s = n[1];
  return r[0] = e[0] * i + e[3] * s + e[6], r[1] = e[1] * i + e[4] * s + e[7], r;
}
function q0(r, e, n) {
  for (let i = 0; i < n.length; i += 2)
    cl(r[i], e, n[i]);
  return r;
}
function D0(r, e, n) {
  let i = 2 / e, s = -2 / n;
  return r[0] = i, r[3] = 0, r[6] = -1, r[1] = 0, r[4] = s, r[7] = 1, r[2] = 0, r[5] = 0, r[8] = 1, r;
}
let T2 = class extends Float32Array {
  static default() {
    return new this();
  }
  static identity = oc;
  static multiply = Ho;
  static invert = F0;
  static makeProjection = f2;
  static makeTranslation = P0;
  static makeRotation = I0;
  static makeScale = k0;
  static makeTranslationRotationScale = O0;
  static makeTranslationRotationScaleOrigin = d2;
  static makeTranslationRotationScaleOriginPivot = p2;
  static makeTranslationSkewRotationScaleOriginPivot = y2;
  static extractTranslation = x2;
  static extractRotation = m2;
  static extractScale = g2;
  //static extractOrigin=extractOrigin
  static decompose = w2;
  static adjugate = L0;
  static determinant = B0;
  static transpose = N0;
  static fromValues = S2;
  static makeSkew = R0;
  static mapPoint = cl;
  static mapPoints = q0;
  static projection = D0;
  constructor() {
    super(9), oc(this);
  }
  identity() {
    return oc(this);
  }
  multiplyMatrices(e, n) {
    return Ho(this, e, n);
  }
  premultiply(e) {
    return Ho(this, e, this);
  }
  multiply(e) {
    return Ho(this, this, e);
  }
  translate(e) {
    return c2(this, this, e);
  }
  rotate(e) {
    return l2(this, this, e);
  }
  scale(e) {
    return u2(this, this, e);
  }
  makeTranslation(e) {
    return P0(this, e);
  }
  makeRotation(e) {
    return I0(this, e);
  }
  makeScale(e) {
    return k0(this, e);
  }
  makeSkew(e) {
    return R0(this, e);
  }
  // makeTranslationRotationScale(v: Vector2Like, radian: number, scale: Vector2Like) {
  //     return makeTranslationRotationScale(this, v, radian, scale);
  // }
  // makeTranslationRotationScaleOrigin(v: Vector2Like, radian: number, scale: Vector2Like, origin: Vector2Like) {
  //     return makeTranslationRotationScaleOrigin(this, v, radian, scale, origin);
  // }
  // makeTranslationRotationScaleOriginPivot(v: Vector2Like, radian: number, scale: Vector2Like, origin: Vector2Like, pivot: Vector2Like) {
  //     return makeTranslationRotationScaleOriginPivot(this, v, radian, scale, origin, pivot);
  // }
  // makeTranslationSkewRotationScaleOriginPivot(v: Vector2Like, skew: Vector2Like, radian: number, scale: Vector2Like, origin: Vector2Like, pivot: Vector2Like) {
  //     return makeTranslationSkewRotationScaleOriginPivot(this, v, skew, radian, scale, origin, pivot);
  // }
  makeTRS(e, n, i) {
    return O0(this, e, n, i);
  }
  adjugate() {
    return L0(this, this);
  }
  determinant() {
    return B0(this);
  }
  invert() {
    return F0(this, this);
  }
  transpose() {
    return N0(this, this);
  }
  hasTranslation() {
    return b2(this);
  }
  hasRotation() {
    return v2(this);
  }
  hasScale() {
    return M2(this);
  }
  hasIdentity() {
    return _2(this);
  }
  mapPoint(e, n = e) {
    return cl(n, this, e);
  }
  mapPoints(e, n = e) {
    return q0(n, this, e);
  }
  projection(e, n) {
    return D0(this, e, n);
  }
}, nr = class extends Float32Array {
  static create(e, n) {
    return new this(e, n);
  }
  constructor(e, n) {
    super(2), this[0] = e, this[1] = n;
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  set x(e) {
    this[0] !== e && (this[0] = e, this._change(this));
  }
  set y(e) {
    this[1] !== e && (this[1] = e, this._change(this));
  }
  _change(e) {
  }
  onChange(e) {
    this._change = e;
  }
  copy(e) {
    this.setXY(e[0], e[1]);
  }
  setXY(e, n) {
    (this[0] !== e || this[1] !== n) && (this[0] = e, this[1] = n, this._change(this));
  }
  set(e, n) {
    this.setXY(e, n);
  }
};
function E2(r) {
  return class extends r {
    position = nr.create(0, 0);
    _rotation = 0;
    _cx = 1;
    _sx = 0;
    _cy = 0;
    _sy = 1;
    skew = nr.create(0, 0);
    // 斜切
    scale = nr.create(1, 1);
    // 缩放向量
    origin = nr.create(0, 0);
    // 图形的变换原点
    pivot = nr.create(0, 0);
    // 图形的轴点
    _matrix = ue.default();
    // 本地矩阵
    _matrixWorld = ue.default();
    // 世界矩阵
    localMatrixDirty = !1;
    // 本地矩阵是否需要更新
    worldMatrixId = 0;
    // 当前世界矩阵每次更新的自增ID
    parentWorldMatrixId = 0;
    // 父级世界矩阵ID，相同代表不需要更新
    parent = null;
    children = null;
    constructor(...e) {
      super(...e);
      const n = e[0];
      this.position.onChange(this.onUpdateTransformable), this.scale.onChange(this.onUpdateTransformable), this.origin.onChange(this.onUpdateTransformable), this.pivot.onChange(this.onUpdateTransformable), this.skew.onChange(this.onUpdateTransformable), this.setTransformWithOptions(n);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(e) {
      this._rotation !== e && (this._rotation = e, this.onUpdateTransformable(this.skew));
    }
    get angle() {
      return this._rotation / Math.PI * 180;
    }
    set angle(e) {
      this.rotation = e / 180 * Math.PI;
    }
    // 递归计算父级世界矩阵是否变化
    get hasWorldMatrixDirty() {
      return this.parent ? this.parentWorldMatrixId === -1 || this.parentWorldMatrixId !== this.parent.worldMatrixId || this.parent.hasWorldMatrixDirty : this.parentWorldMatrixId === -1;
    }
    get matrix() {
      return this.updateMatrix(), this._matrix;
    }
    get worldMatrix() {
      return this.updateWorldMatrix(), this._matrixWorld;
    }
    setTransformWithOptions(e) {
      e && (e.position && this.position.setXY(e.position.x, e.position.y), e.rotation !== void 0 && (this.rotation = e.rotation), e.angle !== void 0 && (this.angle = e.angle), e.scale && this.scale.setXY(e.scale.x, e.scale.y), e.origin && this.origin.setXY(e.origin.x, e.origin.y), e.pivot && this.pivot.setXY(e.pivot.x, e.pivot.y), e.skew && this.skew.setXY(e.skew.x, e.skew.y));
    }
    setTransformFromMatrix(e) {
      e.decompose(this), this.onUpdateTransformable();
    }
    // 更新局部矩阵，但不更新世界矩阵
    updateMatrix() {
      if (!this.localMatrixDirty)
        return;
      this.localMatrixDirty = !1;
      const e = this.position.x, n = this.position.y, i = this.pivot.x, s = this.pivot.y, o = -this.origin.x, a = -this.origin.y, h = this.scale.x, c = this.scale.y, l = this._matrix;
      l.a = this._cx * h, l.b = this._sx * h, l.c = this._cy * c, l.d = this._sy * c, l.tx = e - (i * l.a + s * l.c) + (o * l.a + a * l.c) - o, l.ty = n - (i * l.b + s * l.d) + (o * l.b + a * l.d) - a;
    }
    updateWorldMatrix() {
      this.hasWorldMatrixDirty && (this.parent ? (this._matrixWorld.multiplyMatrices(this.parent.worldMatrix, this.matrix), this.parentWorldMatrixId = this.parent.worldMatrixId) : (this._matrixWorld.copy(this.matrix), this.parentWorldMatrixId = 0), this.worldMatrixId += 1);
    }
    onUpdateTransformable = (e) => {
      e === this.skew && this._updateSkew(), this.localMatrixDirty = !0, this.parentWorldMatrixId = -1, this.onTransformChange();
    };
    _updateSkew() {
      const e = this._rotation, n = this.skew;
      this._cx = Math.cos(e + n.y), this._sx = Math.sin(e + n.y), this._cy = -Math.sin(e - n.x), this._sy = Math.cos(e - n.x);
    }
    onTransformChange() {
    }
  };
}
let Ms = class n1 {
  static empty() {
    return this.fromLTRB(0, 0, 0, 0);
  }
  static default() {
    return new this();
  }
  static fromXYWH(e, n, i, s) {
    return this.fromLTRB(e, n, e + i, n + s);
  }
  static fromLTRB(e, n, i, s) {
    return new this(O.create(e, n), O.create(i, s));
  }
  min;
  max;
  constructor(e = O.create(1 / 0, 1 / 0), n = O.create(-1 / 0, -1 / 0)) {
    this.min = e, this.max = n;
  }
  get left() {
    return this.min.x;
  }
  get top() {
    return this.min.y;
  }
  get right() {
    return this.max.x;
  }
  get bottom() {
    return this.max.y;
  }
  get x() {
    return this.min.x;
  }
  get y() {
    return this.min.y;
  }
  get width() {
    return this.max.x - this.min.x;
  }
  get height() {
    return this.max.y - this.min.y;
  }
  get cx() {
    return this.left * 0.5 + this.right * 0.5;
  }
  get cy() {
    return this.top * 0.5 + this.bottom * 0.5;
  }
  get center() {
    return O.create(this.cx, this.cy);
  }
  isEmpty() {
    return this.min.x > this.max.x || this.min.y > this.max.y;
  }
  clone() {
    return new n1().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  makeZero() {
    return this.min.x = this.min.y = 0, this.max.x = this.max.y = 0, this;
  }
  setViewport(e, n, i, s) {
    return this.min.set(e, n), this.max.set(e + i, n + s), this;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  fromCircle(e, n, i) {
    return this.min.set(e - i, n - i), this.max.set(e + i, n + i), this;
  }
  fromLine(e, n, i, s, o) {
    const a = i - e, h = s - n, c = Math.sqrt(a * a + h * h);
    if (c === 0) {
      this.makeZero();
      return;
    }
    const l = a / c, f = -(h / c), d = l, p = f * o / 2, y = d * o / 2, x = [
      { x: e - p, y: n - y },
      // 起点左侧
      { x: e + p, y: n + y },
      // 起点右侧
      { x: i - p, y: s - y },
      // 终点左侧
      { x: i + p, y: s + y }
      // 终点右侧
    ];
    return this.setFromPoints(x), this;
  }
  fromRect(e, n, i, s) {
    return this.min.set(e, n), this.max.set(e + i, n + s), this;
  }
  setFromVertices(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 2)
      this.expandByXY(e[n], e[n + 1]);
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  expandByStrokeWidth(e) {
    let n = e * 0.5;
    return this.min.translate(-n, -n), this.max.translate(n, n), this;
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByXY(e, n) {
    return this.min.set(Math.min(this.min.x, e), Math.min(this.min.y, n)), this.max.set(Math.max(this.max.x, e), Math.max(this.max.y, n)), this;
  }
  // isEmpty() {
  //     return !(this.left < this.right && this.top < this.bottom);
  // }
  isValid() {
    return this.isFinite() && this.left <= this.right && this.top <= this.bottom;
  }
  isZero() {
    return this.width === 0 || this.height === 0;
  }
  isFinite() {
    return this.isEmpty();
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  translate(e, n) {
    this.min.translate(e, n), this.max.translate(e, n);
  }
  inset(e, n) {
    this.min.translate(e, n), this.max.translate(-e, -n);
  }
  outset(e, n) {
    this.inset(-e, -n);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  containsXY(e, n) {
    return !(e < this.left || e > this.right || n < this.top || n > this.bottom);
  }
  containsPoint(e) {
    return this.containsXY(e.x, e.y);
  }
  containsBox(e) {
    return !(e.min.x < this.min.x || e.max.x > this.max.x || e.min.y < this.min.y || e.max.y > this.max.y);
  }
  intersectBox3(e, n) {
    if (!e)
      return !1;
    const i = this, s = i.left, o = i.right, a = i.top, h = i.bottom, c = e.left, l = e.right, u = e.top, f = e.bottom, d = O.default(), p = O.default();
    let y = !(o < c || l < s || h < u || f < a);
    if (n) {
      let x = 1 / 0, m = 0;
      const g = Math.abs(o - c), w = Math.abs(l - s), M = Math.abs(h - u), S = Math.abs(f - a), E = Math.min(g, w), A = Math.min(M, S);
      o < c || l < s ? E > m && (m = E, g < w ? d.set(-g, 0) : d.set(w, 0)) : E < x && (x = E, g < w ? p.set(g, 0) : p.set(-w, 0)), h < u || f < a ? A > m && (m = A, M < S ? d.set(0, -M) : d.set(0, S)) : E < x && (x = E, M < S ? p.set(0, M) : p.set(0, -S));
    }
    return n && n.copy(y ? p : d), y;
  }
  intersectionBox(e) {
    return !(this.left > e.right || this.right < e.left || this.top > e.bottom || this.bottom < e.top);
  }
  // intersectionBox2(box:BoundingRect) {
  //     return (box.min.x >= this.min.x && box.min.x <= this.max.x || box.max.x >= this.min.x && box.max.x <= this.max.x) && (box.min.y >= this.min.y && box.min.y <= this.max.y || box.max.y >= this.min.y && box.max.y <= this.max.y)
  // }
  applyMatrix(e) {
    if (e.hasIdentity())
      return;
    const n = O.create(this.left, this.top), i = O.create(this.right, this.top), s = O.create(this.left, this.bottom), o = O.create(this.right, this.bottom);
    n.applyMatrix2D(e), i.applyMatrix2D(e), s.applyMatrix2D(e), o.applyMatrix2D(e), this.makeEmpty(), this.expandByPoint(n), this.expandByPoint(i), this.expandByPoint(s), this.expandByPoint(o);
  }
};
const z2 = Math.PI * 2;
let Ai = class i1 {
  /**
   * Position of the point on the x axis
   * @example
   * ```ts
   * // Set x position
   * const point = new Point();
   * point.x = 100;
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   */
  x = 0;
  /**
   * Position of the point on the y axis
   * @example
   * ```ts
   * // Set y position
   * const point = new Point();
   * point.y = 200;
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   */
  y = 0;
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e = 0, n = 0) {
    this.x = e, this.y = n;
  }
  /**
   * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
   * @example
   * ```ts
   * // Basic point cloning
   * const original = new Point(100, 200);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.set(300, 400);
   *
   * // Verify independence
   * console.log(original); // Point(100, 200)
   * console.log(modified); // Point(300, 400)
   * ```
   * @remarks
   * - Creates new Point instance
   * - Deep copies x and y values
   * - Independent from original
   * - Useful for preserving values
   * @returns A clone of this point
   * @see {@link Point.copyFrom} For copying into existing point
   * @see {@link Point.copyTo} For copying to existing point
   */
  clone() {
    return new i1(this.x, this.y);
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new Point()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link Point.copyTo} For copying to another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyFrom(e) {
    return this.set(e.x, e.y), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyTo(e) {
    return e.set(this.x, this.y), e;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new Point(100, 200);
   * const p2 = new Point(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new Point(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link Point.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new Point();
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   *
   * // Chain with other operations
   * point
   *     .set(10, 20)
   *     .copyTo(otherPoint);
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.equals} For comparing positions
   */
  set(e = 0, n = e) {
    return this.x = e, this.y = n, this;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  // #endif
  /**
   * A static Point object with `x` and `y` values of `0`.
   *
   * This shared instance is reset to zero values when accessed.
   *
   * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempPoint = Point.shared;
   * tempPoint.set(100, 200);
   * matrix.apply(tempPoint);
   *
   * // Will be reset to (0,0) on next access
   * const fresh = Point.shared; // x=0, y=0
   * ```
   * @readonly
   * @returns A fresh zeroed point for temporary use
   * @see {@link Point.constructor} For creating new points
   * @see {@link PointData} For basic point interface
   */
  static get shared() {
    return ac.x = 0, ac.y = 0, ac;
  }
};
const ac = new Ai();
let cu = class s1 {
  /**
   * Scale on the x axis.
   * @default 1
   */
  a;
  /**
   * Shear on the y axis.
   * @default 0
   */
  b;
  /**
   * Shear on the x axis.
   * @default 0
   */
  c;
  /**
   * Scale on the y axis.
   * @default 1
   */
  d;
  /**
   * Translation on the x axis.
   * @default 0
   */
  tx;
  /**
   * Translation on the y axis.
   * @default 0
   */
  ty;
  /**
   * Array representation of the matrix.
   * Only populated when `toArray()` is called.
   * @default null
   * @see {@link Matrix.toArray} For filling this array
   */
  array = null;
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(e = 1, n = 0, i = 0, s = 1, o = 0, a = 0) {
    this.a = e, this.b = n, this.c = i, this.d = s, this.tx = o, this.ty = a;
  }
  /**
   * Creates a Matrix object based on the given array.
   * Populates matrix components from a flat array in column-major order.
   *
   * > [!NOTE] Array mapping order:
   * > ```
   * > array[0] = a  (x scale)
   * > array[1] = b  (y skew)
   * > array[2] = tx (x translation)
   * > array[3] = c  (x skew)
   * > array[4] = d  (y scale)
   * > array[5] = ty (y translation)
   * > ```
   * @example
   * ```ts
   * // Create matrix from array
   * const matrix = new Matrix();
   * matrix.fromArray([
   *     2, 0,  100,  // a, b, tx
   *     0, 2,  100   // c, d, ty
   * ]);
   *
   * // Create matrix from typed array
   * const float32Array = new Float32Array([
   *     1, 0, 0,     // Scale x1, no skew
   *     0, 1, 0      // No skew, scale x1
   * ]);
   * matrix.fromArray(float32Array);
   * ```
   * @param array - The array to populate the matrix from
   * @see {@link Matrix.toArray} For converting matrix to array
   * @see {@link Matrix.set} For setting values directly
   */
  fromArray(e) {
    this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
  }
  /**
   * Sets the matrix properties directly.
   * All matrix components can be set in one call.
   * @example
   * ```ts
   * // Set to identity matrix
   * matrix.set(1, 0, 0, 1, 0, 0);
   *
   * // Set to scale matrix
   * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
   *
   * // Set to translation matrix
   * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
   * ```
   * @param a - Scale on x axis
   * @param b - Shear on y axis
   * @param c - Shear on x axis
   * @param d - Scale on y axis
   * @param tx - Translation on x axis
   * @param ty - Translation on y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.fromArray} For setting from array
   */
  set(e, n, i, s, o, a) {
    return this.a = e, this.b = n, this.c = i, this.d = s, this.tx = o, this.ty = a, this;
  }
  /**
   * Creates an array from the current Matrix object.
   *
   * > [!NOTE] The array format is:
   * > ```
   * > Non-transposed:
   * > [a, c, tx,
   * > b, d, ty,
   * > 0, 0, 1]
   * >
   * > Transposed:
   * > [a, b, 0,
   * > c, d, 0,
   * > tx,ty,1]
   * > ```
   * @example
   * ```ts
   * // Basic array conversion
   * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
   * const array = matrix.toArray();
   *
   * // Using existing array
   * const float32Array = new Float32Array(9);
   * matrix.toArray(false, float32Array);
   *
   * // Get transposed array
   * const transposed = matrix.toArray(true);
   * ```
   * @param transpose - Whether to transpose the matrix
   * @param out - Optional Float32Array to store the result
   * @returns The array containing the matrix values
   * @see {@link Matrix.fromArray} For creating matrix from array
   * @see {@link Matrix.array} For cached array storage
   */
  toArray(e, n) {
    this.array || (this.array = new Float32Array(9));
    const i = n || this.array;
    return e ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i;
  }
  /**
   * Get a new position with the current transformation applied.
   *
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @example
   * ```ts
   * // Basic point transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const point = new Point(10, 20);
   * const transformed = matrix.apply(point);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.apply(point, output);
   * ```
   * @param pos - The origin point to transform
   * @param newPos - Optional point to store the result
   * @returns The transformed point
   * @see {@link Matrix.applyInverse} For inverse transformation
   * @see {@link Point} For point operations
   */
  apply(e, n) {
    n = n || new Ai();
    const i = e.x, s = e.y;
    return n.x = this.a * i + this.c * s + this.tx, n.y = this.b * i + this.d * s + this.ty, n;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   *
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @example
   * ```ts
   * // Basic inverse transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const worldPoint = new Point(150, 100);
   * const localPoint = matrix.applyInverse(worldPoint);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.applyInverse(worldPoint, output);
   *
   * // Convert mouse position to local space
   * const mousePoint = new Point(mouseX, mouseY);
   * const localMouse = matrix.applyInverse(mousePoint);
   * ```
   * @param pos - The origin point to inverse-transform
   * @param newPos - Optional point to store the result
   * @returns The inverse-transformed point
   * @see {@link Matrix.apply} For forward transformation
   * @see {@link Matrix.invert} For getting inverse matrix
   */
  applyInverse(e, n) {
    n = n || new Ai();
    const i = this.a, s = this.b, o = this.c, a = this.d, h = this.tx, c = this.ty, l = 1 / (i * a + o * -s), u = e.x, f = e.y;
    return n.x = a * l * u + -o * l * f + (c * o - h * a) * l, n.y = i * l * f + -s * l * u + (-c * i + h * s) * l, n;
  }
  /**
   * Translates the matrix on the x and y axes.
   * Adds to the position values while preserving scale, rotation and skew.
   * @example
   * ```ts
   * // Basic translation
   * const matrix = new Matrix();
   * matrix.translate(100, 50); // Move right 100, down 50
   *
   * // Chain with other transformations
   * matrix
   *     .scale(2, 2)
   *     .translate(100, 0)
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - How much to translate on the x axis
   * @param y - How much to translate on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.set} For setting position directly
   * @see {@link Matrix.setTransform} For complete transform setup
   */
  translate(e, n) {
    return this.tx += e, this.ty += n, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * Multiplies the scale values with existing matrix components.
   * @example
   * ```ts
   * // Basic scaling
   * const matrix = new Matrix();
   * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100)
   *     .scale(2, 2)     // Scales after translation
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting scale directly
   * @see {@link Matrix.append} For combining transformations
   */
  scale(e, n) {
    return this.a *= e, this.d *= n, this.c *= e, this.b *= n, this.tx *= e, this.ty *= n, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   *
   * Rotates around the origin (0,0) by the given angle in radians.
   * @example
   * ```ts
   * // Basic rotation
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100) // Move to rotation center
   *     .rotate(Math.PI)     // Rotate 180 degrees
   *     .scale(2, 2);        // Scale after rotation
   *
   * // Common angles
   * matrix.rotate(Math.PI / 2);  // 90 degrees
   * matrix.rotate(Math.PI);      // 180 degrees
   * matrix.rotate(Math.PI * 2);  // 360 degrees
   * ```
   * @remarks
   * - Rotates around origin point (0,0)
   * - Affects position if translation was set
   * - Uses counter-clockwise rotation
   * - Order of operations matters when chaining
   * @param angle - The angle in radians
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting rotation directly
   * @see {@link Matrix.append} For combining transformations
   */
  rotate(e) {
    const n = Math.cos(e), i = Math.sin(e), s = this.a, o = this.c, a = this.tx;
    return this.a = s * n - this.b * i, this.b = s * i + this.b * n, this.c = o * n - this.d * i, this.d = o * i + this.d * n, this.tx = a * n - this.ty * i, this.ty = a * i + this.ty * n, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = this * matrix
   * @example
   * ```ts
   * // Basic matrix combination
   * const matrix = new Matrix();
   * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
   * matrix.append(other);
   * ```
   * @remarks
   * - Order matters: A.append(B) !== B.append(A)
   * - Modifies current matrix
   * - Preserves transformation order
   * - Commonly used for combining transforms
   * @param matrix - The matrix to append
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.prepend} For prepending transformations
   * @see {@link Matrix.appendFrom} For appending two external matrices
   */
  append(e) {
    const n = this.a, i = this.b, s = this.c, o = this.d;
    return this.a = e.a * n + e.b * s, this.b = e.a * i + e.b * o, this.c = e.c * n + e.d * s, this.d = e.c * i + e.d * o, this.tx = e.tx * n + e.ty * s + this.tx, this.ty = e.tx * i + e.ty * o + this.ty, this;
  }
  /**
   * Appends two matrices and sets the result to this matrix.
   * Performs matrix multiplication: this = A * B
   * @example
   * ```ts
   * // Basic matrix multiplication
   * const result = new Matrix();
   * const matrixA = new Matrix().scale(2, 2);
   * const matrixB = new Matrix().rotate(Math.PI / 4);
   * result.appendFrom(matrixA, matrixB);
   * ```
   * @remarks
   * - Order matters: A * B !== B * A
   * - Creates a new transformation from two others
   * - More efficient than append() for multiple operations
   * - Does not modify input matrices
   * @param a - The first matrix to multiply
   * @param b - The second matrix to multiply
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For single matrix combination
   * @see {@link Matrix.prepend} For reverse order multiplication
   */
  appendFrom(e, n) {
    const i = e.a, s = e.b, o = e.c, a = e.d, h = e.tx, c = e.ty, l = n.a, u = n.b, f = n.c, d = n.d;
    return this.a = i * l + s * f, this.b = i * u + s * d, this.c = o * l + a * f, this.d = o * u + a * d, this.tx = h * l + c * f + n.tx, this.ty = h * u + c * d + n.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties.
   * Combines position, scale, rotation, skew and pivot in a single operation.
   * @example
   * ```ts
   * // Basic transform setup
   * const matrix = new Matrix();
   * matrix.setTransform(
   *     100, 100,    // position
   *     0, 0,        // pivot
   *     2, 2,        // scale
   *     Math.PI / 4, // rotation (45 degrees)
   *     0, 0         // skew
   * );
   * ```
   * @remarks
   * - Updates all matrix components at once
   * - More efficient than separate transform calls
   * - Uses radians for rotation and skew
   * - Pivot affects rotation center
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.decompose} For extracting transform properties
   * @see {@link TransformableObject} For transform data structure
   */
  setTransform(e, n, i, s, o, a, h, c, l) {
    return this.a = Math.cos(h + l) * o, this.b = Math.sin(h + l) * o, this.c = -Math.sin(h - c) * a, this.d = Math.cos(h - c) * a, this.tx = e - (i * this.a + s * this.c), this.ty = n - (i * this.b + s * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = matrix * this
   * @example
   * ```ts
   * // Basic matrix prepend
   * const matrix = new Matrix().scale(2, 2);
   * const other = new Matrix().translate(100, 0);
   * matrix.prepend(other); // Translation happens before scaling
   * ```
   * @remarks
   * - Order matters: A.prepend(B) !== B.prepend(A)
   * - Modifies current matrix
   * - Reverses transformation order compared to append()
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For appending transformations
   * @see {@link Matrix.appendFrom} For combining external matrices
   */
  prepend(e) {
    const n = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const i = this.a, s = this.c;
      this.a = i * e.a + this.b * e.c, this.b = i * e.b + this.b * e.d, this.c = s * e.a + this.d * e.c, this.d = s * e.b + this.d * e.d;
    }
    return this.tx = n * e.a + this.ty * e.c + e.tx, this.ty = n * e.b + this.ty * e.d + e.ty, this;
  }
  /**
   * Decomposes the matrix into its individual transform components.
   * Extracts position, scale, rotation and skew values from the matrix.
   * @example
   * ```ts
   * // Basic decomposition
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * const transform = {
   *     position: new Point(),
   *     scale: new Point(),
   *     pivot: new Point(),
   *     skew: new Point(),
   *     rotation: 0
   * };
   *
   * matrix.decompose(transform);
   * console.log(transform.position); // Point(100, 100)
   * console.log(transform.rotation); // ~0.785 (PI/4)
   * console.log(transform.scale); // Point(2, 2)
   * ```
   * @remarks
   * - Handles combined transformations
   * - Accounts for pivot points
   * - Chooses between rotation/skew based on transform type
   * - Uses radians for rotation and skew
   * @param transform - The transform object to store the decomposed values
   * @returns The transform with the newly applied properties
   * @see {@link Matrix.setTransform} For composing from components
   * @see {@link TransformableObject} For transform structure
   */
  decompose(e) {
    const n = this.a, i = this.b, s = this.c, o = this.d, a = e.pivot, h = -Math.atan2(-s, o), c = Math.atan2(i, n), l = Math.abs(h + c);
    return l < 1e-5 || Math.abs(z2 - l) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = h, e.skew.y = c), e.scale.x = Math.sqrt(n * n + i * i), e.scale.y = Math.sqrt(s * s + o * o), e.position.x = this.tx + (a.x * n + a.y * s), e.position.y = this.ty + (a.x * i + a.y * o), e;
  }
  /**
   * Inverts this matrix.
   * Creates the matrix that when multiplied with this matrix results in an identity matrix.
   * @example
   * ```ts
   * // Basic matrix inversion
   * const matrix = new Matrix()
   *     .translate(100, 50)
   *     .scale(2, 2);
   *
   * matrix.invert(); // Now transforms in opposite direction
   *
   * // Verify inversion
   * const point = new Point(50, 50);
   * const transformed = matrix.apply(point);
   * const original = matrix.invert().apply(transformed);
   * // original ≈ point
   * ```
   * @remarks
   * - Modifies the current matrix
   * - Useful for reversing transformations
   * - Cannot invert matrices with zero determinant
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.applyInverse} For inverse transformations
   */
  invert() {
    const e = this.a, n = this.b, i = this.c, s = this.d, o = this.tx, a = e * s - n * i;
    return this.a = s / a, this.b = -n / a, this.c = -i / a, this.d = e / a, this.tx = (i * this.ty - s * o) / a, this.ty = -(e * this.ty - n * o) / a, this;
  }
  /**
   * Checks if this matrix is an identity matrix.
   *
   * An identity matrix has no transformations applied (default state).
   * @example
   * ```ts
   * // Check if matrix is identity
   * const matrix = new Matrix();
   * console.log(matrix.isIdentity()); // true
   *
   * // Check after transformations
   * matrix.translate(100, 0);
   * console.log(matrix.isIdentity()); // false
   *
   * // Reset and verify
   * matrix.identity();
   * console.log(matrix.isIdentity()); // true
   * ```
   * @remarks
   * - Verifies a = 1, d = 1 (no scale)
   * - Verifies b = 0, c = 0 (no skew)
   * - Verifies tx = 0, ty = 0 (no translation)
   * @returns True if matrix has no transformations
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * Sets all components to their default values: scale=1, no skew, no translation.
   * @example
   * ```ts
   * // Reset transformed matrix
   * const matrix = new Matrix()
   *     .scale(2, 2)
   *     .rotate(Math.PI / 4);
   * matrix.identity(); // Back to default state
   *
   * // Chain after reset
   * matrix
   *     .identity()
   *     .translate(100, 100)
   *     .scale(2, 2);
   *
   * // Compare with identity constant
   * const isDefault = matrix.equals(Matrix.IDENTITY);
   * ```
   * @remarks
   * - Sets a=1, d=1 (default scale)
   * - Sets b=0, c=0 (no skew)
   * - Sets tx=0, ty=0 (no translation)
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   * @see {@link Matrix.isIdentity} For checking identity state
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const e = new s1();
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @param matrix
   * @example
   * ```ts
   * // Basic matrix cloning
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const copy = matrix.clone();
   *
   * // Clone and modify
   * const modified = matrix.clone()
   *     .scale(2, 2);
   *
   * // Compare matrices
   * console.log(matrix.equals(copy));     // true
   * console.log(matrix.equals(modified)); // false
   * ```
   * @returns A copy of this matrix. Good for chaining method calls.
   * @see {@link Matrix.copyTo} For copying to existing matrix
   * @see {@link Matrix.copyFrom} For copying from another matrix
   */
  copyTo(e) {
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix.
   * @example
   * ```ts
   * // Basic matrix copying
   * const source = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const target = new Matrix();
   * target.copyFrom(source);
   * ```
   * @param matrix - The matrix to copy from
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.clone} For creating new matrix copy
   * @see {@link Matrix.copyTo} For copying to another matrix
   */
  copyFrom(e) {
    return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
  }
  /**
   * Checks if this matrix equals another matrix.
   * Compares all components for exact equality.
   * @example
   * ```ts
   * // Basic equality check
   * const m1 = new Matrix();
   * const m2 = new Matrix();
   * console.log(m1.equals(m2)); // true
   *
   * // Compare transformed matrices
   * const transform = new Matrix()
   *     .translate(100, 100)
   * const clone = new Matrix()
   *     .scale(2, 2);
   * console.log(transform.equals(clone)); // false
   * ```
   * @param matrix - The matrix to compare to
   * @returns True if matrices are identical
   * @see {@link Matrix.copyFrom} For copying matrix values
   * @see {@link Matrix.isIdentity} For identity comparison
   */
  equals(e) {
    return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  // #endif
  /**
   * A default (identity) matrix with no transformations applied.
   *
   * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
   * @example
   * ```ts
   * // Get identity matrix reference
   * const identity = Matrix.IDENTITY;
   * console.log(identity.isIdentity()); // true
   *
   * // Compare with identity
   * const matrix = new Matrix();
   * console.log(matrix.equals(Matrix.IDENTITY)); // true
   *
   * // Create new matrix instead of modifying IDENTITY
   * const transform = new Matrix()
   *     .copyFrom(Matrix.IDENTITY)
   *     .translate(100, 100);
   * ```
   * @readonly
   * @returns A read-only identity matrix
   * @see {@link Matrix.shared} For temporary calculations
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get IDENTITY() {
    return C2.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   *
   * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempMatrix = Matrix.shared;
   * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
   * const point = tempMatrix.apply({ x: 10, y: 20 });
   *
   * // Will be reset to identity on next access
   * const fresh = Matrix.shared; // Back to identity
   * ```
   * @remarks
   * - Always returns identity matrix
   * - Safe to modify temporarily
   * - Not safe to store references
   * - Useful for one-off calculations
   * @readonly
   * @returns A fresh identity matrix for temporary use
   * @see {@link Matrix.IDENTITY} For immutable identity matrix
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get shared() {
    return A2.identity();
  }
};
const A2 = new cu(), C2 = new cu(), Xo = [new Ai(), new Ai(), new Ai(), new Ai()];
let Fo = class Va {
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Rectangle(0, 0, 100, 100);
   * console.log(shape.type); // 'rectangle'
   *
   * // Use in type guards
   * if (shape.type === 'rectangle') {
   *     console.log(shape.width, shape.height);
   * }
   * ```
   * @readonly
   * @default 'rectangle'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "rectangle";
  /**
   * The X coordinate of the upper-left corner of the rectangle
   * @example
   * ```ts
   * // Basic x position
   * const rect = new Rectangle();
   * rect.x = 100;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the upper-left corner of the rectangle
   * @example
   * ```ts
   * // Basic y position
   * const rect = new Rectangle();
   * rect.y = 100;
   * ```
   * @default 0
   */
  y;
  /**
   * The overall width of this rectangle
   * @example
   * ```ts
   * // Basic width setting
   * const rect = new Rectangle();
   * rect.width = 200;
   * ```
   * @default 0
   */
  width;
  /**
   * The overall height of this rectangle
   * @example
   * ```ts
   * // Basic height setting
   * const rect = new Rectangle();
   * rect.height = 150;
   * ```
   * @default 0
   */
  height;
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(e = 0, n = 0, i = 0, s = 0) {
    this.x = Number(e), this.y = Number(n), this.width = Number(i), this.height = Number(s);
  }
  /**
   * Returns the left edge (x-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get left edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.left); // 100
   *
   * // Use in alignment calculations
   * sprite.x = rect.left + padding;
   *
   * // Compare positions
   * if (point.x > rect.left) {
   *     console.log('Point is right of rectangle');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the left edge
   * @see {@link Rectangle.right} For right edge position
   * @see {@link Rectangle.x} For direct x-coordinate access
   */
  get left() {
    return this.x;
  }
  /**
   * Returns the right edge (x + width) of the rectangle.
   * @example
   * ```ts
   * // Get right edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.right); // 300
   *
   * // Align to right edge
   * sprite.x = rect.right - sprite.width;
   *
   * // Check boundaries
   * if (point.x < rect.right) {
   *     console.log('Point is inside right bound');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the right edge
   * @see {@link Rectangle.left} For left edge position
   * @see {@link Rectangle.width} For width value
   */
  get right() {
    return this.x + this.width;
  }
  /**
   * Returns the top edge (y-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get top edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.top); // 100
   *
   * // Position above rectangle
   * sprite.y = rect.top - sprite.height;
   *
   * // Check vertical position
   * if (point.y > rect.top) {
   *     console.log('Point is below top edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the top edge
   * @see {@link Rectangle.bottom} For bottom edge position
   * @see {@link Rectangle.y} For direct y-coordinate access
   */
  get top() {
    return this.y;
  }
  /**
   * Returns the bottom edge (y + height) of the rectangle.
   * @example
   * ```ts
   * // Get bottom edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.bottom); // 250
   *
   * // Stack below rectangle
   * sprite.y = rect.bottom + margin;
   *
   * // Check vertical bounds
   * if (point.y < rect.bottom) {
   *     console.log('Point is above bottom edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the bottom edge
   * @see {@link Rectangle.top} For top edge position
   * @see {@link Rectangle.height} For height value
   */
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Determines whether the Rectangle is empty (has no area).
   * @example
   * ```ts
   * // Check zero dimensions
   * const rect = new Rectangle(100, 100, 0, 50);
   * console.log(rect.isEmpty()); // true
   * ```
   * @returns True if the rectangle has no area
   * @see {@link Rectangle.width} For width value
   * @see {@link Rectangle.height} For height value
   */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /**
   * A constant empty rectangle. This is a new object every time the property is accessed.
   * @example
   * ```ts
   * // Get fresh empty rectangle
   * const empty = Rectangle.EMPTY;
   * console.log(empty.isEmpty()); // true
   * ```
   * @returns A new empty rectangle instance
   * @see {@link Rectangle.isEmpty} For empty state testing
   */
  static get EMPTY() {
    return new Va(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Rectangle(100, 100, 200, 150);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.width *= 2;
   * modified.height += 50;
   *
   * // Verify independence
   * console.log(original.width);  // 200
   * console.log(modified.width);  // 400
   * ```
   * @returns A copy of the rectangle
   * @see {@link Rectangle.copyFrom} For copying into existing rectangle
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new Va(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @example
   * ```ts
   * // Convert bounds to rectangle
   * const bounds = container.getBounds();
   * const rect = new Rectangle().copyFromBounds(bounds);
   * ```
   * @param bounds - The bounds to copy and convert to a rectangle
   * @returns Returns itself
   * @see {@link Bounds} For bounds object structure
   * @see {@link Rectangle.getBounds} For getting rectangle bounds
   */
  copyFromBounds(e) {
    return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new Rectangle()
   *     .copyFrom(source)
   *     .pad(10);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new Rectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isInside = rect.contains(150, 125); // true
   * // Check edge cases
   * console.log(rect.contains(100, 100)); // true (on edge)
   * console.log(rect.contains(300, 250)); // false (outside)
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   * @see {@link Rectangle.containsRect} For rectangle containment
   * @see {@link Rectangle.strokeContains} For checking stroke intersection
   */
  contains(e, n) {
    return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link Rectangle.contains} For checking fill containment
   * @see {@link Rectangle.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, i, s = 0.5) {
    const { width: o, height: a } = this;
    if (o <= 0 || a <= 0) return !1;
    const h = this.x, c = this.y, l = i * (1 - s), u = i - l, f = h - l, d = h + o + l, p = c - l, y = c + a + l, x = h + u, m = h + o - u, g = c + u, w = c + a - u;
    return e >= f && e <= d && n >= p && n <= y && !(e > x && e < m && n > g && n < w);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   *
   * Returns true only if the area of the intersection is greater than 0.
   * This means that rectangles sharing only a side are not considered intersecting.
   * @example
   * ```ts
   * // Basic intersection check
   * const rect1 = new Rectangle(0, 0, 100, 100);
   * const rect2 = new Rectangle(50, 50, 100, 100);
   * console.log(rect1.intersects(rect2)); // true
   *
   * // With transformation matrix
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // 45 degrees
   * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
   *
   * // Edge cases
   * const zeroWidth = new Rectangle(0, 0, 0, 100);
   * console.log(rect1.intersects(zeroWidth)); // false (no area)
   * ```
   * @remarks
   * - Returns true only if intersection area is > 0
   * - Rectangles sharing only a side are not intersecting
   * - Zero-area rectangles cannot intersect anything
   * - Supports optional transformation matrix
   * @param other - The Rectangle to intersect with `this`
   * @param transform - Optional transformation matrix of `other`
   * @returns True if the transformed `other` Rectangle intersects with `this`
   * @see {@link Rectangle.containsRect} For containment testing
   * @see {@link Rectangle.contains} For point testing
   */
  intersects(e, n) {
    if (!n) {
      const b = this.x < e.x ? e.x : this.x;
      if ((this.right > e.right ? e.right : this.right) <= b)
        return !1;
      const _ = this.y < e.y ? e.y : this.y;
      return (this.bottom > e.bottom ? e.bottom : this.bottom) > _;
    }
    const i = this.left, s = this.right, o = this.top, a = this.bottom;
    if (s <= i || a <= o)
      return !1;
    const h = Xo[0].set(e.left, e.top), c = Xo[1].set(e.left, e.bottom), l = Xo[2].set(e.right, e.top), u = Xo[3].set(e.right, e.bottom);
    if (l.x <= h.x || c.y <= h.y)
      return !1;
    const f = Math.sign(n.a * n.d - n.b * n.c);
    if (f === 0 || (n.apply(h, h), n.apply(c, c), n.apply(l, l), n.apply(u, u), Math.max(h.x, c.x, l.x, u.x) <= i || Math.min(h.x, c.x, l.x, u.x) >= s || Math.max(h.y, c.y, l.y, u.y) <= o || Math.min(h.y, c.y, l.y, u.y) >= a))
      return !1;
    const d = f * (c.y - h.y), p = f * (h.x - c.x), y = d * i + p * o, x = d * s + p * o, m = d * i + p * a, g = d * s + p * a;
    if (Math.max(y, x, m, g) <= d * h.x + p * h.y || Math.min(y, x, m, g) >= d * u.x + p * u.y)
      return !1;
    const w = f * (h.y - l.y), M = f * (l.x - h.x), S = w * i + M * o, E = w * s + M * o, A = w * i + M * a, I = w * s + M * a;
    return !(Math.max(S, E, A, I) <= w * h.x + M * h.y || Math.min(S, E, A, I) >= w * u.x + M * u.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   *
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * // Basic padding
   * const rect = new Rectangle(100, 100, 200, 150);
   * rect.pad(10); // Adds 10px padding on all sides
   *
   * // Different horizontal and vertical padding
   * const uiRect = new Rectangle(0, 0, 100, 50);
   * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
   * ```
   * @remarks
   * - Adjusts x/y by subtracting padding
   * - Increases width/height by padding * 2
   * - Common in UI layout calculations
   * - Chainable with other methods
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   */
  pad(e = 0, n = e) {
    return this.x -= e, this.y -= n, this.width += e * 2, this.height += n * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @example
   * ```ts
   * // Basic fitting
   * const container = new Rectangle(0, 0, 100, 100);
   * const content = new Rectangle(25, 25, 200, 200);
   * content.fit(container); // Clips to container bounds
   * ```
   * @param rectangle - The rectangle to fit around
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  fit(e) {
    const n = Math.max(this.x, e.x), i = Math.min(this.x + this.width, e.x + e.width), s = Math.max(this.y, e.y), o = Math.min(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = Math.max(i - n, 0), this.y = s, this.height = Math.max(o - s, 0), this;
  }
  /**
   * Enlarges rectangle so that its corners lie on a grid defined by resolution.
   * @example
   * ```ts
   * // Basic grid alignment
   * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
   * rect.ceil(); // Aligns to whole pixels
   *
   * // Custom resolution grid
   * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
   * uiRect.ceil(0.5); // Aligns to half pixels
   *
   * // Use with precision value
   * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
   * preciseRect.ceil(1, 0.01); // Handles small decimal variations
   * ```
   * @param resolution - The grid size to align to (1 = whole pixels)
   * @param eps - Small number to prevent floating point errors
   * @returns Returns itself
   * @see {@link Rectangle.fit} For constraining to bounds
   * @see {@link Rectangle.enlarge} For growing dimensions
   */
  ceil(e = 1, n = 1e-3) {
    const i = Math.ceil((this.x + this.width - n) * e) / e, s = Math.ceil((this.y + this.height - n) * e) / e;
    return this.x = Math.floor((this.x + n) * e) / e, this.y = Math.floor((this.y + n) * e) / e, this.width = i - this.x, this.height = s - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @example
   * ```ts
   * // Basic enlargement
   * const rect = new Rectangle(50, 50, 100, 100);
   * const other = new Rectangle(0, 0, 200, 75);
   * rect.enlarge(other);
   * // rect is now: x=0, y=0, width=200, height=150
   *
   * // Use for bounding box calculation
   * const bounds = new Rectangle();
   * objects.forEach((obj) => {
   *     bounds.enlarge(obj.getBounds());
   * });
   * ```
   * @param rectangle - The rectangle to include
   * @returns Returns itself
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  enlarge(e) {
    const n = Math.min(this.x, e.x), i = Math.max(this.x + this.width, e.x + e.width), s = Math.min(this.y, e.y), o = Math.max(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = i - n, this.y = s, this.height = o - s, this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds retrieval
   * const rect = new Rectangle(100, 100, 200, 150);
   * const bounds = rect.getBounds();
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle.copyFrom} For direct copying
   * @see {@link Rectangle.clone} For creating new copy
   */
  getBounds(e) {
    return e ||= new Va(), e.copyFrom(this), e;
  }
  /**
   * Determines whether another Rectangle is fully contained within this Rectangle.
   *
   * Rectangles that occupy the same space are considered to be containing each other.
   *
   * Rectangles without area (width or height equal to zero) can't contain anything,
   * not even other arealess rectangles.
   * @example
   * ```ts
   * // Check if one rectangle contains another
   * const container = new Rectangle(0, 0, 100, 100);
   * const inner = new Rectangle(25, 25, 50, 50);
   *
   * console.log(container.containsRect(inner)); // true
   *
   * // Check overlapping rectangles
   * const partial = new Rectangle(75, 75, 50, 50);
   * console.log(container.containsRect(partial)); // false
   *
   * // Zero-area rectangles
   * const empty = new Rectangle(0, 0, 0, 100);
   * console.log(container.containsRect(empty)); // false
   * ```
   * @param other - The Rectangle to check for containment
   * @returns True if other is fully contained within this Rectangle
   * @see {@link Rectangle.contains} For point containment
   * @see {@link Rectangle.intersects} For overlap testing
   */
  containsRect(e) {
    if (this.width <= 0 || this.height <= 0) return !1;
    const n = e.x, i = e.y, s = e.x + e.width, o = e.y + e.height;
    return n >= this.x && n < this.x + this.width && i >= this.y && i < this.y + this.height && s >= this.x && s < this.x + this.width && o >= this.y && o < this.y + this.height;
  }
  /**
   * Sets the position and dimensions of the rectangle.
   * @example
   * ```ts
   * // Basic usage
   * const rect = new Rectangle();
   * rect.set(100, 100, 200, 150);
   *
   * // Chain with other operations
   * const bounds = new Rectangle()
   *     .set(0, 0, 100, 100)
   *     .pad(10);
   * ```
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   * @returns Returns itself for method chaining
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating a new copy
   */
  set(e, n, i, s) {
    return this.x = e, this.y = n, this.width = i, this.height = s, this;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
  // #endif
}, P2 = class r1 {
  /**
   * The X coordinate of the center of this circle
   * @example
   * ```ts
   * // Basic x position
   * const circle = new Circle();
   * circle.x = 100;
   *
   * // Center circle on point
   * circle.x = point.x;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the center of this circle
   * @example
   * ```ts
   * // Basic y position
   * const circle = new Circle();
   * circle.y = 200;
   *
   * // Center circle on point
   * circle.y = point.y;
   * ```
   * @default 0
   */
  y;
  /**
   * The radius of the circle
   * @example
   * ```ts
   * // Basic radius setting
   * const circle = new Circle(100, 100);
   * circle.radius = 50;
   *
   * // Calculate area
   * const area = Math.PI * circle.radius * circle.radius;
   * ```
   * @default 0
   */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks.
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Circle(0, 0, 50);
   * console.log(shape.type); // 'circle'
   *
   * // Use in type guards
   * if (shape.type === 'circle') {
   *     console.log(shape.radius);
   * }
   * ```
   * @remarks
   * - Used for shape type checking
   * - More efficient than instanceof
   * - Read-only property
   * @readonly
   * @default 'circle'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   * @see {@link ShapePrimitive} For shape interface
   */
  type = "circle";
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(e = 0, n = 0, i = 0) {
    this.x = e, this.y = n, this.radius = i;
  }
  /**
   * Creates a clone of this Circle instance.
   * @example
   * ```ts
   * // Basic circle cloning
   * const original = new Circle(100, 100, 50);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 75;
   *
   * // Verify independence
   * console.log(original.radius); // 50
   * console.log(modified.radius); // 75
   * ```
   * @returns A copy of the Circle
   * @see {@link Circle.copyFrom} For copying into existing circle
   * @see {@link Circle.copyTo} For copying to another circle
   */
  clone() {
    return new r1(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle.
   *
   * Uses the distance formula to determine if a point is inside the circle's radius.
   *
   * Commonly used for hit testing in PixiJS events and graphics.
   * @example
   * ```ts
   * // Basic containment check
   * const circle = new Circle(100, 100, 50);
   * const isInside = circle.contains(120, 120);
   *
   * // Check mouse position
   * const circle = new Circle(0, 0, 100);
   * container.hitArea = circle;
   * container.on('pointermove', (e) => {
   *     // only called if pointer is within circle
   * });
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   * @see {@link Circle.strokeContains} For checking stroke intersection
   * @see {@link Circle.getBounds} For getting bounding box
   */
  contains(e, n) {
    if (this.radius <= 0) return !1;
    const i = this.radius * this.radius;
    let s = this.x - e, o = this.y - n;
    return s *= s, o *= o, s + o <= i;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const circle = new Circle(100, 100, 50);
   * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this Circle's stroke
   * @see {@link Circle.contains} For checking fill containment
   * @see {@link Circle.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, i, s = 0.5) {
    if (this.radius === 0) return !1;
    const o = this.x - e, a = this.y - n, h = this.radius, c = (1 - s) * i, l = Math.sqrt(o * o + a * a);
    return l <= h + c && l > h - (i - c);
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const circle = new Circle(100, 100, 50);
   * const bounds = circle.getBounds();
   * // bounds: x=50, y=50, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * circle.getBounds(rect);
   * ```
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Circle.contains} For point containment
   */
  getBounds(e) {
    return e ||= new Fo(), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
  }
  /**
   * Copies another circle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * target.copyFrom(source);
   * ```
   * @param circle - The circle to copy from
   * @returns Returns itself
   * @see {@link Circle.copyTo} For copying to another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
  }
  /**
   * Copies this circle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * source.copyTo(target);
   * ```
   * @param circle - The circle to copy to
   * @returns Returns given parameter
   * @see {@link Circle.copyFrom} For copying from another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
  // #endif
}, I2 = class o1 {
  /**
   * The X coordinate of the center of this ellipse
   * @example
   * ```ts
   * // Basic x position
   * const ellipse = new Ellipse();
   * ellipse.x = 100;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the center of this ellipse
   * @example
   * ```ts
   * // Basic y position
   * const ellipse = new Ellipse();
   * ellipse.y = 200;
   * ```
   * @default 0
   */
  y;
  /**
   * The half width of this ellipse
   * @example
   * ```ts
   * // Set half width
   * const ellipse = new Ellipse(100, 100);
   * ellipse.halfWidth = 50; // Total width will be 100
   * ```
   * @default 0
   */
  halfWidth;
  /**
   * The half height of this ellipse
   * @example
   * ```ts
   * // Set half height
   * const ellipse = new Ellipse(100, 100);
   * ellipse.halfHeight = 25; // Total height will be 50
   * ```
   * @default 0
   */
  halfHeight;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Ellipse(0, 0, 50, 25);
   * console.log(shape.type); // 'ellipse'
   *
   * // Use in type guards
   * if (shape.type === 'ellipse') {
   *     console.log(shape.halfWidth, shape.halfHeight);
   * }
   * ```
   * @readonly
   * @default 'ellipse'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "ellipse";
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(e = 0, n = 0, i = 0, s = 0) {
    this.x = e, this.y = n, this.halfWidth = i, this.halfHeight = s;
  }
  /**
   * Creates a clone of this Ellipse instance.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Ellipse(100, 100, 50, 25);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.halfWidth *= 2;
   * modified.halfHeight *= 2;
   *
   * // Verify independence
   * console.log(original.halfWidth);  // 50
   * console.log(modified.halfWidth);  // 100
   * ```
   * @returns A copy of the ellipse
   * @see {@link Ellipse.copyFrom} For copying into existing ellipse
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   */
  clone() {
    return new o1(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse.
   * Uses normalized coordinates and the ellipse equation to determine containment.
   * @example
   * ```ts
   * // Basic containment check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isInside = ellipse.contains(120, 110);
   * ```
   * @remarks
   * - Uses ellipse equation (x²/a² + y²/b² ≤ 1)
   * - Returns false if dimensions are 0 or negative
   * - Normalized to center (0,0) for calculation
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   * @see {@link Ellipse.strokeContains} For checking stroke intersection
   * @see {@link Ellipse.getBounds} For getting containing rectangle
   */
  contains(e, n) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0)
      return !1;
    let i = (e - this.x) / this.halfWidth, s = (n - this.y) / this.halfHeight;
    return i *= i, s *= s, i + s <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @remarks
   * - Uses normalized ellipse equations
   * - Considers stroke alignment
   * - Returns false if dimensions are 0
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coords are within this ellipse's stroke
   * @see {@link Ellipse.contains} For checking fill containment
   * @see {@link Ellipse.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, i, s = 0.5) {
    const { halfWidth: o, halfHeight: a } = this;
    if (o <= 0 || a <= 0)
      return !1;
    const h = i * (1 - s), c = i - h, l = o - c, u = a - c, f = o + h, d = a + h, p = e - this.x, y = n - this.y, x = p * p / (l * l) + y * y / (u * u), m = p * p / (f * f) + y * y / (d * d);
    return x > 1 && m <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const bounds = ellipse.getBounds();
   * // bounds: x=50, y=75, width=100, height=50
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * ellipse.getBounds(rect);
   * ```
   * @remarks
   * - Creates Rectangle if none provided
   * - Top-left is (x-halfWidth, y-halfHeight)
   * - Width is halfWidth * 2
   * - Height is halfHeight * 2
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Ellipse.contains} For checking if a point is inside
   */
  getBounds(e) {
    return e ||= new Fo(), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
  }
  /**
   * Copies another ellipse to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * target.copyFrom(source);
   * ```
   * @param ellipse - The ellipse to copy from
   * @returns Returns itself
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
  }
  /**
   * Copies this ellipse to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * source.copyTo(target);
   * ```
   * @param ellipse - The ellipse to copy to
   * @returns Returns given parameter
   * @see {@link Ellipse.copyFrom} For copying from another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
  // #endif
};
function k2(r, e, n, i, s, o) {
  const a = r - n, h = e - i, c = s - n, l = o - i, u = a * c + h * l, f = c * c + l * l;
  let d = -1;
  f !== 0 && (d = u / f);
  let p, y;
  d < 0 ? (p = n, y = i) : d > 1 ? (p = s, y = o) : (p = n + d * c, y = i + d * l);
  const x = r - p, m = e - y;
  return x * x + m * m;
}
let R2, O2, L2 = class a1 {
  /**
   * An array of the points of this polygon stored as a flat array of numbers.
   * @example
   * ```ts
   * // Access points directly
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]
   *
   * // Modify points
   * polygon.points[0] = 10; // Move first x coordinate
   * polygon.points[1] = 10; // Move first y coordinate
   * ```
   * @remarks
   * - Stored as [x1, y1, x2, y2, ...]
   * - Each pair represents a vertex
   * - Length is always even
   * - Can be modified directly
   */
  points;
  /**
   * Indicates if the polygon path is closed.
   * @example
   * ```ts
   * // Create open polygon
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * polygon.closePath = false;
   *
   * // Check path state
   * if (polygon.closePath) {
   *     // Last point connects to first
   * }
   * ```
   * @remarks
   * - True by default
   * - False after moveTo
   * - True after closePath
   * @default true
   */
  closePath;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(shape.type); // 'polygon'
   *
   * // Use in type guards
   * if (shape.type === 'polygon') {
   *     // TypeScript knows this is a Polygon
   *     console.log(shape.points.length);
   * }
   * ```
   * @readonly
   * @default 'polygon'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "polygon";
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...e) {
    let n = Array.isArray(e[0]) ? e[0] : e;
    if (typeof n[0] != "number") {
      const i = [];
      for (let s = 0, o = n.length; s < o; s++)
        i.push(n[s].x, n[s].y);
      n = i;
    }
    this.points = n, this.closePath = !0;
  }
  /**
   * Determines whether the polygon's points are arranged in a clockwise direction.
   * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
   *
   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
   *
   * The formula sums up the cross products of adjacent vertices:
   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
   * The final sum divided by 2 gives the signed area - positive for clockwise.
   * @example
   * ```ts
   * // Check polygon winding
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.isClockwise()); // Check direction
   *
   * // Use in path construction
   * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
   * if (hole.isClockwise() === shape.isClockwise()) {
   *     hole.points.reverse(); // Reverse for proper hole winding
   * }
   * ```
   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
   */
  isClockwise() {
    let e = 0;
    const n = this.points, i = n.length;
    for (let s = 0; s < i; s += 2) {
      const o = n[s], a = n[s + 1], h = n[(s + 2) % i], c = n[(s + 3) % i];
      e += (h - o) * (c + a);
    }
    return e < 0;
  }
  /**
   * Checks if this polygon completely contains another polygon.
   * Used for detecting holes in shapes, like when parsing SVG paths.
   * @example
   * ```ts
   * // Basic containment check
   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
   *
   * outerSquare.containsPolygon(innerSquare); // Returns true
   * innerSquare.containsPolygon(outerSquare); // Returns false
   * ```
   * @remarks
   * - Uses bounds check for quick rejection
   * - Tests all points for containment
   * @param polygon - The polygon to test for containment
   * @returns True if this polygon completely contains the other polygon
   * @see {@link Polygon.contains} For single point testing
   * @see {@link Polygon.getBounds} For bounds calculation
   */
  containsPolygon(e) {
    const n = this.getBounds(R2), i = e.getBounds(O2);
    if (!n.containsRect(i))
      return !1;
    const s = e.points;
    for (let o = 0; o < s.length; o += 2) {
      const a = s[o], h = s[o + 1];
      if (!this.contains(a, h))
        return !1;
    }
    return !0;
  }
  /**
   * Creates a clone of this polygon.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Polygon([0, 0, 100, 0, 50, 100]);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.points[0] = 10; // Modify first x coordinate
   * ```
   * @returns A copy of the polygon
   * @see {@link Polygon.copyFrom} For copying into existing polygon
   * @see {@link Polygon.copyTo} For copying to another polygon
   */
  clone() {
    const e = this.points.slice(), n = new a1(e);
    return n.closePath = this.closePath, n;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * Uses raycasting algorithm for point-in-polygon testing.
   * @example
   * ```ts
   * // Basic containment check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isInside = polygon.contains(25, 25); // true
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this polygon
   * @see {@link Polygon.strokeContains} For checking stroke intersection
   * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
   */
  contains(e, n) {
    let i = !1;
    const s = this.points.length / 2;
    for (let o = 0, a = s - 1; o < s; a = o++) {
      const h = this.points[o * 2], c = this.points[o * 2 + 1], l = this.points[a * 2], u = this.points[a * 2 + 1];
      c > n != u > n && e < (l - h) * ((n - c) / (u - c)) + h && (i = !i);
    }
    return i;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
   * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
   * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this polygon's stroke
   * @see {@link Polygon.contains} For checking fill containment
   * @see {@link Polygon.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, i, s = 0.5) {
    const o = i * i, a = o * (1 - s), h = o - a, { points: c } = this, l = c.length - (this.closePath ? 0 : 2);
    for (let u = 0; u < l; u += 2) {
      const f = c[u], d = c[u + 1], p = c[(u + 2) % c.length], y = c[(u + 3) % c.length], x = k2(e, n, f, d, p, y), m = Math.sign((p - f) * (n - d) - (y - d) * (e - f));
      if (x <= (m < 0 ? h : a))
        return !0;
    }
    return !1;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const bounds = polygon.getBounds();
   * // bounds: x=0, y=0, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * polygon.getBounds(rect);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Polygon.contains} For checking if a point is inside
   */
  getBounds(e) {
    e ||= new Fo();
    const n = this.points;
    let i = 1 / 0, s = -1 / 0, o = 1 / 0, a = -1 / 0;
    for (let h = 0, c = n.length; h < c; h += 2) {
      const l = n[h], u = n[h + 1];
      i = l < i ? l : i, s = l > s ? l : s, o = u < o ? u : o, a = u > a ? u : a;
    }
    return e.x = i, e.width = s - i, e.y = o, e.height = a - o, e;
  }
  /**
   * Copies another polygon to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * target.copyFrom(source);
   * ```
   * @param polygon - The polygon to copy from
   * @returns Returns itself
   * @see {@link Polygon.copyTo} For copying to another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyFrom(e) {
    return this.points = e.points.slice(), this.closePath = e.closePath, this;
  }
  /**
   * Copies this polygon to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * source.copyTo(target);
   * ```
   * @param polygon - The polygon to copy to
   * @returns Returns given parameter
   * @see {@link Polygon.copyFrom} For copying from another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, n) => `${e}, ${n}`, "")}]`;
  }
  // #endif
  /**
   * Get the last X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastX); // 300
   * ```
   * @readonly
   * @returns The x-coordinate of the last vertex
   * @see {@link Polygon.lastY} For last Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastY); // 400
   * ```
   * @readonly
   * @returns The y-coordinate of the last vertex
   * @see {@link Polygon.lastX} For last X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the last X coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
   */
  get x() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
   */
  get y() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.x); // 0
   * ```
   * @readonly
   * @returns The x-coordinate of the first vertex
   * @see {@link Polygon.startY} For first Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startX() {
    return this.points[0];
  }
  /**
   * Get the first Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.y); // 0
   * ```
   * @readonly
   * @returns The y-coordinate of the first vertex
   * @see {@link Polygon.startX} For first X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startY() {
    return this.points[1];
  }
};
const Zo = (r, e, n, i, s, o, a) => {
  const h = r - n, c = e - i, l = Math.sqrt(h * h + c * c);
  return l >= s - o && l <= s + a;
};
let B2 = class h1 {
  /**
   * The X coordinate of the upper-left corner of the rounded rectangle
   * @example
   * ```ts
   * // Basic x position
   * const rect = new RoundedRectangle();
   * rect.x = 100;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the upper-left corner of the rounded rectangle
   * @example
   * ```ts
   * // Basic y position
   * const rect = new RoundedRectangle();
   * rect.y = 100;
   * ```
   * @default 0
   */
  y;
  /**
   * The overall width of this rounded rectangle
   * @example
   * ```ts
   * // Basic width setting
   * const rect = new RoundedRectangle();
   * rect.width = 200; // Total width will be 200
   * ```
   * @default 0
   */
  width;
  /**
   * The overall height of this rounded rectangle
   * @example
   * ```ts
   * // Basic height setting
   * const rect = new RoundedRectangle();
   * rect.height = 150; // Total height will be 150
   * ```
   * @default 0
   */
  height;
  /**
   * Controls the radius of the rounded corners
   * @example
   * ```ts
   * // Basic radius setting
   * const rect = new RoundedRectangle(0, 0, 200, 150);
   * rect.radius = 20;
   *
   * // Clamp to maximum safe radius
   * rect.radius = Math.min(rect.width, rect.height) / 2;
   *
   * // Create pill shape
   * rect.radius = rect.height / 2;
   * ```
   * @remarks
   * - Automatically clamped to half of smallest dimension
   * - Common values: 0-20 for UI elements
   * - Higher values create more rounded corners
   * @default 20
   */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new RoundedRectangle(0, 0, 100, 100, 20);
   * console.log(shape.type); // 'roundedRectangle'
   *
   * // Use in type guards
   * if (shape.type === 'roundedRectangle') {
   *     console.log(shape.radius);
   * }
   * ```
   * @readonly
   * @default 'roundedRectangle'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "roundedRectangle";
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(e = 0, n = 0, i = 0, s = 0, o = 20) {
    this.x = e, this.y = n, this.width = i, this.height = s, this.radius = o;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds calculation
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const bounds = rect.getBounds();
   * // bounds: x=100, y=100, width=200, height=150
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @remarks
   * - Rectangle matches outer dimensions
   * - Ignores corner radius
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link RoundedRectangle.contains} For checking if a point is inside
   */
  getBounds(e) {
    return e ||= new Fo(), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new RoundedRectangle(100, 100, 200, 150, 20);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 30;
   * modified.width *= 2;
   *
   * // Verify independence
   * console.log(original.radius);  // 20
   * console.log(modified.radius);  // 30
   * ```
   * @returns A copy of the rounded rectangle
   * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new h1(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new RoundedRectangle()
   *     .copyFrom(source)
   *     .getBounds(rect);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new RoundedRectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isInside = rect.contains(150, 125); // true
   * // Check corner radius
   * const corner = rect.contains(100, 100); // false if within corner curve
   * ```
   * @remarks
   * - Returns false if width/height is 0 or negative
   * - Handles rounded corners with radius check
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rounded Rectangle
   * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
   * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
   */
  contains(e, n) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (e >= this.x && e <= this.x + this.width && n >= this.y && n <= this.y + this.height) {
      const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (n >= this.y + i && n <= this.y + this.height - i || e >= this.x + i && e <= this.x + this.width - i)
        return !0;
      let s = e - (this.x + i), o = n - (this.y + i);
      const a = i * i;
      if (s * s + o * o <= a || (s = e - (this.x + this.width - i), s * s + o * o <= a) || (o = n - (this.y + this.height - i), s * s + o * o <= a) || (s = e - (this.x + i), s * s + o * o <= a))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link RoundedRectangle.contains} For checking fill containment
   * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, i, s = 0.5) {
    const { x: o, y: a, width: h, height: c, radius: l } = this, u = i * (1 - s), f = i - u, d = o + l, p = a + l, y = h - l * 2, x = c - l * 2, m = o + h, g = a + c;
    return (e >= o - u && e <= o + f || e >= m - f && e <= m + u) && n >= p && n <= p + x || (n >= a - u && n <= a + f || n >= g - f && n <= g + u) && e >= d && e <= d + y ? !0 : (
      // Top-left
      e < d && n < p && Zo(
        e,
        n,
        d,
        p,
        l,
        f,
        u
      ) || e > m - l && n < p && Zo(
        e,
        n,
        m - l,
        p,
        l,
        f,
        u
      ) || e > m - l && n > g - l && Zo(
        e,
        n,
        m - l,
        g - l,
        l,
        f,
        u
      ) || e < d && n > g - l && Zo(
        e,
        n,
        d,
        g - l,
        l,
        f,
        u
      )
    );
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
  // #endif
};
const F2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: P2,
  Ellipse: I2,
  Polygon: L2,
  Rectangle: Fo,
  RoundedRectangle: B2
}, Symbol.toStringTag, { value: "Module" }));
let N2 = class c1 {
  /** @ignore */
  _x;
  /** @ignore */
  _y;
  /** This object used to call the `onUpdate` callback when the point changes. */
  _observer;
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e, n, i) {
    this._x = n || 0, this._y = i || 0, this._observer = e;
  }
  /**
   * Creates a clone of this point.
   * @example
   * ```ts
   * // Basic cloning
   * const point = new ObservablePoint(observer, 100, 200);
   * const copy = point.clone();
   *
   * // Clone with new observer
   * const newObserver = {
   *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
   * };
   * const watched = point.clone(newObserver);
   *
   * // Verify independence
   * watched.set(300, 400); // Only triggers new observer
   * ```
   * @param observer - Optional observer to pass to the new observable point
   * @returns A copy of this observable point
   * @see {@link ObservablePoint.copyFrom} For copying into existing point
   * @see {@link Observer} For observer interface details
   */
  clone(e) {
    return new c1(e ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new ObservablePoint(observer);
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.equals} For comparing positions
   */
  set(e = 0, n = e) {
    return (this._x !== e || this._y !== n) && (this._x = e, this._y = n, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(observer, 100, 200);
   * const target = new ObservablePoint();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new ObservablePoint()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyTo} For copying to another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyFrom(e) {
    return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(100, 200);
   * const target = new ObservablePoint();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyTo(e) {
    return e.set(this._x, this._y), e;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new ObservablePoint(100, 200);
   * const p2 = new ObservablePoint(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new ObservablePoint(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link ObservablePoint.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(e) {
    return e.x === this._x && e.y === this._y;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
  }
  // #endif
  /**
   * Position of the observable point on the x axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic x position
   * const point = new ObservablePoint(observer);
   * point.x = 100; // Triggers observer
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x !== e && (this._x = e, this._observer._onUpdate(this));
  }
  /**
   * Position of the observable point on the y axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic y position
   * const point = new ObservablePoint(observer);
   * point.y = 200; // Triggers observer
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y !== e && (this._y = e, this._observer._onUpdate(this));
  }
};
function q2(r, e, n, i, s, o, a, h) {
  const c = a - n, l = h - i, u = s - n, f = o - i, d = r - n, p = e - i, y = c * c + l * l, x = c * u + l * f, m = c * d + l * p, g = u * u + f * f, w = u * d + f * p, M = 1 / (y * g - x * x), S = (g * m - x * w) * M, E = (y * w - x * m) * M;
  return S >= 0 && E >= 0 && S + E < 1;
}
const D2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ObservablePoint: N2,
  Point: Ai,
  pointInTriangle: q2
}, Symbol.toStringTag, { value: "Module" })), $2 = (r, e) => r[0] * e[0] + r[1] * e[1], V2 = (r, e) => r[0] * e[1] - r[1] * e[0], $0 = (r, e) => Math.atan2(V2(r, e), $2(r, e));
function l1(r, e, n, i, s, o, a) {
  let h = Math.PI * 2;
  a === 0 && (a = 1e-6), a === h && (a = h - 1e-6);
  let c = Math.cos(s), l = Math.sin(s), u = c * n * Math.cos(o) - l * i * Math.sin(o) + r, f = l * n * Math.cos(o) + c * i * Math.sin(o) + e, d = c * n * Math.cos(o + a) - l * i * Math.sin(o + a) + r, p = l * n * Math.cos(o + a) + c * i * Math.sin(o + a) + e, y = Math.abs(a) > Math.PI ? 1 : 0, x = a > 0 ? 1 : 0;
  return {
    x1: u,
    y1: f,
    x2: d,
    y2: p,
    fa: y,
    //是大弧标志，如果选择跨度小于或等于 180 度的弧，则为 0，如果选择跨度大于 180 度的弧，则为 1。
    fs: x
    //是扫描标志，如果连接中心和圆弧的线扫描的角度减小，则为 0，如果扫描的角度增加，则为 1。
  };
}
function u1(r, e, n, i, s, o, a, h, c) {
  let l = Math.cos(c), u = Math.sin(c), f = l * (r - n) / 2 + u * (e - i) / 2, d = -u * (r - n) / 2 + l * (e - i) / 2, p = f * f / (a * a) + d * d / (h * h);
  p > 1 && (p = Math.sqrt(p), a *= p, h *= p);
  let y = s !== o ? 1 : -1, x = (a * a * h * h - a * a * d * d - h * h * f * f) / (a * a * d * d + h * h * f * f);
  x < 0 ? x = 0 : x = Math.sqrt(x);
  let m = y * x * (a * d / h), g = y * x * (-h * f / a), w = l * m - u * g + (r + n) / 2, M = u * m + l * g + (e + i) / 2, S = $0([1, 0], [(f - m) / a, (d - g) / h]), E = $0([(f - m) / a, (d - g) / h], [(-f - m) / a, (-d - g) / h]);
  !o && E > 0 ? E -= Math.PI * 2 : o && E < 0 && (E += Math.PI * 2);
  let A = S + E;
  return {
    rx: a,
    ry: h,
    cx: w,
    cy: M,
    theta1: S,
    // 是拉伸和旋转操作之前椭圆弧的起始角度。
    theta2: A,
    // 是拉伸和旋转操作之前椭圆弧的终止角度。
    dtheta: E
    // 是这两个角度之间的差值。
  };
}
function f1(r, e, n, i, s, o) {
  const a = Math.cos(o) * n, h = Math.sin(o) * i, c = Math.cos(s), l = Math.sin(s);
  return {
    x: r + c * a - l * h,
    y: e + l * a + c * h
  };
}
function lu(r, e, n, i, s, o, a) {
  const h = a - o, c = 4 / 3 * Math.tan(h / 4), l = O.fromRotation(o), u = O.fromRotation(a), f = O.fromPoint(l), d = O.fromPoint(u);
  return f.translate(-c * l.y, c * l.x), d.translate(c * u.y, -c * u.x), l.scale(n, i).rotate(s).translate(r, e), f.scale(n, i).rotate(s).translate(r, e), d.scale(n, i).rotate(s).translate(r, e), u.scale(n, i).rotate(s).translate(r, e), [l.x, l.y, f.x, f.y, d.x, d.y, u.x, u.y];
}
function Rh(r, e, n, i, s, o, a, h, c, l) {
  const { cx: u, cy: f, theta1: d, dtheta: p, rx: y, ry: x } = u1(r, e, n, i, h, c, s, o, a), m = Math.ceil(Math.abs(p / (Math.PI / 2))), g = p / m, w = [];
  let M = d;
  for (let S = 0; S < m; S++) {
    const E = M + g;
    let [A, I, b, v, _, z, P, k] = lu(u, f, y, x, a, M, E);
    l?.(A, I, b, v, _, z, P, k, S), M = E, w.push(A, I, b, v, _, z, P, k);
  }
  return w;
}
const d1 = Math.PI, U2 = Math.PI * 2, W2 = Math.PI * 0.5, j2 = 4 / 3 * (Math.sqrt(2) - 1);
function Y2(r) {
  return 4 / 3 * Math.tan(r / 4);
}
function H2(r) {
  return Math.ceil(Math.abs(r) / d1);
}
function X2(r) {
  for (var e = 0; e < r.length; e++)
    if (r[e] !== void 0 && !Number.isFinite(r[e]))
      return !1;
  return !0;
}
function Z2(r, e, n = 1e-5) {
  return Math.abs(r - e) <= n;
}
function G2(r) {
  return r * (180 / Math.PI);
}
function J2(r) {
  return r * (Math.PI / 180);
}
function Q2(r) {
  return Math.sqrt(r);
}
function K2(r, e) {
  return Math.pow(r, e);
}
function tw(r) {
  return Math.abs(r);
}
function ew(r, e) {
  return Math.min(r, e);
}
function nw(r, e) {
  return Math.max(r, e);
}
function iw(r, e) {
  return Math.random() * (e - r) + r;
}
function sw(r, e, n = 1e-4) {
  return (r(e + n) - r(e - n)) / (2 * n);
}
function ll(r) {
  if (r < 0) return -1;
  let e = 1;
  for (let n = 2; n <= r; n++)
    e *= n;
  return e;
}
function p1(r, e) {
  if (e > r) return 0;
  let n = 1;
  for (let i = 1; i <= e; i++)
    n *= (r - i + 1) / i;
  return n;
}
function rw(r, e) {
  if (e > r) return 0;
  let n = 1;
  for (let i = 1; i <= e; i++)
    n *= r - i + 1;
  return n;
}
function ow(r, e, n, i, s) {
  return (r - e) * (s - i) / (n - e) + i;
}
function Ce(r, e, n) {
  return Math.min(Math.max(r, e), n);
}
function aw(r, e, n) {
  return r * (1 - n) + e * n;
}
function hw(r, e, n) {
  return (n - r) / (e - r);
}
function cw(r, e, n) {
  const i = Ce((n - r) / (e - r), 0, 1);
  return i * i * (3 - 2 * i);
}
function lw(r, e, n) {
  const i = Ce((n - r) / (e - r), 0, 1);
  return i < 0.5 ? 4 * i * i * i : (i - 1) * (2 * i - 2) * (2 * i - 2) + 1;
}
function uw(r, e, n) {
  const i = Ce((n - r) / (e - r), 0, 1);
  return i * i * i;
}
function fw(r, e, n) {
  const i = Ce((n - r) / (e - r), 0, 1);
  return (i - 1) * (2 * i - 2) * (2 * i - 2) + 1;
}
function dw(r) {
  return (e) => class extends e {
    constructor(...n) {
      super(...n), Object.assign(this, r);
    }
  };
}
const pw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BEZIER_CIRCLE_GOLDEN_RATIO: j2,
  PI: d1,
  PI2: U2,
  PI_2: W2,
  abs: tw,
  allAreFinite: X2,
  calcArcGoldenRatio: Y2,
  calcArcSteps: H2,
  clamp: Ce,
  createMixin: dw,
  degreesToRadians: J2,
  derivative: sw,
  easeIn: uw,
  easeInOut: lw,
  easeOut: fw,
  equalsEpsilon: Z2,
  factorial: ll,
  inverseLerp: hw,
  lerp: aw,
  map: ow,
  max: nw,
  min: ew,
  nCr: p1,
  nPr: rw,
  pow: K2,
  radiansToDegrees: G2,
  random: iw,
  smoothstep: cw,
  sqrt: Q2
}, Symbol.toStringTag, { value: "Module" })), ht = 1e-6, yw = "zyx", V0 = new Float32Array([
  1,
  0,
  0,
  1
]);
class le extends Float32Array {
  /**
   * The number of bytes in a {@link Mat2}.
   */
  static BYTE_LENGTH = 4 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 4:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 4);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n
        ]) : super(n, 0, 4);
        break;
      default:
        super(V0);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat2.str(this);`
   */
  get str() {
    return le.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat2} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat2.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(V0), this;
  }
  /**
   * Multiplies this {@link Mat2} against another one
   * Equivalent to `Mat2.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return le.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat2.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Transpose this {@link Mat2}
   * Equivalent to `Mat2.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return le.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat2}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return le.invert(this, this);
  }
  /**
   * Scales this {@link Mat2} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat2.scale(this, this, v);`
   *
   * @param v - The {@link Vec2} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return le.scale(this, this, e);
  }
  /**
   * Rotates this {@link Mat2} by the given angle around the given axis
   * Equivalent to `Mat2.rotate(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  rotate(e) {
    return le.rotate(this, this, e);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat2}
   * @category Static
   *
   * @returns A new {@link Mat2}
   */
  static create() {
    return new le();
  }
  /**
   * Creates a new {@link Mat2} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat2}
   */
  static clone(e) {
    return new le(e);
  }
  /**
   * Copy the values from one {@link Mat2} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Create a new {@link Mat2} with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat2}
   */
  static fromValues(...e) {
    return new le(...e);
  }
  /**
   * Set the components of a {@link Mat2} to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set a {@link Mat2} to the identity matrix
   * @category Static
   *
   * @param out - The receiving matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, n) {
    if (e === n) {
      let i = n[1];
      e[1] = n[2], e[2] = i;
    } else
      e[0] = n[0], e[1] = n[2], e[2] = n[1], e[3] = n[3];
    return e;
  }
  /**
   * Inverts a {@link Mat2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3];
    let h = i * a - o * s;
    return h ? (h = 1 / h, e[0] = a * h, e[1] = -s * h, e[2] = -o * h, e[3] = i * h, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, n) {
    const i = n[0];
    return e[0] = n[3], e[1] = -n[1], e[2] = -n[2], e[3] = i, e;
  }
  /**
   * Calculates the determinant of a {@link Mat2}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    return e[0] * e[3] - e[2] * e[1];
  }
  /**
   * Adds two {@link Mat2}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e[2] = n[2] + i[2], e[3] = n[3] + i[3], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, i) {
    return e[0] = n[0] - i[0], e[1] = n[1] - i[1], e[2] = n[2] - i[2], e[3] = n[3] - i[3], e;
  }
  /**
   * Alias for {@link Mat2.subtract}
   * @category Static
   */
  static sub(e, n, i) {
    return e;
  }
  /**
   * Multiplies two {@link Mat2}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = i[0], l = i[1], u = i[2], f = i[3];
    return e[0] = s * c + a * l, e[1] = o * c + h * l, e[2] = s * u + a * f, e[3] = o * u + h * f, e;
  }
  /**
   * Alias for {@link Mat2.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return e;
  }
  /**
   * Rotates a {@link Mat2} by the given angle
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotate(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = Math.sin(i), l = Math.cos(i);
    return e[0] = s * l + a * c, e[1] = o * l + h * c, e[2] = s * -c + a * l, e[3] = o * -c + h * l, e;
  }
  /**
   * Scales the {@link Mat2} by the dimensions in the given {@link Vec2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec2} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = i[0], l = i[1];
    return e[0] = s * c, e[1] = o * c, e[2] = a * l, e[3] = h * l, e;
  }
  /**
   * Creates a {@link Mat2} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   * @category Static
   *
   * @param out - {@link Mat2} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromRotation(e, n) {
    const i = Math.sin(n), s = Math.cos(n);
    return e[0] = s, e[1] = i, e[2] = -i, e[3] = s, e;
  }
  /**
   * Creates a {@link Mat2} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat2} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = n[1], e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat2}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3]);
  }
  /**
   * Multiply each element of a {@link Mat2} by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = n[3] * i, e;
  }
  /**
   * Adds two {@link Mat2}'s after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, i, s) {
    return e[0] = n[0] + i[0] * s, e[1] = n[1] + i[1] * s, e[2] = n[2] + i[2] * s, e[3] = n[3] + i[3] * s, e;
  }
  /**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @category Static
   *
   * @param L - the lower triangular matrix
   * @param D - the diagonal matrix
   * @param U - the upper triangular matrix
   * @param a - the input matrix to factorize
   */
  static LDU(e, n, i, s) {
    return e[2] = s[2] / s[0], i[0] = s[0], i[1] = s[1], i[3] = s[3] - e[2] * i[1], [e, n, i];
  }
  /**
   * Returns whether or not two {@link Mat2}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3];
  }
  /**
   * Returns whether or not two {@link Mat2}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = e[2], a = e[3], h = n[0], c = n[1], l = n[2], u = n[3];
    return Math.abs(i - h) <= ht * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(s - c) <= ht * Math.max(1, Math.abs(s), Math.abs(c)) && Math.abs(o - l) <= ht * Math.max(1, Math.abs(o), Math.abs(l)) && Math.abs(a - u) <= ht * Math.max(1, Math.abs(a), Math.abs(u));
  }
  /**
   * Returns a string representation of a {@link Mat2}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat2(${e.join(", ")})`;
  }
}
le.prototype.mul = le.prototype.multiply;
le.mul = le.multiply;
le.sub = le.subtract;
const ur = le, U0 = new Float32Array([
  1,
  0,
  0,
  1,
  0,
  0
]);
class Te extends Float32Array {
  /**
   * The number of bytes in a {@link Mat2d}.
   */
  static BYTE_LENGTH = 6 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 6:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 6);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n,
          n,
          n
        ]) : super(n, 0, 6);
        break;
      default:
        super(U0);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat2d.str(this);`
   */
  get str() {
    return Te.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Mat2d} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat2d.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(U0), this;
  }
  /**
   * Multiplies this {@link Mat2d} against another one
   * Equivalent to `Mat2d.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return Te.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat2d.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Translate this {@link Mat2d} by the given vector
   * Equivalent to `Mat2d.translate(this, this, v);`
   *
   * @param v - The {@link Vec2} to translate by
   * @returns `this`
   */
  translate(e) {
    return Te.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat2d} by the given angle around the given axis
   * Equivalent to `Mat2d.rotate(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  rotate(e) {
    return Te.rotate(this, this, e);
  }
  /**
   * Scales this {@link Mat2d} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat2d.scale(this, this, v);`
   *
   * @param v - The {@link Vec2} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return Te.scale(this, this, e);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat2d}
   * @category Static
   *
   * @returns A new {@link Mat2d}
   */
  static create() {
    return new Te();
  }
  /**
   * Creates a new {@link Mat2d} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat2d}
   */
  static clone(e) {
    return new Te(e);
  }
  /**
   * Copy the values from one {@link Mat2d} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e;
  }
  /**
   * Create a new {@link Mat2d} with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat2d}
   */
  static fromValues(...e) {
    return new Te(...e);
  }
  /**
   * Set the components of a {@link Mat2d} to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e;
  }
  /**
   * Set a {@link Mat2d} to the identity matrix
   * @category Static
   *
   * @param out - The receiving matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
  }
  /**
   * Inverts a {@link Mat2d}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = n[4], c = n[5];
    let l = i * a - s * o;
    return l ? (l = 1 / l, e[0] = a * l, e[1] = -s * l, e[2] = -o * l, e[3] = i * l, e[4] = (o * c - a * h) * l, e[5] = (s * h - i * c) * l, e) : null;
  }
  /**
   * Calculates the determinant of a {@link Mat2d}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    return e[0] * e[3] - e[1] * e[2];
  }
  /**
   * Adds two {@link Mat2d}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e[2] = n[2] + i[2], e[3] = n[3] + i[3], e[4] = n[4] + i[4], e[5] = n[5] + i[5], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, i) {
    return e[0] = n[0] - i[0], e[1] = n[1] - i[1], e[2] = n[2] - i[2], e[3] = n[3] - i[3], e[4] = n[4] - i[4], e[5] = n[5] - i[5], e;
  }
  /**
   * Alias for {@link Mat2d.subtract}
   * @category Static
   */
  static sub(e, n, i) {
    return e;
  }
  /**
   * Multiplies two {@link Mat2d}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = i[0], f = i[1], d = i[2], p = i[3], y = i[4], x = i[5];
    return e[0] = s * u + a * f, e[1] = o * u + h * f, e[2] = s * d + a * p, e[3] = o * d + h * p, e[4] = s * y + a * x + c, e[5] = o * y + h * x + l, e;
  }
  /**
   * Alias for {@link Mat2d.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return e;
  }
  /**
   * Translate a {@link Mat2d} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = i[0], f = i[1];
    return e[0] = s, e[1] = o, e[2] = a, e[3] = h, e[4] = s * u + a * f + c, e[5] = o * u + h * f + l, e;
  }
  /**
   * Rotates a {@link Mat2d} by the given angle
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotate(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = Math.sin(i), f = Math.cos(i);
    return e[0] = s * f + a * u, e[1] = o * f + h * u, e[2] = s * -u + a * f, e[3] = o * -u + h * f, e[4] = c, e[5] = l, e;
  }
  /**
   * Scales the {@link Mat2d} by the dimensions in the given {@link Vec2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec2} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = i[0], f = i[1];
    return e[0] = s * u, e[1] = o * u, e[2] = a * f, e[3] = h * f, e[4] = c, e[5] = l, e;
  }
  // TODO: Got to fromRotation
  /**
   * Creates a {@link Mat2d} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     Mat2d.identity(dest);
   *     Mat2d.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat2d} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = n[0], e[5] = n[1], e;
  }
  /**
   * Creates a {@link Mat2d} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     Mat2d.identity(dest);
   *     Mat2d.rotate(dest, dest, rad);
   * @category Static
   *
   * @param out - {@link Mat2d} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromRotation(e, n) {
    const i = Math.sin(n), s = Math.cos(n);
    return e[0] = s, e[1] = i, e[2] = -i, e[3] = s, e[4] = 0, e[5] = 0, e;
  }
  /**
   * Creates a {@link Mat2d} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     Mat2d.identity(dest);
   *     Mat2d.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat2d} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = n[1], e[4] = 0, e[5] = 0, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat2d}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + 1);
  }
  /**
   * Multiply each element of a {@link Mat2d} by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = n[3] * i, e[4] = n[4] * i, e[5] = n[5] * i, e;
  }
  /**
   * Adds two {@link Mat2d}'s after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, i, s) {
    return e[0] = n[0] + i[0] * s, e[1] = n[1] + i[1] * s, e[2] = n[2] + i[2] * s, e[3] = n[3] + i[3] * s, e[4] = n[4] + i[4] * s, e[5] = n[5] + i[5] * s, e;
  }
  /**
   * Returns whether or not two {@link Mat2d}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5];
  }
  /**
   * Returns whether or not two {@link Mat2d}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = e[2], a = e[3], h = e[4], c = e[5], l = n[0], u = n[1], f = n[2], d = n[3], p = n[4], y = n[5];
    return Math.abs(i - l) <= ht * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - u) <= ht * Math.max(1, Math.abs(s), Math.abs(u)) && Math.abs(o - f) <= ht * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(a - d) <= ht * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(h - p) <= ht * Math.max(1, Math.abs(h), Math.abs(p)) && Math.abs(c - y) <= ht * Math.max(1, Math.abs(c), Math.abs(y));
  }
  /**
   * Returns a string representation of a {@link Mat2d}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat2d(${e.join(", ")})`;
  }
}
Te.mul = Te.multiply;
Te.sub = Te.subtract;
const Si = Te, W0 = new Float32Array([
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1
]);
class Zt extends Float32Array {
  /**
   * The number of bytes in a {@link Mat3}.
   */
  static BYTE_LENGTH = 9 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat3}.
   */
  constructor(...e) {
    switch (e.length) {
      case 9:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 9);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n
        ]) : super(n, 0, 9);
        break;
      default:
        super(W0);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat3.str(this);`
   */
  get str() {
    return Zt.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat3} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat3.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(W0), this;
  }
  /**
   * Multiplies this {@link Mat3} against another one
   * Equivalent to `Mat3.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return Zt.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat3.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Transpose this {@link Mat3}
   * Equivalent to `Mat3.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return Zt.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat3}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return Zt.invert(this, this);
  }
  /**
   * Translate this {@link Mat3} by the given vector
   * Equivalent to `Mat3.translate(this, this, v);`
   *
   * @param v - The {@link Vec2} to translate by
   * @returns `this`
   */
  translate(e) {
    return Zt.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat3} by the given angle around the given axis
   * Equivalent to `Mat3.rotate(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  rotate(e) {
    return Zt.rotate(this, this, e);
  }
  /**
   * Scales this {@link Mat3} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat3.scale(this, this, v);`
   *
   * @param v - The {@link Vec2} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return Zt.scale(this, this, e);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat3}
   * @category Static
   *
   * @returns A new {@link Mat3}
   */
  static create() {
    return new Zt();
  }
  /**
   * Creates a new {@link Mat3} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat3}
   */
  static clone(e) {
    return new Zt(e);
  }
  /**
   * Copy the values from one {@link Mat3} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e;
  }
  /**
   * Create a new {@link Mat3} with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat3}
   */
  static fromValues(...e) {
    return new Zt(...e);
  }
  /**
   * Set the components of a {@link Mat3} to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e;
  }
  /**
   * Set a {@link Mat3} to the identity matrix
   * @category Static
   *
   * @param out - The receiving matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat3}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, n) {
    if (e === n) {
      const i = n[1], s = n[2], o = n[5];
      e[1] = n[3], e[2] = n[6], e[3] = i, e[5] = n[7], e[6] = s, e[7] = o;
    } else
      e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8];
    return e;
  }
  /**
   * Inverts a {@link Mat3}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8], d = f * h - c * u, p = -f * a + c * l, y = u * a - h * l;
    let x = i * d + s * p + o * y;
    return x ? (x = 1 / x, e[0] = d * x, e[1] = (-f * s + o * u) * x, e[2] = (c * s - o * h) * x, e[3] = p * x, e[4] = (f * i - o * l) * x, e[5] = (-c * i + o * a) * x, e[6] = y * x, e[7] = (-u * i + s * l) * x, e[8] = (h * i - s * a) * x, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat3}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8];
    return e[0] = h * f - c * u, e[1] = o * u - s * f, e[2] = s * c - o * h, e[3] = c * l - a * f, e[4] = i * f - o * l, e[5] = o * a - i * c, e[6] = a * u - h * l, e[7] = s * l - i * u, e[8] = i * h - s * a, e;
  }
  /**
   * Calculates the determinant of a {@link Mat3}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    const n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], h = e[5], c = e[6], l = e[7], u = e[8];
    return n * (u * a - h * l) + i * (-u * o + h * c) + s * (l * o - a * c);
  }
  /**
   * Adds two {@link Mat3}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e[2] = n[2] + i[2], e[3] = n[3] + i[3], e[4] = n[4] + i[4], e[5] = n[5] + i[5], e[6] = n[6] + i[6], e[7] = n[7] + i[7], e[8] = n[8] + i[8], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, i) {
    return e[0] = n[0] - i[0], e[1] = n[1] - i[1], e[2] = n[2] - i[2], e[3] = n[3] - i[3], e[4] = n[4] - i[4], e[5] = n[5] - i[5], e[6] = n[6] - i[6], e[7] = n[7] - i[7], e[8] = n[8] - i[8], e;
  }
  /**
   * Alias for {@link Mat3.subtract}
   * @category Static
   */
  static sub(e, n, i) {
    return e;
  }
  /**
   * Multiplies two {@link Mat3}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8];
    let p = i[0], y = i[1], x = i[2];
    return e[0] = p * s + y * h + x * u, e[1] = p * o + y * c + x * f, e[2] = p * a + y * l + x * d, p = i[3], y = i[4], x = i[5], e[3] = p * s + y * h + x * u, e[4] = p * o + y * c + x * f, e[5] = p * a + y * l + x * d, p = i[6], y = i[7], x = i[8], e[6] = p * s + y * h + x * u, e[7] = p * o + y * c + x * f, e[8] = p * a + y * l + x * d, e;
  }
  /**
   * Alias for {@link Mat3.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return e;
  }
  /**
   * Translate a {@link Mat3} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8], p = i[0], y = i[1];
    return e[0] = s, e[1] = o, e[2] = a, e[3] = h, e[4] = c, e[5] = l, e[6] = p * s + y * h + u, e[7] = p * o + y * c + f, e[8] = p * a + y * l + d, e;
  }
  /**
   * Rotates a {@link Mat3} by the given angle
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotate(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8], p = Math.sin(i), y = Math.cos(i);
    return e[0] = y * s + p * h, e[1] = y * o + p * c, e[2] = y * a + p * l, e[3] = y * h - p * s, e[4] = y * c - p * o, e[5] = y * l - p * a, e[6] = u, e[7] = f, e[8] = d, e;
  }
  /**
   * Scales the {@link Mat3} by the dimensions in the given {@link Vec2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec2} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, i) {
    const s = i[0], o = i[1];
    return e[0] = s * n[0], e[1] = s * n[1], e[2] = s * n[2], e[3] = o * n[3], e[4] = o * n[4], e[5] = o * n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e;
  }
  /**
   * Creates a {@link Mat3} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat3} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = n[0], e[7] = n[1], e[8] = 1, e;
  }
  /**
   * Creates a {@link Mat3} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   * @category Static
   *
   * @param out - {@link Mat3} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromRotation(e, n) {
    const i = Math.sin(n), s = Math.cos(n);
    return e[0] = s, e[1] = i, e[2] = 0, e[3] = -i, e[4] = s, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
  }
  /**
   * Creates a {@link Mat3} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat3} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = n[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
  }
  /**
   * Copies the upper-left 3x3 values of a {@link Mat2d} into the given
   * {@link Mat3}.
   * @category Static
   *
   * @param out - the receiving 3x3 matrix
   * @param a - the source 2x3 matrix
   * @returns `out`
   */
  static fromMat2d(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = 0, e[3] = n[2], e[4] = n[3], e[5] = 0, e[6] = n[4], e[7] = n[5], e[8] = 1, e;
  }
  /**
   * Calculates a {@link Mat3} from the given quaternion
   *
   * @param out - {@link Mat3} receiving operation result
   * @param q - {@link Quat} to create matrix from
   * @returns `out`
   */
  static fromQuat(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = i + i, c = s + s, l = o + o, u = i * h, f = s * h, d = s * c, p = o * h, y = o * c, x = o * l, m = a * h, g = a * c, w = a * l;
    return e[0] = 1 - d - x, e[3] = f - w, e[6] = p + g, e[1] = f + w, e[4] = 1 - u - x, e[7] = y - m, e[2] = p - g, e[5] = y + m, e[8] = 1 - u - d, e;
  }
  /**
   * Copies the upper-left 3x3 values of a {@link Mat4} into the given
   * {@link Mat3}.
   * @category Static
   *
   * @param out - the receiving 3x3 matrix
   * @param a - the source 4x4 matrix
   * @returns `out`
   */
  static fromMat4(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[4], e[4] = n[5], e[5] = n[6], e[6] = n[8], e[7] = n[9], e[8] = n[10], e;
  }
  /**
   * Calculates a {@link Mat3} normal matrix (adjoint) from the upper 3x3 of a {@link Mat4}.
   * See https://www.shadertoy.com/view/3s33zj for details.
   * @category Static
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
   * @returns `out` or `null` if the matrix is not invertable
   */
  static normalFromMat4(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[4], h = n[5], c = n[6], l = n[8], u = n[9], f = n[10];
    return e[0] = h * f - c * u, e[1] = o * u - s * f, e[2] = s * c - o * h, e[3] = c * l - a * f, e[4] = i * f - o * l, e[5] = o * a - i * c, e[6] = a * u - h * l, e[7] = s * l - i * u, e[8] = i * h - s * a, e;
  }
  /**
   * Alias for {@link Mat3.adjointFromMat4}
   * @category Static
   * @deprecated Use {@link Mat3.normalFromMat4}
   */
  static normalFromMat4Fast(e, n) {
    return e;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   * @category Static
   *
   * @param out mat3 frustum matrix will be written into
   * @param width Width of your gl context
   * @param height Height of gl context
   * @returns `out`
   */
  static projection(e, n, i) {
    return e[0] = 2 / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / i, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat3}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(
      e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8]
    );
  }
  /**
   * Multiply each element of a {@link Mat3} by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = n[3] * i, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = n[7] * i, e[8] = n[8] * i, e;
  }
  /**
   * Adds two {@link Mat3}'s after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, i, s) {
    return e[0] = n[0] + i[0] * s, e[1] = n[1] + i[1] * s, e[2] = n[2] + i[2] * s, e[3] = n[3] + i[3] * s, e[4] = n[4] + i[4] * s, e[5] = n[5] + i[5] * s, e[6] = n[6] + i[6] * s, e[7] = n[7] + i[7] * s, e[8] = n[8] + i[8] * s, e;
  }
  /**
   * Returns whether or not two {@link Mat3}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5] && e[6] === n[6] && e[7] === n[7] && e[8] === n[8];
  }
  /**
   * Returns whether or not two {@link Mat3}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = e[2], a = e[3], h = e[4], c = e[5], l = e[6], u = e[7], f = e[8], d = n[0], p = n[1], y = n[2], x = n[3], m = n[4], g = n[5], w = n[6], M = n[7], S = n[8];
    return Math.abs(i - d) <= ht * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(s - p) <= ht * Math.max(1, Math.abs(s), Math.abs(p)) && Math.abs(o - y) <= ht * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(a - x) <= ht * Math.max(1, Math.abs(a), Math.abs(x)) && Math.abs(h - m) <= ht * Math.max(1, Math.abs(h), Math.abs(m)) && Math.abs(c - g) <= ht * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(l - w) <= ht * Math.max(1, Math.abs(l), Math.abs(w)) && Math.abs(u - M) <= ht * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(f - S) <= ht * Math.max(1, Math.abs(f), Math.abs(S));
  }
  /**
   * Returns a string representation of a {@link Mat3}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat3(${e.join(", ")})`;
  }
}
Zt.prototype.mul = Zt.prototype.multiply;
Zt.mul = Zt.multiply;
Zt.sub = Zt.subtract;
Zt.normalFromMat4Fast = Zt.normalFromMat4;
const y1 = Zt, j0 = new Float32Array([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]);
class At extends Float32Array {
  /**
   * The number of bytes in a {@link Mat4}.
   */
  static BYTE_LENGTH = 16 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat4}.
   */
  constructor(...e) {
    switch (e.length) {
      case 16:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 16);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n
        ]) : super(n, 0, 16);
        break;
      default:
        super(j0);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat4.str(this);`
   */
  get str() {
    return At.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat4} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat4.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(j0), this;
  }
  /**
   * Multiplies this {@link Mat4} against another one
   * Equivalent to `Mat4.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return At.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat4.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Transpose this {@link Mat4}
   * Equivalent to `Mat4.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return At.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat4}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return At.invert(this, this);
  }
  /**
   * Translate this {@link Mat4} by the given vector
   * Equivalent to `Mat4.translate(this, this, v);`
   *
   * @param v - The {@link Vec3} to translate by
   * @returns `this`
   */
  translate(e) {
    return At.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the given axis
   * Equivalent to `Mat4.rotate(this, this, rad, axis);`
   *
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  rotate(e, n) {
    return At.rotate(this, this, e, n);
  }
  /**
   * Scales this {@link Mat4} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat4.scale(this, this, v);`
   *
   * @param v - The {@link Vec3} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return At.scale(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the X axis
   * Equivalent to `Mat4.rotateX(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateX(e) {
    return At.rotateX(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Y axis
   * Equivalent to `Mat4.rotateY(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateY(e) {
    return At.rotateY(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Z axis
   * Equivalent to `Mat4.rotateZ(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateZ(e) {
    return At.rotateZ(this, this, e);
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveNO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveNO(e, n, i, s) {
    return At.perspectiveNO(this, e, n, i, s);
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveZO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveZO(e, n, i, s) {
    return At.perspectiveZO(this, e, n, i, s);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Equivalent to `Mat4.orthoNO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoNO(e, n, i, s, o, a) {
    return At.orthoNO(this, e, n, i, s, o, a);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Equivalent to `Mat4.orthoZO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoZO(e, n, i, s, o, a) {
    return At.orthoZO(this, e, n, i, s, o, a);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat4}
   * @category Static
   *
   * @returns A new {@link Mat4}
   */
  static create() {
    return new At();
  }
  /**
   * Creates a new {@link Mat4} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat4}
   */
  static clone(e) {
    return new At(e);
  }
  /**
   * Copy the values from one {@link Mat4} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e;
  }
  /**
   * Create a new mat4 with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat4}
   */
  static fromValues(...e) {
    return new At(...e);
  }
  /**
   * Set the components of a mat4 to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e;
  }
  /**
   * Set a {@link Mat4} to the identity matrix
   * @category Static
   *
   * @param out - The receiving Matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, n) {
    if (e === n) {
      const i = n[1], s = n[2], o = n[3], a = n[6], h = n[7], c = n[11];
      e[1] = n[4], e[2] = n[8], e[3] = n[12], e[4] = i, e[6] = n[9], e[7] = n[13], e[8] = s, e[9] = a, e[11] = n[14], e[12] = o, e[13] = h, e[14] = c;
    } else
      e[0] = n[0], e[1] = n[4], e[2] = n[8], e[3] = n[12], e[4] = n[1], e[5] = n[5], e[6] = n[9], e[7] = n[13], e[8] = n[2], e[9] = n[6], e[10] = n[10], e[11] = n[14], e[12] = n[3], e[13] = n[7], e[14] = n[11], e[15] = n[15];
    return e;
  }
  /**
   * Inverts a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8], d = n[9], p = n[10], y = n[11], x = n[12], m = n[13], g = n[14], w = n[15], M = i * c - s * h, S = i * l - o * h, E = i * u - a * h, A = s * l - o * c, I = s * u - a * c, b = o * u - a * l, v = f * m - d * x, _ = f * g - p * x, z = f * w - y * x, P = d * g - p * m, k = d * w - y * m, B = p * w - y * g;
    let R = M * B - S * k + E * P + A * z - I * _ + b * v;
    return R ? (R = 1 / R, e[0] = (c * B - l * k + u * P) * R, e[1] = (o * k - s * B - a * P) * R, e[2] = (m * b - g * I + w * A) * R, e[3] = (p * I - d * b - y * A) * R, e[4] = (l * z - h * B - u * _) * R, e[5] = (i * B - o * z + a * _) * R, e[6] = (g * E - x * b - w * S) * R, e[7] = (f * b - p * E + y * S) * R, e[8] = (h * k - c * z + u * v) * R, e[9] = (s * z - i * k - a * v) * R, e[10] = (x * I - m * E + w * M) * R, e[11] = (d * E - f * I - y * M) * R, e[12] = (c * _ - h * P - l * v) * R, e[13] = (i * P - s * _ + o * v) * R, e[14] = (m * S - x * A - g * M) * R, e[15] = (f * A - d * S + p * M) * R, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8], d = n[9], p = n[10], y = n[11], x = n[12], m = n[13], g = n[14], w = n[15], M = i * c - s * h, S = i * l - o * h, E = i * u - a * h, A = s * l - o * c, I = s * u - a * c, b = o * u - a * l, v = f * m - d * x, _ = f * g - p * x, z = f * w - y * x, P = d * g - p * m, k = d * w - y * m, B = p * w - y * g;
    return e[0] = c * B - l * k + u * P, e[1] = o * k - s * B - a * P, e[2] = m * b - g * I + w * A, e[3] = p * I - d * b - y * A, e[4] = l * z - h * B - u * _, e[5] = i * B - o * z + a * _, e[6] = g * E - x * b - w * S, e[7] = f * b - p * E + y * S, e[8] = h * k - c * z + u * v, e[9] = s * z - i * k - a * v, e[10] = x * I - m * E + w * M, e[11] = d * E - f * I - y * M, e[12] = c * _ - h * P - l * v, e[13] = i * P - s * _ + o * v, e[14] = m * S - x * A - g * M, e[15] = f * A - d * S + p * M, e;
  }
  /**
   * Calculates the determinant of a {@link Mat4}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    const n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = e[9], d = e[10], p = e[11], y = e[12], x = e[13], m = e[14], g = e[15], w = n * h - i * a, M = n * c - s * a, S = i * c - s * h, E = u * x - f * y, A = u * m - d * y, I = f * m - d * x, b = n * I - i * A + s * E, v = a * I - h * A + c * E, _ = u * S - f * M + d * w, z = y * S - x * M + m * w;
    return l * b - o * v + g * _ - p * z;
  }
  /**
   * Multiplies two {@link Mat4}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8], p = n[9], y = n[10], x = n[11], m = n[12], g = n[13], w = n[14], M = n[15];
    let S = i[0], E = i[1], A = i[2], I = i[3];
    return e[0] = S * s + E * c + A * d + I * m, e[1] = S * o + E * l + A * p + I * g, e[2] = S * a + E * u + A * y + I * w, e[3] = S * h + E * f + A * x + I * M, S = i[4], E = i[5], A = i[6], I = i[7], e[4] = S * s + E * c + A * d + I * m, e[5] = S * o + E * l + A * p + I * g, e[6] = S * a + E * u + A * y + I * w, e[7] = S * h + E * f + A * x + I * M, S = i[8], E = i[9], A = i[10], I = i[11], e[8] = S * s + E * c + A * d + I * m, e[9] = S * o + E * l + A * p + I * g, e[10] = S * a + E * u + A * y + I * w, e[11] = S * h + E * f + A * x + I * M, S = i[12], E = i[13], A = i[14], I = i[15], e[12] = S * s + E * c + A * d + I * m, e[13] = S * o + E * l + A * p + I * g, e[14] = S * a + E * u + A * y + I * w, e[15] = S * h + E * f + A * x + I * M, e;
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return e;
  }
  /**
   * Translate a {@link Mat4} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, i) {
    const s = i[0], o = i[1], a = i[2];
    if (n === e)
      e[12] = n[0] * s + n[4] * o + n[8] * a + n[12], e[13] = n[1] * s + n[5] * o + n[9] * a + n[13], e[14] = n[2] * s + n[6] * o + n[10] * a + n[14], e[15] = n[3] * s + n[7] * o + n[11] * a + n[15];
    else {
      const h = n[0], c = n[1], l = n[2], u = n[3], f = n[4], d = n[5], p = n[6], y = n[7], x = n[8], m = n[9], g = n[10], w = n[11];
      e[0] = h, e[1] = c, e[2] = l, e[3] = u, e[4] = f, e[5] = d, e[6] = p, e[7] = y, e[8] = x, e[9] = m, e[10] = g, e[11] = w, e[12] = h * s + f * o + x * a + n[12], e[13] = c * s + d * o + m * a + n[13], e[14] = l * s + p * o + g * a + n[14], e[15] = u * s + y * o + w * a + n[15];
    }
    return e;
  }
  /**
   * Scales the {@link Mat4} by the dimensions in the given {@link Vec3} not using vectorization
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec3} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, i) {
    const s = i[0], o = i[1], a = i[2];
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e[4] = n[4] * o, e[5] = n[5] * o, e[6] = n[6] * o, e[7] = n[7] * o, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = n[11] * a, e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e;
  }
  /**
   * Rotates a {@link Mat4} by the given angle around the given axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if axis has a length of 0
   */
  static rotate(e, n, i, s) {
    let o = s[0], a = s[1], h = s[2], c = Math.sqrt(o * o + a * a + h * h);
    if (c < ht)
      return null;
    c = 1 / c, o *= c, a *= c, h *= c;
    const l = Math.sin(i), u = Math.cos(i), f = 1 - u, d = n[0], p = n[1], y = n[2], x = n[3], m = n[4], g = n[5], w = n[6], M = n[7], S = n[8], E = n[9], A = n[10], I = n[11], b = o * o * f + u, v = a * o * f + h * l, _ = h * o * f - a * l, z = o * a * f - h * l, P = a * a * f + u, k = h * a * f + o * l, B = o * h * f + a * l, R = a * h * f - o * l, L = h * h * f + u;
    return e[0] = d * b + m * v + S * _, e[1] = p * b + g * v + E * _, e[2] = y * b + w * v + A * _, e[3] = x * b + M * v + I * _, e[4] = d * z + m * P + S * k, e[5] = p * z + g * P + E * k, e[6] = y * z + w * P + A * k, e[7] = x * z + M * P + I * k, e[8] = d * B + m * R + S * L, e[9] = p * B + g * R + E * L, e[10] = y * B + w * R + A * L, e[11] = x * B + M * R + I * L, n !== e && (e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateX(e, n, i) {
    let s = Math.sin(i), o = Math.cos(i), a = n[4], h = n[5], c = n[6], l = n[7], u = n[8], f = n[9], d = n[10], p = n[11];
    return n !== e && (e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e[4] = a * o + u * s, e[5] = h * o + f * s, e[6] = c * o + d * s, e[7] = l * o + p * s, e[8] = u * o - a * s, e[9] = f * o - h * s, e[10] = d * o - c * s, e[11] = p * o - l * s, e;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateY(e, n, i) {
    let s = Math.sin(i), o = Math.cos(i), a = n[0], h = n[1], c = n[2], l = n[3], u = n[8], f = n[9], d = n[10], p = n[11];
    return n !== e && (e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e[0] = a * o - u * s, e[1] = h * o - f * s, e[2] = c * o - d * s, e[3] = l * o - p * s, e[8] = a * s + u * o, e[9] = h * s + f * o, e[10] = c * s + d * o, e[11] = l * s + p * o, e;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateZ(e, n, i) {
    let s = Math.sin(i), o = Math.cos(i), a = n[0], h = n[1], c = n[2], l = n[3], u = n[4], f = n[5], d = n[6], p = n[7];
    return n !== e && (e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e[0] = a * o + u * s, e[1] = h * o + f * s, e[2] = c * o + d * s, e[3] = l * o + p * s, e[4] = u * o - a * s, e[5] = f * o - h * s, e[6] = d * o - c * s, e[7] = p * o - l * s, e;
  }
  /**
   * Creates a {@link Mat4} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = n[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if `axis` has a length of 0
   */
  static fromRotation(e, n, i) {
    let s = i[0], o = i[1], a = i[2], h = Math.sqrt(s * s + o * o + a * a);
    if (h < ht)
      return null;
    h = 1 / h, s *= h, o *= h, a *= h;
    const c = Math.sin(n), l = Math.cos(n), u = 1 - l;
    return e[0] = s * s * u + l, e[1] = o * s * u + a * c, e[2] = a * s * u - o * c, e[3] = 0, e[4] = s * o * u - a * c, e[5] = o * o * u + l, e[6] = a * o * u + s * c, e[7] = 0, e[8] = s * a * u + o * c, e[9] = o * a * u - s * c, e[10] = a * a * u + l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromXRotation(e, n) {
    let i = Math.sin(n), s = Math.cos(n);
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = i, e[7] = 0, e[8] = 0, e[9] = -i, e[10] = s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromYRotation(e, n) {
    let i = Math.sin(n), s = Math.cos(n);
    return e[0] = s, e[1] = 0, e[2] = -i, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = i, e[9] = 0, e[10] = s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromZRotation(e, n) {
    const i = Math.sin(n), s = Math.cos(n);
    return e[0] = s, e[1] = i, e[2] = 0, e[3] = 0, e[4] = -i, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @returns `out`
   */
  static fromRotationTranslation(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = s + s, l = o + o, u = a + a, f = s * c, d = s * l, p = s * u, y = o * l, x = o * u, m = a * u, g = h * c, w = h * l, M = h * u;
    return e[0] = 1 - (y + m), e[1] = d + M, e[2] = p - w, e[3] = 0, e[4] = d - M, e[5] = 1 - (f + m), e[6] = x + g, e[7] = 0, e[8] = p + w, e[9] = x - g, e[10] = 1 - (f + y), e[11] = 0, e[12] = i[0], e[13] = i[1], e[14] = i[2], e[15] = 1, e;
  }
  /**
   * Sets a {@link Mat4} from a {@link Quat2}.
   * @category Static
   *
   * @param out - Matrix
   * @param a - Dual Quaternion
   * @returns `out`
   */
  static fromQuat2(e, n) {
    const i = -n[0], s = -n[1], o = -n[2], a = n[3], h = n[4], c = n[5], l = n[6], u = n[7];
    let f = i * i + s * s + o * o + a * a;
    return f > 0 ? (ln[0] = (h * a + u * i + c * o - l * s) * 2 / f, ln[1] = (c * a + u * s + l * i - h * o) * 2 / f, ln[2] = (l * a + u * o + h * s - c * i) * 2 / f) : (ln[0] = (h * a + u * i + c * o - l * s) * 2, ln[1] = (c * a + u * s + l * i - h * o) * 2, ln[2] = (l * a + u * o + h * s - c * i) * 2), At.fromRotationTranslation(e, n, ln), e;
  }
  /**
   * Calculates a {@link Mat4} normal matrix (adjoint) from a {@link Mat4}
   * See https://www.shadertoy.com/view/3s33zj for details.
   * @category Static
   *
   * @param out - Matrix receiving operation result
   * @param a - Mat4 to derive the normal matrix from
   * @returns `out`
   */
  static normalFromMat4(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[4], h = n[5], c = n[6], l = n[8], u = n[9], f = n[10];
    return e[0] = h * f - c * u, e[1] = o * u - s * f, e[2] = s * c - o * h, e[3] = 0, e[4] = c * l - a * f, e[5] = i * f - o * l, e[6] = o * a - i * c, e[7] = 0, e[8] = a * u - h * l, e[9] = s * l - i * u, e[10] = i * h - s * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Alias for {@link Mat4.adjointFromMat4}
   * @category Static
   * @deprecated Use {@link Mat4.normalFromMat4}
   */
  static normalFromMat4Fast(e, n) {
    return e;
  }
  /**
   * Returns the translation vector component of a transformation
   * matrix. If a matrix is built with fromRotationTranslation,
   * the returned vector will be the same as the translation vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getTranslation(e, n) {
    return e[0] = n[12], e[1] = n[13], e[2] = n[14], e;
  }
  /**
   * Returns the scaling factor component of a transformation
   * matrix. If a matrix is built with fromRotationTranslationScale
   * with a normalized Quaternion parameter, the returned vector will be
   * the same as the scaling vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getScaling(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[4], h = n[5], c = n[6], l = n[8], u = n[9], f = n[10];
    return e[0] = Math.sqrt(i * i + s * s + o * o), e[1] = Math.sqrt(a * a + h * h + c * c), e[2] = Math.sqrt(l * l + u * u + f * f), e;
  }
  /**
   * Returns a quaternion representing the rotational component
   * of a transformation matrix. If a matrix is built with
   * fromRotationTranslation, the returned quaternion will be the
   * same as the quaternion originally supplied.
   * @category Static
   *
   * @param out - Quaternion to receive the rotation component
   * @param mat - Matrix to be decomposed (input)
   * @return `out`
   */
  static getRotation(e, n) {
    At.getScaling(ln, n);
    const i = 1 / ln[0], s = 1 / ln[1], o = 1 / ln[2], a = n[0] * i, h = n[1] * s, c = n[2] * o, l = n[4] * i, u = n[5] * s, f = n[6] * o, d = n[8] * i, p = n[9] * s, y = n[10] * o, x = a + u + y;
    let m = 0;
    return x > 0 ? (m = Math.sqrt(x + 1) * 2, e[3] = 0.25 * m, e[0] = (f - p) / m, e[1] = (d - c) / m, e[2] = (h - l) / m) : a > u && a > y ? (m = Math.sqrt(1 + a - u - y) * 2, e[3] = (f - p) / m, e[0] = 0.25 * m, e[1] = (h + l) / m, e[2] = (d + c) / m) : u > y ? (m = Math.sqrt(1 + u - a - y) * 2, e[3] = (d - c) / m, e[0] = (h + l) / m, e[1] = 0.25 * m, e[2] = (f + p) / m) : (m = Math.sqrt(1 + y - a - u) * 2, e[3] = (h - l) / m, e[0] = (d + c) / m, e[1] = (f + p) / m, e[2] = 0.25 * m), e;
  }
  /**
   * Decomposes a transformation matrix into its rotation, translation
   * and scale components. Returns only the rotation component
   * @category Static
   *
   * @param out_r - Quaternion to receive the rotation component
   * @param out_t - Vector to receive the translation vector
   * @param out_s - Vector to receive the scaling factor
   * @param mat - Matrix to be decomposed (input)
   * @returns `out_r`
   */
  static decompose(e, n, i, s) {
    n[0] = s[12], n[1] = s[13], n[2] = s[14];
    const o = s[0], a = s[1], h = s[2], c = s[4], l = s[5], u = s[6], f = s[8], d = s[9], p = s[10];
    i[0] = Math.sqrt(o * o + a * a + h * h), i[1] = Math.sqrt(c * c + l * l + u * u), i[2] = Math.sqrt(f * f + d * d + p * p);
    const y = 1 / i[0], x = 1 / i[1], m = 1 / i[2], g = o * y, w = a * x, M = h * m, S = c * y, E = l * x, A = u * m, I = f * y, b = d * x, v = p * m, _ = g + E + v;
    let z = 0;
    return _ > 0 ? (z = Math.sqrt(_ + 1) * 2, e[3] = 0.25 * z, e[0] = (A - b) / z, e[1] = (I - M) / z, e[2] = (w - S) / z) : g > E && g > v ? (z = Math.sqrt(1 + g - E - v) * 2, e[3] = (A - b) / z, e[0] = 0.25 * z, e[1] = (w + S) / z, e[2] = (I + M) / z) : E > v ? (z = Math.sqrt(1 + E - g - v) * 2, e[3] = (I - M) / z, e[0] = (w + S) / z, e[1] = 0.25 * z, e[2] = (A + b) / z) : (z = Math.sqrt(1 + v - g - E) * 2, e[3] = (w - S) / z, e[0] = (I + M) / z, e[1] = (A + b) / z, e[2] = 0.25 * z), e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @returns `out`
   */
  static fromRotationTranslationScale(e, n, i, s) {
    const o = n[0], a = n[1], h = n[2], c = n[3], l = o + o, u = a + a, f = h + h, d = o * l, p = o * u, y = o * f, x = a * u, m = a * f, g = h * f, w = c * l, M = c * u, S = c * f, E = s[0], A = s[1], I = s[2];
    return e[0] = (1 - (x + g)) * E, e[1] = (p + S) * E, e[2] = (y - M) * E, e[3] = 0, e[4] = (p - S) * A, e[5] = (1 - (d + g)) * A, e[6] = (m + w) * A, e[7] = 0, e[8] = (y + M) * I, e[9] = (m - w) * I, e[10] = (1 - (d + x)) * I, e[11] = 0, e[12] = i[0], e[13] = i[1], e[14] = i[2], e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @param o - The origin vector around which to scale and rotate
   * @returns `out`
   */
  static fromRotationTranslationScaleOrigin(e, n, i, s, o) {
    const a = n[0], h = n[1], c = n[2], l = n[3], u = a + a, f = h + h, d = c + c, p = a * u, y = a * f, x = a * d, m = h * f, g = h * d, w = c * d, M = l * u, S = l * f, E = l * d, A = s[0], I = s[1], b = s[2], v = o[0], _ = o[1], z = o[2], P = (1 - (m + w)) * A, k = (y + E) * A, B = (x - S) * A, R = (y - E) * I, L = (1 - (p + w)) * I, N = (g + M) * I, q = (x + S) * b, U = (g - M) * b, J = (1 - (p + m)) * b;
    return e[0] = P, e[1] = k, e[2] = B, e[3] = 0, e[4] = R, e[5] = L, e[6] = N, e[7] = 0, e[8] = q, e[9] = U, e[10] = J, e[11] = 0, e[12] = i[0] + v - (P * v + R * _ + q * z), e[13] = i[1] + _ - (k * v + L * _ + U * z), e[14] = i[2] + z - (B * v + N * _ + J * z), e[15] = 1, e;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Quaternion to create matrix from
   * @returns `out`
   */
  static fromQuat(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = i + i, c = s + s, l = o + o, u = i * h, f = s * h, d = s * c, p = o * h, y = o * c, x = o * l, m = a * h, g = a * c, w = a * l;
    return e[0] = 1 - d - x, e[1] = f + w, e[2] = p - g, e[3] = 0, e[4] = f - w, e[5] = 1 - u - x, e[6] = y + m, e[7] = 0, e[8] = p + g, e[9] = y - m, e[10] = 1 - u - d, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far -  Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumNO(e, n, i, s, o, a, h = 1 / 0) {
    const c = 1 / (i - n), l = 1 / (o - s);
    if (e[0] = a * 2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a * 2 * l, e[6] = 0, e[7] = 0, e[8] = (i + n) * c, e[9] = (o + s) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, h != null && h !== 1 / 0) {
      const u = 1 / (a - h);
      e[10] = (h + a) * u, e[14] = 2 * h * a * u;
    } else
      e[10] = -1, e[14] = -2 * a;
    return e;
  }
  /**
   * Alias for {@link Mat4.frustumNO}
   * @category Static
   * @deprecated Use {@link Mat4.frustumNO} or {@link Mat4.frustumZO} explicitly
   */
  static frustum(e, n, i, s, o, a, h = 1 / 0) {
    return e;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumZO(e, n, i, s, o, a, h = 1 / 0) {
    const c = 1 / (i - n), l = 1 / (o - s);
    if (e[0] = a * 2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a * 2 * l, e[6] = 0, e[7] = 0, e[8] = (i + n) * c, e[9] = (o + s) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, h != null && h !== 1 / 0) {
      const u = 1 / (a - h);
      e[10] = h * u, e[14] = h * a * u;
    } else
      e[10] = -1, e[14] = -a;
    return e;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveNO(e, n, i, s, o = 1 / 0) {
    const a = 1 / Math.tan(n / 2);
    if (e[0] = a / i, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, o != null && o !== 1 / 0) {
      const h = 1 / (s - o);
      e[10] = (o + s) * h, e[14] = 2 * o * s * h;
    } else
      e[10] = -1, e[14] = -2 * s;
    return e;
  }
  /**
   * Alias for {@link Mat4.perspectiveNO}
   * @category Static
   * @deprecated Use {@link Mat4.perspectiveNO} or {@link Mat4.perspectiveZO} explicitly
   */
  static perspective(e, n, i, s, o = 1 / 0) {
    return e;
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveZO(e, n, i, s, o = 1 / 0) {
    const a = 1 / Math.tan(n / 2);
    if (e[0] = a / i, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, o != null && o !== 1 / 0) {
      const h = 1 / (s - o);
      e[10] = o * h, e[14] = o * s * h;
    } else
      e[10] = -1, e[14] = -s;
    return e;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fov - Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   * @deprecated
   */
  static perspectiveFromFieldOfView(e, n, i, s) {
    const o = Math.tan(n.upDegrees * Math.PI / 180), a = Math.tan(n.downDegrees * Math.PI / 180), h = Math.tan(n.leftDegrees * Math.PI / 180), c = Math.tan(n.rightDegrees * Math.PI / 180), l = 2 / (h + c), u = 2 / (o + a);
    return e[0] = l, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = u, e[6] = 0, e[7] = 0, e[8] = -((h - c) * l * 0.5), e[9] = (o - a) * u * 0.5, e[10] = s / (i - s), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * i / (i - s), e[15] = 0, e;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoNO(e, n, i, s, o, a, h) {
    const c = 1 / (n - i), l = 1 / (s - o), u = 1 / (a - h);
    return e[0] = -2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (n + i) * c, e[13] = (o + s) * l, e[14] = (h + a) * u, e[15] = 1, e;
  }
  /**
   * Alias for {@link Mat4.orthoNO}
   * @category Static
   * @deprecated Use {@link Mat4.orthoNO} or {@link Mat4.orthoZO} explicitly
   */
  static ortho(e, n, i, s, o, a, h) {
    return e;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoZO(e, n, i, s, o, a, h) {
    const c = 1 / (n - i), l = 1 / (s - o), u = 1 / (a - h);
    return e[0] = -2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = u, e[11] = 0, e[12] = (n + i) * c, e[13] = (o + s) * l, e[14] = a * u, e[15] = 1, e;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param center - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static lookAt(e, n, i, s) {
    const o = n[0], a = n[1], h = n[2], c = s[0], l = s[1], u = s[2], f = i[0], d = i[1], p = i[2];
    if (Math.abs(o - f) < ht && Math.abs(a - d) < ht && Math.abs(h - p) < ht)
      return At.identity(e);
    let y = o - f, x = a - d, m = h - p, g = 1 / Math.sqrt(y * y + x * x + m * m);
    y *= g, x *= g, m *= g;
    let w = l * m - u * x, M = u * y - c * m, S = c * x - l * y;
    g = Math.sqrt(w * w + M * M + S * S), g ? (g = 1 / g, w *= g, M *= g, S *= g) : (w = 0, M = 0, S = 0);
    let E = x * S - m * M, A = m * w - y * S, I = y * M - x * w;
    return g = Math.sqrt(E * E + A * A + I * I), g ? (g = 1 / g, E *= g, A *= g, I *= g) : (E = 0, A = 0, I = 0), e[0] = w, e[1] = E, e[2] = y, e[3] = 0, e[4] = M, e[5] = A, e[6] = x, e[7] = 0, e[8] = S, e[9] = I, e[10] = m, e[11] = 0, e[12] = -(w * o + M * a + S * h), e[13] = -(E * o + A * a + I * h), e[14] = -(y * o + x * a + m * h), e[15] = 1, e;
  }
  /**
   * Generates a matrix that makes something look at something else.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param target - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static targetTo(e, n, i, s) {
    const o = n[0], a = n[1], h = n[2], c = s[0], l = s[1], u = s[2];
    let f = o - i[0], d = a - i[1], p = h - i[2], y = f * f + d * d + p * p;
    y > 0 && (y = 1 / Math.sqrt(y), f *= y, d *= y, p *= y);
    let x = l * p - u * d, m = u * f - c * p, g = c * d - l * f;
    return y = x * x + m * m + g * g, y > 0 && (y = 1 / Math.sqrt(y), x *= y, m *= y, g *= y), e[0] = x, e[1] = m, e[2] = g, e[3] = 0, e[4] = d * g - p * m, e[5] = p * x - f * g, e[6] = f * m - d * x, e[7] = 0, e[8] = f, e[9] = d, e[10] = p, e[11] = 0, e[12] = o, e[13] = a, e[14] = h, e[15] = 1, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat4}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(
      e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8] + e[9] * e[9] + e[10] * e[10] + e[11] * e[11] + e[12] * e[12] + e[13] * e[13] + e[14] * e[14] + e[15] * e[15]
    );
  }
  /**
   * Adds two {@link Mat4}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e[2] = n[2] + i[2], e[3] = n[3] + i[3], e[4] = n[4] + i[4], e[5] = n[5] + i[5], e[6] = n[6] + i[6], e[7] = n[7] + i[7], e[8] = n[8] + i[8], e[9] = n[9] + i[9], e[10] = n[10] + i[10], e[11] = n[11] + i[11], e[12] = n[12] + i[12], e[13] = n[13] + i[13], e[14] = n[14] + i[14], e[15] = n[15] + i[15], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, i) {
    return e[0] = n[0] - i[0], e[1] = n[1] - i[1], e[2] = n[2] - i[2], e[3] = n[3] - i[3], e[4] = n[4] - i[4], e[5] = n[5] - i[5], e[6] = n[6] - i[6], e[7] = n[7] - i[7], e[8] = n[8] - i[8], e[9] = n[9] - i[9], e[10] = n[10] - i[10], e[11] = n[11] - i[11], e[12] = n[12] - i[12], e[13] = n[13] - i[13], e[14] = n[14] - i[14], e[15] = n[15] - i[15], e;
  }
  /**
   * Alias for {@link Mat4.subtract}
   * @category Static
   */
  static sub(e, n, i) {
    return e;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = n[3] * i, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = n[7] * i, e[8] = n[8] * i, e[9] = n[9] * i, e[10] = n[10] * i, e[11] = n[11] * i, e[12] = n[12] * i, e[13] = n[13] * i, e[14] = n[14] * i, e[15] = n[15] * i, e;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, i, s) {
    return e[0] = n[0] + i[0] * s, e[1] = n[1] + i[1] * s, e[2] = n[2] + i[2] * s, e[3] = n[3] + i[3] * s, e[4] = n[4] + i[4] * s, e[5] = n[5] + i[5] * s, e[6] = n[6] + i[6] * s, e[7] = n[7] + i[7] * s, e[8] = n[8] + i[8] * s, e[9] = n[9] + i[9] * s, e[10] = n[10] + i[10] * s, e[11] = n[11] + i[11] * s, e[12] = n[12] + i[12] * s, e[13] = n[13] + i[13] * s, e[14] = n[14] + i[14] * s, e[15] = n[15] + i[15] * s, e;
  }
  /**
   * Returns whether or not two {@link Mat4}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5] && e[6] === n[6] && e[7] === n[7] && e[8] === n[8] && e[9] === n[9] && e[10] === n[10] && e[11] === n[11] && e[12] === n[12] && e[13] === n[13] && e[14] === n[14] && e[15] === n[15];
  }
  /**
   * Returns whether or not two {@link Mat4}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = e[2], a = e[3], h = e[4], c = e[5], l = e[6], u = e[7], f = e[8], d = e[9], p = e[10], y = e[11], x = e[12], m = e[13], g = e[14], w = e[15], M = n[0], S = n[1], E = n[2], A = n[3], I = n[4], b = n[5], v = n[6], _ = n[7], z = n[8], P = n[9], k = n[10], B = n[11], R = n[12], L = n[13], N = n[14], q = n[15];
    return Math.abs(i - M) <= ht * Math.max(1, Math.abs(i), Math.abs(M)) && Math.abs(s - S) <= ht * Math.max(1, Math.abs(s), Math.abs(S)) && Math.abs(o - E) <= ht * Math.max(1, Math.abs(o), Math.abs(E)) && Math.abs(a - A) <= ht * Math.max(1, Math.abs(a), Math.abs(A)) && Math.abs(h - I) <= ht * Math.max(1, Math.abs(h), Math.abs(I)) && Math.abs(c - b) <= ht * Math.max(1, Math.abs(c), Math.abs(b)) && Math.abs(l - v) <= ht * Math.max(1, Math.abs(l), Math.abs(v)) && Math.abs(u - _) <= ht * Math.max(1, Math.abs(u), Math.abs(_)) && Math.abs(f - z) <= ht * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(d - P) <= ht * Math.max(1, Math.abs(d), Math.abs(P)) && Math.abs(p - k) <= ht * Math.max(1, Math.abs(p), Math.abs(k)) && Math.abs(y - B) <= ht * Math.max(1, Math.abs(y), Math.abs(B)) && Math.abs(x - R) <= ht * Math.max(1, Math.abs(x), Math.abs(R)) && Math.abs(m - L) <= ht * Math.max(1, Math.abs(m), Math.abs(L)) && Math.abs(g - N) <= ht * Math.max(1, Math.abs(g), Math.abs(N)) && Math.abs(w - q) <= ht * Math.max(1, Math.abs(w), Math.abs(q));
  }
  /**
   * Returns a string representation of a {@link Mat4}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat4(${e.join(", ")})`;
  }
}
const ln = new Float32Array(3);
At.prototype.mul = At.prototype.multiply;
At.sub = At.subtract;
At.mul = At.multiply;
At.frustum = At.frustumNO;
At.perspective = At.perspectiveNO;
At.ortho = At.orthoNO;
At.normalFromMat4Fast = At.normalFromMat4;
const x1 = At;
class xt extends Float32Array {
  /**
  * The number of bytes in a {@link Vec3}.
  */
  static BYTE_LENGTH = 3 * Float32Array.BYTES_PER_ELEMENT;
  /**
  * Create a {@link Vec3}.
  */
  constructor(...e) {
    switch (e.length) {
      case 3:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 3);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n]) : super(n, 0, 3);
        break;
      }
      default:
        super(3);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color components
   */
  get b() {
    return this[2];
  }
  set b(e) {
    this[2] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec3.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    const e = this[0], n = this[1], i = this[2];
    return Math.sqrt(e * e + n * n + i * i);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec3.squaredMagnitude(this);`
   */
  get squaredMagnitude() {
    const e = this[0], n = this[1], i = this[2];
    return e * e + n * n + i * i;
  }
  /**
   * Alias for {@link Vec3.squaredMagnitude}
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec3.str(this);`
   */
  get str() {
    return xt.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec3} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Adds a {@link Vec3} to `this`.
   * Equivalent to `Vec3.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this[2] += e[2], this;
  }
  /**
   * Subtracts a {@link Vec3} from `this`.
   * Equivalent to `Vec3.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this[2] -= e[2], this;
  }
  /**
   * Alias for {@link Vec3.subtract}
   */
  sub(e) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec3}.
   * Equivalent to `Vec3.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this[2] *= e[2], this;
  }
  /**
   * Alias for {@link Vec3.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec3}.
   * Equivalent to `Vec3.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this[2] /= e[2], this;
  }
  /**
   * Alias for {@link Vec3.divide}
   */
  div(e) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec3.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec3.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, n) {
    return this[0] += e[0] * n, this[1] += e[1] * n, this[2] += e[2] * n, this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return xt.distance(this, e);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  dist(e) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return xt.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  sqrDist(e) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec3.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this[2] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec3.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this[2] = 1 / this[2], this;
  }
  /**
   * Sets each component of `this` to it's absolute value.
   * Equivalent to `Vec3.abs(this, this);`
   *
   * @returns `this`
   */
  abs() {
    return this[0] = Math.abs(this[0]), this[1] = Math.abs(this[1]), this[2] = Math.abs(this[2]), this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec3}.
   * Equivalent to `Vec3.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1] + this[2] * e[2];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec3.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return xt.normalize(this, this);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, empty vec3
   * @category Static
   *
   * @returns a new 3D vector
   */
  static create() {
    return new xt();
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 3D vector
   */
  static clone(e) {
    return new xt(e);
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec3}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(e) {
    let n = e[0], i = e[1], s = e[2];
    return Math.sqrt(n * n + i * i + s * s);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Creates a new vec3 initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns a new 3D vector
   */
  static fromValues(e, n, i) {
    return new xt(e, n, i);
  }
  /**
   * Copy the values from one vec3 to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e;
  }
  /**
   * Set the components of a vec3 to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns `out`
   */
  static set(e, n, i, s) {
    return e[0] = n, e[1] = i, e[2] = s, e;
  }
  /**
   * Adds two {@link Vec3}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e[2] = n[2] + i[2], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, i) {
    return e[0] = n[0] - i[0], e[1] = n[1] - i[1], e[2] = n[2] - i[2], e;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Static
   */
  static sub(e, n, i) {
    return [0, 0, 0];
  }
  /**
   * Multiplies two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    return e[0] = n[0] * i[0], e[1] = n[1] * i[1], e[2] = n[2] * i[2], e;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return [0, 0, 0];
  }
  /**
   * Divides two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(e, n, i) {
    return e[0] = n[0] / i[0], e[1] = n[1] / i[1], e[2] = n[2] / i[2], e;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Static
   */
  static div(e, n, i) {
    return [0, 0, 0];
  }
  /**
   * Math.ceil the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(e, n) {
    return e[0] = Math.ceil(n[0]), e[1] = Math.ceil(n[1]), e[2] = Math.ceil(n[2]), e;
  }
  /**
   * Math.floor the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(e, n) {
    return e[0] = Math.floor(n[0]), e[1] = Math.floor(n[1]), e[2] = Math.floor(n[2]), e;
  }
  /**
   * Returns the minimum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(e, n, i) {
    return e[0] = Math.min(n[0], i[0]), e[1] = Math.min(n[1], i[1]), e[2] = Math.min(n[2], i[2]), e;
  }
  /**
   * Returns the maximum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(e, n, i) {
    return e[0] = Math.max(n[0], i[0]), e[1] = Math.max(n[1], i[1]), e[2] = Math.max(n[2], i[2]), e;
  }
  /**
   * symmetric round the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  /*static round(out: Vec3Like, a: Readonly<Vec3Like>): Vec3Like {
    out[0] = glMatrix.round(a[0]);
    out[1] = glMatrix.round(a[1]);
    out[2] = glMatrix.round(a[2]);
    return out;
  }*/
  /**
   * Scales a vec3 by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, n, i, s) {
    return e[0] = n[0] + i[0] * s, e[1] = n[1] + i[1] * s, e[2] = n[2] + i[2] * s, e;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(e, n) {
    const i = n[0] - e[0], s = n[1] - e[1], o = n[2] - e[2];
    return Math.sqrt(i * i + s * s + o * o);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  static dist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(e, n) {
    const i = n[0] - e[0], s = n[1] - e[1], o = n[2] - e[2];
    return i * i + s * s + o * o;
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  static sqrDist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared length of a vec3
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    const n = e[0], i = e[1], s = e[2];
    return n * n + i * i + s * s;
  }
  /**
   * Alias for {@link Vec3.squaredLength}
   */
  static sqrLen(e, n) {
    return 0;
  }
  /**
   * Negates the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e;
  }
  /**
   * Returns the inverse of the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(e, n) {
    return e[0] = 1 / n[0], e[1] = 1 / n[1], e[2] = 1 / n[2], e;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec3}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(e, n) {
    return e[0] = Math.abs(n[0]), e[1] = Math.abs(n[1]), e[2] = Math.abs(n[2]), e;
  }
  /**
   * Normalize a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    const i = n[0], s = n[1], o = n[2];
    let a = i * i + s * s + o * o;
    return a > 0 && (a = 1 / Math.sqrt(a)), e[0] = n[0] * a, e[1] = n[1] * a, e[2] = n[2] * a, e;
  }
  /**
   * Calculates the dot product of two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2];
  }
  /**
   * Computes the cross product of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static cross(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = i[0], c = i[1], l = i[2];
    return e[0] = o * l - a * c, e[1] = a * h - s * l, e[2] = s * c - o * h, e;
  }
  /**
   * Performs a linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, i, s) {
    const o = n[0], a = n[1], h = n[2];
    return e[0] = o + s * (i[0] - o), e[1] = a + s * (i[1] - a), e[2] = h + s * (i[2] - h), e;
  }
  /**
   * Performs a spherical linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(e, n, i, s) {
    const o = Math.acos(Math.min(Math.max(xt.dot(n, i), -1), 1)), a = Math.sin(o), h = Math.sin((1 - s) * o) / a, c = Math.sin(s * o) / a;
    return e[0] = h * n[0] + c * i[0], e[1] = h * n[1] + c * i[1], e[2] = h * n[2] + c * i[2], e;
  }
  /**
   * Performs a hermite interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static hermite(e, n, i, s, o, a) {
    const h = a * a, c = h * (2 * a - 3) + 1, l = h * (a - 2) + a, u = h * (a - 1), f = h * (3 - 2 * a);
    return e[0] = n[0] * c + i[0] * l + s[0] * u + o[0] * f, e[1] = n[1] * c + i[1] * l + s[1] * u + o[1] * f, e[2] = n[2] * c + i[2] * l + s[2] * u + o[2] * f, e;
  }
  /**
   * Performs a bezier interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static bezier(e, n, i, s, o, a) {
    const h = 1 - a, c = h * h, l = a * a, u = c * h, f = 3 * a * c, d = 3 * l * h, p = l * a;
    return e[0] = n[0] * u + i[0] * f + s[0] * d + o[0] * p, e[1] = n[1] * u + i[1] * f + s[1] * d + o[1] * p, e[2] = n[2] * u + i[2] * f + s[2] * d + o[2] * p, e;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
   * @returns `out`
   */
  /*static random(out: Vec3Like, scale) {
      scale = scale === undefined ? 1.0 : scale;
  
      let r = glMatrix.RANDOM() * 2.0 * Math.PI;
      let z = glMatrix.RANDOM() * 2.0 - 1.0;
      let zScale = Math.sqrt(1.0 - z * z) * scale;
  
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale;
      return out;
    }*/
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = i[3] * s + i[7] * o + i[11] * a + i[15] || 1;
    return e[0] = (i[0] * s + i[4] * o + i[8] * a + i[12]) / h, e[1] = (i[1] * s + i[5] * o + i[9] * a + i[13]) / h, e[2] = (i[2] * s + i[6] * o + i[10] * a + i[14]) / h, e;
  }
  /**
   * Transforms the vec3 with a mat3.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - the 3x3 matrix to transform with
   * @returns `out`
   */
  static transformMat3(e, n, i) {
    let s = n[0], o = n[1], a = n[2];
    return e[0] = s * i[0] + o * i[3] + a * i[6], e[1] = s * i[1] + o * i[4] + a * i[7], e[2] = s * i[2] + o * i[5] + a * i[8], e;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(e, n, i) {
    const s = i[0], o = i[1], a = i[2], h = i[3] * 2, c = n[0], l = n[1], u = n[2], f = o * u - a * l, d = a * c - s * u, p = s * l - o * c, y = (o * p - a * d) * 2, x = (a * f - s * p) * 2, m = (s * d - o * f) * 2;
    return e[0] = c + f * h + y, e[1] = l + d * h + x, e[2] = u + p * h + m, e;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateX(e, n, i, s) {
    const o = i[1], a = i[2], h = n[1] - o, c = n[2] - a;
    return e[0] = n[0], e[1] = h * Math.cos(s) - c * Math.sin(s) + o, e[2] = h * Math.sin(s) + c * Math.cos(s) + a, e;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateY(e, n, i, s) {
    const o = i[0], a = i[2], h = n[0] - o, c = n[2] - a;
    return e[0] = c * Math.sin(s) + h * Math.cos(s) + o, e[1] = n[1], e[2] = c * Math.cos(s) - h * Math.sin(s) + a, e;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateZ(e, n, i, s) {
    const o = i[0], a = i[1], h = n[0] - o, c = n[1] - a;
    return e[0] = h * Math.cos(s) - c * Math.sin(s) + o, e[1] = h * Math.sin(s) + c * Math.cos(s) + a, e[2] = i[2], e;
  }
  /**
   * Get the angle between two 3D vectors
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(e, n) {
    const i = e[0], s = e[1], o = e[2], a = n[0], h = n[1], c = n[2], l = Math.sqrt((i * i + s * s + o * o) * (a * a + h * h + c * c)), u = l && xt.dot(e, n) / l;
    return Math.acos(Math.min(Math.max(u, -1), 1));
  }
  /**
   * Set the components of a vec3 to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e;
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Vec3(${e.join(", ")})`;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = e[2], a = n[0], h = n[1], c = n[2];
    return Math.abs(i - a) <= ht * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(s - h) <= ht * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(o - c) <= ht * Math.max(1, Math.abs(o), Math.abs(c));
  }
}
xt.prototype.sub = xt.prototype.subtract;
xt.prototype.mul = xt.prototype.multiply;
xt.prototype.div = xt.prototype.divide;
xt.prototype.dist = xt.prototype.distance;
xt.prototype.sqrDist = xt.prototype.squaredDistance;
xt.sub = xt.subtract;
xt.mul = xt.multiply;
xt.div = xt.divide;
xt.dist = xt.distance;
xt.sqrDist = xt.squaredDistance;
xt.sqrLen = xt.squaredLength;
xt.mag = xt.magnitude;
xt.length = xt.magnitude;
xt.len = xt.magnitude;
const ei = xt;
class yt extends Float32Array {
  /**
   * The number of bytes in a {@link Vec4}.
   */
  static BYTE_LENGTH = 4 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Vec4}.
   */
  constructor(...e) {
    switch (e.length) {
      case 4:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 4);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n, n]) : super(n, 0, 4);
        break;
      }
      default:
        super(4);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  /**
   * The w component of the vector. Equivalent to `this[3];`
   * @category Vector components
   */
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color components
   */
  get b() {
    return this[2];
  }
  set b(e) {
    this[2] = e;
  }
  /**
   * The a component of the vector. Equivalent to `this[3];`
   * @category Color components
   */
  get a() {
    return this[3];
  }
  set a(e) {
    this[3] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec4.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    const e = this[0], n = this[1], i = this[2], s = this[3];
    return Math.sqrt(e * e + n * n + i * i + s * s);
  }
  /**
   * Alias for {@link Vec4.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec4.str(this);`
   */
  get str() {
    return yt.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec4} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return super.set(e), this;
  }
  /**
   * Adds a {@link Vec4} to `this`.
   * Equivalent to `Vec4.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this[2] += e[2], this[3] += e[3], this;
  }
  /**
   * Subtracts a {@link Vec4} from `this`.
   * Equivalent to `Vec4.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this[2] -= e[2], this[3] -= e[3], this;
  }
  /**
   * Alias for {@link Vec4.subtract}
   */
  sub(e) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec4}.
   * Equivalent to `Vec4.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this[2] *= e[2], this[3] *= e[3], this;
  }
  /**
   * Alias for {@link Vec4.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec4}.
   * Equivalent to `Vec4.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this[2] /= e[2], this[3] /= e[3], this;
  }
  /**
   * Alias for {@link Vec4.divide}
   */
  div(e) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec4.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this[3] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec4.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, n) {
    return this[0] += e[0] * n, this[1] += e[1] * n, this[2] += e[2] * n, this[3] += e[3] * n, this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec4} and `this`.
   * Equivalent to `Vec4.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return yt.distance(this, e);
  }
  /**
   * Alias for {@link Vec4.distance}
   */
  dist(e) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec4} and `this`.
   * Equivalent to `Vec4.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return yt.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec4.squaredDistance}
   */
  sqrDist(e) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec4.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this[2] *= -1, this[3] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec4.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this[2] = 1 / this[2], this[3] = 1 / this[3], this;
  }
  /**
   * Sets each component of `this` to it's absolute value.
   * Equivalent to `Vec4.abs(this, this);`
   *
   * @returns `this`
   */
  abs() {
    return this[0] = Math.abs(this[0]), this[1] = Math.abs(this[1]), this[2] = Math.abs(this[2]), this[3] = Math.abs(this[3]), this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec4}.
   * Equivalent to `Vec4.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1] + this[2] * e[2] + this[3] * e[3];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec4.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return yt.normalize(this, this);
  }
  //===================
  // Static methods
  //===================
  /**
   * Creates a new, empty {@link Vec4}
   * @category Static
   *
   * @returns a new 4D vector
   */
  static create() {
    return new yt();
  }
  /**
   * Creates a new {@link Vec4} initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 4D vector
   */
  static clone(e) {
    return new yt(e);
  }
  /**
   * Creates a new {@link Vec4} initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns a new 4D vector
   */
  static fromValues(e, n, i, s) {
    return new yt(e, n, i, s);
  }
  /**
   * Copy the values from one {@link Vec4} to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set the components of a {@link Vec4} to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns `out`
   */
  static set(e, n, i, s, o) {
    return e[0] = n, e[1] = i, e[2] = s, e[3] = o, e;
  }
  /**
   * Adds two {@link Vec4}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e[2] = n[2] + i[2], e[3] = n[3] + i[3], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, i) {
    return e[0] = n[0] - i[0], e[1] = n[1] - i[1], e[2] = n[2] - i[2], e[3] = n[3] - i[3], e;
  }
  /**
   * Alias for {@link Vec4.subtract}
   * @category Static
   */
  static sub(e, n, i) {
    return e;
  }
  /**
   * Multiplies two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    return e[0] = n[0] * i[0], e[1] = n[1] * i[1], e[2] = n[2] * i[2], e[3] = n[3] * i[3], e;
  }
  /**
   * Alias for {@link Vec4.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return e;
  }
  /**
   * Divides two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(e, n, i) {
    return e[0] = n[0] / i[0], e[1] = n[1] / i[1], e[2] = n[2] / i[2], e[3] = n[3] / i[3], e;
  }
  /**
   * Alias for {@link Vec4.divide}
   * @category Static
   */
  static div(e, n, i) {
    return e;
  }
  /**
   * Math.ceil the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(e, n) {
    return e[0] = Math.ceil(n[0]), e[1] = Math.ceil(n[1]), e[2] = Math.ceil(n[2]), e[3] = Math.ceil(n[3]), e;
  }
  /**
   * Math.floor the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(e, n) {
    return e[0] = Math.floor(n[0]), e[1] = Math.floor(n[1]), e[2] = Math.floor(n[2]), e[3] = Math.floor(n[3]), e;
  }
  /**
   * Returns the minimum of two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(e, n, i) {
    return e[0] = Math.min(n[0], i[0]), e[1] = Math.min(n[1], i[1]), e[2] = Math.min(n[2], i[2]), e[3] = Math.min(n[3], i[3]), e;
  }
  /**
   * Returns the maximum of two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(e, n, i) {
    return e[0] = Math.max(n[0], i[0]), e[1] = Math.max(n[1], i[1]), e[2] = Math.max(n[2], i[2]), e[3] = Math.max(n[3], i[3]), e;
  }
  /**
   * Math.round the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  static round(e, n) {
    return e[0] = Math.round(n[0]), e[1] = Math.round(n[1]), e[2] = Math.round(n[2]), e[3] = Math.round(n[3]), e;
  }
  /**
   * Scales a {@link Vec4} by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = n[3] * i, e;
  }
  /**
   * Adds two {@link Vec4}'s after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, n, i, s) {
    return e[0] = n[0] + i[0] * s, e[1] = n[1] + i[1] * s, e[2] = n[2] + i[2] * s, e[3] = n[3] + i[3] * s, e;
  }
  /**
   * Calculates the euclidian distance between two {@link Vec4}'s
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(e, n) {
    const i = n[0] - e[0], s = n[1] - e[1], o = n[2] - e[2], a = n[3] - e[3];
    return Math.hypot(i, s, o, a);
  }
  /**
   * Alias for {@link Vec4.distance}
   * @category Static
   */
  static dist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two {@link Vec4}'s
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(e, n) {
    const i = n[0] - e[0], s = n[1] - e[1], o = n[2] - e[2], a = n[3] - e[3];
    return i * i + s * s + o * o + a * a;
  }
  /**
   * Alias for {@link Vec4.squaredDistance}
   * @category Static
   */
  static sqrDist(e, n) {
    return 0;
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec4}
   * @category Static
   *
   * @param a - vector to calculate length of
   * @returns length of `a`
   */
  static magnitude(e) {
    const n = e[0], i = e[1], s = e[2], o = e[3];
    return Math.sqrt(n * n + i * i + s * s + o * o);
  }
  /**
   * Alias for {@link Vec4.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec4.magnitude}
   * @category Static
   * @deprecated Use {@link Vec4.magnitude} to avoid conflicts with builtin `length` methods/attribs
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec4.magnitude}
   * @category Static
   * @deprecated Use {@link Vec4.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Vec4}
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    const n = e[0], i = e[1], s = e[2], o = e[3];
    return n * n + i * i + s * s + o * o;
  }
  /**
   * Alias for {@link Vec4.squaredLength}
   * @category Static
   */
  static sqrLen(e) {
    return 0;
  }
  /**
   * Negates the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e[3] = -n[3], e;
  }
  /**
   * Returns the inverse of the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(e, n) {
    return e[0] = 1 / n[0], e[1] = 1 / n[1], e[2] = 1 / n[2], e[3] = 1 / n[3], e;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec4}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(e, n) {
    return e[0] = Math.abs(n[0]), e[1] = Math.abs(n[1]), e[2] = Math.abs(n[2]), e[3] = Math.abs(n[3]), e;
  }
  /**
   * Normalize a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3];
    let h = i * i + s * s + o * o + a * a;
    return h > 0 && (h = 1 / Math.sqrt(h)), e[0] = i * h, e[1] = s * h, e[2] = o * h, e[3] = a * h, e;
  }
  /**
   * Calculates the dot product of two {@link Vec4}'s
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2] + e[3] * n[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   * @category Static
   *
   * @param out the receiving vector
   * @param u - the first vector
   * @param v - the second vector
   * @param w - the third vector
   * @returns result
   */
  static cross(e, n, i, s) {
    const o = i[0] * s[1] - i[1] * s[0], a = i[0] * s[2] - i[2] * s[0], h = i[0] * s[3] - i[3] * s[0], c = i[1] * s[2] - i[2] * s[1], l = i[1] * s[3] - i[3] * s[1], u = i[2] * s[3] - i[3] * s[2], f = n[0], d = n[1], p = n[2], y = n[3];
    return e[0] = d * u - p * l + y * c, e[1] = -(f * u) + p * h - y * a, e[2] = f * l - d * h + y * o, e[3] = -(f * c) + d * a - p * o, e;
  }
  /**
   * Performs a linear interpolation between two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, i, s) {
    const o = n[0], a = n[1], h = n[2], c = n[3];
    return e[0] = o + s * (i[0] - o), e[1] = a + s * (i[1] - a), e[2] = h + s * (i[2] - h), e[3] = c + s * (i[3] - c), e;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param [scale] - Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns `out`
   */
  /*static random(out: Vec4Like, scale): Vec4Like {
      scale = scale || 1.0;
  
      // Marsaglia, George. Choosing a Point from the Surface of a
      // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
      // http://projecteuclid.org/euclid.aoms/1177692644;
      var v1, v2, v3, v4;
      var s1, s2;
      do {
        v1 = glMatrix.RANDOM() * 2 - 1;
        v2 = glMatrix.RANDOM() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
      } while (s1 >= 1);
      do {
        v3 = glMatrix.RANDOM() * 2 - 1;
        v4 = glMatrix.RANDOM() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
      } while (s2 >= 1);
  
      var d = Math.sqrt((1 - s1) / s2);
      out[0] = scale * v1;
      out[1] = scale * v2;
      out[2] = scale * v3 * d;
      out[3] = scale * v4 * d;
      return out;
    }*/
  /**
   * Transforms the {@link Vec4} with a {@link Mat4}.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3];
    return e[0] = i[0] * s + i[4] * o + i[8] * a + i[12] * h, e[1] = i[1] * s + i[5] * o + i[9] * a + i[13] * h, e[2] = i[2] * s + i[6] * o + i[10] * a + i[14] * h, e[3] = i[3] * s + i[7] * o + i[11] * a + i[15] * h, e;
  }
  /**
   * Transforms the {@link Vec4} with a {@link Quat}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = i[0], c = i[1], l = i[2], u = i[3], f = u * s + c * a - l * o, d = u * o + l * s - h * a, p = u * a + h * o - c * s, y = -h * s - c * o - l * a;
    return e[0] = f * u + y * -h + d * -l - p * -c, e[1] = d * u + y * -c + p * -h - f * -l, e[2] = p * u + y * -l + f * -c - d * -h, e[3] = n[3], e;
  }
  /**
   * Set the components of a {@link Vec4} to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;
  }
  /**
   * Returns a string representation of a {@link Vec4}
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Vec4(${e.join(", ")})`;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = e[2], a = e[3], h = n[0], c = n[1], l = n[2], u = n[3];
    return Math.abs(i - h) <= ht * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(s - c) <= ht * Math.max(1, Math.abs(s), Math.abs(c)) && Math.abs(o - l) <= ht * Math.max(1, Math.abs(o), Math.abs(l)) && Math.abs(a - u) <= ht * Math.max(1, Math.abs(a), Math.abs(u));
  }
}
yt.prototype.sub = yt.prototype.subtract;
yt.prototype.mul = yt.prototype.multiply;
yt.prototype.div = yt.prototype.divide;
yt.prototype.dist = yt.prototype.distance;
yt.prototype.sqrDist = yt.prototype.squaredDistance;
yt.sub = yt.subtract;
yt.mul = yt.multiply;
yt.div = yt.divide;
yt.dist = yt.distance;
yt.sqrDist = yt.squaredDistance;
yt.sqrLen = yt.squaredLength;
yt.mag = yt.magnitude;
yt.length = yt.magnitude;
yt.len = yt.magnitude;
const ss = yt;
class pt extends Float32Array {
  /**
   * The number of bytes in a {@link Quat}.
   */
  static BYTE_LENGTH = 4 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Quat}.
   */
  constructor(...e) {
    switch (e.length) {
      case 4:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 4);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n, n]) : super(n, 0, 4);
        break;
      }
      default:
        super(4), this[3] = 1;
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the quaternion. Equivalent to `this[0];`
   * @category Quaternion components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the quaternion. Equivalent to `this[1];`
   * @category Quaternion components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the quaternion. Equivalent to `this[2];`
   * @category Quaternion components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  /**
   * The w component of the quaternion. Equivalent to `this[3];`
   * @category Quaternion components
   */
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Quat.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    const e = this[0], n = this[1], i = this[2], s = this[3];
    return Math.sqrt(e * e + n * n + i * i + s * s);
  }
  /**
   * Alias for {@link Quat.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Quat.str(this);`
   */
  get str() {
    return pt.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Quat} into `this`.
   *
   * @param a the source quaternion
   * @returns `this`
   */
  copy(e) {
    return super.set(e), this;
  }
  /**
   * Set `this` to the identity quaternion
   * Equivalent to Quat.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this[0] = 0, this[1] = 0, this[2] = 0, this[3] = 1, this;
  }
  /**
   * Multiplies `this` by a {@link Quat}.
   * Equivalent to `Quat.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return pt.multiply(this, this, e);
  }
  /**
   * Alias for {@link Quat.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Rotates `this` by the given angle about the X axis
   * Equivalent to `Quat.rotateX(this, this, rad);`
   *
   * @param rad - angle (in radians) to rotate
   * @returns `this`
   */
  rotateX(e) {
    return pt.rotateX(this, this, e);
  }
  /**
   * Rotates `this` by the given angle about the Y axis
   * Equivalent to `Quat.rotateY(this, this, rad);`
   *
   * @param rad - angle (in radians) to rotate
   * @returns `this`
   */
  rotateY(e) {
    return pt.rotateY(this, this, e);
  }
  /**
   * Rotates `this` by the given angle about the Z axis
   * Equivalent to `Quat.rotateZ(this, this, rad);`
   *
   * @param rad - angle (in radians) to rotate
   * @returns `this`
   */
  rotateZ(e) {
    return pt.rotateZ(this, this, e);
  }
  /**
   * Inverts `this`
   * Equivalent to `Quat.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return pt.invert(this, this);
  }
  /**
   * Scales `this` by a scalar number
   * Equivalent to `Quat.scale(this, this, scale);`
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this[3] *= e, this;
  }
  /**
   * Calculates the dot product of `this` and another {@link Quat}
   * Equivalent to `Quat.dot(this, b);`
   *
   * @param b - the second operand
   * @returns dot product of `this` and b
   */
  dot(e) {
    return pt.dot(this, e);
  }
  //===================
  // Static methods
  //===================
  /**
   * Creates a new identity quat
   * @category Static
   *
   * @returns a new quaternion
   */
  static create() {
    return new pt();
  }
  /**
   * Set a quat to the identity quaternion
   * @category Static
   *
   * @param out - the receiving quaternion
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param axis - the axis around which to rotate
   * @param rad - the angle in radians
   * @returns `out`
   **/
  static setAxisAngle(e, n, i) {
    i = i * 0.5;
    const s = Math.sin(i);
    return e[0] = s * n[0], e[1] = s * n[1], e[2] = s * n[2], e[3] = Math.cos(i), e;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @category Static
   *
   * @param out_axis - Vector receiving the axis of rotation
   * @param q - Quaternion to be decomposed
   * @return Angle, in radians, of the rotation
   */
  static getAxisAngle(e, n) {
    const i = Math.acos(n[3]) * 2, s = Math.sin(i / 2);
    return s > ht ? (e[0] = n[0] / s, e[1] = n[1] / s, e[2] = n[2] / s) : (e[0] = 1, e[1] = 0, e[2] = 0), i;
  }
  /**
   * Gets the angular distance between two unit quaternions
   * @category Static
   *
   * @param  {ReadonlyQuat} a     Origin unit quaternion
   * @param  {ReadonlyQuat} b     Destination unit quaternion
   * @return {Number}     Angle, in radians, between the two quaternions
   */
  static getAngle(e, n) {
    const i = pt.dot(e, n);
    return Math.acos(2 * i * i - 1);
  }
  /**
   * Multiplies two quat's
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = i[0], l = i[1], u = i[2], f = i[3];
    return e[0] = s * f + h * c + o * u - a * l, e[1] = o * f + h * l + a * c - s * u, e[2] = a * f + h * u + s * l - o * c, e[3] = h * f - s * c - o * l - a * u, e;
  }
  /**
   * Rotates a quaternion by the given angle about the X axis
   * @category Static
   *
   * @param out - quat receiving operation result
   * @param a - quat to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateX(e, n, i) {
    i *= 0.5;
    const s = n[0], o = n[1], a = n[2], h = n[3], c = Math.sin(i), l = Math.cos(i);
    return e[0] = s * l + h * c, e[1] = o * l + a * c, e[2] = a * l - o * c, e[3] = h * l - s * c, e;
  }
  /**
   * Rotates a quaternion by the given angle about the Y axis
   * @category Static
   *
   * @param out - quat receiving operation result
   * @param a - quat to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateY(e, n, i) {
    i *= 0.5;
    const s = n[0], o = n[1], a = n[2], h = n[3], c = Math.sin(i), l = Math.cos(i);
    return e[0] = s * l - a * c, e[1] = o * l + h * c, e[2] = a * l + s * c, e[3] = h * l - o * c, e;
  }
  /**
   * Rotates a quaternion by the given angle about the Z axis
   * @category Static
   *
   * @param out - quat receiving operation result
   * @param a - quat to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateZ(e, n, i) {
    i *= 0.5;
    const s = n[0], o = n[1], a = n[2], h = n[3], c = Math.sin(i), l = Math.cos(i);
    return e[0] = s * l + o * c, e[1] = o * l - s * c, e[2] = a * l + h * c, e[3] = h * l - a * c, e;
  }
  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate W component of
   * @returns `out`
   */
  static calculateW(e, n) {
    const i = n[0], s = n[1], o = n[2];
    return e[0] = i, e[1] = s, e[2] = o, e[3] = Math.sqrt(Math.abs(1 - i * i - s * s - o * o)), e;
  }
  /**
   * Calculate the exponential of a unit quaternion.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate the exponential of
   * @returns `out`
   */
  static exp(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = Math.sqrt(i * i + s * s + o * o), c = Math.exp(a), l = h > 0 ? c * Math.sin(h) / h : 0;
    return e[0] = i * l, e[1] = s * l, e[2] = o * l, e[3] = c * Math.cos(h), e;
  }
  /**
   * Calculate the natural logarithm of a unit quaternion.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate the exponential of
   * @returns `out`
   */
  static ln(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = Math.sqrt(i * i + s * s + o * o), c = h > 0 ? Math.atan2(h, a) / h : 0;
    return e[0] = i * c, e[1] = s * c, e[2] = o * c, e[3] = 0.5 * Math.log(i * i + s * s + o * o + a * a), e;
  }
  /**
   * Calculate the scalar power of a unit quaternion.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate the exponential of
   * @param b - amount to scale the quaternion by
   * @returns `out`
   */
  static pow(e, n, i) {
    return pt.ln(e, n), pt.scale(e, e, i), pt.exp(e, e), e;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(e, n, i, s) {
    const o = n[0], a = n[1], h = n[2], c = n[3];
    let l = i[0], u = i[1], f = i[2], d = i[3], p, y, x = o * l + a * u + h * f + c * d;
    if (x < 0 && (x = -x, l = -l, u = -u, f = -f, d = -d), 1 - x > ht) {
      const m = Math.acos(x), g = Math.sin(m);
      p = Math.sin((1 - s) * m) / g, y = Math.sin(s * m) / g;
    } else
      p = 1 - s, y = s;
    return e[0] = p * o + y * l, e[1] = p * a + y * u, e[2] = p * h + y * f, e[3] = p * c + y * d, e;
  }
  /**
   * Generates a random unit quaternion
   * @category Static
   *
   * @param out - the receiving quaternion
   * @returns `out`
   */
  /*static random(out: QuatLike): QuatLike {
      // Implementation of http://planning.cs.uiuc.edu/node198.html
      // TODO: Calling random 3 times is probably not the fastest solution
      let u1 = glMatrix.RANDOM();
      let u2 = glMatrix.RANDOM();
      let u3 = glMatrix.RANDOM();
  
      let sqrt1MinusU1 = Math.sqrt(1 - u1);
      let sqrtU1 = Math.sqrt(u1);
  
      out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
      out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
      out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
      out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
      return out;
    }*/
  /**
   * Calculates the inverse of a quat
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate inverse of
   * @returns `out`
   */
  static invert(e, n) {
    const i = n[0], s = n[1], o = n[2], a = n[3], h = i * i + s * s + o * o + a * a, c = h ? 1 / h : 0;
    return e[0] = -i * c, e[1] = -s * c, e[2] = -o * c, e[3] = a * c, e;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate conjugate of
   * @returns `out`
   */
  static conjugate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e[3] = n[3], e;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param m - rotation matrix
   * @returns `out`
   */
  static fromMat3(e, n) {
    const i = n[0] + n[4] + n[8];
    let s;
    if (i > 0)
      s = Math.sqrt(i + 1), e[3] = 0.5 * s, s = 0.5 / s, e[0] = (n[5] - n[7]) * s, e[1] = (n[6] - n[2]) * s, e[2] = (n[1] - n[3]) * s;
    else {
      let o = 0;
      n[4] > n[0] && (o = 1), n[8] > n[o * 3 + o] && (o = 2);
      let a = (o + 1) % 3, h = (o + 2) % 3;
      s = Math.sqrt(n[o * 3 + o] - n[a * 3 + a] - n[h * 3 + h] + 1), e[o] = 0.5 * s, s = 0.5 / s, e[3] = (n[a * 3 + h] - n[h * 3 + a]) * s, e[a] = (n[a * 3 + o] + n[o * 3 + a]) * s, e[h] = (n[h * 3 + o] + n[o * 3 + h]) * s;
    }
    return e;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param x - Angle to rotate around X axis in degrees.
   * @param y - Angle to rotate around Y axis in degrees.
   * @param z - Angle to rotate around Z axis in degrees.
   * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order - Intrinsic order for conversion, default is zyx.
   * @returns `out`
   */
  static fromEuler(e, n, i, s, o = yw) {
    let a = 0.5 * Math.PI / 180;
    n *= a, i *= a, s *= a;
    let h = Math.sin(n), c = Math.cos(n), l = Math.sin(i), u = Math.cos(i), f = Math.sin(s), d = Math.cos(s);
    switch (o) {
      case "xyz":
        e[0] = h * u * d + c * l * f, e[1] = c * l * d - h * u * f, e[2] = c * u * f + h * l * d, e[3] = c * u * d - h * l * f;
        break;
      case "xzy":
        e[0] = h * u * d - c * l * f, e[1] = c * l * d - h * u * f, e[2] = c * u * f + h * l * d, e[3] = c * u * d + h * l * f;
        break;
      case "yxz":
        e[0] = h * u * d + c * l * f, e[1] = c * l * d - h * u * f, e[2] = c * u * f - h * l * d, e[3] = c * u * d + h * l * f;
        break;
      case "yzx":
        e[0] = h * u * d + c * l * f, e[1] = c * l * d + h * u * f, e[2] = c * u * f - h * l * d, e[3] = c * u * d - h * l * f;
        break;
      case "zxy":
        e[0] = h * u * d - c * l * f, e[1] = c * l * d + h * u * f, e[2] = c * u * f + h * l * d, e[3] = c * u * d - h * l * f;
        break;
      case "zyx":
        e[0] = h * u * d - c * l * f, e[1] = c * l * d + h * u * f, e[2] = c * u * f - h * l * d, e[3] = c * u * d + h * l * f;
        break;
      default:
        throw new Error("Unknown angle order " + o);
    }
    return e;
  }
  /**
   * Returns a string representation of a quatenion
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Quat(${e.join(", ")})`;
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   * @category Static
   *
   * @param a - quaternion to clone
   * @returns a new quaternion
   */
  static clone(e) {
    return new pt(e);
  }
  /**
   * Creates a new quat initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns a new quaternion
   */
  static fromValues(e, n, i, s) {
    return new pt(e, n, i, s);
  }
  /**
   * Copy the values from one quat to another
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the source quaternion
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set the components of a {@link Quat} to the given values
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns `out`
   */
  static set(e, n, i, s, o) {
    return e;
  }
  /**
   * Adds two {@link Quat}'s
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e;
  }
  /**
   * Alias for {@link Quat.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return e;
  }
  /**
   * Scales a quat by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param b - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = n[3] * i, e;
  }
  /**
   * Calculates the dot product of two quat's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2] + e[3] * n[3];
  }
  /**
   * Performs a linear interpolation between two quat's
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, i, s) {
    return e;
  }
  /**
   * Calculates the magnitude (length) of a {@link Quat}
   * @category Static
   *
   * @param a - quaternion to calculate length of
   * @returns length of `a`
   */
  static magnitude(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.magnitude}
   * @category Static
   * @deprecated Use {@link Quat.magnitude} to avoid conflicts with builtin `length` methods/attribs
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.magnitude}
   * @category Static
   * @deprecated Use {@link Quat.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Quat}
   * @category Static
   *
   * @param a - quaternion to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.squaredLength}
   * @category Static
   */
  static sqrLen(e) {
    return 0;
  }
  /**
   * Normalize a {@link Quat}
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quaternion to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    return e;
  }
  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first quaternion.
   * @param b - The second quaternion.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return !1;
  }
  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, n) {
    return !1;
  }
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   * @category Static
   *
   * @param out - the receiving quaternion.
   * @param a - the initial vector
   * @param b - the destination vector
   * @returns `out`
   */
  static rotationTo(e, n, i) {
    let s = xt.dot(n, i);
    return s < -0.999999 ? (xt.cross(Pn, xw, n), xt.mag(Pn) < 1e-6 && xt.cross(Pn, mw, n), xt.normalize(Pn, Pn), pt.setAxisAngle(e, Pn, Math.PI), e) : s > 0.999999 ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (xt.cross(Pn, n, i), e[0] = Pn[0], e[1] = Pn[1], e[2] = Pn[2], e[3] = 1 + s, pt.normalize(e, e));
  }
  /**
   * Performs a spherical linear interpolation with two control points
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static sqlerp(e, n, i, s, o, a) {
    return pt.slerp(Y0, n, o, a), pt.slerp(H0, i, s, a), pt.slerp(e, Y0, H0, 2 * a * (1 - a)), e;
  }
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   * @category Static
   *
   * @param out - The receiving quaternion
   * @param view - the vector representing the viewing direction
   * @param right - the vector representing the local "right" direction
   * @param up - the vector representing the local "up" direction
   * @returns `out`
   */
  static setAxes(e, n, i, s) {
    return Cn[0] = i[0], Cn[3] = i[1], Cn[6] = i[2], Cn[1] = s[0], Cn[4] = s[1], Cn[7] = s[2], Cn[2] = -n[0], Cn[5] = -n[1], Cn[8] = -n[2], pt.normalize(e, pt.fromMat3(e, Cn));
  }
}
const Y0 = new Float32Array(4), H0 = new Float32Array(4), Cn = new Float32Array(9), Pn = new Float32Array(3), xw = new Float32Array([1, 0, 0]), mw = new Float32Array([0, 1, 0]);
pt.set = yt.set;
pt.add = yt.add;
pt.lerp = yt.lerp;
pt.normalize = yt.normalize;
pt.squaredLength = yt.squaredLength;
pt.sqrLen = yt.squaredLength;
pt.exactEquals = yt.exactEquals;
pt.equals = yt.equals;
pt.magnitude = yt.magnitude;
pt.prototype.mul = pt.prototype.multiply;
pt.mul = pt.multiply;
pt.mag = pt.magnitude;
pt.length = pt.magnitude;
pt.len = pt.magnitude;
const gw = pt;
class Gt extends Float32Array {
  /**
   * The number of bytes in a {@link Quat}.
   */
  static BYTE_LENGTH = 8 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Quat2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 8:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 8);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n, n, n, n, n, n]) : super(n, 0, 8);
        break;
      }
      default:
        super(8), this[3] = 1;
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Quat2.str(this);`
   */
  get str() {
    return Gt.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Quat2} into `this`.
   *
   * @param a the source dual quaternion
   * @returns `this`
   */
  copy(e) {
    return super.set(e), this;
  }
  //===================
  // Static methods
  //===================
  /**
   * Creates a new identity {@link Quat2}
   * @category Static
   *
   * @returns a new dual quaternion [real -> rotation, dual -> translation]
   */
  static create() {
    return new Gt();
  }
  /**
   * Creates a {@link Quat2} quat initialized with values from an existing quaternion
   * @category Static
   *
   * @param a - dual quaternion to clone
   * @returns a new dual quaternion
   */
  static clone(e) {
    return new Gt(e);
  }
  /**
   * Creates a new {@link Quat2}  initialized with the given values
   * @category Static
   *
   * @param x1 - 1st X component
   * @param y1 - 1st Y component
   * @param z1 - 1st Z component
   * @param w1 - 1st W component
   * @param x2 - 2nd X component
   * @param y2 - 2nd Y component
   * @param z2 - 2nd Z component
   * @param w2 - 2nd W component
   * @returns a new dual quaternion
   */
  static fromValues(e, n, i, s, o, a, h, c) {
    return new Gt(e, n, i, s, o, a, h, c);
  }
  /**
   * Creates a new {@link Quat2} from the given values (quat and translation)
   * @category Static
   *
   * @param x1 - X component (rotation)
   * @param y1 - Y component (rotation)
   * @param z1 - Z component (rotation)
   * @param w1 - W component (rotation)
   * @param x2 - X component (translation)
   * @param y2 - Y component (translation)
   * @param z2 - Z component (translation)
   * @returns a new dual quaternion
   */
  static fromRotationTranslationValues(e, n, i, s, o, a, h) {
    const c = o * 0.5, l = a * 0.5, u = h * 0.5;
    return new Gt(
      e,
      n,
      i,
      s,
      c * s + l * i - u * n,
      l * s + u * e - c * i,
      u * s + c * n - l * e,
      -c * e - l * n - u * i
    );
  }
  /**
   * Sets a {@link Quat2} from a quaternion and a translation
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param q - a normalized quaternion
   * @param t - translation vector
   * @returns `out`
   */
  static fromRotationTranslation(e, n, i) {
    const s = i[0] * 0.5, o = i[1] * 0.5, a = i[2] * 0.5, h = n[0], c = n[1], l = n[2], u = n[3];
    return e[0] = h, e[1] = c, e[2] = l, e[3] = u, e[4] = s * u + o * l - a * c, e[5] = o * u + a * h - s * l, e[6] = a * u + s * c - o * h, e[7] = -s * h - o * c - a * l, e;
  }
  /**
   * Sets a {@link Quat2} from a translation
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param t - translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = n[0] * 0.5, e[5] = n[1] * 0.5, e[6] = n[2] * 0.5, e[7] = 0, e;
  }
  /**
   * Sets a {@link Quat2} from a quaternion
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param q - a normalized quaternion
   * @returns `out`
   */
  static fromRotation(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e;
  }
  /**
   * Sets a {@link Quat2} from a quaternion
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param a - the matrix
   * @returns `out`
   */
  static fromMat4(e, n) {
    return At.getRotation(X0, n), At.getTranslation(Z0, n), Gt.fromRotationTranslation(e, X0, Z0);
  }
  /**
   * Copy the values from one {@link Quat2} to another
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the source dual quaternion
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e;
  }
  /**
   * Set a {@link Quat2} to the identity dual quaternion
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e;
  }
  /**
   * Set the components of a {@link Quat2} to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x1 - 1st X component
   * @param y1 - 1st Y component
   * @param z1 - 1st Z component
   * @param w1 - 1st W component
   * @param x2 - 2nd X component
   * @param y2 - 2nd Y component
   * @param z2 - 2nd Z component
   * @param w2 - 2nd W component
   * @returns `out`
   */
  static set(e, n, i, s, o, a, h, c, l) {
    return e[0] = n, e[1] = i, e[2] = s, e[3] = o, e[4] = a, e[5] = h, e[6] = c, e[7] = l, e;
  }
  /**
   * Gets the real part of a dual quat
   * @category Static
   *
   * @param out - real part
   * @param a - Dual Quaternion
   * @return `out`
   */
  static getReal(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Gets the dual part of a dual quat
   * @category Static
   *
   * @param out - dual part
   * @param a - Dual Quaternion
   * @return `out`
   */
  static getDual(e, n) {
    return e[0] = n[4], e[1] = n[5], e[2] = n[6], e[3] = n[7], e;
  }
  /**
   * Set the real component of a {@link Quat2} to the given quaternion
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - a quaternion representing the real part
   * @return `out`
   */
  static setReal(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set the dual component of a {@link Quat2} to the given quaternion
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - a quaternion representing the dual part
   * @return `out`
   */
  static setDual(e, n) {
    return e[4] = n[0], e[5] = n[1], e[6] = n[2], e[7] = n[3], e;
  }
  /**
   * Gets the translation of a normalized {@link Quat2}
   * @category Static
   *
   * @param out - the receiving translation vector
   * @param a - Dual Quaternion to be decomposed
   * @return `out`
   */
  static getTranslation(e, n) {
    const i = n[4], s = n[5], o = n[6], a = n[7], h = -n[0], c = -n[1], l = -n[2], u = n[3];
    return e[0] = (i * u + a * h + s * l - o * c) * 2, e[1] = (s * u + a * c + o * h - i * l) * 2, e[2] = (o * u + a * l + i * c - s * h) * 2, e;
  }
  /**
   * Translates a {@link Quat2} by the given vector
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = i[0] * 0.5, l = i[1] * 0.5, u = i[2] * 0.5, f = n[4], d = n[5], p = n[6], y = n[7];
    return e[0] = s, e[1] = o, e[2] = a, e[3] = h, e[4] = h * c + o * u - a * l + f, e[5] = h * l + a * c - s * u + d, e[6] = h * u + s * l - o * c + p, e[7] = -s * c - o * l - a * u + y, e;
  }
  /**
   * Rotates a {@link Quat2} around the X axis
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateX(e, n, i) {
    let s = -n[0], o = -n[1], a = -n[2], h = n[3];
    const c = n[4], l = n[5], u = n[6], f = n[7], d = c * h + f * s + l * a - u * o, p = l * h + f * o + u * s - c * a, y = u * h + f * a + c * o - l * s, x = f * h - c * s - l * o - u * a;
    return pt.rotateX(e, n, i), s = e[0], o = e[1], a = e[2], h = e[3], e[4] = d * h + x * s + p * a - y * o, e[5] = p * h + x * o + y * s - d * a, e[6] = y * h + x * a + d * o - p * s, e[7] = x * h - d * s - p * o - y * a, e;
  }
  /**
   * Rotates a {@link Quat2} around the Y axis
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateY(e, n, i) {
    let s = -n[0], o = -n[1], a = -n[2], h = n[3];
    const c = n[4], l = n[5], u = n[6], f = n[7], d = c * h + f * s + l * a - u * o, p = l * h + f * o + u * s - c * a, y = u * h + f * a + c * o - l * s, x = f * h - c * s - l * o - u * a;
    return pt.rotateY(e, n, i), s = e[0], o = e[1], a = e[2], h = e[3], e[4] = d * h + x * s + p * a - y * o, e[5] = p * h + x * o + y * s - d * a, e[6] = y * h + x * a + d * o - p * s, e[7] = x * h - d * s - p * o - y * a, e;
  }
  /**
   * Rotates a {@link Quat2} around the Z axis
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateZ(e, n, i) {
    let s = -n[0], o = -n[1], a = -n[2], h = n[3];
    const c = n[4], l = n[5], u = n[6], f = n[7], d = c * h + f * s + l * a - u * o, p = l * h + f * o + u * s - c * a, y = u * h + f * a + c * o - l * s, x = f * h - c * s - l * o - u * a;
    return pt.rotateZ(e, n, i), s = e[0], o = e[1], a = e[2], h = e[3], e[4] = d * h + x * s + p * a - y * o, e[5] = p * h + x * o + y * s - d * a, e[6] = y * h + x * a + d * o - p * s, e[7] = x * h - d * s - p * o - y * a, e;
  }
  /**
   * Rotates a {@link Quat2} by a given quaternion (a * q)
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param q - quaternion to rotate by
   * @returns `out`
   */
  static rotateByQuatAppend(e, n, i) {
    const s = i[0], o = i[1], a = i[2], h = i[3];
    let c = n[0], l = n[1], u = n[2], f = n[3];
    return e[0] = c * h + f * s + l * a - u * o, e[1] = l * h + f * o + u * s - c * a, e[2] = u * h + f * a + c * o - l * s, e[3] = f * h - c * s - l * o - u * a, c = n[4], l = n[5], u = n[6], f = n[7], e[4] = c * h + f * s + l * a - u * o, e[5] = l * h + f * o + u * s - c * a, e[6] = u * h + f * a + c * o - l * s, e[7] = f * h - c * s - l * o - u * a, e;
  }
  /**
   * Rotates a {@link Quat2} by a given quaternion (q * a)
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param q - quaternion to rotate by
   * @param a - the dual quaternion to rotate
   * @returns `out`
   */
  static rotateByQuatPrepend(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3];
    let c = i[0], l = i[1], u = i[2], f = i[3];
    return e[0] = s * f + h * c + o * u - a * l, e[1] = o * f + h * l + a * c - s * u, e[2] = a * f + h * u + s * l - o * c, e[3] = h * f - s * c - o * l - a * u, c = i[4], l = i[5], u = i[6], f = i[7], e[4] = s * f + h * c + o * u - a * l, e[5] = o * f + h * l + a * c - s * u, e[6] = a * f + h * u + s * l - o * c, e[7] = h * f - s * c - o * l - a * u, e;
  }
  /**
   * Rotates a {@link Quat2} around a given axis. Does the normalization automatically
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param axis - the axis to rotate around
   * @param rad - how far the rotation should be
   * @returns `out`
   */
  static rotateAroundAxis(e, n, i, s) {
    if (Math.abs(s) < ht)
      return Gt.copy(e, n);
    const o = Math.sqrt(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]);
    s = s * 0.5;
    const a = Math.sin(s), h = a * i[0] / o, c = a * i[1] / o, l = a * i[2] / o, u = Math.cos(s), f = n[0], d = n[1], p = n[2], y = n[3];
    e[0] = f * u + y * h + d * l - p * c, e[1] = d * u + y * c + p * h - f * l, e[2] = p * u + y * l + f * c - d * h, e[3] = y * u - f * h - d * c - p * l;
    const x = n[4], m = n[5], g = n[6], w = n[7];
    return e[4] = x * u + w * h + m * l - g * c, e[5] = m * u + w * c + g * h - x * l, e[6] = g * u + w * l + x * c - m * h, e[7] = w * u - x * h - m * c - g * l, e;
  }
  /**
   * Adds two {@link Quat2}s
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e[2] = n[2] + i[2], e[3] = n[3] + i[3], e[4] = n[4] + i[4], e[5] = n[5] + i[5], e[6] = n[6] + i[6], e[7] = n[7] + i[7], e;
  }
  /**
   * Multiplies two {@link Quat2}s
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns {quat2} out
   */
  static multiply(e, n, i) {
    const s = n[0], o = n[1], a = n[2], h = n[3], c = i[4], l = i[5], u = i[6], f = i[7], d = n[4], p = n[5], y = n[6], x = n[7], m = i[0], g = i[1], w = i[2], M = i[3];
    return e[0] = s * M + h * m + o * w - a * g, e[1] = o * M + h * g + a * m - s * w, e[2] = a * M + h * w + s * g - o * m, e[3] = h * M - s * m - o * g - a * w, e[4] = s * f + h * c + o * u - a * l + d * M + x * m + p * w - y * g, e[5] = o * f + h * l + a * c - s * u + p * M + x * g + y * m - d * w, e[6] = a * f + h * u + s * l - o * c + y * M + x * w + d * g - p * m, e[7] = h * f - s * c - o * l - a * u + x * M - d * m - p * g - y * w, e;
  }
  /**
   * Alias for {@link Quat2.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return e;
  }
  /**
   * Scales a {@link Quat2} by a scalar value
   * @category Static
   *
   * @param out - the receiving dual quaterion
   * @param a - the dual quaternion to scale
   * @param b - scalar value to scale the dual quaterion by
   * @returns `out`
   */
  static scale(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = n[3] * i, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = n[7] * i, e;
  }
  /**
   * Calculates the dot product of two {@link Quat2}s (The dot product of the real parts)
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return 0;
  }
  /**
   * Performs a linear interpolation between two {@link Quat2}s
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when `t = 0.5`)
   * @category Static
   *
   * @param out - the receiving dual quat
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, i, s) {
    const o = 1 - s;
    return Gt.dot(n, i) < 0 && (s = -s), e[0] = n[0] * o + i[0] * s, e[1] = n[1] * o + i[1] * s, e[2] = n[2] * o + i[2] * s, e[3] = n[3] * o + i[3] * s, e[4] = n[4] * o + i[4] * s, e[5] = n[5] * o + i[5] * s, e[6] = n[6] * o + i[6] * s, e[7] = n[7] * o + i[7] * s, e;
  }
  /**
   * Calculates the inverse of a {@link Quat2}. If they are normalized, conjugate is cheaper
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - dual quat to calculate inverse of
   * @returns `out`
   */
  static invert(e, n) {
    const i = Gt.squaredLength(n);
    return e[0] = -n[0] / i, e[1] = -n[1] / i, e[2] = -n[2] / i, e[3] = n[3] / i, e[4] = -n[4] / i, e[5] = -n[5] / i, e[6] = -n[6] / i, e[7] = n[7] / i, e;
  }
  /**
   * Calculates the conjugate of a {@link Quat2}
   * If the dual quaternion is normalized, this function is faster than {@link Quat2.invert} and produces the same result.
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - dual quaternion to calculate conjugate of
   * @returns `out`
   */
  static conjugate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e[3] = n[3], e[4] = -n[4], e[5] = -n[5], e[6] = -n[6], e[7] = n[7], e;
  }
  /**
   * Calculates the magnitude (length) of a {@link Quat2}
   * @category Static
   *
   * @param a - dual quaternion to calculate length of
   * @returns length of `a`
   */
  static magnitude(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.magnitude}
   * @category Static
   * @deprecated Use {@link Quat2.magnitude} to avoid conflicts with builtin `length` methods/attribs
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.magnitude}
   * @category Static
   * @deprecated Use {@link Quat2.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Quat2}
   * @category Static
   *
   * @param a - dual quaternion to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.squaredLength}
   * @category Static
   */
  static sqrLen(e) {
    return 0;
  }
  /**
   * Normalize a {@link Quat2}
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - dual quaternion to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    let i = Gt.squaredLength(n);
    if (i > 0) {
      i = Math.sqrt(i);
      const s = n[0] / i, o = n[1] / i, a = n[2] / i, h = n[3] / i, c = n[4], l = n[5], u = n[6], f = n[7], d = s * c + o * l + a * u + h * f;
      e[0] = s, e[1] = o, e[2] = a, e[3] = h, e[4] = (c - s * d) / i, e[5] = (l - o * d) / i, e[6] = (u - a * d) / i, e[7] = (f - h * d) / i;
    }
    return e;
  }
  /**
   * Returns a string representation of a {@link Quat2}
   * @category Static
   *
   * @param a - dual quaternion to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Quat2(${e.join(", ")})`;
  }
  /**
   * Returns whether or not the {@link Quat2}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first dual quaternion.
   * @param b - The second dual quaternion.
   * @returns True if the dual quaternions are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5] && e[6] === n[6] && e[7] === n[7];
  }
  /**
   * Returns whether or not the {@link Quat2}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first dual quaternion.
   * @param b - The second dual quaternion.
   * @returns True if the dual quaternions are equal, false otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = e[2], a = e[3], h = e[4], c = e[5], l = e[6], u = e[7], f = n[0], d = n[1], p = n[2], y = n[3], x = n[4], m = n[5], g = n[6], w = n[7];
    return Math.abs(i - f) <= ht * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(s - d) <= ht * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(o - p) <= ht * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - y) <= ht * Math.max(1, Math.abs(a), Math.abs(y)) && Math.abs(h - x) <= ht * Math.max(1, Math.abs(h), Math.abs(x)) && Math.abs(c - m) <= ht * Math.max(1, Math.abs(c), Math.abs(m)) && Math.abs(l - g) <= ht * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u - w) <= ht * Math.max(1, Math.abs(u), Math.abs(w));
  }
}
const X0 = new Float32Array(4), Z0 = new Float32Array(3);
Gt.dot = pt.dot;
Gt.squaredLength = pt.squaredLength;
Gt.sqrLen = pt.squaredLength;
Gt.mag = pt.magnitude;
Gt.length = pt.magnitude;
Gt.len = pt.magnitude;
Gt.mul = Gt.multiply;
const ww = Gt;
class Et extends Float32Array {
  /**
   * The number of bytes in a {@link Vec2}.
   */
  static BYTE_LENGTH = 2 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Vec2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 2: {
        const n = e[0];
        typeof n == "number" ? super([n, e[1]]) : super(n, e[1], 2);
        break;
      }
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n]) : super(n, 0, 2);
        break;
      }
      default:
        super(2);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec2.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    return Math.hypot(this[0], this[1]);
  }
  /**
   * Alias for {@link Vec2.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec2.squaredMagnitude(this);`
   */
  get squaredMagnitude() {
    const e = this[0], n = this[1];
    return e * e + n * n;
  }
  /**
   * Alias for {@link Vec2.squaredMagnitude}
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec2.str(this);`
   */
  get str() {
    return Et.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec2} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  // Instead of zero(), use a.fill(0) for instances;
  /**
   * Adds a {@link Vec2} to `this`.
   * Equivalent to `Vec2.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this;
  }
  /**
   * Subtracts a {@link Vec2} from `this`.
   * Equivalent to `Vec2.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this;
  }
  /**
   * Alias for {@link Vec2.subtract}
   */
  sub(e) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec2}.
   * Equivalent to `Vec2.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this;
  }
  /**
   * Alias for {@link Vec2.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec2}.
   * Equivalent to `Vec2.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns {Vec2} `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this;
  }
  /**
   * Alias for {@link Vec2.divide}
   */
  div(e) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec2.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec2.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, n) {
    return this[0] += e[0] * n, this[1] += e[1] * n, this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec2} and `this`.
   * Equivalent to `Vec2.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return Et.distance(this, e);
  }
  /**
   * Alias for {@link Vec2.distance}
   */
  dist(e) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec2} and `this`.
   * Equivalent to `Vec2.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return Et.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec2.squaredDistance}
   */
  sqrDist(e) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec2.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec2.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this;
  }
  /**
   * Sets each component of `this` to it's absolute value.
   * Equivalent to `Vec2.abs(this, this);`
   *
   * @returns `this`
   */
  abs() {
    return this[0] = Math.abs(this[0]), this[1] = Math.abs(this[1]), this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec2}.
   * Equivalent to `Vec2.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec2.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return Et.normalize(this, this);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, empty {@link Vec2}
   * @category Static
   *
   * @returns A new 2D vector
   */
  static create() {
    return new Et();
  }
  /**
   * Creates a new {@link Vec2} initialized with values from an existing vector
   * @category Static
   *
   * @param a - Vector to clone
   * @returns A new 2D vector
   */
  static clone(e) {
    return new Et(e);
  }
  /**
   * Creates a new {@link Vec2} initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @returns A new 2D vector
   */
  static fromValues(e, n) {
    return new Et(e, n);
  }
  /**
   * Copy the values from one {@link Vec2} to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - The source vector
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e;
  }
  /**
   * Set the components of a {@link Vec2} to the given values
   * @category Static
   *
   * @param out - The receiving vector
   * @param x - X component
   * @param y - Y component
   * @returns `out`
   */
  static set(e, n, i) {
    return e[0] = n, e[1] = i, e;
  }
  /**
   * Adds two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, n, i) {
    return e[0] = n[0] + i[0], e[1] = n[1] + i[1], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static subtract(e, n, i) {
    return e[0] = n[0] - i[0], e[1] = n[1] - i[1], e;
  }
  /**
   * Alias for {@link Vec2.subtract}
   * @category Static
   */
  static sub(e, n, i) {
    return [0, 0];
  }
  /**
   * Multiplies two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, i) {
    return e[0] = n[0] * i[0], e[1] = n[1] * i[1], e;
  }
  /**
   * Alias for {@link Vec2.multiply}
   * @category Static
   */
  static mul(e, n, i) {
    return [0, 0];
  }
  /**
   * Divides two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static divide(e, n, i) {
    return e[0] = n[0] / i[0], e[1] = n[1] / i[1], e;
  }
  /**
   * Alias for {@link Vec2.divide}
   * @category Static
   */
  static div(e, n, i) {
    return [0, 0];
  }
  /**
   * Math.ceil the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to ceil
   * @returns `out`
   */
  static ceil(e, n) {
    return e[0] = Math.ceil(n[0]), e[1] = Math.ceil(n[1]), e;
  }
  /**
   * Math.floor the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to floor
   * @returns `out`
   */
  static floor(e, n) {
    return e[0] = Math.floor(n[0]), e[1] = Math.floor(n[1]), e;
  }
  /**
   * Returns the minimum of two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static min(e, n, i) {
    return e[0] = Math.min(n[0], i[0]), e[1] = Math.min(n[1], i[1]), e;
  }
  /**
   * Returns the maximum of two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static max(e, n, i) {
    return e[0] = Math.max(n[0], i[0]), e[1] = Math.max(n[1], i[1]), e;
  }
  /**
   * Math.round the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to round
   * @returns `out`
   */
  static round(e, n) {
    return e[0] = Math.round(n[0]), e[1] = Math.round(n[1]), e;
  }
  /**
   * Scales a {@link Vec2} by a scalar number
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The vector to scale
   * @param b - Amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, i) {
    return e[0] = n[0] * i, e[1] = n[1] * i, e;
  }
  /**
   * Adds two Vec2's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @param scale - The amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, n, i, s) {
    return e[0] = n[0] + i[0] * s, e[1] = n[1] + i[1] * s, e;
  }
  /**
   * Calculates the euclidian distance between two {@link Vec2}s
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns distance between `a` and `b`
   */
  static distance(e, n) {
    return Math.hypot(n[0] - e[0], n[1] - e[1]);
  }
  /**
   * Alias for {@link Vec2.distance}
   * @category Static
   */
  static dist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two {@link Vec2}s
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns Squared distance between `a` and `b`
   */
  static squaredDistance(e, n) {
    const i = n[0] - e[0], s = n[1] - e[1];
    return i * i + s * s;
  }
  /**
   * Alias for {@link Vec2.distance}
   * @category Static
   */
  static sqrDist(e, n) {
    return 0;
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec2}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(e) {
    let n = e[0], i = e[1];
    return Math.sqrt(n * n + i * i);
  }
  /**
   * Alias for {@link Vec2.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec2.magnitude}
   * @category Static
   * @deprecated Use {@link Vec2.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec2.magnitude}
   * @category Static
   * @deprecated Use {@link Vec2.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Vec2}
   * @category Static
   *
   * @param a - Vector to calculate squared length of
   * @returns Squared length of a
   */
  static squaredLength(e) {
    const n = e[0], i = e[1];
    return n * n + i * i;
  }
  /**
   * Alias for {@link Vec2.squaredLength}
   */
  static sqrLen(e, n) {
    return 0;
  }
  /**
   * Negates the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to negate
   * @returns `out`
   */
  static negate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e;
  }
  /**
   * Returns the inverse of the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to invert
   * @returns `out`
   */
  static inverse(e, n) {
    return e[0] = 1 / n[0], e[1] = 1 / n[1], e;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(e, n) {
    return e[0] = Math.abs(n[0]), e[1] = Math.abs(n[1]), e;
  }
  /**
   * Normalize a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    const i = n[0], s = n[1];
    let o = i * i + s * s;
    return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = n[0] * o, e[1] = n[1] * o, e;
  }
  /**
   * Calculates the dot product of two {@link Vec2}s
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns Dot product of `a` and `b`
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1];
  }
  /**
   * Computes the cross product of two {@link Vec2}s
   * Note that the cross product must by definition produce a 3D vector.
   * For this reason there is also not instance equivalent for this function.
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static cross(e, n, i) {
    const s = n[0] * i[1] - n[1] * i[0];
    return e[0] = e[1] = 0, e[2] = s, e;
  }
  /**
   * Performs a linear interpolation between two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @param t - Interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, i, s) {
    const o = n[0], a = n[1];
    return e[0] = o + s * (i[0] - o), e[1] = a + s * (i[1] - a), e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat2}
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat2(e, n, i) {
    const s = n[0], o = n[1];
    return e[0] = i[0] * s + i[2] * o, e[1] = i[1] * s + i[3] * o, e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat2d}
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat2d(e, n, i) {
    const s = n[0], o = n[1];
    return e[0] = i[0] * s + i[2] * o + i[4], e[1] = i[1] * s + i[3] * o + i[5], e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat3}
   * 3rd vector component is implicitly '1'
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat3(e, n, i) {
    const s = n[0], o = n[1];
    return e[0] = i[0] * s + i[3] * o + i[6], e[1] = i[1] * s + i[4] * o + i[7], e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat4}
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, n, i) {
    const s = n[0], o = n[1];
    return e[0] = i[0] * s + i[4] * o + i[12], e[1] = i[1] * s + i[5] * o + i[13], e;
  }
  /**
   * Rotate a 2D vector
   * @category Static
   *
   * @param out - The receiving {@link Vec2}
   * @param a - The {@link Vec2} point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotate(e, n, i, s) {
    const o = n[0] - i[0], a = n[1] - i[1], h = Math.sin(s), c = Math.cos(s);
    return e[0] = o * c - a * h + i[0], e[1] = o * h + a * c + i[1], e;
  }
  /**
   * Get the angle between two 2D vectors
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(e, n) {
    const i = e[0], s = e[1], o = n[0], a = n[1], h = Math.sqrt(i * i + s * s) * Math.sqrt(o * o + a * a), c = h && (i * o + s * a) / h;
    return Math.acos(Math.min(Math.max(c, -1), 1));
  }
  /**
   * Set the components of a {@link Vec2} to zero
   * @category Static
   *
   * @param out - The receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns `true` if the vectors components are ===, `false` otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns `true` if the vectors are approximately equal, `false` otherwise.
   */
  static equals(e, n) {
    const i = e[0], s = e[1], o = n[0], a = n[1];
    return Math.abs(i - o) <= ht * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(s - a) <= ht * Math.max(1, Math.abs(s), Math.abs(a));
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - Vector to represent as a string
   * @returns String representation of the vector
   */
  static str(e) {
    return `Vec2(${e.join(", ")})`;
  }
}
Et.prototype.sub = Et.prototype.subtract;
Et.prototype.mul = Et.prototype.multiply;
Et.prototype.div = Et.prototype.divide;
Et.prototype.dist = Et.prototype.distance;
Et.prototype.sqrDist = Et.prototype.squaredDistance;
Et.sub = Et.subtract;
Et.mul = Et.multiply;
Et.div = Et.divide;
Et.dist = Et.distance;
Et.sqrDist = Et.squaredDistance;
Et.sqrLen = Et.squaredLength;
Et.mag = Et.magnitude;
Et.length = Et.magnitude;
Et.len = Et.magnitude;
const et = Et, bw = ["xx", "xy", "yx", "yy", "xxx", "xxy", "xyx", "xyy", "yxx", "yxy", "yyx", "yyy", "xxxx", "xxxy", "xxyx", "xxyy", "xyxx", "xyxy", "xyyx", "xyyy", "yxxx", "yxxy", "yxyx", "yxyy", "yyxx", "yyxy", "yyyx", "yyyy", "rr", "rg", "gr", "gg", "rrr", "rrg", "rgr", "rgg", "grr", "grg", "ggr", "ggg", "rrrr", "rrrg", "rrgr", "rrgg", "rgrr", "rgrg", "rggr", "rggg", "grrr", "grrg", "grgr", "grgg", "ggrr", "ggrg", "gggr", "gggg"], vw = ["xz", "yz", "zx", "zy", "zz", "xxz", "xyz", "xzx", "xzy", "xzz", "yxz", "yyz", "yzx", "yzy", "yzz", "zxx", "zxy", "zxz", "zyx", "zyy", "zyz", "zzx", "zzy", "zzz", "xxxz", "xxyz", "xxzx", "xxzy", "xxzz", "xyxz", "xyyz", "xyzx", "xyzy", "xyzz", "xzxx", "xzxy", "xzxz", "xzyx", "xzyy", "xzyz", "xzzx", "xzzy", "xzzz", "yxxz", "yxyz", "yxzx", "yxzy", "yxzz", "yyxz", "yyyz", "yyzx", "yyzy", "yyzz", "yzxx", "yzxy", "yzxz", "yzyx", "yzyy", "yzyz", "yzzx", "yzzy", "yzzz", "zxxx", "zxxy", "zxxz", "zxyx", "zxyy", "zxyz", "zxzx", "zxzy", "zxzz", "zyxx", "zyxy", "zyxz", "zyyx", "zyyy", "zyyz", "zyzx", "zyzy", "zyzz", "zzxx", "zzxy", "zzxz", "zzyx", "zzyy", "zzyz", "zzzx", "zzzy", "zzzz", "rb", "gb", "br", "bg", "bb", "rrb", "rgb", "rbr", "rbg", "rbb", "grb", "ggb", "gbr", "gbg", "gbb", "brr", "brg", "brb", "bgr", "bgg", "bgb", "bbr", "bbg", "bbb", "rrrb", "rrgb", "rrbr", "rrbg", "rrbb", "rgrb", "rggb", "rgbr", "rgbg", "rgbb", "rbrr", "rbrg", "rbrb", "rbgr", "rbgg", "rbgb", "rbbr", "rbbg", "rbbb", "grrb", "grgb", "grbr", "grbg", "grbb", "ggrb", "gggb", "ggbr", "ggbg", "ggbb", "gbrr", "gbrg", "gbrb", "gbgr", "gbgg", "gbgb", "gbbr", "gbbg", "gbbb", "brrr", "brrg", "brrb", "brgr", "brgg", "brgb", "brbr", "brbg", "brbb", "bgrr", "bgrg", "bgrb", "bggr", "bggg", "bggb", "bgbr", "bgbg", "bgbb", "bbrr", "bbrg", "bbrb", "bbgr", "bbgg", "bbgb", "bbbr", "bbbg", "bbbb"], Mw = ["xw", "yw", "zw", "wx", "wy", "wz", "ww", "xxw", "xyw", "xzw", "xwx", "xwy", "xwz", "xww", "yxw", "yyw", "yzw", "ywx", "ywy", "ywz", "yww", "zxw", "zyw", "zzw", "zwx", "zwy", "zwz", "zww", "wxx", "wxy", "wxz", "wxw", "wyx", "wyy", "wyz", "wyw", "wzx", "wzy", "wzz", "wzw", "wwx", "wwy", "wwz", "www", "xxxw", "xxyw", "xxzw", "xxwx", "xxwy", "xxwz", "xxww", "xyxw", "xyyw", "xyzw", "xywx", "xywy", "xywz", "xyww", "xzxw", "xzyw", "xzzw", "xzwx", "xzwy", "xzwz", "xzww", "xwxx", "xwxy", "xwxz", "xwxw", "xwyx", "xwyy", "xwyz", "xwyw", "xwzx", "xwzy", "xwzz", "xwzw", "xwwx", "xwwy", "xwwz", "xwww", "yxxw", "yxyw", "yxzw", "yxwx", "yxwy", "yxwz", "yxww", "yyxw", "yyyw", "yyzw", "yywx", "yywy", "yywz", "yyww", "yzxw", "yzyw", "yzzw", "yzwx", "yzwy", "yzwz", "yzww", "ywxx", "ywxy", "ywxz", "ywxw", "ywyx", "ywyy", "ywyz", "ywyw", "ywzx", "ywzy", "ywzz", "ywzw", "ywwx", "ywwy", "ywwz", "ywww", "zxxw", "zxyw", "zxzw", "zxwx", "zxwy", "zxwz", "zxww", "zyxw", "zyyw", "zyzw", "zywx", "zywy", "zywz", "zyww", "zzxw", "zzyw", "zzzw", "zzwx", "zzwy", "zzwz", "zzww", "zwxx", "zwxy", "zwxz", "zwxw", "zwyx", "zwyy", "zwyz", "zwyw", "zwzx", "zwzy", "zwzz", "zwzw", "zwwx", "zwwy", "zwwz", "zwww", "wxxx", "wxxy", "wxxz", "wxxw", "wxyx", "wxyy", "wxyz", "wxyw", "wxzx", "wxzy", "wxzz", "wxzw", "wxwx", "wxwy", "wxwz", "wxww", "wyxx", "wyxy", "wyxz", "wyxw", "wyyx", "wyyy", "wyyz", "wyyw", "wyzx", "wyzy", "wyzz", "wyzw", "wywx", "wywy", "wywz", "wyww", "wzxx", "wzxy", "wzxz", "wzxw", "wzyx", "wzyy", "wzyz", "wzyw", "wzzx", "wzzy", "wzzz", "wzzw", "wzwx", "wzwy", "wzwz", "wzww", "wwxx", "wwxy", "wwxz", "wwxw", "wwyx", "wwyy", "wwyz", "wwyw", "wwzx", "wwzy", "wwzz", "wwzw", "wwwx", "wwwy", "wwwz", "wwww", "ra", "ga", "ba", "ar", "ag", "ab", "aa", "rra", "rga", "rba", "rar", "rag", "rab", "raa", "gra", "gga", "gba", "gar", "gag", "gab", "gaa", "bra", "bga", "bba", "bar", "bag", "bab", "baa", "arr", "arg", "arb", "ara", "agr", "agg", "agb", "aga", "abr", "abg", "abb", "aba", "aar", "aag", "aab", "aaa", "rrra", "rrga", "rrba", "rrar", "rrag", "rrab", "rraa", "rgra", "rgga", "rgba", "rgar", "rgag", "rgab", "rgaa", "rbra", "rbga", "rbba", "rbar", "rbag", "rbab", "rbaa", "rarr", "rarg", "rarb", "rara", "ragr", "ragg", "ragb", "raga", "rabr", "rabg", "rabb", "raba", "raar", "raag", "raab", "raaa", "grra", "grga", "grba", "grar", "grag", "grab", "graa", "ggra", "ggga", "ggba", "ggar", "ggag", "ggab", "ggaa", "gbra", "gbga", "gbba", "gbar", "gbag", "gbab", "gbaa", "garr", "garg", "garb", "gara", "gagr", "gagg", "gagb", "gaga", "gabr", "gabg", "gabb", "gaba", "gaar", "gaag", "gaab", "gaaa", "brra", "brga", "brba", "brar", "brag", "brab", "braa", "bgra", "bgga", "bgba", "bgar", "bgag", "bgab", "bgaa", "bbra", "bbga", "bbba", "bbar", "bbag", "bbab", "bbaa", "barr", "barg", "barb", "bara", "bagr", "bagg", "bagb", "baga", "babr", "babg", "babb", "baba", "baar", "baag", "baab", "baaa", "arrr", "arrg", "arrb", "arra", "argr", "argg", "argb", "arga", "arbr", "arbg", "arbb", "arba", "arar", "arag", "arab", "araa", "agrr", "agrg", "agrb", "agra", "aggr", "aggg", "aggb", "agga", "agbr", "agbg", "agbb", "agba", "agar", "agag", "agab", "agaa", "abrr", "abrg", "abrb", "abra", "abgr", "abgg", "abgb", "abga", "abbr", "abbg", "abbb", "abba", "abar", "abag", "abab", "abaa", "aarr", "aarg", "aarb", "aara", "aagr", "aagg", "aagb", "aaga", "aabr", "aabg", "aabb", "aaba", "aaar", "aaag", "aaab", "aaaa"], jn = {
  x: 0,
  r: 0,
  y: 1,
  g: 1,
  z: 2,
  b: 2,
  w: 3,
  a: 3
};
function hc(r) {
  switch (r.length) {
    case 2:
      return function() {
        return new Et(this[jn[r[0]]], this[jn[r[1]]]);
      };
    case 3:
      return function() {
        return new xt(this[jn[r[0]]], this[jn[r[1]]], this[jn[r[2]]]);
      };
    case 4:
      return function() {
        return new yt(this[jn[r[0]]], this[jn[r[1]]], this[jn[r[2]]], this[jn[r[3]]]);
      };
  }
  return () => null;
}
let G0 = !1;
function _w() {
  if (!G0) {
    for (const r of bw) {
      const e = hc(r);
      Object.defineProperty(Et.prototype, r, {
        get: e
      }), Object.defineProperty(xt.prototype, r, {
        get: e
      }), Object.defineProperty(yt.prototype, r, {
        get: e
      });
    }
    for (const r of vw) {
      const e = hc(r);
      Object.defineProperty(xt.prototype, r, {
        get: e
      }), Object.defineProperty(yt.prototype, r, {
        get: e
      });
    }
    for (const r of Mw) {
      const e = hc(r);
      Object.defineProperty(yt.prototype, r, {
        get: e
      });
    }
    G0 = !0;
  }
}
const wP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EnableSwizzles: _w,
  Mat2: le,
  Mat2d: Te,
  Mat3: Zt,
  Mat4: At,
  Quat: pt,
  Quat2: Gt,
  Vec2: Et,
  Vec3: xt,
  Vec4: yt,
  mat2: ur,
  mat2d: Si,
  mat3: y1,
  mat4: x1,
  quat: gw,
  quat2: ww,
  vec2: et,
  vec3: ei,
  vec4: ss
}, Symbol.toStringTag, { value: "Module" })), m1 = Math.sqrt, g1 = 1e-4;
class gr {
  static fromPoints(e, n, i) {
    return new gr(e, n, i);
  }
  static fromXY(e, n, i, s, o, a) {
    return new gr(new O(e, n), new O(i, s), new O(o, a));
  }
  p0 = O.default();
  p1 = O.default();
  p2 = O.default();
  constructor(e, n, i) {
    this.p0.copy(e), this.p1.copy(n), this.p2.copy(i);
  }
  getBoundingBox() {
    let e = Ms.default(), n = [];
    const i = ml([this.p0, this.p1, this.p2], n);
    for (let s = 0; s < i; s++)
      e.expandByXY(n[s].x, n[s].y);
    return e;
  }
  split(e) {
    return Oh(this.p0, this.p1, this.p2, e);
  }
  /**
   * 获取贝塞尔曲线上某一点的坐标
   * @param {number} t
   * @returns
   * @memberof QuadBezier
   */
  getPoint(e) {
    return w1(this.p0, this.p1, this.p2, e);
  }
  getPoints(e = 0.01) {
    return dl(this.p0, this.p1, this.p2, e);
  }
  getExtermas(e) {
    return ml([this.p0, this.p1, this.p2], e);
  }
  fatten(e = 1) {
    return dl(this.p0, this.p1, this.p2, e);
  }
}
let ul = class fl {
  static fromQuadBezier(e) {
    const n = O.lerp(O.default(), e.p0, e.p1, 0.6666666666666666), i = O.lerp(O.default(), e.p2, e.p1, 2 / 3);
    return this.fromPoints(e.p0, n, i, e.p2);
  }
  static fromPoints(e, n, i, s) {
    return new fl(e, n, i, s);
  }
  static fromXY(e, n, i, s, o, a, h, c) {
    return new fl(new O(e, n), new O(i, s), new O(o, a), new O(h, c));
  }
  p0 = O.default();
  p1 = O.default();
  p2 = O.default();
  p3 = O.default();
  constructor(e, n, i, s) {
    this.p0.copy(e), this.p1.copy(n), this.p2.copy(i), this.p3.copy(s);
  }
  getBoundingBox() {
    let e = Ms.default(), n = [];
    const i = gl([this.p0, this.p1, this.p2, this.p3], n);
    for (let s = 0; s < i; s++)
      e.expandByXY(n[s].x, n[s].y);
    return e;
  }
  split(e) {
    return du(this.p0, this.p1, this.p2, this.p3, e);
  }
  getPoint(e) {
    return fu(this.p0, this.p1, this.p2, this.p3, e);
  }
  getPoints(e = 0.01) {
    return pl(this.p0, this.p1, this.p2, this.p3, e);
  }
  getExtermas(e) {
    return gl([this.p0, this.p1, this.p2, this.p3], e);
  }
  fatten(e = 1) {
    return pl(this.p0, this.p1, this.p2, this.p3, e);
  }
};
function zr(r, e, n) {
  return p1(r, e) * Math.pow(n, e) * Math.pow(1 - n, r - e);
}
function Sw(r, e) {
  const n = r.length - 1;
  if (n < 0) return O.default();
  const i = O.default();
  for (let s = 0; s <= n; s++) {
    const o = r[s], a = zr(n, s, e);
    i.x += o.x * a, i.y += o.y * a;
  }
  return i;
}
function uu(r, e) {
  const n = r.length - 1;
  if (n < 0) return O.default();
  let i = r.map((s) => s.clone());
  for (let s = 1; s <= n; s++)
    for (let o = 0; o < n - s + 1; o++)
      i[o] = i[o].lerp(i[o + 1], e);
  return i[0];
}
function Tw(r, e, n, i = 1, s) {
  const o = 4 * i / (3 * (1 + i)), a = r + (e - r) * o, h = n + (e - n) * o;
  return en(r, a, h, n, s);
}
function Ew(r, e, n, i = 1, s) {
  const o = 4 * i / (3 * (1 + i)), a = O.lerp(O.default(), r, e, o), h = O.lerp(O.default(), e, n, o);
  return fu(r, a, h, n, s);
}
function zw(r, e, n) {
  const i = r.length - 1;
  if (i < 0) return O.default();
  const s = O.default();
  let o = 0;
  for (let a = 0; a <= i; a++) {
    const h = r[a], c = zr(i, a, n);
    s.x += e[a] * c * h.x, s.y += e[a] * c * h.y, o += e[a] * c;
  }
  return s.x /= o, s.y /= o, s;
}
function Aw(r, e) {
  const n = b1(r, e), i = v1(r, e), s = Math.abs(n.cross(i)), o = Math.pow(n.magnitudeSquared(), 3 / 2);
  return s / o;
}
function Cw(r, e, n, i) {
  const s = y1.fromValues(
    1,
    -2,
    1,
    0,
    2,
    -2,
    0,
    0,
    1
  ), o = ei.fromValues(1, i, i * i), a = ei.transformMat3(ei.create(), o, s), h = ei.fromValues(r.x, e.x, n.x), c = ei.fromValues(r.y, e.y, n.y);
  return O.create(ei.dot(a, h), ei.dot(a, c));
}
function Pw(r, e, n, i, s) {
  const o = x1.fromValues(
    1,
    -3,
    3,
    -1,
    0,
    3,
    -6,
    3,
    0,
    0,
    3,
    -3,
    0,
    0,
    0,
    1
  ), a = ss.fromValues(1, s, s * s, s * s * s), h = ss.transformMat4(ei.create(), a, o), c = ss.fromValues(r.x, e.x, n.x, i.x), l = ss.fromValues(r.y, e.y, n.y, i.y);
  return O.create(ss.dot(h, c), ss.dot(h, l));
}
function xn(r, e, n, i) {
  const s = i * i, o = 1 - i, a = o * o;
  return r * a + 2 * i * o * e + s * n;
}
function w1(r, e, n, i) {
  const s = i * i, o = 1 - i, a = o * o, h = r.x * a + 2 * o * i * e.x + s * n.x, c = r.y * a + 2 * o * i * e.y + s * n.y;
  return O.create(h, c);
}
function en(r, e, n, i, s) {
  const o = s * s, a = o * s, h = 1 - s, c = h * h, l = c * h;
  return r * l + 3 * s * c * e + 3 * h * o * n + a * i;
}
function fu(r, e, n, i, s) {
  const o = s * s, a = o * s, h = 1 - s, c = h * h, l = c * h, u = r.x * l + 3 * c * s * e.x + 3 * h * o * n.x + a * i.x, f = r.y * l + 3 * c * s * e.y + 3 * h * o * n.y + a * i.y;
  return O.create(u, f);
}
function Iw(r) {
  const e = r.length;
  if (e <= 1) return [];
  let n = [r[0]];
  for (let i = 1; i < e; i++) {
    let s = r[i - 1], o = r[i];
    n[i - 1] = O.create(
      s.x * i / e + o.x * (e - i) / e,
      s.y * i / e + o.y * (e - i) / e
    );
  }
  return n[e] = r[e - 1], n;
}
function b1(r, e) {
  const n = r.length - 1;
  if (n < 0) return O.default();
  let i = O.default();
  for (let s = 0; s < n; s++) {
    const o = zr(n - 1, s, e);
    i.x += (r[s + 1].x - r[s].x) * o, i.y += (r[s + 1].y - r[s].y) * o;
  }
  return i.multiplyScalar(n);
}
function v1(r, e) {
  const n = r.length - 1;
  if (n < 2) return O.create(0, 0);
  let i = O.create(0, 0);
  for (let s = 0; s <= n - 2; s++) {
    const o = zr(n - 2, s, e);
    i.x += r[s + 2].x - 2 * r[s + 1].x + r[s].x * o, i.y += r[s + 2].y - 2 * r[s + 1].y + r[s].y * o;
  }
  return i.x *= n * (n - 1), i.y *= n * (n - 1), i;
}
function kw(r, e) {
  let n = r;
  for (let i = 0; i < e; i++) {
    const s = [];
    for (let o = 0; o < n.length - 1; o++) {
      const a = n[o + 1].clone().sub(n[o]);
      s.push(a);
    }
    n = s;
  }
  return n;
}
function Rw(r, e, n) {
  const i = r.length - 1;
  if (n > i) throw new Error("导数阶数不能超过贝塞尔曲线阶数");
  const s = ll(i) / ll(i - n), o = kw(r, n), a = i - n, h = O.default();
  for (let c = 0; c <= a; c++) {
    const l = zr(a, c, e);
    h.x += o[c].x * l, h.y += o[c].y * l;
  }
  return h.x *= s, h.y *= s, h;
}
function Ow(r) {
  const e = r.length - 1;
  if (e < 0) return [];
  let n = Array.from({ length: e }).map(() => O.default());
  for (let i = 0; i < e; i++)
    n[i].x = e * (r[i + 1].x - r[i].x), n[i].y = e * (r[i + 1].y - r[i].y);
  return n;
}
function Lw(r, e, n) {
  if (e === 0 && n === 1) return r;
  if (e === 0)
    return Xr(r, n).left;
  if (n === 1)
    return Xr(r, e).right;
  const i = Xr(r, e).right;
  return Xr(i, n).left;
}
function Xr(r, e = 0.5) {
  const n = r.length - 1, i = [], s = [], o = r.map((a) => a.clone());
  i.push(o[0].clone()), s.unshift(o[n].clone());
  for (let a = 1; a <= n; a++) {
    for (let h = 0; h < n - a + 1; h++)
      o[h].x = (1 - e) * o[h].x + e * o[h + 1].x, o[h].y = (1 - e) * o[h].y + e * o[h + 1].y;
    i.push(o[0].clone()), s.unshift(o[n - a].clone());
  }
  return {
    left: i,
    right: s
  };
}
function Oh(r, e, n, i = 0.5) {
  const s = r.clone().lerp(e, i), o = e.clone().lerp(n, i), a = s.clone().lerp(o, i);
  return [r, s, a, o, n];
}
function Bw(r, e) {
  const n = M1(r[0], r[1], r[2]);
  return n > 0 && n < 1 ? Oh(r[0], r[1], r[2], n) : r;
}
function du(r, e, n, i, s = 0.5) {
  const o = r.clone().lerp(e, s), a = e.clone().lerp(n, s), h = n.clone().lerp(i, s), c = o.clone().lerp(a, s), l = a.clone().lerp(h, s), u = c.clone().lerp(l, s);
  return [r, o, c, u, l, h, i];
}
function Fw(r, e, n, i, s, o) {
  const a = s - n, h = o - i, c = r - n, l = e - i, u = a * a + h * h;
  if (u == 0)
    return 0;
  const f = Math.max(0, Math.min(1, (c * a + l * h) / u)), d = n + f * a, p = i + f * h, y = r - d, x = e - p;
  return y * y + x * x;
}
function rh(r, e, n, i, s, o) {
  const a = s - n, h = o - i, c = h, l = -a, u = a * i - h * n;
  return Math.abs(c * r + l * e + u) / Math.sqrt(c * c + l * l);
}
function dl(r, e, n, i = 1, s = 1e3) {
  const o = [];
  function a(h, c, l, u = 0) {
    if (rh(c.x, c.y, h.x, h.y, l.x, l.y) < i || u > s) {
      o.push(l);
      return;
    }
    const [d, p, y, x, m] = Oh(h, c, l, 0.5);
    a(d, p, y, u + 1), a(y, x, m, u + 1);
  }
  return o.push(r), a(r, e, n), o;
}
function pl(r, e, n, i, s = 1, o = 1e3) {
  const a = [];
  function h(c, l, u, f, d = 0) {
    const p = rh(l.x, l.y, c.x, c.y, f.x, f.y), y = rh(u.x, u.y, c.x, c.y, f.x, f.y);
    if (Math.max(p, y) < s || d > o) {
      a.push(f);
      return;
    }
    const [x, m, g, w, M, S, E] = du(c, l, u, f, 0.5);
    h(x, m, g, w, d + 1), h(w, M, S, E, d + 1);
  }
  return a.push(r), h(r, e, n, i), a;
}
function Nw(r, e, n) {
  const i = O.lerp(O.default(), r, e, 0.6666666666666666), s = O.lerp(O.default(), n, e, 2 / 3);
  return [r, i, s, n];
}
function qw(r, e, n, i) {
  const s = 2 * (e.x - r.x) + 2 * (n.x - 2 * e.x + r.x) * i, o = 2 * (e.y - r.y) + 2 * (n.y - 2 * e.y + r.y) * i;
  return O.create(s, o);
}
function M1(r, e, n) {
  const i = 2 * (e.x - r.x), s = 2 * (e.y - r.y), o = 2 * (r.x - 2 * e.x + n.x), a = 2 * (r.y - 2 * e.y + n.y);
  let h = -(i * o + s * a), c = o * o + a * a;
  return c < 0 && (h = -h, c = -c), h <= 0 ? 0 : h >= c ? 1 : h / c;
}
function Dw(r, e, n, i, s) {
  const o = 3 * s * s * (i.x - 3 * n.x + 3 * e.x - r.x) + 6 * s * (n.x - 2 * e.x + r.x) + 3 * (e.x - r.x), a = 3 * s * s * (i.y - 3 * n.y + 3 * e.y - r.y) + 6 * s * (n.y - 2 * e.y + r.y) + 3 * (e.y - r.x);
  return O.create(o, a);
}
function J0(r, e) {
  let n = r[2] - r[0], i = r[4] - 2 * r[2] + r[0], s = r[6] + 3 * (r[2] - r[4]) - r[0];
  e[0] = s * s, e[1] = 3 * i * s, e[2] = 2 * i * i + s * n, e[3] = n * i;
}
function $w(r, e) {
  let n = 0;
  for (let i = e; i > 1; --i)
    if (r[n] == r[n + 1]) {
      for (let s = 1; s < i; ++s)
        r[s - 1] = r[s];
      e -= 1;
    } else
      n++;
  return e;
}
function Vw(r, e) {
  for (let n = e - 1; n > 0; --n)
    for (let i = n; i > 0; --i)
      if (r[i] < r[i - 1]) {
        let s = r[i];
        r[i] = r[i - 1], r[i - 1] = s;
      }
}
function Uw(r, e) {
  if (Math.abs(r[0]) <= 1e-6)
    return pu(r[1], r[2], r[3], e);
  let n, i, s, o, a;
  {
    let u = 1 / r[0];
    n = r[1] * u, i = r[2] * u, s = r[3] * u;
  }
  o = (n * n - i * 3) / 9, a = (2 * n * n * n - 9 * n * i + 27 * s) / 54;
  let h = o * o * o, c = a * a - h, l = n / 3;
  if (c < 0) {
    let u = Math.cos(Ce(a / Math.sqrt(h), -1, 1)), f = -2 * Math.sqrt(o);
    return e[0] = Ce(f * Math.cos(u / 3) - l, 0, 1), e[1] = Ce(f * Math.cos((u + 2 * Math.PI) / 3) - l, 0, 1), e[2] = Ce(f * Math.cos((u - 2 * Math.PI) / 3) - l, 0, 1), Vw(e, 3), $w(e, 3);
  } else {
    let u = Math.abs(a) + Math.sqrt(c);
    return u = Math.pow(u, 0.3333333), a > 0 && (u = -u), u != 0 && (u += o / u), e[0] = Ce(u - l, 0, 1), 1;
  }
}
function Ww(r, e) {
  let n = new Array(4).fill(0), i = new Array(4).fill(0), s;
  for (J0(r.map((a) => a.x), n), J0(r.map((a) => a.y), i), s = 0; s < 4; s++)
    n[s] += i[s];
  return Uw(n, e);
}
function Ua(r, e, n) {
  if (r < 0 && (r = -r, e = -e), e == 0 || r == 0 || r >= e)
    return 0;
  let i = r / e;
  return !Number.isFinite(i) || i == 0 ? 0 : (n[0] = i, 1);
}
function yl(r, e, n, i) {
  return Ua(r - e, r - e - e + n, i);
}
function xl(r, e, n, i, s) {
  const o = i - r + 3 * (e - n), a = 2 * (r - e - e + n), h = e - r;
  return pu(o, a, h, s);
}
function pu(r, e, n, i) {
  if (r == 0)
    return Ua(-n, e, i);
  let s = 0, o = e * e - 4 * r * n;
  if (o < 0)
    return 0;
  o = Math.sqrt(o);
  let a = o;
  if (!Number.isFinite(a))
    return 0;
  let h = e < 0 ? -(e - a) / 2 : -(e + a) / 2, c = [];
  if (Ua(h, r, c) > 0 && (i[s] = c[0], s++), Ua(n, h, c) && (i[s] = c[0], s++), s == 2)
    if (i[0] > i[1]) {
      let l = i[0];
      i[0] = i[1], i[1] = l;
    } else i[0] == i[1] && (s -= 1);
  return s;
}
function ml(r, e) {
  let n = [], i = [], s = 0;
  yl(r[0].x, r[1].x, r[2].x, i) > 0 && (n[s] = i[0], s++), yl(r[0].y, r[1].y, r[2].y, i) > 0 && (n[s] = i[0], s++);
  for (let o = 0; o < s; ++o)
    e[o] = uu(r, n[o]);
  return e[s] = r[2], s + 1;
}
function gl(r, e) {
  let n = [0, 0, 0, 0], i = [], s = 0, o = 0;
  (o = xl(r[0].x, r[1].x, r[2].x, r[3].x, i)) > 0 && (o == 1 && (n[0] = i[0]), o == 2 && (n[1] = i[1]), s += o), (o = xl(r[0].y, r[1].y, r[2].y, r[3].y, i)) > 0 && (o == 1 && (n[s] = i[0]), o == 2 && (n[s + 1] = i[1]), s += o);
  for (let a = 0; a < s; ++a)
    e[a] = uu(r, n[a]);
  return e[s] = r[3], s + 1;
}
function _1(r, e, n, i, s, o, a, h, c) {
  let l = 0, u = 5e-3, f = 1 / 0;
  const d = O.create(a, h), p = O.default(), y = O.default();
  for (let x = 0; x < 1; x += 0.05) {
    p[0] = xn(r, n, s, x), p[1] = xn(e, i, o, x);
    const m = d.distanceSquared(p);
    m < f && (l = x, f = m);
  }
  f = 1 / 0;
  for (let x = 0; x < 32 && !(u < g1); x++) {
    const m = l - u, g = l + u;
    p[0] = xn(r, n, s, m), p[1] = xn(e, i, o, m);
    const w = d.distanceSquared(p);
    if (m >= 0 && w < f)
      l = m, f = w;
    else {
      y[0] = xn(r, n, s, g), y[1] = xn(e, i, o, g);
      const M = y.distanceSquared(d);
      g <= 1 && M < f ? (l = g, f = M) : u *= 0.5;
    }
  }
  return c && (c[0] = xn(r, n, s, l), c[1] = xn(e, i, o, l)), m1(f);
}
function jw(r, e, n, i, s, o, a) {
  let h = r, c = e, l = 0;
  const u = 1 / a;
  for (let f = 1; f <= a; f++) {
    let d = f * u;
    const p = xn(r, n, s, d), y = xn(e, i, o, d), x = p - h, m = y - c;
    l += Math.sqrt(x * x + m * m), h = p, c = y;
  }
  return l;
}
function S1(r, e, n, i, s, o, a, h, c, l, u) {
  let f = 0, d = 5e-3, p = 1 / 0, y, x, m, g;
  const w = O.create(c, l), M = O.default(), S = O.default();
  for (let E = 0; E < 1; E += 0.05)
    M[0] = en(r, n, s, a, E), M[1] = en(e, i, o, h, E), m = w.distanceSquared(M), m < p && (f = E, p = m);
  p = 1 / 0;
  for (let E = 0; E < 32 && !(d < g1); E++)
    y = f - d, x = f + d, M[0] = en(r, n, s, a, y), M[1] = en(e, i, o, h, y), m = M.distanceSquared(w), y >= 0 && m < p ? (f = y, p = m) : (S[0] = en(r, n, s, a, x), S[1] = en(e, i, o, h, x), g = S.distanceSquared(w), x <= 1 && g < p ? (f = x, p = g) : d *= 0.5);
  return u && (u[0] = en(r, n, s, a, f), u[1] = en(e, i, o, h, f)), m1(p);
}
function Yw(r, e, n, i, s, o, a, h, c) {
  let l = r, u = e, f = 0;
  const d = 1 / c;
  for (let p = 1; p <= c; p++) {
    let y = p * d;
    const x = en(r, n, s, a, y), m = en(e, i, o, h, y), g = x - l, w = m - u;
    f += Math.sqrt(g * g + w * w), l = x, u = m;
  }
  return f;
}
const { abs: kr, cos: Yn, sin: Ds, acos: Hw, atan2: Rr, sqrt: di, pow: tn } = Math;
function Or(r) {
  return r < 0 ? -tn(-r, 1 / 3) : tn(r, 1 / 3);
}
const T1 = Math.PI, Go = 2 * T1, pi = T1 / 2, Xw = 1e-6, cc = Number.MAX_SAFE_INTEGER || 9007199254740991, lc = Number.MIN_SAFE_INTEGER || -9007199254740991, Zw = { x: 0, y: 0, z: 0 }, K = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(r, e) {
    const n = e(r);
    let i = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (i += n.z * n.z), di(i);
  },
  compute: function(r, e, n) {
    if (r === 0)
      return e[0].t = 0, e[0];
    const i = e.length - 1;
    if (r === 1)
      return e[i].t = 1, e[i];
    const s = 1 - r;
    let o = e;
    if (i === 0)
      return e[0].t = r, e[0];
    if (i === 1) {
      const h = {
        x: s * o[0].x + r * o[1].x,
        y: s * o[0].y + r * o[1].y,
        t: r
      };
      return n && (h.z = s * o[0].z + r * o[1].z), h;
    }
    if (i < 4) {
      let h = s * s, c = r * r, l, u, f, d = 0;
      i === 2 ? (o = [o[0], o[1], o[2], Zw], l = h, u = s * r * 2, f = c) : i === 3 && (l = h * s, u = h * r * 3, f = s * c * 3, d = r * c);
      const p = {
        x: l * o[0].x + u * o[1].x + f * o[2].x + d * o[3].x,
        y: l * o[0].y + u * o[1].y + f * o[2].y + d * o[3].y,
        t: r
      };
      return n && (p.z = l * o[0].z + u * o[1].z + f * o[2].z + d * o[3].z), p;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let h = 0; h < a.length - 1; h++)
        a[h] = {
          x: a[h].x + (a[h + 1].x - a[h].x) * r,
          y: a[h].y + (a[h + 1].y - a[h].y) * r
        }, typeof a[h].z < "u" && (a[h].z = a[h].z + (a[h + 1].z - a[h].z) * r);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = r, a[0];
  },
  computeWithRatios: function(r, e, n, i) {
    const s = 1 - r, o = n, a = e;
    let h = o[0], c = o[1], l = o[2], u = o[3], f;
    if (h *= s, c *= r, a.length === 2)
      return f = h + c, {
        x: (h * a[0].x + c * a[1].x) / f,
        y: (h * a[0].y + c * a[1].y) / f,
        z: i ? (h * a[0].z + c * a[1].z) / f : !1,
        t: r
      };
    if (h *= s, c *= 2 * s, l *= r * r, a.length === 3)
      return f = h + c + l, {
        x: (h * a[0].x + c * a[1].x + l * a[2].x) / f,
        y: (h * a[0].y + c * a[1].y + l * a[2].y) / f,
        z: i ? (h * a[0].z + c * a[1].z + l * a[2].z) / f : !1,
        t: r
      };
    if (h *= s, c *= 1.5 * s, l *= 3 * s, u *= r * r * r, a.length === 4)
      return f = h + c + l + u, {
        x: (h * a[0].x + c * a[1].x + l * a[2].x + u * a[3].x) / f,
        y: (h * a[0].y + c * a[1].y + l * a[2].y + u * a[3].y) / f,
        z: i ? (h * a[0].z + c * a[1].z + l * a[2].z + u * a[3].z) / f : !1,
        t: r
      };
  },
  // 导数控制点计算函数
  derive: function(r, e) {
    const n = [];
    for (let i = r, s = i.length, o = s - 1; s > 1; s--, o--) {
      const a = [];
      for (let h = 0, c; h < o; h++)
        c = {
          x: o * (i[h + 1].x - i[h].x),
          y: o * (i[h + 1].y - i[h].y)
        }, e && (c.z = o * (i[h + 1].z - i[h].z)), a.push(c);
      n.push(a), i = a;
    }
    return n;
  },
  between: function(r, e, n) {
    return e <= r && r <= n || K.approximately(r, e) || K.approximately(r, n);
  },
  approximately: function(r, e, n) {
    return kr(r - e) <= (n || Xw);
  },
  length: function(r) {
    const n = K.Tvalues.length;
    let i = 0;
    for (let s = 0, o; s < n; s++)
      o = 0.5 * K.Tvalues[s] + 0.5, i += K.Cvalues[s] * K.arcfn(o, r);
    return 0.5 * i;
  },
  map: function(r, e, n, i, s) {
    const o = n - e, a = s - i, h = r - e, c = h / o;
    return i + a * c;
  },
  lerp: function(r, e, n) {
    const i = {
      x: e.x + r * (n.x - e.x),
      y: e.y + r * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (i.z = e.z + r * (n.z - e.z)), i;
  },
  pointToString: function(r) {
    let e = r.x + "/" + r.y;
    return typeof r.z < "u" && (e += "/" + r.z), e;
  },
  pointsToString: function(r) {
    return "[" + r.map(K.pointToString).join(", ") + "]";
  },
  copy: function(r) {
    return JSON.parse(JSON.stringify(r));
  },
  angle: function(r, e, n) {
    const i = e.x - r.x, s = e.y - r.y, o = n.x - r.x, a = n.y - r.y, h = i * a - s * o, c = i * o + s * a;
    return Rr(h, c);
  },
  // round as string, to avoid rounding errors
  round: function(r, e) {
    const n = "" + r, i = n.indexOf(".");
    return parseFloat(n.substring(0, i + 1 + e));
  },
  dist: function(r, e) {
    const n = r.x - e.x, i = r.y - e.y;
    return di(n * n + i * i);
  },
  closest: function(r, e) {
    let n = tn(2, 63), i, s;
    return r.forEach(function(o, a) {
      s = K.dist(e, o), s < n && (n = s, i = a);
    }), { mdist: n, mpos: i };
  },
  abcratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const n = tn(r, e) + tn(1 - r, e), i = n - 1;
    return kr(i / n);
  },
  projectionratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const n = tn(1 - r, e), i = tn(r, e) + n;
    return n / i;
  },
  lli8: function(r, e, n, i, s, o, a, h) {
    const c = (r * i - e * n) * (s - a) - (r - n) * (s * h - o * a), l = (r * i - e * n) * (o - h) - (e - i) * (s * h - o * a), u = (r - n) * (o - h) - (e - i) * (s - a);
    return u == 0 ? !1 : { x: c / u, y: l / u };
  },
  lli4: function(r, e, n, i) {
    const s = r.x, o = r.y, a = e.x, h = e.y, c = n.x, l = n.y, u = i.x, f = i.y;
    return K.lli8(s, o, a, h, c, l, u, f);
  },
  lli: function(r, e) {
    return K.lli4(r, r.c, e, e.c);
  },
  makeline: function(r, e) {
    return new Wt(
      r.x,
      r.y,
      (r.x + e.x) / 2,
      (r.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(r) {
    let e = cc, n = cc, i = lc, s = lc;
    return r.forEach(function(o) {
      const a = o.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), i < a.x.max && (i = a.x.max), s < a.y.max && (s = a.y.max);
    }), {
      x: { min: e, mid: (e + i) / 2, max: i, size: i - e },
      y: { min: n, mid: (n + s) / 2, max: s, size: s - n }
    };
  },
  shapeintersections: function(r, e, n, i, s) {
    if (!K.bboxoverlap(e, i)) return [];
    const o = [], a = [r.startcap, r.forward, r.back, r.endcap], h = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(c) {
      c.virtual || h.forEach(function(l) {
        if (l.virtual) return;
        const u = c.intersects(l, s);
        u.length > 0 && (u.c1 = c, u.c2 = l, u.s1 = r, u.s2 = n, o.push(u));
      });
    }), o;
  },
  makeshape: function(r, e, n) {
    const i = e.points.length, s = r.points.length, o = K.makeline(e.points[i - 1], r.points[0]), a = K.makeline(r.points[s - 1], e.points[0]), h = {
      startcap: o,
      forward: r,
      back: e,
      endcap: a,
      bbox: K.findbbox([o, r, e, a])
    };
    return h.intersections = function(c) {
      return K.shapeintersections(
        h,
        h.bbox,
        c,
        c.bbox,
        n
      );
    }, h;
  },
  getminmax: function(r, e, n) {
    if (!n) return { min: 0, max: 0 };
    let i = cc, s = lc, o, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let h = 0, c = n.length; h < c; h++)
      o = n[h], a = r.get(o), a[e] < i && (i = a[e]), a[e] > s && (s = a[e]);
    return { min: i, mid: (i + s) / 2, max: s, size: s - i };
  },
  align: function(r, e) {
    const n = e.p1.x, i = e.p1.y, s = -Rr(e.p2.y - i, e.p2.x - n), o = function(a) {
      return {
        x: (a.x - n) * Yn(s) - (a.y - i) * Ds(s),
        y: (a.x - n) * Ds(s) + (a.y - i) * Yn(s)
      };
    };
    return r.map(o);
  },
  // 根据控制点求根
  roots: function(r, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = r.length - 1, i = K.align(r, e), s = function(I) {
      return 0 <= I && I <= 1;
    };
    if (n === 2) {
      const I = i[0].y, b = i[1].y, v = i[2].y, _ = I - 2 * b + v;
      if (_ !== 0) {
        const z = -di(b * b - I * v), P = -I + b, k = -(z + P) / _, B = -(-z + P) / _;
        return [k, B].filter(s);
      } else if (b !== v && _ === 0)
        return [(2 * b - v) / (2 * b - 2 * v)].filter(s);
      return [];
    }
    const o = i[0].y, a = i[1].y, h = i[2].y, c = i[3].y;
    let l = -o + 3 * a - 3 * h + c, u = 3 * o - 6 * a + 3 * h, f = -3 * o + 3 * a, d = o;
    if (K.approximately(l, 0)) {
      if (K.approximately(u, 0))
        return K.approximately(f, 0) ? [] : [-d / f].filter(s);
      const I = di(f * f - 4 * u * d), b = 2 * u;
      return [(I - f) / b, (-f - I) / b].filter(s);
    }
    u /= l, f /= l, d /= l;
    const p = (3 * f - u * u) / 3, y = p / 3, x = (2 * u * u * u - 9 * u * f + 27 * d) / 27, m = x / 2, g = m * m + y * y * y;
    let w, M, S, E, A;
    if (g < 0) {
      const I = -p / 3, b = I * I * I, v = di(b), _ = -x / (2 * v), z = _ < -1 ? -1 : _ > 1 ? 1 : _, P = Hw(z), k = Or(v), B = 2 * k;
      return S = B * Yn(P / 3) - u / 3, E = B * Yn((P + Go) / 3) - u / 3, A = B * Yn((P + 2 * Go) / 3) - u / 3, [S, E, A].filter(s);
    } else {
      if (g === 0)
        return w = m < 0 ? Or(-m) : -Or(m), S = 2 * w - u / 3, E = -w - u / 3, [S, E].filter(s);
      {
        const I = di(g);
        return w = Or(-m + I), M = Or(m + I), [w - M - u / 3].filter(s);
      }
    }
  },
  // 根据导数控制点计算根，即曲线切线为零的点
  droots: function(r) {
    if (r.length === 3) {
      const e = r[0], n = r[1], i = r[2], s = e - 2 * n + i;
      if (s !== 0) {
        const o = -di(n * n - e * i), a = -e + n, h = -(o + a) / s, c = -(-o + a) / s;
        return [h, c];
      } else if (n !== i && s === 0)
        return [(2 * n - i) / (2 * (n - i))];
      return [];
    }
    if (r.length === 2) {
      const e = r[0], n = r[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(r, e, n, i, s) {
    let o, a, h, c, l = 0, u = 0;
    const f = K.compute(r, e), d = K.compute(r, n), p = f.x * f.x + f.y * f.y;
    if (i ? (o = di(
      tn(f.y * d.z - d.y * f.z, 2) + tn(f.z * d.x - d.z * f.x, 2) + tn(f.x * d.y - d.x * f.y, 2)
    ), a = tn(p + f.z * f.z, 3 / 2)) : (o = f.x * d.y - f.y * d.x, a = tn(p, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (l = o / a, u = a / o, !s) {
      const y = K.curvature(r - 1e-3, e, n, i, !0).k, x = K.curvature(r + 1e-3, e, n, i, !0).k;
      c = (x - l + (l - y)) / 2, h = (kr(x - l) + kr(l - y)) / 2;
    }
    return { k: l, r: u, dk: c, adk: h };
  },
  inflections: function(r) {
    if (r.length < 4) return [];
    const e = K.align(r, { p1: r[0], p2: r.slice(-1)[0] }), n = e[2].x * e[1].y, i = e[3].x * e[1].y, s = e[1].x * e[2].y, o = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * i + 3 * s - o), h = 18 * (3 * n - i - 3 * s), c = 18 * (s - n);
    if (K.approximately(a, 0)) {
      if (!K.approximately(h, 0)) {
        let d = -c / h;
        if (0 <= d && d <= 1) return [d];
      }
      return [];
    }
    const l = 2 * a;
    if (K.approximately(l, 0)) return [];
    const u = h * h - 4 * a * c;
    if (u < 0) return [];
    const f = Math.sqrt(u);
    return [(f - h) / l, -(h + f) / l].filter(function(d) {
      return 0 <= d && d <= 1;
    });
  },
  bboxoverlap: function(r, e) {
    const n = ["x", "y"], i = n.length;
    for (let s = 0, o, a, h, c; s < i; s++)
      if (o = n[s], a = r[o].mid, h = e[o].mid, c = (r[o].size + e[o].size) / 2, kr(a - h) >= c) return !1;
    return !0;
  },
  expandbox: function(r, e) {
    e.x.min < r.x.min && (r.x.min = e.x.min), e.y.min < r.y.min && (r.y.min = e.y.min), e.z && e.z.min < r.z.min && (r.z.min = e.z.min), e.x.max > r.x.max && (r.x.max = e.x.max), e.y.max > r.y.max && (r.y.max = e.y.max), e.z && e.z.max > r.z.max && (r.z.max = e.z.max), r.x.mid = (r.x.min + r.x.max) / 2, r.y.mid = (r.y.min + r.y.max) / 2, r.z && (r.z.mid = (r.z.min + r.z.max) / 2), r.x.size = r.x.max - r.x.min, r.y.size = r.y.max - r.y.min, r.z && (r.z.size = r.z.max - r.z.min);
  },
  pairiteration: function(r, e, n) {
    const i = r.bbox(), s = e.bbox(), o = 1e5, a = n || 0.5;
    if (i.x.size + i.y.size < a && s.x.size + s.y.size < a)
      return [
        (o * (r._t1 + r._t2) / 2 | 0) / o + "/" + (o * (e._t1 + e._t2) / 2 | 0) / o
      ];
    let h = r.split(0.5), c = e.split(0.5), l = [
      { left: h.left, right: c.left },
      { left: h.left, right: c.right },
      { left: h.right, right: c.right },
      { left: h.right, right: c.left }
    ];
    l = l.filter(function(f) {
      return K.bboxoverlap(f.left.bbox(), f.right.bbox());
    });
    let u = [];
    return l.length === 0 || (l.forEach(function(f) {
      u = u.concat(
        K.pairiteration(f.left, f.right, a)
      );
    }), u = u.filter(function(f, d) {
      return u.indexOf(f) === d;
    })), u;
  },
  getccenter: function(r, e, n) {
    const i = e.x - r.x, s = e.y - r.y, o = n.x - e.x, a = n.y - e.y, h = i * Yn(pi) - s * Ds(pi), c = i * Ds(pi) + s * Yn(pi), l = o * Yn(pi) - a * Ds(pi), u = o * Ds(pi) + a * Yn(pi), f = (r.x + e.x) / 2, d = (r.y + e.y) / 2, p = (e.x + n.x) / 2, y = (e.y + n.y) / 2, x = f + h, m = d + c, g = p + l, w = y + u, M = K.lli8(f, d, x, m, p, y, g, w), S = K.dist(M, r);
    let E = Rr(r.y - M.y, r.x - M.x), A = Rr(e.y - M.y, e.x - M.x), I = Rr(n.y - M.y, n.x - M.x), b;
    return E < I ? ((E > A || A > I) && (E += Go), E > I && (b = I, I = E, E = b)) : I < A && A < E ? (b = I, I = E, E = b) : I += Go, M.s = E, M.e = I, M.r = S, M;
  },
  numberSort: function(r, e) {
    return r - e;
  }
};
class so {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return K.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), i = 1; i < e.length; i++)
      K.expandbox(n, e[i].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(i) {
      n.push(...i.offset(e));
    }), new so(n);
  }
}
const { abs: Lr, min: Q0, max: K0, cos: Gw, sin: Jw, acos: Qw, sqrt: Br } = Math, Kw = Math.PI;
class Wt {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), i = !1;
    if (typeof n[0] == "object") {
      i = n.length;
      const p = [];
      n.forEach(function(y) {
        ["x", "y", "z"].forEach(function(x) {
          typeof y[x] < "u" && p.push(y[x]);
        });
      }), n = p;
    }
    let s = !1;
    const o = n.length;
    if (i) {
      if (i > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        s = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !s && (o === 9 || o === 12) || e && e[0] && typeof e[0].z < "u", h = this.points = [];
    for (let p = 0, y = a ? 3 : 2; p < o; p += y) {
      var c = {
        x: n[p],
        y: n[p + 1]
      };
      a && (c.z = n[p + 2]), h.push(c);
    }
    const l = this.order = h.length - 1, u = this.dims = ["x", "y"];
    a && u.push("z"), this.dimlen = u.length;
    const f = K.align(h, { p1: h[0], p2: h[l] }), d = K.dist(h[0], h[l]);
    this._linear = f.reduce((p, y) => p + Lr(y.y), 0) < d / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  // 根据t和二次控制点创建基于t的二次贝塞曲线
  static quadraticFromPoints(e, n, i, s) {
    if (typeof s > "u" && (s = 0.5), s === 0)
      return new Wt(n, n, i);
    if (s === 1)
      return new Wt(e, n, n);
    const o = Wt.getABC(2, e, n, i, s);
    return new Wt(e, o.A, i);
  }
  // 根据t和三次控制点创建基于t的三次贝塞曲线
  static cubicFromPoints(e, n, i, s, o) {
    typeof s > "u" && (s = 0.5);
    const a = Wt.getABC(3, e, n, i, s);
    typeof o > "u" && (o = K.dist(n, a.C));
    const h = o * (1 - s) / s, c = K.dist(e, i), l = (i.x - e.x) / c, u = (i.y - e.y) / c, f = o * l, d = o * u, p = h * l, y = h * u, x = { x: n.x - f, y: n.y - d }, m = { x: n.x + p, y: n.y + y }, g = a.A, w = { x: g.x + (x.x - g.x) / (1 - s), y: g.y + (x.y - g.y) / (1 - s) }, M = { x: g.x + (m.x - g.x) / s, y: g.y + (m.y - g.y) / s }, S = { x: e.x + (w.x - e.x) / s, y: e.y + (w.y - e.y) / s }, E = {
      x: i.x + (M.x - i.x) / (1 - s),
      y: i.y + (M.y - i.y) / (1 - s)
    };
    return new Wt(e, S, E, i);
  }
  static getUtils() {
    return K;
  }
  getUtils() {
    return Wt.getUtils();
  }
  static get PolyBezier() {
    return so;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return K.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, i = e[0].y, s = ["M", n, i, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = e.length; o < a; o++)
      s.push(e[o].x), s.push(e[o].y);
    return s.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = K.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = K.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return K.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, i, s, o = 0.5) {
    const a = K.projectionratio(o, e), h = 1 - a, c = {
      x: a * n.x + h * s.x,
      y: a * n.y + h * s.y
    }, l = K.abcratio(o, e);
    return { A: {
      x: i.x + (i.x - c.x) / l,
      y: i.y + (i.y - c.y) / l
    }, B: i, C: c, S: n, E: s };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let i = this.points[0], s = this.points[this.order];
    return Wt.getABC(this.order, i, n, s, e);
  }
  // 根据步骤数分割贝塞尔曲线为多个点，并返回这些点的数组
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, i, s; n < e; n++)
      s = n / (e - 1), i = this.compute(s), i.t = s, this._lut.push(i);
    return this._lut;
  }
  // 判断点是否在贝塞尔曲线上，并返回t值
  on(e, n) {
    n = n || 5;
    const i = this.getLUT(), s = [];
    for (let o = 0, a, h = 0; o < i.length; o++)
      a = i[o], K.dist(a, e) < n && (s.push(a), h += o / i.length);
    return s.length ? t /= s.length : !1;
  }
  // 投影点至贝塞尔曲线
  //使用基于曲线查找表 (LUT) 的两遍投影测试，查找最接近特定曲线外点的曲线内点。通过距离比较找到最接近的匹配项，然后检查该匹配项周围的精细区间，看看是否可以找到更优的投影
  project(e) {
    const n = this.getLUT(), i = n.length - 1, s = K.closest(n, e), o = s.mpos, a = (o - 1) / i, h = (o + 1) / i, c = 0.1 / i;
    let l = s.mdist, u = a, f = u, d;
    l += 1;
    for (let p; u < h + c; u += c)
      d = this.compute(u), p = K.dist(e, d), p < l && (l = p, f = u);
    return f = f < 0 ? 0 : f > 1 ? 1 : f, d = this.compute(f), d.t = f, d.d = l, d;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  // 计算贝塞尔曲线在t时刻的点
  compute(e) {
    return this.ratios ? K.computeWithRatios(e, this.points, this.ratios, this._3d) : K.compute(e, this.points, this._3d, this.ratios);
  }
  // 向上提升曲线阶数，使之成为更高阶的贝塞尔曲线
  raise() {
    const e = this.points, n = [e[0]], i = e.length;
    for (let s = 1, o, a; s < i; s++)
      o = e[s], a = e[s - 1], n[s] = {
        x: (i - s) / i * o.x + s / i * a.x,
        y: (i - s) / i * o.y + s / i * a.y
      };
    return n[i] = e[i - 1], new Wt(n);
  }
  //计算指定值处的曲线切线t。注意，这将生成一个非标准化的向量{x: dx, y: dy}。
  derivative(e) {
    return K.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return K.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new Wt(K.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  //t使用曲率公式计算点处的曲线曲率：
  curvature(e) {
    return K.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  //计算曲线上的所有拐点。即曲线曲率符号发生变化的所有点。
  inflections() {
    return K.inflections(this.points);
  }
  /**
   * 计算指定t值处的曲线法线。注意，这将生成一个法线化的向量{x: nx, y: ny}。
  在二维空间中，法线就是将法线向量旋转四分之一圈。在三维空间中，法线就是将法线向量绕切平面旋转四分之一圈。
   */
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), i = Br(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / i, y: n.x / i };
  }
  __normal3(e) {
    const n = this.derivative(e), i = this.derivative(e + 0.01), s = Br(n.x * n.x + n.y * n.y + n.z * n.z), o = Br(i.x * i.x + i.y * i.y + i.z * i.z);
    n.x /= s, n.y /= s, n.z /= s, i.x /= o, i.y /= o, i.z /= o;
    const a = {
      x: i.y * n.z - i.z * n.y,
      y: i.z * n.x - i.x * n.z,
      z: i.x * n.y - i.y * n.x
    }, h = Br(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= h, a.y /= h, a.z /= h;
    const c = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  //在所有迭代中，为指定 t 值的曲线上点生成所有包点
  hull(e) {
    let n = this.points, i = [], s = [], o = 0;
    for (s[o++] = n[0], s[o++] = n[1], s[o++] = n[2], this.order === 3 && (s[o++] = n[3]); n.length > 1; ) {
      i = [];
      for (let a = 0, h, c = n.length - 1; a < c; a++)
        h = K.lerp(e, n[a], n[a + 1]), s[o++] = h, i.push(h);
      n = i;
    }
    return s;
  }
  //当仅给出一个值时，此函数将把曲线分成t=... 两条新曲线，这两条新曲线合在一起相当于原始曲线。
  //当提供两个t值时，曲线在 上分割t1，之后得到的第二个子曲线在 （缩放） 上分割t2，从而产生一条与区间 上的原始曲线等价的新曲线[t1,t2]。
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const i = this.hull(e), s = {
      left: this.order === 2 ? new Wt([i[0], i[3], i[5]]) : new Wt([i[0], i[4], i[7], i[9]]),
      right: this.order === 2 ? new Wt([i[5], i[4], i[2]]) : new Wt([i[9], i[8], i[6], i[3]]),
      span: i
    };
    return s.left._t1 = K.map(0, 0, 1, this._t1, this._t2), s.left._t2 = K.map(e, 0, 1, this._t1, this._t2), s.right._t1 = K.map(e, 0, 1, this._t1, this._t2), s.right._t2 = K.map(1, 0, 1, this._t1, this._t2), n ? (n = K.map(n, e, 1, 0, 1), s.right.split(n).left) : s;
  }
  /*** 
   * 计算曲线上的所有极值。极值是针对每个维度而不是整条曲线计算的，因此结果不是凸/凹过渡的数量，而是每个单独维度的过渡数量。
   * 此函数生成一个对象，其中每个维度列出了出现极值的值 {x: [num, num, ...], y: [...], z: [...], values: [...]} 数组，仅当曲线是 3d 曲线时才存在，并且该属性是所有维度上的值的总和。tzvaluest
  */
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(i) {
        let s = function(a) {
          return a[i];
        }, o = this.dpoints[0].map(s);
        e[i] = K.droots(o), this.order === 3 && (o = this.dpoints[1].map(s), e[i] = e[i].concat(K.droots(o))), e[i] = e[i].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[i].sort(K.numberSort));
      }).bind(this)
    ), e.values = n.sort(K.numberSort).filter(function(i, s) {
      return n.indexOf(i) === s;
    }), e;
  }
  // 根据其外壳坐标和极值计算（如果未缓存）此曲线的边界框。
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(i) {
        n[i] = K.getminmax(this, i, e[i]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), i = e.bbox();
    return K.bboxoverlap(n, i);
  }
  /**
   * 如果仅使用距离参数调用此函数，则会创建一条沿曲线法线偏移距离为 的新曲线d。请注意，这里隐藏着深奥的魔法，贝塞尔曲线的偏移曲线永远不可能是另一条贝塞尔曲线。因此，此函数“作弊”并生成一个曲线数组，这些曲线组合在一起，形成一条与理论上的偏移曲线等同的连续曲线。
  
  如果同时给出了距离和t值，则返回坐标，表示曲线上位于 处的点t=...，沿其法线偏移距离d。
   * @param {*} t 
   * @param {*} d 
   * @returns 
   */
  offset(e, n) {
    if (typeof n < "u") {
      const i = this.get(e), s = this.normal(e), o = {
        c: i,
        n: s,
        x: i.x + s.x * n,
        y: i.y + s.y * n
      };
      return this._3d && (o.z = i.z + s.z * n), o;
    }
    if (this._linear) {
      const i = this.normal(0), s = this.points.map(function(o) {
        const a = {
          x: o.x + e * i.x,
          y: o.y + e * i.y
        };
        return o.z && i.z && (a.z = o.z + e * i.z), a;
      });
      return [new Wt(s)];
    }
    return this.reduce().map(function(i) {
      return i._linear ? i.offset(e)[0] : i.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const s = K.angle(this.points[0], this.points[3], this.points[1]), o = K.angle(this.points[0], this.points[3], this.points[2]);
      if (s > 0 && o < 0 || s < 0 && o > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let i = e.x * n.x + e.y * n.y;
    return this._3d && (i += e.z * n.z), Lr(Qw(i)) < Kw / 3;
  }
  /**
   * 将曲线简化为“简单”子曲线的集合，其中简单性定义为所有控制点都在基线的同一侧（三次曲线具有控制到端点线不得交叉的附加约束），并且端点法线之间的角度不大于 60 度。
   * @returns 
   */
  reduce() {
    let e, n = 0, i = 0, s = 0.01, o, a = [], h = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      i = c[e], o = this.split(n, i), o._t1 = n, o._t2 = i, a.push(o), n = i;
    return a.forEach(function(l) {
      for (n = 0, i = 0; i <= 1; )
        for (i = n + s; i <= 1 + s; i += s)
          if (o = l.split(n, i), !o.simple()) {
            if (i -= s, Lr(n - i) < s)
              return [];
            o = l.split(n, i), o._t1 = K.map(n, 0, 1, l._t1, l._t2), o._t2 = K.map(i, 0, 1, l._t1, l._t2), h.push(o), n = i;
            break;
          }
      n < 1 && (o = l.split(n, 1), o._t1 = K.map(n, 0, 1, l._t1, l._t2), o._t2 = l._t2, h.push(o));
    }), h;
  }
  translate(e, n, i) {
    i = typeof i == "number" ? i : n;
    const s = this.order;
    let o = this.points.map((a, h) => (1 - h / s) * n + h / s * i);
    return new Wt(
      this.points.map((a, h) => ({
        x: a.x + e.x * o[h],
        y: a.y + e.y * o[h]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let i = !1;
    if (typeof e == "function" && (i = e), i && n === 2)
      return this.raise().scale(i);
    const s = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        i ? i(0) : e,
        i ? i(1) : e
      );
    const a = i ? i(0) : e, h = i ? i(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], l = [], u = K.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!u)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(f) {
      const d = l[f * n] = K.copy(o[f * n]);
      d.x += (f ? h : a) * c[f].n.x, d.y += (f ? h : a) * c[f].n.y;
    }), i ? ([0, 1].forEach(function(f) {
      if (!(n === 2 && f)) {
        var d = o[f + 1], p = {
          x: d.x - u.x,
          y: d.y - u.y
        }, y = i ? i((f + 1) / n) : e;
        i && !s && (y = -y);
        var x = Br(p.x * p.x + p.y * p.y);
        p.x /= x, p.y /= x, l[f + 1] = {
          x: d.x + y * p.x,
          y: d.y + y * p.y
        };
      }
    }), new Wt(l)) : ([0, 1].forEach((f) => {
      if (n === 2 && f) return;
      const d = l[f * n], p = this.derivative(f), y = { x: d.x + p.x, y: d.y + p.y };
      l[f + 1] = K.lli4(d, y, u, o[f + 1]);
    }), new Wt(l));
  }
  /**
   * 这将生成一条曲线的轮廓，该轮廓沿着曲线法线和反向法线方向的一定距离d。结果是一个曲线数组，这些曲线组合在一起构成了该曲线的轮廓路径。顶点是三次贝塞尔曲线，其控制点的方向形成一条直线。
   通过使用四个距离测量来实现渐进偏移，其中d1 是沿法线的初始偏移，d2沿反法线的初始距离，d3沿法线的最终偏移，以及d4沿反法线的最终偏移。
  * @param {*} d1 
   * @param {*} d2 
   * @param {*} d3 
   * @param {*} d4 
   * @returns 
   */
  outline(e, n, i, s) {
    if (n = n === void 0 ? e : n, this._linear) {
      const E = this.normal(0), A = this.points[0], I = this.points[this.points.length - 1];
      let b, v, _;
      i === void 0 && (i = e, s = n), b = { x: A.x + E.x * e, y: A.y + E.y * e }, _ = { x: I.x + E.x * i, y: I.y + E.y * i }, v = { x: (b.x + _.x) / 2, y: (b.y + _.y) / 2 };
      const z = [b, v, _];
      b = { x: A.x - E.x * n, y: A.y - E.y * n }, _ = { x: I.x - E.x * s, y: I.y - E.y * s }, v = { x: (b.x + _.x) / 2, y: (b.y + _.y) / 2 };
      const P = [_, v, b], k = K.makeline(P[2], z[0]), B = K.makeline(z[2], P[0]), R = [k, new Wt(z), B, new Wt(P)];
      return new so(R);
    }
    const o = this.reduce(), a = o.length, h = [];
    let c = [], l, u = 0, f = this.length();
    const d = typeof i < "u" && typeof s < "u";
    function p(E, A, I, b, v) {
      return function(_) {
        const z = b / I, P = (b + v) / I, k = A - E;
        return K.map(_, 0, 1, E + z * k, E + P * k);
      };
    }
    o.forEach(function(E) {
      const A = E.length();
      d ? (h.push(
        E.scale(p(e, i, f, u, A))
      ), c.push(
        E.scale(p(-n, -s, f, u, A))
      )) : (h.push(E.scale(e)), c.push(E.scale(-n))), u += A;
    }), c = c.map(function(E) {
      return l = E.points, l[3] ? E.points = [l[3], l[2], l[1], l[0]] : E.points = [l[2], l[1], l[0]], E;
    }).reverse();
    const y = h[0].points[0], x = h[a - 1].points[h[a - 1].points.length - 1], m = c[a - 1].points[c[a - 1].points.length - 1], g = c[0].points[0], w = K.makeline(m, y), M = K.makeline(x, g), S = [w].concat(h).concat([M]).concat(c);
    return new so(S);
  }
  /**
   * 这会将曲线轮廓生成为一系列形状，而不是路径序列。每个形状都是一个对象{startcap: (bezier), forward: (bezier), endcap: (bezier), back: (bezier)}。此外，每个端点都有一个.virtual属性，用于指示它是原始曲线轮廓的真正端点，还是轮廓形状集合中某个位置的中间端点。
   * @param {*} d1 
   * @param {*} d2 
   * @param {*} curveIntersectionThreshold 
   * @returns 
   */
  outlineshapes(e, n, i) {
    n = n || e;
    const s = this.outline(e, n).curves, o = [];
    for (let a = 1, h = s.length; a < h / 2; a++) {
      const c = K.makeshape(
        s[a],
        s[h - a],
        i
      );
      c.startcap.virtual = a > 1, c.endcap.virtual = a < h / 2 - 1, o.push(c);
    }
    return o;
  }
  /**
   * 如果不带参数，此函数将检查自相交。这意味着它对二次曲线没有意义，二次曲线若自相交则为退化曲线（即所有坐标都位于同一条线上，因此与其说是“曲线”，不如说是一种“奇怪的画线方法”）。相交结果将返回一个字符串数组float/float，其中两个浮点数由字符分隔/，并且两个浮点数都对应于t相交点处的曲线值。
   * @param {*} curve 
   * @param {*} curveIntersectionThreshold 
   * @returns 
   */
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof Wt && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  /**
    * 查找此曲线与某条线的交点{p1: {x:... ,y:...}, p2: ... }。交点是t此曲线上的值的数组。
  首先对曲线进行对齐（平移/旋转），使曲线的第一个坐标为 (0,0)，然后旋转曲线，使相交线与 x 轴重合。这样做会将“查找交点”转换为简单的“查找根点”。
  作为求根解决方案，使用您可能在高中时记得的标准平方根函数以及绝对非标准的 Cardano 求解立方根函数算法，以符号方式计算二次和三次曲线的根。
    * @param {*} line 
    * @returns 
    */
  lineIntersects(e) {
    const n = Q0(e.p1.x, e.p2.x), i = Q0(e.p1.y, e.p2.y), s = K0(e.p1.x, e.p2.x), o = K0(e.p1.y, e.p2.y);
    return K.roots(this.points, e).filter((a) => {
      var h = this.get(a);
      return K.between(h.x, n, s) && K.between(h.y, i, o);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), i = n.length - 2, s = [];
    for (let o = 0, a, h, c; o < i; o++)
      h = n.slice(o, o + 1), c = n.slice(o + 2), a = this.curveintersects(h, c, e), s.push(...a);
    return s;
  }
  curveintersects(e, n, i) {
    const s = [];
    e.forEach(function(a) {
      n.forEach(function(h) {
        a.overlaps(h) && s.push({ left: a, right: h });
      });
    });
    let o = [];
    return s.forEach(function(a) {
      const h = K.pairiteration(
        a.left,
        a.right,
        i
      );
      h.length > 0 && (o = o.concat(h));
    }), o;
  }
  /** 
   * 将贝塞尔曲线近似为一系列圆弧。可选的阈值参数控制圆弧需要达到何种程度的拟合才能被视为合理的近似值。阈值越高，圆弧拟合的精度越低。如果未设置明确的阈值，则使用threshold的值。0.5
  */
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, i, s) {
    const o = (s - i) / 4, a = this.get(i + o), h = this.get(s - o), c = K.dist(e, n), l = K.dist(e, a), u = K.dist(e, h);
    return Lr(l - c) + Lr(u - c);
  }
  _iterate(e, n) {
    let i = 0, s = 1, o;
    do {
      o = 0, s = 1;
      let a = this.get(i), h, c, l, u, f = !1, d = !1, p, y = s, x = 1;
      do
        if (d = f, u = l, y = (i + s) / 2, h = this.get(y), c = this.get(s), l = K.getccenter(a, h, c), l.interval = {
          start: i,
          end: s
        }, f = this._error(l, a, i, s) <= e, p = d && !f, p || (x = s), f) {
          if (s >= 1) {
            if (l.interval.end = x = 1, u = l, s > 1) {
              let g = {
                x: l.x + l.r * Gw(l.e),
                y: l.y + l.r * Jw(l.e)
              };
              l.e += K.angle({ x: l.x, y: l.y }, g, this.get(1));
            }
            break;
          }
          s = s + (s - i) / 2;
        } else
          s = y;
      while (!p && o++ < 100);
      if (o >= 100)
        break;
      u = u || l, n.push(u), i = x;
    } while (s < 1);
    return n;
  }
}
const fr = O.distanceSquared, Jo = Math.pow, Ii = Math.sqrt, oh = 1e-8, E1 = 1e-4, td = Ii(3), Qo = 1 / 3, Fn = O.default(), on = O.default(), dr = O.default();
function Ci(r) {
  return r > -oh && r < oh;
}
function z1(r) {
  return r > oh || r < -oh;
}
function Ee(r, e, n, i, s) {
  const o = 1 - s;
  return o * o * (o * r + 3 * s * e) + s * s * (s * i + 3 * o * n);
}
function tb(r, e, n, i, s) {
  const o = 1 - s;
  return 3 * (((e - r) * o + 2 * (n - e) * s) * o + (i - n) * s * s);
}
function A1(r, e, n, i, s, o) {
  const a = i + 3 * (e - n) - r, h = 3 * (n - e * 2 + r), c = 3 * (e - r), l = r - s, u = h * h - 3 * a * c, f = h * c - 9 * a * l, d = c * c - 3 * h * l;
  let p = 0;
  if (Ci(u) && Ci(f))
    if (Ci(h))
      o[0] = 0;
    else {
      const y = -c / h;
      y >= 0 && y <= 1 && (o[p++] = y);
    }
  else {
    const y = f * f - 4 * u * d;
    if (Ci(y)) {
      const x = f / u, m = -h / a + x, g = -x / 2;
      m >= 0 && m <= 1 && (o[p++] = m), g >= 0 && g <= 1 && (o[p++] = g);
    } else if (y > 0) {
      const x = Ii(y);
      let m = u * h + 1.5 * a * (-f + x), g = u * h + 1.5 * a * (-f - x);
      m < 0 ? m = -Jo(-m, Qo) : m = Jo(m, Qo), g < 0 ? g = -Jo(-g, Qo) : g = Jo(g, Qo);
      const w = (-h - (m + g)) / (3 * a);
      w >= 0 && w <= 1 && (o[p++] = w);
    } else {
      const x = (2 * u * h - 3 * a * f) / (2 * Ii(u * u * u)), m = Math.acos(x) / 3, g = Ii(u), w = Math.cos(m), M = (-h - 2 * g * w) / (3 * a), S = (-h + g * (w + td * Math.sin(m))) / (3 * a), E = (-h + g * (w - td * Math.sin(m))) / (3 * a);
      M >= 0 && M <= 1 && (o[p++] = M), S >= 0 && S <= 1 && (o[p++] = S), E >= 0 && E <= 1 && (o[p++] = E);
    }
  }
  return p;
}
function yu(r, e, n, i, s) {
  const o = 6 * n - 12 * e + 6 * r, a = 9 * e + 3 * i - 3 * r - 9 * n, h = 3 * e - 3 * r;
  let c = 0;
  if (Ci(a)) {
    if (z1(o)) {
      const l = -h / o;
      l >= 0 && l <= 1 && (s[c++] = l);
    }
  } else {
    const l = o * o - 4 * a * h;
    if (Ci(l))
      s[0] = -o / (2 * a);
    else if (l > 0) {
      const u = Ii(l), f = (-o + u) / (2 * a), d = (-o - u) / (2 * a);
      f >= 0 && f <= 1 && (s[c++] = f), d >= 0 && d <= 1 && (s[c++] = d);
    }
  }
  return c;
}
function wl(r, e, n, i, s, o) {
  const a = (e - r) * s + r, h = (n - e) * s + e, c = (i - n) * s + n, l = (h - a) * s + a, u = (c - h) * s + h, f = (u - l) * s + l;
  o[0] = r, o[1] = a, o[2] = l, o[3] = f, o[4] = f, o[5] = u, o[6] = c, o[7] = i;
}
function eb(r, e, n, i, s, o, a, h, c, l, u) {
  let f = 0, d = 5e-3, p = 1 / 0, y, x, m, g;
  Fn[0] = c, Fn[1] = l;
  for (let w = 0; w < 1; w += 0.05)
    on[0] = Ee(r, n, s, a, w), on[1] = Ee(e, i, o, h, w), m = fr(Fn, on), m < p && (f = w, p = m);
  p = 1 / 0;
  for (let w = 0; w < 32 && !(d < E1); w++)
    y = f - d, x = f + d, on[0] = Ee(r, n, s, a, y), on[1] = Ee(e, i, o, h, y), m = fr(on, Fn), y >= 0 && m < p ? (f = y, p = m) : (dr[0] = Ee(r, n, s, a, x), dr[1] = Ee(e, i, o, h, x), g = fr(dr, Fn), x <= 1 && g < p ? (f = x, p = g) : d *= 0.5);
  return u && (u[0] = Ee(r, n, s, a, f), u[1] = Ee(e, i, o, h, f)), Ii(p);
}
function C1(r, e, n, i, s, o, a, h, c) {
  let l = r, u = e, f = 0;
  const d = 1 / c;
  for (let p = 1; p <= c; p++) {
    let y = p * d;
    const x = Ee(r, n, s, a, y), m = Ee(e, i, o, h, y), g = x - l, w = m - u;
    f += Math.sqrt(g * g + w * w), l = x, u = m;
  }
  return f;
}
function ze(r, e, n, i) {
  const s = 1 - i;
  return s * (s * r + 2 * i * e) + i * i * n;
}
function nb(r, e, n, i) {
  return 2 * ((1 - i) * (e - r) + i * (n - e));
}
function P1(r, e, n, i, s) {
  const o = r - 2 * e + n, a = 2 * (e - r), h = r - i;
  let c = 0;
  if (Ci(o)) {
    if (z1(a)) {
      const l = -h / a;
      l >= 0 && l <= 1 && (s[c++] = l);
    }
  } else {
    const l = a * a - 4 * o * h;
    if (Ci(l)) {
      const u = -a / (2 * o);
      u >= 0 && u <= 1 && (s[c++] = u);
    } else if (l > 0) {
      const u = Ii(l), f = (-a + u) / (2 * o), d = (-a - u) / (2 * o);
      f >= 0 && f <= 1 && (s[c++] = f), d >= 0 && d <= 1 && (s[c++] = d);
    }
  }
  return c;
}
function xu(r, e, n) {
  const i = r + n - 2 * e;
  return i === 0 ? 0.5 : (r - e) / i;
}
function bl(r, e, n, i, s) {
  const o = (e - r) * i + r, a = (n - e) * i + e, h = (a - o) * i + o;
  s[0] = r, s[1] = o, s[2] = h, s[3] = h, s[4] = a, s[5] = n;
}
function ib(r, e, n, i, s, o, a, h, c) {
  let l = 0, u = 5e-3, f = 1 / 0;
  Fn[0] = a, Fn[1] = h;
  for (let d = 0; d < 1; d += 0.05) {
    on[0] = ze(r, n, s, d), on[1] = ze(e, i, o, d);
    const p = fr(Fn, on);
    p < f && (l = d, f = p);
  }
  f = 1 / 0;
  for (let d = 0; d < 32 && !(u < E1); d++) {
    const p = l - u, y = l + u;
    on[0] = ze(r, n, s, p), on[1] = ze(e, i, o, p);
    const x = fr(on, Fn);
    if (p >= 0 && x < f)
      l = p, f = x;
    else {
      dr[0] = ze(r, n, s, y), dr[1] = ze(e, i, o, y);
      const m = fr(dr, Fn);
      y <= 1 && m < f ? (l = y, f = m) : u *= 0.5;
    }
  }
  return c && (c[0] = ze(r, n, s, l), c[1] = ze(e, i, o, l)), Ii(f);
}
function I1(r, e, n, i, s, o, a) {
  let h = r, c = e, l = 0;
  const u = 1 / a;
  for (let f = 1; f <= a; f++) {
    let d = f * u;
    const p = ze(r, n, s, d), y = ze(e, i, o, d), x = p - h, m = y - c;
    l += Math.sqrt(x * x + m * m), h = p, c = y;
  }
  return l;
}
const sb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cubicAt: Ee,
  cubicDerivativeAt: tb,
  cubicExtrema: yu,
  cubicLength: C1,
  cubicProjectPoint: eb,
  cubicRootAt: A1,
  cubicSubdivide: wl,
  quadraticAt: ze,
  quadraticDerivativeAt: nb,
  quadraticExtremum: xu,
  quadraticLength: I1,
  quadraticProjectPoint: ib,
  quadraticRootAt: P1,
  quadraticSubdivide: bl
}, Symbol.toStringTag, { value: "Module" }));
class rb {
  xs;
  ys;
  ks;
  constructor(e, n) {
    this.xs = e, this.ys = n, this.ks = this.getNaturalKs(new Float64Array(this.xs.length));
  }
  getNaturalKs(e) {
    const n = this.xs.length - 1, i = ab(n + 1, n + 2);
    for (let s = 1; s < n; s++)
      i[s][s - 1] = 1 / (this.xs[s] - this.xs[s - 1]), i[s][s] = 2 * (1 / (this.xs[s] - this.xs[s - 1]) + 1 / (this.xs[s + 1] - this.xs[s])), i[s][s + 1] = 1 / (this.xs[s + 1] - this.xs[s]), i[s][n + 1] = 3 * ((this.ys[s] - this.ys[s - 1]) / ((this.xs[s] - this.xs[s - 1]) * (this.xs[s] - this.xs[s - 1])) + (this.ys[s + 1] - this.ys[s]) / ((this.xs[s + 1] - this.xs[s]) * (this.xs[s + 1] - this.xs[s])));
    return i[0][0] = 2 / (this.xs[1] - this.xs[0]), i[0][1] = 1 / (this.xs[1] - this.xs[0]), i[0][n + 1] = 3 * (this.ys[1] - this.ys[0]) / ((this.xs[1] - this.xs[0]) * (this.xs[1] - this.xs[0])), i[n][n - 1] = 1 / (this.xs[n] - this.xs[n - 1]), i[n][n] = 2 / (this.xs[n] - this.xs[n - 1]), i[n][n + 1] = 3 * (this.ys[n] - this.ys[n - 1]) / ((this.xs[n] - this.xs[n - 1]) * (this.xs[n] - this.xs[n - 1])), ob(i, e);
  }
  /**
   * inspired by https://stackoverflow.com/a/40850313/4417327
   */
  getIndexBefore(e) {
    let n = 0, i = this.xs.length, s = 0;
    for (; n < i; )
      s = Math.floor((n + i) / 2), this.xs[s] < e && s !== n ? n = s : this.xs[s] >= e && s !== i ? i = s : i = n;
    return n === this.xs.length - 1 ? this.xs.length - 1 : n + 1;
  }
  at(e) {
    let n = this.getIndexBefore(e);
    const i = (e - this.xs[n - 1]) / (this.xs[n] - this.xs[n - 1]), s = this.ks[n - 1] * (this.xs[n] - this.xs[n - 1]) - (this.ys[n] - this.ys[n - 1]), o = -this.ks[n] * (this.xs[n] - this.xs[n - 1]) + (this.ys[n] - this.ys[n - 1]);
    return (1 - i) * this.ys[n - 1] + i * this.ys[n] + i * (1 - i) * (s * (1 - i) + o * i);
  }
}
function ob(r, e) {
  const n = r.length;
  let i = 0, s = 0;
  for (; i < n && s <= n; ) {
    let a = 0, h = -1 / 0;
    for (let c = i; c < n; c++) {
      const l = Math.abs(r[c][s]);
      l > h && (a = c, h = l);
    }
    if (r[a][s] === 0)
      s++;
    else {
      hb(r, i, a);
      for (let c = i + 1; c < n; c++) {
        const l = r[c][s] / r[i][s];
        r[c][s] = 0;
        for (let u = s + 1; u <= n; u++) r[c][u] -= r[i][u] * l;
      }
      i++, s++;
    }
  }
  for (let a = n - 1; a >= 0; a--) {
    var o = 0;
    r[a][a] && (o = r[a][n] / r[a][a]), e[a] = o;
    for (let h = a - 1; h >= 0; h--)
      r[h][n] -= r[h][a] * o, r[h][a] = 0;
  }
  return e;
}
function ab(r, e) {
  const n = [];
  for (let i = 0; i < r; i++) n.push(new Float64Array(e));
  return n;
}
function hb(r, e, n) {
  let i = r[e];
  r[e] = r[n], r[n] = i;
}
class mu {
  length = 0;
  advance = 1;
  _currentIndex = 0;
  data = [];
  constructor(e, n = e.length, i = !1, s = 0) {
    this.data = e, this.length = n, this.advance = i ? -1 : 1, this._currentIndex = Math.floor(s) % n;
  }
  get current() {
    return this.data[this._currentIndex];
  }
  get(e = 0) {
    const n = (this._currentIndex + e * this.advance) % this.length;
    return this.data[n];
  }
  next(e = 0) {
    return this._currentIndex = (this._currentIndex + this.advance + e * this.advance) % this.length, this.current;
  }
}
class cb extends mu {
  constructor(e, n = !1, i = 0) {
    super([
      O.create(e.cx, e.top),
      O.create(e.right, e.cy),
      O.create(e.cx, e.bottom),
      O.create(e.left, e.cy)
    ], 4, n, i);
  }
}
class uc extends mu {
  constructor(e, n = !1, i = 0) {
    super([
      O.create(e.left, e.top),
      O.create(e.right, e.top),
      O.create(e.right, e.bottom),
      O.create(e.left, e.bottom)
    ], 4, n, i);
  }
}
class oi {
  static default() {
    return this.fromLTRB(0, 0, 0, 0);
  }
  static from(e, n) {
    return this.fromXYWH(e.x, e.x, n.width, n.height);
  }
  static fromXYWH(e, n, i, s) {
    return new oi(e, n, e + i, n + s);
  }
  static fromLTRB(e, n, i, s) {
    return new oi(e, n, i, s);
  }
  left = 0;
  top = 0;
  right = 0;
  bottom = 0;
  constructor(e = 0, n = 0, i = 0, s = 0) {
    this.left = e, this.top = n, this.right = i, this.bottom = s;
  }
  get x() {
    return this.left;
  }
  get y() {
    return this.top;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  get halfWidth() {
    return this.width * 0.5;
  }
  get halfHeight() {
    return this.height * 0.5;
  }
  get cx() {
    return (this.left + this.right) / 2;
  }
  get cy() {
    return (this.top + this.bottom) / 2;
  }
  isEmpty() {
    return !(this.left < this.right && this.top < this.bottom);
  }
  copy(e) {
    return this.left = e.left, this.top = e.top, this.right = e.right, this.bottom = e.bottom, this;
  }
  clone() {
    return new oi(this.left, this.top, this.right, this.bottom);
  }
  offset(e, n) {
    return this.left += e, this.right += e, this.top += n, this.bottom += n, this;
  }
  isSorted() {
    return this.left <= this.right && this.top <= this.bottom;
  }
  isFinite() {
    let e = 0;
    return e *= this.left, e *= this.top, e *= this.right, e *= this.bottom, Number.isFinite(e);
  }
  makeSorted() {
    const e = this.left, n = this.right, i = this.top, s = this.bottom;
    return oi.fromLTRB(
      Math.min(e, n),
      Math.min(i, s),
      Math.max(e, n),
      Math.max(i, s)
    );
  }
}
class lb extends mu {
  constructor(e, n = !1, i = 0) {
    super([], 8, n, i);
    const s = e.getBounds(), o = s.left, a = s.top, h = s.right, c = s.bottom, l = [];
    l[0] = O.create(o + e.radii(mn.kUpperLeft_Corner).x, a), l[1] = O.create(h - e.radii(mn.kUpperRight_Corner).x, a), l[2] = O.create(h, a + e.radii(mn.kUpperRight_Corner).y), l[3] = O.create(h, c - e.radii(mn.kLowerRight_Corner).y), l[4] = O.create(h - e.radii(mn.kLowerRight_Corner).x, c), l[5] = O.create(o + e.radii(mn.kLowerLeft_Corner).x, c), l[6] = O.create(o, c - e.radii(mn.kLowerLeft_Corner).y), l[7] = O.create(o, a + e.radii(mn.kUpperLeft_Corner).y), this.data = l;
  }
}
function ed(r) {
  let e = !0;
  for (let n = 0; n < 4; ++n)
    r[n].x <= 0 || r[n].y <= 0 ? (r[n].x = 0, r[n].y = 0) : e = !1;
  return e;
}
function Ko(r, e, n, i) {
  return r + e > n ? Math.min(i, n / (r + e)) : i;
}
function ta(r, e, n) {
  r[n] + e[n] == r[n] ? e[n] = 0 : r[n] + e[n] == e[n] && (r[n] = 0);
}
function ub(r, e) {
  if (r === e) return r;
  const n = r > e ? -1 : 1, i = Number.EPSILON * Math.abs(r) || Number.MIN_VALUE;
  return r + n * i;
}
function ea(r, e, n, i, s) {
  if (n[s] = n[s] * e, i[s] = i[s] * e, n[s] + i[s] > r) {
    let o = n, a = i;
    o[s] > a[s] && ([a, o] = [o, a]);
    let h = o[s], c = r - h;
    for (; c + h > r; )
      c = ub(c, 0);
    a[s] = c;
  }
}
function nd(r) {
  return r[
    0
    /* kUpperLeft_Corner */
  ].x == r[
    3
    /* kLowerLeft_Corner */
  ].x && r[
    0
    /* kUpperLeft_Corner */
  ].y == r[
    1
    /* kUpperRight_Corner */
  ].y && r[
    1
    /* kUpperRight_Corner */
  ].x == r[
    2
    /* kLowerRight_Corner */
  ].x && r[
    3
    /* kLowerLeft_Corner */
  ].y == r[
    2
    /* kLowerRight_Corner */
  ].y;
}
function id(r, e, n) {
  return e <= n && r <= n - e && e + r <= n && n - r >= e && r >= 0;
}
class mn {
  static default() {
    return new mn();
  }
  static fromRect(e) {
    return this.default().setRect(e);
  }
  static fromOval(e) {
    return this.default().setOval(e);
  }
  static kUpperLeft_Corner = 0;
  static kUpperRight_Corner = 1;
  static kLowerRight_Corner = 2;
  static kLowerLeft_Corner = 3;
  type = 0;
  _rect = oi.default();
  _radii = [O.default(), O.default(), O.default(), O.default()];
  radii(e) {
    return this._radii[e];
  }
  getType() {
    return this.type;
  }
  getBounds() {
    return this._rect;
  }
  isEmpty() {
    return this.type == 0;
  }
  isOval() {
    return this.type == 2;
  }
  isRect() {
    return this.type == 1;
  }
  resetRadii() {
    this._radii.forEach((e) => {
      e.setXY(0, 0);
    });
  }
  copyDadii(e) {
    e.forEach((n, i) => {
      this._radii[i].copy(n);
    });
  }
  scaleRadii() {
    let e = 1, n = this._rect, i = this._radii, s = n.right - n.left, o = n.bottom - n.top;
    return e = Ko(i[0].x, i[1].x, s, e), e = Ko(i[1].y, i[2].y, o, e), e = Ko(i[2].x, i[3].x, s, e), e = Ko(i[3].y, i[0].y, o, e), ta(i[0], i[1], 0), ta(i[1], i[2], 1), ta(i[2], i[3], 0), ta(i[3], i[0], 1), e < 1 && (ea(s, e, i[0], i[1], 0), ea(o, e, i[1], i[2], 1), ea(s, e, i[2], i[3], 0), ea(o, e, i[3], i[0], 1)), ed(i), this.computeType(), e < 1;
  }
  initializeRect(e) {
    return e.isFinite() ? (this._rect = e.makeSorted(), this._rect.isEmpty() ? (this.resetRadii(), this.type = 0, !1) : !0) : (this._rect = oi.default(), !1);
  }
  /**
   * 
   * @param rect 
   * @param radii [topLeft, topRight, bottomRight, bottomLeft] 
   */
  setRectRadii(e, n) {
    if (this.initializeRect(e)) {
      if (n.every((i) => i.x == 0)) {
        this.setRect(e);
        return;
      }
      if (this.copyDadii(n), ed(this._radii)) {
        this.setRect(e);
        return;
      }
      this.scaleRadii(), this.isValid() || this.setRect(e);
    }
  }
  setRect(e) {
    return this._rect.copy(e), this.resetRadii(), this.type = 1, this;
  }
  setOval(e) {
    if (e.isEmpty() || !e.isFinite())
      return;
    this._rect.copy(e.makeSorted());
    let n = this._rect.halfWidth, i = this._rect.halfHeight;
    if (n == 0 || i == 0)
      this.resetRadii(), this.type = 1;
    else {
      for (let s = 0; s < 4; ++s)
        this._radii[s].setXY(n, i);
      this.type = 2;
    }
  }
  get width() {
    return this._rect.width;
  }
  get height() {
    return this._rect.height;
  }
  computeType() {
    if (this._rect.isEmpty()) {
      this.type = 0;
      return;
    }
    let e = this._radii, n = this._rect, i = !0, s = e[0].x == 0 || e[0].y == 0;
    for (let o = 1; o < 4; ++o)
      e[o].x != 0 && e[o].y != 0 && (s = !1), (e[o].x != e[o - 1].x || e[o].y != e[o - 1].y) && (i = !1);
    if (s) {
      this.type = 1;
      return;
    }
    if (i) {
      e[0].x >= n.halfWidth && e[0].y >= n.halfHeight ? this.type = 2 : this.type = 3;
      return;
    }
    nd(e) ? this.type = 4 : this.type = 5, this.isValid() || this.setRect(this._rect);
  }
  areRectAndRadiiValid(e, n) {
    if (!e.isFinite() || !e.isSorted())
      return !1;
    for (let i = 0; i < 4; ++i)
      if (!id(n[i].x, e.left, e.right) || !id(n[i].y, e.top, e.bottom))
        return !1;
    return !0;
  }
  isValid() {
    let e = this.type, n = this._rect, i = this._radii;
    if (!this.areRectAndRadiiValid(n, i))
      return !1;
    let s = i[0].x == 0 && i[0].y == 0, o = i[0].x == 0 || i[0].y == 0, a = !0;
    for (let c = 1; c < 4; ++c)
      (i[c].x != 0 || i[c].y != 0) && (s = !1), (i[c].x != i[c - 1].x || i[c].y != i[c - 1].y) && (a = !1), i[c].x != 0 && i[c].y != 0 && (o = !1);
    let h = nd(i);
    if (e < 0 || e > 5)
      return !1;
    switch (e) {
      case 0:
        if (!n.isEmpty() || !s || !a || !o)
          return !1;
        break;
      case 1:
        if (n.isEmpty() || !s || !a || !o)
          return !1;
        break;
      case 2:
        if (n.isEmpty() || s || !a || o)
          return !1;
        for (let c = 0; c < 4; ++c)
          if (!(Math.abs(i[c].x - n.halfWidth) <= 1e-6) || !(Math.abs(i[c].y - n.halfHeight) <= 1e-6))
            return !1;
        break;
      case 3:
        if (n.isEmpty() || s || !a || o)
          return !1;
        break;
      case 4:
        if (n.isEmpty() || s || a || o || !h)
          return !1;
        break;
      case 5:
        if (n.isEmpty() || s || a || o || h)
          return !1;
        break;
    }
    return !0;
  }
}
function fb(r) {
  let e = { tl: 0, tr: 0, br: 0, bl: 0 };
  return typeof r == "number" ? e = { tl: r, tr: r, br: r, bl: r } : Array.isArray(r) ? r.length === 1 ? e = { tl: r[0], tr: r[0], br: r[0], bl: r[0] } : r.length === 2 ? e = { tl: r[0], tr: r[1], br: r[0], bl: r[1] } : r.length === 3 ? e = { tl: r[0], tr: r[1], br: r[2], bl: r[1] } : r.length === 4 && (e = { tl: r[0], tr: r[1], br: r[2], bl: r[3] }) : r && (e.tl = r.x ?? 0, e.tr = r.y ?? 0, e.bl = r.z ?? 0, e.br = r.w ?? 0), e;
}
function sd(r) {
  return r !== null && typeof r == "object" && ("x" in r || "y" in r) && (typeof r.x == "number" || typeof r.y == "number" || typeof r.x > "u" || typeof r.y > "u");
}
function db(r) {
  return typeof r == "number" ? { x: r, y: r } : {
    x: typeof r.x == "number" ? r.x : 0,
    y: typeof r.y == "number" ? r.y : 0
  };
}
function pb(r, e, n, i, s = 0) {
  if (typeof s == "number")
    s = [s];
  else if (sd(s))
    s = [s];
  else if (!Array.isArray(s))
    return;
  if (Array.isArray(s)) {
    if (s.length === 0 || s.length > 4)
      throw new RangeError(
        `Failed to execute 'roundRect' on '${this.constructor.name}': ${s.length} radii provided. Between one and four radii are necessary.`
      );
    s.forEach((d) => {
      if (sd(d)) {
        const p = d;
        if (typeof p.x == "number" && p.x < 0)
          throw new RangeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${p.x} is negative.`
          );
        if (typeof p.y == "number" && p.y < 0)
          throw new RangeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${p.y} is negative.`
          );
      } else {
        if (typeof d != "number")
          throw new TypeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${d} is not a number or DOMPointInit.`
          );
        if (typeof d == "number" && d < 0)
          throw new RangeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${d} is negative.`
          );
      }
    });
  }
  const o = s.map(db);
  if (s.length === 1 && o[0].x === 0 && o[0].y === 0) {
    this.rect(r, e, n, i);
    return;
  }
  const a = n / 2, h = i / 2, c = {
    x: Math.min(a, o[0].x),
    y: Math.min(h, o[0].y)
  };
  let l = c, u = c, f = c;
  o.length === 2 && (l = { x: Math.min(a, o[1].x), y: Math.min(h, o[1].y) }, f = l), o.length === 3 && (l = { x: Math.min(a, o[1].x), y: Math.min(h, o[1].y) }, f = l, u = { x: Math.min(a, o[2].x), y: Math.min(h, o[2].y) }), o.length === 4 && (l = { x: Math.min(a, o[1].x), y: Math.min(h, o[1].y) }, u = { x: Math.min(a, o[2].x), y: Math.min(h, o[2].y) }, f = { x: Math.min(a, o[3].x), y: Math.min(h, o[3].y) }), this.moveTo(r, e + i - f.y), c.x === c.y && c.x > 0 ? this.arcTo(r, e, r + c.x, e, c.x) : c.x > 0 || c.y > 0 ? this.ellipse(r + c.x, e + c.y, c.x, c.y, 0, Math.PI, Math.PI * 1.5, !1) : this.lineTo(r, e), this.lineTo(r + n - l.x, e), l.x === l.y && l.x > 0 ? this.arcTo(r + n, e, r + n, e + l.y, l.x) : l.x > 0 || l.y > 0 ? this.ellipse(r + n - l.x, e + l.y, l.x, l.y, 0, Math.PI * 1.5, 0, !1) : this.lineTo(r + n, e), this.lineTo(r + n, e + i - u.y), u.x === u.y && u.x > 0 ? this.arcTo(r + n, e + i, r + n - u.x, e + i, u.x) : u.x > 0 || u.y > 0 ? this.ellipse(r + n - u.x, e + i - u.y, u.x, u.y, 0, 0, Math.PI * 0.5, !1) : this.lineTo(r + n, e + i), this.lineTo(r + f.x, e + i), f.x === f.y && f.x > 0 ? this.arcTo(r, e + i, r, e + i - f.y, f.x) : f.x > 0 || f.y > 0 ? this.ellipse(r + f.x, e + i - f.y, f.x, f.y, 0, Math.PI * 0.5, Math.PI, !1) : this.lineTo(r, e + i), this.closePath(), this.moveTo(r, e);
}
const rd = Math.PI * 2;
function od(r, e, n = !1) {
  const i = Math.PI * 2;
  let s = r % i;
  s <= 0 && (s += i);
  let o = s - r;
  return r = s, e += o, !n && e - r >= i ? e = r + i : n && r - e >= i ? e = r - i : !n && r > e ? e = r + (i - (r - e) % i) : n && r < e && (e = r - (i - (e - r) % i)), { startAngle: r, endAngle: e };
}
var ah = /* @__PURE__ */ ((r) => (r[r.CW = 0] = "CW", r[r.CCW = 1] = "CCW", r[r.Unknown = 2147483647] = "Unknown", r))(ah || {}), ie = /* @__PURE__ */ ((r) => (r[r.MoveTo = 0] = "MoveTo", r[r.LineTo = 1] = "LineTo", r[r.QuadCurveTo = 2] = "QuadCurveTo", r[r.CubicCurveTo = 3] = "CubicCurveTo", r[r.ConicTo = 4] = "ConicTo", r[r.Close = 5] = "Close", r))(ie || {}), k1 = /* @__PURE__ */ ((r) => (r[
  r.MoveTo = 0
  /* MoveTo */
] = "MoveTo", r[
  r.LineTo = 1
  /* LineTo */
] = "LineTo", r[
  r.QuadCurveTo = 2
  /* QuadCurveTo */
] = "QuadCurveTo", r[
  r.ConicTo = 4
  /* ConicTo */
] = "ConicTo", r[
  r.CubicCurveTo = 3
  /* CubicCurveTo */
] = "CubicCurveTo", r[
  r.Close = 5
  /* Close */
] = "Close", r[r.Done = 6] = "Done", r))(k1 || {}), R1 = /* @__PURE__ */ ((r) => (r[r.Line_SegmentMask = 1] = "Line_SegmentMask", r[r.Quad_SegmentMask = 2] = "Quad_SegmentMask", r[r.Conic_SegmentMask = 4] = "Conic_SegmentMask", r[r.Cubic_SegmentMask = 8] = "Cubic_SegmentMask", r))(R1 || {});
class _s {
  static default() {
    return new this();
  }
  static fromVectices(e) {
    const n = this.default();
    for (let i = 0; i < e.length; i += 2)
      i === 0 ? n.moveTo(e[i], e[i + 1]) : n.lineTo(e[i], e[i + 1]);
    return n;
  }
  static fromPoints(e) {
    const n = this.default();
    for (let i = 0; i < e.length; i++)
      i === 0 ? n.moveTo(e[i].x, e[i].y) : n.lineTo(e[i].x, e[i].y);
    return n;
  }
  points = [];
  verbs = [];
  _segmentMask = 1;
  _lastMovePointIndex = 0;
  _needMoveTo = !0;
  _bounds = null;
  reset() {
    return this._needMoveTo = !0, this.points.length = 0, this.verbs.length = 0, this._lastMovePointIndex = 0, this._bounds = null, this._segmentMask = 1, this;
  }
  clear() {
    return this.reset();
  }
  get isEmpty() {
    return this.verbs.length === 0;
  }
  get lastVerb() {
    return this.verbs[this.verbs.length - 1];
  }
  get lastPoint() {
    const e = this.points[this.points.length - 2] || 0, n = this.points[this.points.length - 1] || 0;
    return { x: e, y: n };
  }
  get length() {
    return this.points.length;
  }
  setLastPoint(e, n) {
    return this.isEmpty ? this.moveTo(e, n) : (this.points[this.length - 2] = e, this.points[this.length - 1] = n), this;
  }
  addPoint(e, n) {
    return this.points.push(e, n), this._bounds = null, this;
  }
  addVerb(e) {
    return this.verbs.push(e), this;
  }
  injectMoveToIfNeeded() {
    this._needMoveTo && (this.length <= 0 ? this.moveTo(0, 0) : this.moveTo(this.points[this.length - 2], this.points[this.length - 1]));
  }
  // contains(x: number, y: number) {
  //     return pointInPath(x, y, this, 0)
  // }
  moveTo(e, n) {
    return this._needMoveTo = !1, this.lastVerb === 0 ? (this.points[this._lastMovePointIndex] = e, this.points[this._lastMovePointIndex + 1] = n) : (this._lastMovePointIndex = this.points.length, this.addVerb(
      0
      /* MoveTo */
    ), this.addPoint(e, n)), this;
  }
  lineTo(e, n) {
    return this.injectMoveToIfNeeded(), this.addVerb(
      1
      /* LineTo */
    ), this._segmentMask |= 1, this.addPoint(e, n);
  }
  quadraticCurveTo(e, n, i, s) {
    return this.injectMoveToIfNeeded(), this.addVerb(
      2
      /* QuadCurveTo */
    ), this.addPoint(e, n), this._segmentMask |= 2, this.addPoint(i, s);
  }
  bezierCurveTo(e, n, i, s, o, a) {
    return this.cubicCurveTo(e, n, i, s, o, a);
  }
  cubicCurveTo(e, n, i, s, o, a) {
    return this.injectMoveToIfNeeded(), this.addVerb(
      3
      /* CubicCurveTo */
    ), this.addPoint(e, n), this.addPoint(i, s), this._segmentMask |= 8, this.addPoint(o, a);
  }
  conicTo(e, n, i, s, o) {
    const a = 4 * o / (3 * (o + 1)), h = this.lastPoint, c = h.x + (e - h.x) * a, l = h.y + (n - h.y) * a, u = i + (e - i) * a, f = s + (n - s) * a;
    return this.cubicCurveTo(c, l, u, f, i, s);
  }
  closePath() {
    return this.isEmpty || (this.lastVerb !== 5 && this.addVerb(
      5
      /* Close */
    ), this._needMoveTo = !0), this;
  }
  rect(e, n, i, s) {
    return this.moveTo(e, n), this.lineTo(e + i, n), this.lineTo(e + i, n + s), this.lineTo(e, n + s), this.closePath();
  }
  roundRect(e, n, i, s, o) {
    let a = fb(o);
    const h = [
      O.create(a.tl, a.tl),
      // 左上角 (x半径, y半径)
      O.create(a.tr, a.tr),
      // 右上角
      O.create(a.br, a.br),
      // 右下角
      O.create(a.bl, a.bl)
      // 左下角
    ];
    let c = mn.default();
    c.setRectRadii(oi.fromXYWH(e, n, i, s), h), this.addRRect(c);
  }
  /**
   * 
   * @param x 
   * @param y 
   * @param width 
   * @param height 
   * @param radius all-corners
      [all-corners]
      [top-left-and-bottom-right, top-right-and-bottom-left]
      [top-left, top-right-and-bottom-left, bottom-right]
      [top-left, top-right, bottom-right, bottom-left]
   */
  roundRect2(e, n, i, s, o = 0) {
    pb.call(this, e, n, i, s, o);
  }
  ellipse2(e, n, i, s, o = 0, a = 0, h = rd, c = !1) {
    ({ startAngle: a, endAngle: h } = od(a, h, c));
    let l = h - a, u = a;
    if (Math.abs(l - Math.PI * 2) <= 1e-6) {
      const f = l / 2;
      this.arcToOval(e, n, i, s, o, u, f, !0), this.arcToOval(e, n, i, s, o, u + f, f, !1);
    } else
      this.arcToOval(e, n, i, s, o, u, l, !0);
  }
  ellipse(e, n, i, s, o = 0, a = 0, h = rd, c = !1) {
    ({ startAngle: a, endAngle: h } = od(a, h, c));
    const l = h - a, u = f1(e, n, i, s, o, a);
    this.isEmpty ? this.moveTo(u.x, u.y) : this.lineTo(u.x, u.y);
    const f = Math.ceil(Math.abs(l) / (Math.PI / 2));
    let d = l / f, p = a;
    for (let y = 0; y < f; y++) {
      const x = p + d, m = lu(e, n, i, s, o, p, x);
      this.bezierCurveTo(m[2], m[3], m[4], m[5], m[6], m[7]), p = x;
    }
    return this;
  }
  ellipseArc(e, n, i, s, o, a, h, c, l) {
    Rh(e, n, i, s, o, a, h, c, l, (u, f, d, p, y, x, m, g, w) => {
      w === 0 && (this.isEmpty ? this.moveTo(u, f) : this.lineTo(u, f)), this.cubicCurveTo(d, p, y, x, m, g);
    });
  }
  arc(e, n, i, s, o, a = !1) {
    this.ellipse(e, n, i, i, 0, s, o, a);
  }
  arcTo(e, n, i, s, o) {
    if (this.injectMoveToIfNeeded(), o === 0) {
      this.lineTo(e, n);
      return;
    }
    const a = this.lastPoint, h = O.fromPoint(a), c = O.create(e, n), l = O.create(i, s);
    let u = c.clone().sub(h).normalize(), f = l.clone().sub(c).normalize(), d = u.dot(f), p = u.cross(f);
    if (!u.isFinite() || !f.isFinite() || Math.abs(p) <= 1e-6)
      return this.lineTo(e, n);
    let y = Math.abs(o * (1 - d) / p), x = c.clone().sub(u.mulScalar(y)), m = c.clone().add(f.mulScalar(y)), g = Math.sqrt(0.5 + d * 0.5);
    this.lineTo(x.x, x.y), this.conicTo(e, n, m.x, m.y, g);
  }
  arcTo2(e, n, i, s, o) {
    if (this.injectMoveToIfNeeded(), o === 0) {
      this.lineTo(e, n);
      return;
    }
    const a = this.lastPoint, h = O.fromPoint(a), c = O.create(e, n), l = O.create(i, s);
    let u = c.clone().sub(h).normalize(), f = l.clone().sub(c).normalize(), d = u.dot(f), p = u.cross(f);
    if (Math.abs(p) <= 1e-6) {
      this.lineTo(e, n);
      return;
    }
    let y = Math.abs(o * (1 - d) / p), x = c.clone().sub(u.mulScalar(y)), m = c.clone().add(f.mulScalar(y)), g = p > 0;
    this.lineTo(x.x, x.y), this.ellipseArc(x.x, x.y, m.x, m.y, o, o, 0, !1, g);
  }
  arcToOval(e, n, i, s, o, a, h, c = !1) {
    const { x1: l, y1: u, x2: f, y2: d, fa: p, fs: y } = l1(
      e,
      n,
      i,
      s,
      o,
      a,
      h
    );
    c && this.moveTo(l, u), this.ellipseArc(l, u, f, d, i, s, o, !!p, !!y);
  }
  addCircle(e, n, i, s = !1) {
    return i >= 0 && this.addOval(oi.fromLTRB(e - i, n - i, e + i, n + i), s), this;
  }
  addPolygon(e, n = !0) {
    if (e.length <= 0)
      return this;
    this.moveTo(e[0], e[1]);
    for (let i = 2; i < e.length; i += 2) {
      let s = e[i], o = e[i + 1];
      this.lineTo(s, o);
    }
    return n && this.closePath(), this;
  }
  addOval(e, n = !1, i = 1) {
    let s = new cb(e, n, i), o = new uc(e, n, i + (n ? 1 : 0)), a = Math.SQRT1_2;
    this.moveTo(s.current.x, s.current.y), o.next(), s.next();
    for (let h = 0; h < 4; ++h)
      this.conicTo(o.get(h).x, o.get(h).y, s.get(h).x, s.get(h).y, a);
    this.closePath();
  }
  addRect(e, n = !1, i = 0) {
    let s = new uc(e, n, i);
    return this.moveTo(s.get(0).x, s.get(0).y), this.lineTo(s.get(1).x, s.get(1).y), this.lineTo(s.get(2).x, s.get(2).y), this.lineTo(s.get(3).x, s.get(3).y), this.closePath();
  }
  addRRect(e, n = !1, i = n ? 7 : 6) {
    let s = e.getBounds();
    if (e.isRect() || e.isEmpty())
      this.addRect(s, n, (i + 1) / 2);
    else if (e.isOval())
      this.addOval(s, n, i / 2);
    else {
      const o = (i & 1) == +(n == !1);
      let a = Math.SQRT1_2, h = new lb(e, n, i);
      const c = i / 2 + (n ? 1 : 0);
      let l = new uc(s, n, c);
      if (this.moveTo(h.current.x, h.current.y), o) {
        for (let u = 0; u < 3; ++u)
          l.next(), h.next(), this.conicTo(l.current.x, l.current.y, h.current.x, h.current.y, a), h.next(), this.lineTo(h.current.x, h.current.y);
        l.next(), h.next(), this.conicTo(l.current.x, l.current.y, h.current.x, h.current.y, a);
      } else
        for (let u = 0; u < 4; ++u)
          h.next(), this.lineTo(h.current.x, h.current.y), l.next(), h.next(), this.conicTo(l.current.x, l.current.y, h.current.x, h.current.y, a);
      this.closePath();
    }
  }
  copy(e) {
    return this.points = e.points.slice(), this.verbs = e.verbs.slice(), this._lastMovePointIndex = e._lastMovePointIndex, this._needMoveTo = e._needMoveTo, this;
  }
  clone() {
    return _s.default().copy(this);
  }
  equals(e) {
    if (this.points.length !== e.points.length)
      return !1;
    for (let n = 0; n < this.points.length; n++) {
      const i = this.points[n], s = e.points[n];
      if (i !== s)
        return !1;
    }
    return !0;
  }
  transform(e) {
    for (let n = 0; n < this.points.length; n += 2) {
      const i = this.points[n], s = this.points[n + 1];
      this.points[n] = e[0] * i + e[2] * s + e[4], this.points[n + 1] = e[1] * i + e[3] * s + e[5];
    }
  }
  scaleRound(e, n) {
    for (let i = 0; i < this.points.length; i += 2) {
      const s = this.points[i], o = this.points[i + 1];
      this.points[i] = Math.round(s * e), this.points[i + 1] = Math.round(o * e);
    }
  }
  computeTightBounds() {
    if (this.isEmpty)
      return Ms.empty();
    if (this._segmentMask === 1)
      return this.getBounds();
    const e = Ms.default();
    return this.visit({
      moveTo: (n, i) => {
        e.expandByXY(n, i);
      },
      lineTo: (n, i, s, o) => {
        e.expandByXY(s, o);
      },
      quadraticCurveTo: (n, i, s, o, a, h) => {
        let c = gr.fromXY(n, i, s, o, a, h).getBoundingBox();
        e.expandByPoint(c.min), e.expandByPoint(c.max);
      },
      cubicCurveTo(n, i, s, o, a, h, c, l) {
        let u = ul.fromXY(n, i, s, o, a, h, c, l).getBoundingBox();
        e.expandByPoint(u.min), e.expandByPoint(u.max);
      }
    }), e;
  }
  fatten(e = 1) {
    const n = _s.default();
    return this.isEmpty || this.visit({
      moveTo: (i, s) => {
        n.moveTo(i, s);
      },
      lineTo: (i, s, o, a) => {
        n.lineTo(o, a);
      },
      quadraticCurveTo: (i, s, o, a, h, c) => {
        gr.fromXY(i, s, o, a, h, c).fatten(e).forEach((u) => {
          n.lineTo(u.x, u.y);
        });
      },
      cubicCurveTo: (i, s, o, a, h, c, l, u) => {
        ul.fromXY(i, s, o, a, h, c, l, u).fatten(e).forEach((d) => {
          n.lineTo(d.x, d.y);
        });
      },
      close: () => {
        n.closePath();
      }
    }), n;
  }
  toPolygons(e = !0, n = 1) {
    const i = [];
    let s = null;
    return this.fatten(n).visit({
      moveTo: (a, h) => {
        s !== null && i.push(s), s = [a, h];
      },
      lineTo: (a, h, c, l) => {
        s.push(c, l);
      },
      close: (a, h) => {
        e && (s.push(a, h), i.push(s), s = null);
      }
    }), s !== null && i.push(s), i;
  }
  getBounds() {
    return this._bounds || (this._bounds = Ms.default().setFromVertices(this.points)), this._bounds;
  }
  visit(e) {
    const n = this.points, i = this.verbs;
    let s = 0, o = { x: 0, y: 0 };
    for (let a = 0, h = 0, c = i.length; a < c; a++)
      switch (i[a]) {
        case 0:
          e.moveTo?.(n[h], n[h + 1]), o.x = n[h], o.y = n[h + 1], s = h, h += 2;
          break;
        case 1:
          e.lineTo?.(o.x, o.y, n[h], n[h + 1]), o.x = n[h], o.y = n[h + 1], h += 2;
          break;
        case 2:
          e.quadraticCurveTo?.(o.x, o.y, n[h], n[h + 1], n[h + 2], n[h + 3]), o.x = n[h + 2], o.y = n[h + 3], h += 4;
          break;
        case 3:
          e.cubicCurveTo?.(o.x, o.y, n[h], n[h + 1], n[h + 2], n[h + 3], n[h + 4], n[h + 5]), o.x = n[h + 4], o.y = n[h + 5], h += 6;
          break;
        case 5:
          e.close?.(n[s], n[s + 1], o.x, o.y);
          break;
      }
  }
  invertVisit(e) {
    const n = this.points, i = this.verbs;
    let s = 0, o = !0, a = !1, h = { x: 0, y: 0 };
    for (let c = i.length - 1, l = n.length; c >= 0; c--) {
      let u = i[c];
      switch (o && (l -= 2, o = !1, e.moveTo?.(n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1], s = l), u) {
        case 0:
          a && (e.close?.(n[s], n[s + 1], h.x, h.y), a = !1), o = !0;
          break;
        case 1:
          l -= 2, e.lineTo?.(h.x, h.y, n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1];
          break;
        case 2:
          l -= 4, e.quadraticCurveTo?.(h.x, h.y, n[l + 2], n[l + 3], n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1];
          break;
        case 3:
          l -= 6, e.cubicCurveTo?.(h.x, h.y, n[l + 4], n[l + 5], n[l + 2], n[l + 3], n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1];
          break;
        case 5:
          a = !0;
          break;
      }
    }
  }
  addPath(e, n) {
    return n && (e = e.clone(), e.transform(n)), this._segmentMask |= e._segmentMask, this._needMoveTo = e._needMoveTo, this._lastMovePointIndex = this.points.length + e._lastMovePointIndex, this.points = this.points.concat(e.points), this.verbs = this.verbs.concat(e.verbs), this;
  }
  addReversePath(e) {
    e.invertVisit({
      moveTo: (n, i) => {
        this.moveTo(n, i);
      },
      lineTo: (n, i, s, o) => {
        this.lineTo(s, o);
      },
      quadraticCurveTo: (n, i, s, o, a, h) => {
        this.quadraticCurveTo(s, o, a, h);
      },
      cubicCurveTo: (n, i, s, o, a, h, c, l) => {
        this.cubicCurveTo(s, o, a, h, c, l);
      },
      close: () => {
        this.closePath();
      }
    });
  }
  // ignore move
  reversePathTo(e) {
    e.isEmpty || e.invertVisit({
      moveTo: (n, i) => {
      },
      lineTo: (n, i, s, o) => {
        this.lineTo(s, o);
      },
      quadraticCurveTo: (n, i, s, o, a, h) => {
        this.quadraticCurveTo(s, o, a, h);
      },
      cubicCurveTo: (n, i, s, o, a, h, c, l) => {
        this.cubicCurveTo(s, o, a, h, c, l);
      },
      close: () => {
        this.closePath();
      }
    });
  }
  offset(e, n) {
    for (let i = 0; i < this.points.length; i += 2)
      this.points[i] += e, this.points[i + 1] += n;
  }
  /*** 
   * 判断从某个点开始，后面的路径是否为零长度
   * 如果与start点形成闭合路径则认为非零长度
  */
  isZeroLengthSincePoint(e) {
    let n = this.points.length / 2 - e;
    if (n < 2)
      return !0;
    let i = this.points[e * 2], s = this.points[e * 2 + 1];
    for (let o = 1; o < n; o++)
      if (!(i === this.points[e + o * 2] && s === this.points[e + o * 2 + 1]))
        return !1;
    return !0;
  }
  finish() {
    return this.isEmpty || this.verbs.length == 1 ? null : this;
  }
  toCanvas(e) {
    this.visit({
      moveTo: (n, i) => {
        e.moveTo(n, i);
      },
      lineTo: (n, i, s, o) => {
        e.lineTo(s, o);
      },
      quadraticCurveTo: (n, i, s, o, a, h) => {
        e.quadraticCurveTo(s, o, a, h);
      },
      cubicCurveTo: (n, i, s, o, a, h, c, l) => {
        e.bezierCurveTo(s, o, a, h, c, l);
      },
      close: () => {
        e.closePath();
      }
    });
  }
  toPath2D() {
    const e = new Path2D();
    return this.toCanvas(e), e;
  }
  toSvgPath() {
    let e = [];
    return this.visit({
      moveTo: (n, i) => {
        e.push(["M", n, i]);
      },
      lineTo: (n, i, s, o) => {
        e.push(["L", s, o]);
      },
      quadraticCurveTo: (n, i, s, o, a, h) => {
        e.push(["Q", s, o, a, h]);
      },
      cubicCurveTo: (n, i, s, o, a, h, c, l) => {
        e.push(["C", s, o, a, h, c, l]);
      },
      close: () => {
        e.push(["Z"]);
      }
    }), e.map((n) => n[0] + n.slice(1).join(" ")).join("");
  }
  toPoints() {
    const e = [];
    for (let n = 0; n < this.points.length; n += 2)
      e.push({ x: this.points[n], y: this.points[n + 1] });
    return e;
  }
}
const yb = 3402823466e29, gu = 1 / 4096, wu = Math.SQRT1_2;
function xb(r, e = 1e-6) {
  return Math.abs(r) <= e;
}
const ad = Math.PI, hd = 11920929e-14;
class bu {
  static from_points(e) {
    let n = e[0].clone(), i = e[1].clone(), s = e[2].clone(), o = wr(i.clone().sub(n)), a = s.clone().sub(wr(i)).add(n);
    return new this({
      a,
      b: o,
      c: n
    });
  }
  a = O.default();
  b = O.default();
  c = O.default();
  constructor(e) {
    e && Object.assign(this, e);
  }
  eval(e) {
    return O.default().copy(this.a).multiply(e).add(this.b).mul(e).add(this.c);
  }
}
class O1 {
  static from_points(e) {
    let n = e[0].clone(), i = e[1].clone(), s = e[2].clone(), o = e[3].clone(), a = O.splat(3);
    return new this({
      a: o.clone().add(i.clone().sub(s).mul(a)).sub(n),
      b: a.clone().mul(s.clone().sub(wr(i)).add(n)),
      c: a.clone().mul(i.clone().sub(n)),
      d: n.clone()
    });
  }
  a = O.default();
  b = O.default();
  c = O.default();
  d = O.default();
  constructor(e) {
    e && Object.assign(this, e);
  }
  eval(e) {
    return O.default().copy(this.a).multiply(e).add(this.b).mul(e).add(this.c).mul(e).add(this.d);
  }
}
function L1() {
  return new Array(3);
}
function mb(r, e, n) {
  let i = r[0].clone(), s = r[1].clone(), o = r[2].clone(), a = O.splat(e), h = ni(i, s, a), c = ni(s, o, a);
  n[0] = O.from(i), n[1] = O.from(h), n[2] = O.from(ni(h, c, a)), n[3] = O.from(c), n[4] = O.from(o);
}
function No(r, e, n, i) {
  if (r == 0) {
    let c = ro(-n, e);
    return c ? (i[0] = c, 1) : 0;
  }
  let s = e * e - 4 * r * n;
  if (s < 0)
    return 0;
  s = Math.sqrt(s);
  let o = s;
  if (!Number.isFinite(o))
    return 0;
  let a = e < 0 ? -(e - o) / 2 : -(e + o) / 2, h = 0;
  {
    let c = ro(a, r);
    c && (i[h] = c, h += 1);
  }
  {
    let c = ro(n, a);
    c && (i[h] = c, h += 1);
  }
  return h == 2 && (i[0] > i[1] ? [i[0], i[1]] = [i[1], i[0]] : i[0] == i[1] && (h -= 1)), h;
}
function fc(r, e, n) {
  let i = r[e];
  return r[e] = r[n], r[n] = i, r;
}
function vu(r, e, n) {
  let i = r[0].clone(), s = r[1].clone(), o = r[2].clone(), a = r[3].clone(), h = O.splat(e), c = ni(i, s, h), l = ni(s, o, h), u = ni(o, a, h), f = ni(c, l, h), d = ni(l, u, h), p = ni(f, d, h);
  n[0] = O.from(i), n[1] = O.from(c), n[2] = O.from(f), n[3] = O.from(p), n[4] = O.from(d), n[5] = O.from(u), n[6] = O.from(a);
}
function gb(r, e, n) {
  return ro(r - e, r - e - e + n);
}
function ro(r, e) {
  return r < 0 && (r = -r, e = -e), e == 0 || r == 0 || r >= e ? void 0 : r / e;
}
function ni(r, e, n) {
  return O.default().copy(r).add(e.clone().sub(r)).multiply(n);
}
function wr(r) {
  return O.default().copy(r).add(r);
}
function B1(r) {
  let e = r[1].x - r[0].x, n = r[1].y - r[0].y, i = r[0].x - r[1].x - r[1].x + r[2].x, s = r[0].y - r[1].y - r[1].y + r[2].y, o = -(e * i + n * s), a = i * i + s * s;
  if (a < 0 && (o = -o, a = -a), o <= 0)
    return 0;
  if (o >= a)
    return 1;
  let h = o / a;
  return (h < 0 || h > 1) && console.assert("值无效"), h;
}
class ds {
  static ZERO = 0;
  static ONE = 1;
  static new_clamped(e) {
    return Number.isFinite(e) ? Ce(e, 0, 1) : this.ZERO;
  }
}
function oo(r, e) {
  return O.from(bu.from_points(r).eval(O.splat(e)));
}
function F1(r, e) {
  if (e == ds.ZERO && r[0] == r[1] || e == ds.ONE && r[1] == r[2])
    return r[2].clone().sub(r[0]);
  let n = r[0].clone(), i = r[1].clone(), s = r[2].clone(), o = i.clone().sub(n), h = s.clone().sub(i).sub(o).clone().mul(O.splat(e)).add(o);
  return O.from(h).add(h);
}
function Mu(r, e) {
  let n = cd([r[0].x, r[1].x, r[2].x, r[3].x]), i = cd([r[0].y, r[1].y, r[2].y, r[3].y]);
  for (let o = 0; o < 4; o++)
    n[o] += i[o];
  let s = wb(n, e);
  return e.slice(0, s);
}
function cd(r) {
  let e = r[1] - r[0], n = r[2] - 2 * r[1] + r[0], i = r[3] + 3 * (r[1] - r[2]) - r[0];
  return [i * i, 3 * n * i, 2 * n * n + i * e, e * n];
}
function wb(r, e) {
  if (xb(r[0])) {
    let f = L1(), d = No(r[1], r[2], r[3], f);
    for (let p = 0; p < d; p++)
      e[p] = f[p];
    return d;
  }
  let n = 1 / r[0], i = r[1] * n, s = r[2] * n, o = r[3] * n, a = (i * i - s * 3) / 9, h = (2 * i * i * i - 9 * i * s + 27 * o) / 54, c = a * a * a, l = h * h - c, u = i / 3;
  if (l < 0) {
    let f = Math.acos(Ce(h / Math.sqrt(c), -1, 1)), d = -2 * Math.sqrt(a);
    return e[0] = ds.new_clamped(d * Math.cos(f / 3) - u), e[1] = ds.new_clamped(
      d * Math.cos((f + 2 * ad) / 3) - u
    ), e[2] = ds.new_clamped(
      d * Math.cos((f - 2 * ad) / 3) - u
    ), bb(e), vb(e);
  } else {
    let f = Math.abs(h) + Math.sqrt(l);
    return f = Mb(f), h > 0 && (f = -f), f != 0 && (f += a / f), e[0] = ds.new_clamped(f - u), 1;
  }
}
function bb(r) {
  r[0] > r[1] && fc(r, 0, 1), r[1] > r[2] && fc(r, 1, 2), r[0] > r[1] && fc(r, 0, 1);
}
function vb(r) {
  let e = 3;
  return r[1] == r[2] && (e = 2), r[0] == r[1] && (e = 1), e;
}
function Mb(r) {
  return Math.pow(r, 0.3333333);
}
function hh(r, e) {
  return O.from(O1.from_points(r).eval(O.splat(e)));
}
function N1(r, e) {
  if (e == 0 && r[0] == r[1] || e == 1 && r[2] == r[3]) {
    let n = e == 0 ? r[2].clone().sub(r[0]) : r[3].clone().sub(r[1]);
    return n.x == 0 && n.y == 0 && (n = r[3].clone().sub(r[0])), n;
  } else
    return q1(r, e);
}
function q1(r, e) {
  let n = r[0].clone(), i = r[1].clone(), s = r[2].clone(), o = r[3].clone(), a = new bu({
    a: o.clone().add(O.splat(3).mul(i.clone().sub(s))).sub(n),
    b: wr(s.clone().sub(wr(i)).add(n)),
    c: i.clone().sub(n)
  });
  return O.from(a.eval(O.splat(e)));
}
function _b(r, e, n, i, s) {
  let o = i - r + 3 * (e - n), a = 2 * (r - e - e + n), h = e - r;
  const c = No(o, a, h, s);
  return s.slice(0, c);
}
function D1(r, e) {
  let n = r[1].x - r[0].x, i = r[1].y - r[0].y, s = r[2].x - 2 * r[1].x + r[0].x, o = r[2].y - 2 * r[1].y + r[0].y, a = r[3].x + 3 * (r[1].x - r[2].x) - r[0].x, h = r[3].y + 3 * (r[1].y - r[2].y) - r[0].y, c = No(
    s * h - o * a,
    n * h - i * a,
    n * o - i * s,
    e
  );
  return e.slice(0, c);
}
function $1(r) {
  if (r[0].equals(r[1]) || r[2].equals(r[3]) || ld(r, 0, 2) || ld(r, 2, 0))
    return;
  let e = Array.from({ length: 3 }, () => ds.ZERO), n = Mu(r, e);
  for (let i of n) {
    if (0 >= i || i >= 1)
      continue;
    let o = q1(r, i).magnitudeSquared(), a = Sb(r);
    if (o < a)
      return Ce(i, hd, 1 - hd);
  }
}
function ld(r, e, n) {
  let i = r[n], s = r[n + 1].clone().sub(i), o = [0, 0];
  for (let a = 0; a < 2; a++) {
    let h = r[e + a].clone().sub(i);
    o[a] = s.clone().cross(h);
  }
  return o[0] * o[1] >= 0;
}
function Sb(r) {
  return (r[1].distanceSquared(r[0]) + r[2].distanceSquared(r[1]) + r[3].distanceSquared(r[2])) * 1e-8;
}
class vn {
  points = O.makeZeroArray(3);
  weight = 0;
  static default() {
    return new this();
  }
  static new(e, n, i, s) {
    const o = this.default();
    return o.points[0].copy(e), o.points[1].copy(n), o.points[2].copy(i), o.weight = s, o;
  }
  static from_points(e, n) {
    return this.new(e[0], e[1], e[2], n);
  }
  static build_unit_arc(e, n, i, s, o) {
    let a = e.dot(n), h = e.cross(n);
    if (Math.abs(h) <= gu && a > 0 && (h >= 0 && i == 0 || h <= 0 && i == 1))
      return;
    i == 1 && (h = -h);
    let l = 0;
    h == 0 ? l = 2 : a == 0 ? l = h > 0 ? 1 : 3 : (h < 0 && (l += 2), a < 0 != h < 0 && (l += 1));
    let u = [
      O.create(1, 0),
      O.create(1, 1),
      O.create(0, 1),
      O.create(-1, 1),
      O.create(-1, 0),
      O.create(-1, -1),
      O.create(0, -1),
      O.create(1, -1)
    ];
    const f = wu;
    let d = l;
    for (let g = 0; g < d; g++)
      o[g] = vn.new(u[g * 2], u[g * 2 + 1], u[g * 2 + 2], f);
    let p = O.create(a, h), y = u[l * 2], x = y.dot(p);
    if (x < 1) {
      let g = O.create(y.x + a, y.y + h), w = Math.sqrt((1 + x) / 2);
      g.setLength(1 / w), y.equalsEpsilon(g) || (o[d] = vn.new(y, g, p, w), d += 1);
    }
    let m = ue.fromSinCos(e.y, e.x);
    i == 1 && (m = m.preScale(1, -1)), s && m.premultiply(s);
    for (let g = 0; g < d; g++)
      m.mapPoints(o[g].points, o[g].points);
    if (d != 0) return o.slice(0, d);
  }
  constructor(e) {
    e && (this.points.forEach((n, i) => {
      e.points[i] && n.copy(e.points[i]);
    }), this.weight = e.weight);
  }
  compute_quad_pow2(e) {
    if (e < 0 || !Number.isFinite(e))
      return;
    const n = this;
    if (!n.points[0].isFinite() || !n.points[1].isFinite() || !n.points[2].isFinite())
      return;
    const i = 4;
    let s = n.weight - 1, o = s / (4 * (2 + s)), a = o * (n.points[0].x - 2 * n.points[1].x + n.points[2].x), h = o * (n.points[0].y - 2 * n.points[1].y + n.points[2].y), c = Math.sqrt(a * a + h * h), l = 0;
    for (let u = 0; u < i && !(c <= e); u++)
      c *= 0.25, l += 1;
    return Math.max(l, 1);
  }
  // Chop this conic into N quads, stored continuously in pts[], where
  // N = 1 << pow2. The amount of storage needed is (1 + 2 * N)
  chop_into_quads_pow2(e, n) {
    const i = this;
    n[0] = i.points[0], vl(i, n.slice(1), e);
    let o = 2 * (1 << e) + 1;
    if (n.slice(0, o).some((h) => !Number.isFinite(h)))
      for (let h = 0; h < o - 1; h++)
        this.points[h + 1] = this.points[1];
    return 1 << e;
  }
  chop() {
    const e = this;
    let n = O.splat(1 / (1 + e.weight)), i = Eb(e.weight), s = e.points[0].clone(), o = e.points[1].clone(), a = e.points[2].clone(), c = O.splat(e.weight).clone().mul(o), l = s.clone().add(wr(c)).add(a).multiply(n).mul(O.splat(0.5)), u = O.from(l);
    if (!u.isFinite()) {
      let f = e.weight, d = f * 2, p = 1 / (1 + f) * 0.5;
      u.x = (e.points[0].x + d * e.points[1].x + e.points[2].x) * p, u.y = (e.points[0].y + d * e.points[1].y + e.points[2].y) * p;
    }
    return [
      new vn({
        points: [e.points[0], O.from(s.clone().add(c).mul(n)), u],
        weight: i
      }),
      new vn({
        points: [u, O.from(c.clone().add(a).mul(n)), e.points[2]],
        weight: i
      })
    ];
  }
}
function Tb(r, e, n, i, s) {
  let o = r.dot(e), a = r.cross(e);
  if (Math.abs(a) <= gu && o > 0 && (a >= 0 && n == 0 || a <= 0 && n == 1))
    return;
  n == 1 && (a = -a);
  let c = 0;
  a == 0 ? c = 2 : o == 0 ? c = a > 0 ? 1 : 3 : (a < 0 && (c += 2), o < 0 != a < 0 && (c += 1));
  let l = [
    O.create(1, 0),
    O.create(1, 1),
    O.create(0, 1),
    O.create(-1, 1),
    O.create(-1, 0),
    O.create(-1, -1),
    O.create(0, -1),
    O.create(1, -1)
  ];
  const u = wu;
  let f = c;
  for (let m = 0; m < f; m++)
    s[m] = vn.from_points(l.slice(m * 2), u);
  let d = O.create(o, a), p = l[c * 2], y = p.dot(d);
  if (y < 1) {
    let m = O.create(p.x + o, p.y + a), g = Math.sqrt((1 + y) / 2);
    m.setLength(1 / g), p.equalsEpsilon(m) || (s[f] = vn.new(p, m, d, g), f += 1);
  }
  let x = ue.fromSinCos(r.y, r.x);
  if (n == 1 && (x = x.preScale(1, -1)), x = x.premultiply(i), s.slice(f).forEach((m, g) => {
    x.mapPoints(m.points, m.points);
  }), f != 0)
    return s.slice(0, f);
}
function Eb(r) {
  return Math.sqrt(0.5 + r * 0.5);
}
function vl(r, e, n) {
  if (n == 0)
    return e[0] = r.points[1], e[1] = r.points[2], e.slice(2);
  {
    let i = r.chop(), s = r.points[0].y, o = r.points[2].y;
    if (na(s, r.points[1].y, o)) {
      let a = i[0].points[2].y;
      if (!na(s, a, o)) {
        let h = Math.abs(a - s) < Math.abs(a - o) ? s : o;
        i[0].points[2].y = h, i[1].points[0].y = h;
      }
      na(s, i[0].points[1].y, i[0].points[2].y) || (i[0].points[1].y = s), na(i[1].points[0].y, i[1].points[1].y, o) || (i[1].points[1].y = o);
    }
    return n -= 1, e = vl(i[0], e, n), vl(i[1], e, n);
  }
}
function na(r, e, n) {
  return (r - e) * (n - e) <= 0;
}
class zb {
  points = [];
  len = 0;
  static compute(e, n, i, s) {
    let o = vn.new(e, n, i, s), a = o.compute_quad_pow2(0.25);
    if (a === void 0)
      return;
    let h = Array.from({ length: 64 }, () => O.zero()), c = o.chop_into_quads_pow2(a, h);
    return new this({
      points: h,
      len: c
    });
  }
  constructor(e) {
    e && Object.assign(this, e);
  }
}
function Ab(r, e, n) {
  if (e.length <= 0)
    n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3];
  else {
    let i = e[0], s = O.makeZeroArray(4), o = 0;
    for (let a = 0; a < e.length; a++) {
      let h = [];
      vu(r, i, h);
      for (let l = 0; l < h.length; l++)
        n[o + l] = h[l];
      if (a == e.length - 1)
        break;
      o += 3, s[0] = n[o + 0], s[1] = n[o + 1], s[2] = n[o + 2], s[3] = n[o + 3], r = s;
      let c = ro(
        e[a + 1] - e[a],
        1 - e[a]
      );
      c !== void 0 ? i = c : (n[o + 4].copy(r[3]), n[o + 5].copy(r[3]), n[o + 6].copy(r[3]));
    }
  }
}
function ud(r, e = 1e-6) {
  return Math.abs(r) <= e;
}
var V1 = /* @__PURE__ */ ((r) => (r.Miter = "miter", r.Round = "round", r.Bevel = "bevel", r.MiterClip = "miter-clip", r))(V1 || {}), U1 = /* @__PURE__ */ ((r) => (r.Butt = "butt", r.Round = "round", r.Square = "square", r))(U1 || {}), W1 = /* @__PURE__ */ ((r) => (r.NonZero = "nonzero", r.EvenOdd = "evenodd", r))(W1 || {});
class Lh {
  isAutoClose = !1;
  path;
  verbIndex;
  pointsIndex;
  lastMoveTo = O.default();
  lastPoint = O.default();
  constructor(e) {
    this.isAutoClose = e.isAutoClose ?? !1, this.verbIndex = e.verbIndex, this.pointsIndex = e.pointsIndex, this.path = e.path, e.lastMoveTo && this.lastMoveTo.copy(e.lastMoveTo), e.lastPoint && this.lastPoint.copy(e.lastPoint);
  }
  get curVerb() {
    return this.path.verbs[this.verbIndex - 1];
  }
  get nextVerb() {
    return this.path.verbs[this.verbIndex];
  }
  copy(e) {
    return this.isAutoClose = e.isAutoClose, this.verbIndex = e.verbIndex, this.pointsIndex = e.pointsIndex, this.lastMoveTo.copy(e.lastMoveTo), this.lastPoint.copy(e.lastPoint), this;
  }
  clone() {
    return new Lh({
      isAutoClose: this.isAutoClose,
      path: this.path,
      verbIndex: this.verbIndex,
      pointsIndex: this.pointsIndex,
      lastMoveTo: this.lastMoveTo,
      lastPoint: this.lastPoint
    });
  }
  *[Symbol.iterator]() {
    const e = Array.from({ length: this.path.points.length / 2 }, (s, o) => O.create(this.path.points[o * 2], this.path.points[o * 2 + 1])), n = this.path.verbs;
    let i = null;
    for (; this.verbIndex < n.length; ) {
      const s = n[this.verbIndex++];
      switch (s) {
        case ie.MoveTo:
          this.pointsIndex += 1, i = e[this.pointsIndex - 1], this.lastMoveTo.copy(i), this.lastPoint.copy(this.lastMoveTo), yield { type: s, p0: e[this.pointsIndex - 1] };
          break;
        case ie.LineTo:
          this.pointsIndex += 1, this.lastPoint.copy(e[this.pointsIndex - 1]), yield { type: s, p0: e[this.pointsIndex - 1] };
          break;
        case ie.QuadCurveTo:
          this.pointsIndex += 2, this.lastPoint.copy(e[this.pointsIndex - 1]), yield { type: s, p0: e[this.pointsIndex - 3], p1: e[this.pointsIndex - 2], p2: e[this.pointsIndex - 1] };
          break;
        case ie.CubicCurveTo:
          this.pointsIndex += 3, this.lastPoint.copy(e[this.pointsIndex - 1]), yield { type: s, p0: e[this.pointsIndex - 4], p1: e[this.pointsIndex - 3], p2: e[this.pointsIndex - 2], p3: e[this.pointsIndex - 1] };
          break;
        case ie.Close:
          const o = this.autoClose();
          this.lastPoint.copy(this.lastMoveTo), yield o;
          break;
      }
    }
  }
  hasValidTangent() {
    let e = this.clone();
    for (let n of e)
      switch (n.type) {
        case ie.MoveTo:
          return !1;
        case ie.LineTo: {
          if (e.lastPoint.equals(n.p0))
            continue;
          return !0;
        }
        case ie.QuadCurveTo: {
          if (e.lastPoint.equals(n.p1) && e.lastPoint.equals(n.p2))
            continue;
          return !0;
        }
        case ie.CubicCurveTo: {
          if (e.lastPoint.equals(n.p1) && e.lastPoint.equals(n.p2) && e.lastPoint.equals(n.p3))
            continue;
          return !0;
        }
        case ie.Close:
          return !1;
      }
    return !1;
  }
  setAutoClose(e) {
    this.isAutoClose = e;
  }
  autoClose() {
    return this.isAutoClose && !this.lastPoint.equals(this.lastMoveTo) ? (this.verbIndex -= 1, {
      type: ie.LineTo,
      p0: this.lastMoveTo
    }) : {
      type: ie.Close,
      p0: this.lastPoint,
      p1: this.lastMoveTo
    };
  }
}
class Cb {
  constructor(e, n) {
    this.inner = e, this.outer = n;
  }
  swap() {
    [this.inner, this.outer] = [this.outer, this.inner];
  }
}
const Ml = 0.707106781, _l = (r, e, n, i, s) => {
  s.lineTo(n.x, n.y);
}, Pb = (r, e, n, i, s) => {
  let o = e.clone();
  o.cw();
  let a = r.clone().add(o), h = a.clone().add(e);
  s.conicTo(
    h.x,
    h.y,
    a.x,
    a.y,
    Ml
  ), h.copy(a).sub(e), s.conicTo(
    h.x,
    h.y,
    n.x,
    n.y,
    Ml
  );
}, Ib = (r, e, n, i, s) => {
  let o = e.clone();
  o.cw(), i ? (s.setLastPoint(
    r.x + e.x + o.x,
    r.y + e.y + o.y
  ), s.lineTo(
    r.x - e.x + o.x,
    r.y - e.y + o.y
  )) : (s.lineTo(
    r.x + e.x + o.x,
    r.y + e.y + o.y
  ), s.lineTo(
    r.x - e.x + o.x,
    r.y - e.y + o.y
  ), s.lineTo(n.x, n.y));
};
function fd(r) {
  return Math.abs(r) <= Su;
}
function j1(r) {
  return r >= 0 ? fd(1 - r) ? 3 : 2 : fd(1 + r) ? 0 : 1;
}
function _u(r, e) {
  return r.x * e.y > r.y * e.x;
}
function ch(r, e, n) {
  n.lineTo(r.x, r.y), n.lineTo(r.x - e.x, r.y - e.y);
}
const Y1 = (r, e, n, i, s, o, a, h, c) => {
  function l(w, M, S, E, A, I, b, v, _, z) {
    if (v = v.clone(), v.multiplyScalar(S), b = b.clone(), I = I.clone(), z) {
      b.normalize();
      let P = I.dot(b), k = I.cross(b), B = 0;
      Math.abs(k) <= Su ? B = 1 / _ : B = (1 / _ - P) / k, I.multiplyScalar(S);
      let R = I.clone();
      R.cw();
      let L = v.clone();
      L.ccw();
      let N = O.default();
      N.addVectors(M, I).add(R.clone().multiplyScalar(B));
      let q = O.default();
      N.addVectors(M, v).add(L.clone().multiplyScalar(B)), E ? w.outer.setLastPoint(N.x, N.y) : w.outer.lineTo(N.x, N.y), w.outer.lineTo(q.x, q.y);
    }
    A || w.outer.lineTo(M.x + v.x, M.y + v.y), ch(M, v, w.inner);
  }
  function u(w, M, S, E, A, I, b) {
    b = b.clone(), b.multiplyScalar(S), E ? w.outer.setLastPoint(M.x + I.x, M.y + I.y) : w.outer.lineTo(M.x + I.x, M.y + I.y), A || w.outer.lineTo(M.x + b.x, M.y + b.y), ch(M, b, w.inner);
  }
  let f = r.dot(n), d = j1(f), p = r.clone(), y = n.clone(), x = O.default();
  if (d == 3)
    return;
  if (d == 0) {
    h = !1, x.subVectors(y, p).multiplyScalar(i / 2), l(
      c,
      e,
      i,
      a,
      h,
      p,
      x,
      y,
      s,
      o
    );
    return;
  }
  let m = !_u(p, y);
  if (m && (c.swap(), p.negate(), y.negate()), f == 0 && s <= Ml) {
    x.addVectors(p, y).multiplyScalar(i), u(
      c,
      e,
      i,
      a,
      h,
      x,
      y
    );
    return;
  }
  d == 1 ? (x = O.create(y.y - p.y, p.x - y.x), m && x.negate()) : x = O.create(p.x + y.x, p.y + y.y);
  let g = Math.sqrt((1 + f) / 2);
  if (g < s) {
    h = !1, l(
      c,
      e,
      i,
      a,
      h,
      p,
      x,
      y,
      s,
      o
    );
    return;
  }
  x.setLength(i / g), u(
    c,
    e,
    i,
    a,
    h,
    x,
    y
  );
}, kb = (r, e, n, i, s, o, a, h) => {
  let c = n.clone().multiplyScalar(i);
  _u(r, n) || (h.swap(), c.negate()), h.outer.lineTo(e.x + c.x, e.y + c.y), ch(e, c, h.inner);
}, Rb = (r, e, n, i, s, o, a, h) => Y1(r, e, n, i, s, !1, o, a, h), Ob = (r, e, n, i, s, o, a, h) => {
  Y1(
    r,
    e,
    n,
    i,
    s,
    !0,
    o,
    a,
    h
  );
}, Sl = (r, e, n, i, s, o, a, h) => {
  let c = r.dot(n);
  if (j1(c) == 3)
    return;
  let u = r.clone(), f = n.clone(), d = ah.CW;
  _u(u, f) || (h.swap(), u.negate(), f.negate(), d = ah.CCW);
  let p = ue.fromRows(i, 0, 0, i, e.x, e.y), y = new Array(5).fill(0).map(() => new vn()), x = vn.build_unit_arc(u, f, d, p, y);
  if (x) {
    for (let m of x)
      h.outer.conicTo(
        m.points[1].x,
        m.points[1].y,
        m.points[2].x,
        m.points[2].y,
        m.weight
      );
    f.multiplyScalar(i), ch(e, f, h.inner);
  }
};
function dd(r, e, n, i, s, o) {
  return o.setLengthFromPoint((e.x - r.x) * n, (e.y - r.y) * n, 1) ? (o.ccw(), s.copy(o).multiplyScalar(i), !0) : !1;
}
function Lb(r, e, n, i) {
  return i.setLengthFromPoint(r.x, r.y, 1) ? (i.ccw(), n.copy(i).multiplyScalar(e), !0) : !1;
}
class ia {
  static default() {
    return new this();
  }
  // The state of the quad stroke under construction.
  quad = [O.default(), O.default(), O.default()];
  // the stroked quad parallel to the original curve
  tangent_start = O.default();
  // a point tangent to quad[0]
  tangent_end = O.default();
  // a point tangent to quad[2]
  start_t = 0;
  // a segment of the original curve
  mid_t = 0;
  end_t = 0;
  start_set = !1;
  // state to share common points across structs
  end_set = !1;
  opposite_tangents = !1;
  // set if coincident tangents have opposite directions
  init(e, n) {
    return this.start_t = e, this.mid_t = Math.min(1, Math.max(0, (e + n) / 2)), this.end_t = n, this.start_set = !1, this.end_set = !1, this.start_t < this.mid_t && this.mid_t < this.end_t;
  }
  initWithStart(e) {
    const n = this;
    return n.init(e.start_t, e.mid_t) ? (n.quad[0].copy(e.quad[0]), n.tangent_start.copy(e.tangent_start), n.start_set = !0, !0) : !1;
  }
  initWithEnd(e) {
    const n = this;
    return n.init(e.mid_t, e.end_t) ? (n.quad[2].copy(e.quad[2]), n.tangent_end.copy(e.tangent_end), n.end_set = !0, !0) : !1;
  }
}
function Bb(r) {
  let e = ai(r[1].clone().sub(r[0])), n = ai(r[2].clone().sub(r[1]));
  if (e & n)
    return [
      O.default(),
      0
      /* Point */
    ];
  if (e | n)
    return [
      O.default(),
      1
      /* Line */
    ];
  if (!Fb(r))
    return [
      O.default(),
      2
      /* Quad */
    ];
  let i = B1(r);
  if (i == 0 || i == 1)
    return [
      O.default(),
      1
      /* Line */
    ];
  let s = oo(r, i);
  return [
    O.create(s.x, s.y),
    3
    /* Degenerate */
  ];
}
function ai(r) {
  return +!r.canNormalize();
}
function Fb(r) {
  let e = -1, n = 0, i = 0;
  for (let h = 0; h < 2; h++)
    for (let c = h + 1; c < 3; c++) {
      let l = r[c].clone().sub(r[h]), u = Math.max(Math.abs(l.x), Math.abs(l.y));
      e < u && (n = h, i = c, e = u);
    }
  console.assert(n <= 1), console.assert(i >= 1 && i <= 2), console.assert(n < i);
  let s = n ^ i ^ 3, a = e * e * 5e-6;
  return pr(r[s], r[n], r[i]) <= a;
}
function pr(r, e, n) {
  let i = n.clone().sub(e), s = r.clone().sub(e), o = i.dot(s), a = i.dot(i), h = o / a;
  return h >= 0 && h <= 1 ? O.create(
    e.x * (1 - h) + n.x * h,
    e.y * (1 - h) + n.y * h
  ).distanceSquared(r) : r.distanceSquared(e);
}
function Nb(r, e, n) {
  let i = r[1].clone().sub(r[0]), s = [0, 0, 0];
  for (let l = 0; l < 3; l++)
    s[l] = (e[l].y - r[0].y) * i.x - (e[l].x - r[0].x) * i.y;
  let o = s[2], a = s[1], h = s[0];
  o += h - 2 * a, a -= h;
  let c = No(o, 2 * a, h, n);
  return n.slice(0, c);
}
function dc(r, e, n) {
  return r.distanceSquared(e) <= n * n;
}
function pd(r) {
  let e = r[1].clone().sub(r[0]), n = r[1].clone().sub(r[2]), i = e.magnitudeSquared(), s = n.magnitudeSquared();
  return i > s && ([e, n] = [n, e], s = i), e.setLength(s) ? e.dot(n) > 0 : !1;
}
function qb(r, e, n) {
  let i = Math.min(r[0].x, r[1].x, r[2].x);
  if (e.x + n < i)
    return !1;
  let s = Math.max(r[0].x, r[1].x, r[2].x);
  if (e.x - n > s)
    return !1;
  let o = Math.min(r[0].y, r[1].y, r[2].y);
  if (e.y + n < o)
    return !1;
  let a = Math.max(r[0].y, r[1].y, r[2].y);
  return !(e.y - n > a);
}
function Db(r, e, n) {
  let i = ai(r[1].clone().sub(r[0])), s = ai(r[2].clone().sub(r[1])), o = ai(r[3].clone().sub(r[2]));
  if (i & s & o)
    return 0;
  if (i + s + o == 2)
    return 1;
  if (!$b(r))
    return n && (i ? n.copy(r[2]) : n.copy(r[1])), 2;
  let a = [0, 0, 0];
  a = Mu(r, a);
  let h = 0;
  for (let c of a) {
    if (0 >= c || c >= 1)
      continue;
    let l = hh(r, c);
    e[h] = O.create(l.x, l.y), !e[h].equals(r[0]) && !e[h].equals(r[3]) && (h += 1);
  }
  switch (h) {
    case 0:
      return 1;
    case 1:
      return 1;
    case 2:
      return 4;
    case 3:
      return 5;
    default:
      return -1;
  }
}
function $b(r) {
  let e = -1, n = 0, i = 0;
  for (let h = 0; h < 3; h++)
    for (let c = h + 1; c < 4; c++) {
      let l = r[c].clone().sub(r[h]), u = Math.max(Math.abs(l.x), Math.abs(l.y));
      e < u && (n = h, i = c, e = u);
    }
  let s = 1 + (2 >> i) >> n, o = n ^ i ^ s, a = e * e * 1e-5;
  return pr(r[s], r[n], r[i]) <= a && pr(r[o], r[n], r[i]) <= a;
}
const Vb = {
  bevel: kb,
  miter: Rb,
  "miter-clip": Ob,
  round: Sl
}, Ub = {
  butt: _l,
  round: Pb,
  square: Ib
}, Wb = 3, yd = [15, 78, 33, 33], Su = 1 / 4096;
class jb {
  static computeResolutionScale(e) {
    let n = O.create(e.a, e.b).magnitude(), i = O.create(e.c, e.d).magnitude();
    if (Number.isFinite(n) && Number.isFinite(i)) {
      let s = Math.max(n, i);
      if (s > 0)
        return s;
    }
    return 1;
  }
  radius = 0;
  // 线段宽的一半
  inv_miter_limit = 0;
  // 1/miter_limit
  res_scale = 1;
  // 分辨率缩放因子
  inv_res_scale = 1;
  // 分辨率缩放因子的倒数
  inv_res_scale_squared = 1;
  // 分辨率缩放因子的倒数平方
  first_normal = O.default();
  // Move->LineTo 旋转-90法向量剩以radius
  prev_normal = O.default();
  // 上一个LineTo->lineTo点旋转-90法向量剩以radius
  first_unit_normal = O.default();
  // Move->LineTo 线段的，旋转-90度的单位法向量
  prev_unit_normal = O.default();
  // 上一个lineTo->LineTo点旋转-90度的单位法向量
  first_pt = O.default();
  // moveTo点
  prev_pt = O.default();
  // 上一个lineTo点
  first_outer_pt = O.default();
  // 第一个线段的外侧点
  first_outer_pt_index_in_contour = 0;
  // 第一个线段的外侧点在轮廓中的索引
  segment_count = -1;
  // 从MoveTo线段计数
  prev_is_line = !1;
  // 上一个绘制命令是否是lineTo
  capper;
  joiner;
  inner = _s.default();
  outer = _s.default();
  cusper = _s.default();
  stroke_type = 1;
  // 线段类型
  recursion_depth = 0;
  // 递归深度
  found_tangents = !1;
  // 是否找到切线
  join_completed = !1;
  // 是否完成连接
  get moveToPt() {
    return this.first_pt;
  }
  builders() {
    return new Cb(this.inner, this.outer);
  }
  close(e) {
    this.finishContour(!0, e);
  }
  moveTo(e) {
    this.segment_count > 0 && this.finishContour(!1, !1), this.segment_count = 0, this.first_pt.copy(e), this.prev_pt.copy(e), this.join_completed = !1;
  }
  finishContour(e, n) {
    const i = this;
    if (i.segment_count > 0) {
      if (e) {
        i.joiner(
          i.prev_unit_normal,
          i.prev_pt,
          i.first_unit_normal,
          i.radius,
          i.inv_miter_limit,
          i.prev_is_line,
          n,
          i.builders()
        ), i.outer.closePath();
        let s = i.inner.lastPoint ?? O.create(0, 0);
        i.outer.moveTo(s.x, s.y), i.outer.reversePathTo(i.inner), i.outer.closePath();
      } else {
        let s = i.inner.lastPoint ? O.fromPoint(i.inner.lastPoint) : O.create(0, 0), o = n ? i.inner : null;
        i.capper(
          i.prev_pt,
          i.prev_normal,
          s,
          o,
          i.outer
        ), i.outer.reversePathTo(i.inner), o = i.prev_is_line ? i.inner : null, i.capper(
          i.first_pt,
          i.first_normal.clone().negate(),
          i.first_outer_pt,
          o,
          i.outer
        ), i.outer.closePath();
      }
      i.cusper.isEmpty || (i.outer.addPath(i.cusper), i.cusper.clear());
    }
    i.inner.clear(), i.segment_count = -1, i.first_outer_pt_index_in_contour = i.outer.points.length;
  }
  preJoinTo(e, n, i, s) {
    const o = this;
    let a = o.prev_pt.x, h = o.prev_pt.y;
    if (!dd(
      o.prev_pt,
      e,
      o.res_scale,
      o.radius,
      i,
      s
    )) {
      if (o.capper === _l)
        return !1;
      i.set(o.radius, 0), s.set(1, 0);
    }
    return o.segment_count == 0 ? (o.first_normal.copy(i), o.first_unit_normal.copy(s), o.first_outer_pt = O.create(a + i.x, h + i.y), o.outer.moveTo(o.first_outer_pt.x, o.first_outer_pt.y), o.inner.moveTo(a - i.x, h - i.y)) : o.joiner(
      o.prev_unit_normal,
      o.prev_pt,
      s,
      o.radius,
      o.inv_miter_limit,
      o.prev_is_line,
      n,
      o.builders()
    ), o.prev_is_line = n, !0;
  }
  postJoinTo(e, n, i) {
    this.join_completed = !0, this.prev_pt.copy(e), this.prev_unit_normal.copy(i), this.prev_normal.copy(n), this.segment_count += 1;
  }
  initQuad(e, n, i, s) {
    this.stroke_type = e, this.found_tangents = !1, s.init(n, i);
  }
  quadStroke(e, n) {
    let i = this, s = i.compareQuadQuad(e, n);
    if (s == 2)
      return (i.stroke_type == 1 ? i.outer : i.inner).quadraticCurveTo(
        n.quad[1].x,
        n.quad[1].y,
        n.quad[2].x,
        n.quad[2].y
      ), !0;
    if (s == 1)
      return i.addDegenerateLine(n), !0;
    if (i.recursion_depth += 1, i.recursion_depth > yd[Wb])
      return !1;
    let o = ia.default();
    return o.initWithStart(n), !i.quadStroke(e, o) || (o.initWithEnd(n), !i.quadStroke(e, o)) ? !1 : (i.recursion_depth -= 1, !0);
  }
  compareQuadQuad(e, n) {
    const i = this;
    if (!n.start_set) {
      let h = O.zero();
      i.quadPerpRay(
        e,
        n.start_t,
        h,
        n.quad[0],
        n.tangent_start
      ), n.start_set = !0;
    }
    if (!n.end_set) {
      let h = O.zero();
      i.quadPerpRay(
        e,
        n.end_t,
        h,
        n.quad[2],
        n.tangent_end
      ), n.end_set = !0;
    }
    let s = i.intersectRay(0, n);
    if (s != 2)
      return s;
    let o = O.zero(), a = O.zero();
    return i.quadPerpRay(e, n.mid_t, a, o), i.strokeCloseEnough(n.quad.slice(), [o, a], n);
  }
  // Given a point on the curve and its derivative, scale the derivative by the radius, and
  // compute the perpendicular point and its tangent.
  setRayPoints(e, n, i, s) {
    const o = this;
    n.setLength(o.radius) || n.copy(O.create(o.radius, 0));
    let a = o.stroke_type;
    i.x = e.x + a * n.y, i.y = e.y - a * n.x, s && (s.x = i.x + n.x, s.y = i.y + n.y);
  }
  // Given a quad and t, return the point on curve,
  // its perpendicular, and the perpendicular tangent.
  quadPerpRay(e, n, i, s, o) {
    let a = this, h = oo(e, n);
    i.set(h.x, h.y), h = F1(e, n);
    let c = O.create(h.x, h.y);
    c.isZero() && (c = e[2].sub(e[0])), a.setRayPoints(i, c, s, o);
  }
  strokeCloseEnough(e, n, i) {
    const s = this;
    let a = oo(e, 0.5);
    if (dc(n[0], O.create(a.x, a.y), s.inv_res_scale))
      return pd(i.quad) ? 0 : 2;
    if (!qb(e, n[0], s.inv_res_scale))
      return 0;
    let h = new Array(3).fill(0.5);
    if (h = Nb(n, e, h), h.length != 1)
      return 0;
    let c = oo(e, h[0]), l = s.inv_res_scale * (1 - Math.abs(h[0] - 0.5) * 2);
    return dc(n[0], O.create(c.x, c.y), l) ? pd(i.quad) ? 0 : 2 : 0;
  }
  // Find the intersection of the stroke tangents to construct a stroke quad.
  // Return whether the stroke is a degenerate (a line), a quad, or must be split.
  // Optionally compute the quad's control point.
  intersectRay(e, n) {
    const i = this;
    let s = n.quad[0], o = n.quad[2], a = n.tangent_start.clone().sub(s), h = n.tangent_end.clone().sub(o), c = a.cross(h);
    if (c == 0 || !Number.isFinite(c))
      return n.opposite_tangents = a.dot(h) < 0, 1;
    n.opposite_tangents = !1;
    let l = s.clone().sub(o), u = h.cross(l), f = a.cross(l);
    if (u >= 0 == f >= 0) {
      let p = pr(s, o, n.tangent_end), y = pr(o, s, n.tangent_start);
      return Math.max(p, y) <= i.inv_res_scale_squared ? 1 : 0;
    }
    return u /= c, u > u - 1 ? (e == 0 && (n.quad[1].x = s.x * (1 - u) + n.tangent_start.x * u, n.quad[1].y = s.y * (1 - u) + n.tangent_start.y * u), 2) : (n.opposite_tangents = a.dot(h) < 0, 1);
  }
  addDegenerateLine(e) {
    const n = this;
    n.stroke_type == 1 ? n.outer.lineTo(e.quad[2].x, e.quad[2].y) : n.inner.lineTo(e.quad[2].x, e.quad[2].y);
  }
  setCubicEndNormal(e, n, i, s, o) {
    let a = this, h = e[1].clone().sub(e[0]), c = e[3].clone().sub(e[2]), l = ai(h), u = ai(c);
    if (l && u) {
      s.copy(n), o.copy(i);
      return;
    }
    if (l && (h = e[2].clone().sub(e[0]), l = ai(h)), u && (c = e[3].clone().sub(e[1]), u = ai(c)), l || u) {
      s.copy(n), o.copy(i);
      return;
    }
    return Lb(c, a.radius, s, o);
  }
  lineTo(e, n) {
    const i = this;
    let s = i.prev_pt.equalsEpsilon(e, Su * i.inv_res_scale);
    if (i.capper, _l && s || s && (i.join_completed || n && n.hasValidTangent()))
      return;
    let o = O.default(), a = O.default();
    i.preJoinTo(e, !0, o, a) && (i.outer.lineTo(e.x + o.x, e.y + o.y), i.inner.lineTo(e.x - o.x, e.y - o.y), i.postJoinTo(e, o, a));
  }
  quadraticCurveTo(e, n) {
    const i = this;
    let s = [i.prev_pt, e, n], [o, a] = Bb(s);
    if (a == 0) {
      i.lineTo(n);
      return;
    }
    if (a == 1) {
      i.lineTo(n);
      return;
    }
    if (a == 3) {
      i.lineTo(o);
      let p = i.joiner;
      i.joiner = Sl, i.lineTo(n), i.joiner = p;
      return;
    }
    let h = O.default(), c = O.default(), l = O.default(), u = O.default();
    if (!i.preJoinTo(e, !1, h, c)) {
      i.lineTo(n);
      return;
    }
    let f = ia.default();
    i.initQuad(
      1,
      0,
      1,
      f
    ), i.quadStroke(s, f), i.initQuad(
      -1,
      0,
      1,
      f
    ), i.quadStroke(s, f), dd(
      s[1],
      s[2],
      i.res_scale,
      i.radius,
      l,
      u
    ) || (l = h, u = c), i.postJoinTo(n, l, u);
  }
  bezierCurveTo(e, n, i) {
    const s = this;
    let o = [s.prev_pt, e, n, i], a = Array.from({ length: 3 }, () => O.zero()), h = O.zero(), c = Db(o, a, h);
    if (c == 0) {
      s.lineTo(i);
      return;
    }
    if (c == 1) {
      s.lineTo(i);
      return;
    }
    if (3 <= c && 5 >= c) {
      s.lineTo(a[0]);
      let m = s.joiner;
      s.joiner = Sl, 4 <= c && s.lineTo(a[1]), c == 5 && s.lineTo(a[2]), s.lineTo(i), s.joiner = m;
      return;
    }
    let l = O.zero(), u = O.zero(), f = O.zero(), d = O.zero();
    if (!s.preJoinTo(h, !1, l, u)) {
      s.lineTo(i);
      return;
    }
    let p = new Array(3).fill(0.5);
    p = D1(o, p);
    let y = 0;
    for (let m = 0, g = p.length; m <= g; m++) {
      let w = Number.isFinite(p[m]) ? p[m] : 1, M = ia.default();
      s.initQuad(1, y, w, M), s.cubicStroke(o, M), s.initQuad(-1, y, w, M), s.cubicStroke(o, M), y = w;
    }
    let x = $1(o);
    if (x) {
      let m = hh(o, x);
      s.cusper.addCircle(m.x, m.y, s.radius);
    }
    s.setCubicEndNormal(o, l, u, f, d), s.postJoinTo(i, f, d);
  }
  cubicStroke(e, n) {
    const i = this;
    if (!i.found_tangents) {
      let o = i.tangentsMeet(e, n);
      if (o != 2) {
        let a = dc(
          n.quad[0],
          n.quad[2],
          i.inv_res_scale
        );
        if ((o == 1 || a) && i.cubicMidOnLine(e, n))
          return i.addDegenerateLine(n), !0;
      } else
        i.found_tangents = !0;
    }
    if (i.found_tangents) {
      let o = i.compareQuadCubic(e, n);
      if (o == 2) {
        let a = n.quad;
        return i.stroke_type == 1 ? i.outer.quadraticCurveTo(a[1].x, a[1].y, a[2].x, a[2].y) : i.inner.quadraticCurveTo(a[1].x, a[1].y, a[2].x, a[2].y), !0;
      }
      if (o == 1 && !n.opposite_tangents)
        return i.addDegenerateLine(n), !0;
    }
    if (!Number.isFinite(n.quad[2].x) || !Number.isFinite(n.quad[2].x) || (i.recursion_depth += 1, i.recursion_depth > yd[Number(i.found_tangents)]))
      return !1;
    let s = ia.default();
    return s.initWithStart(n) ? i.cubicStroke(e, s) ? s.initWithEnd(n) ? i.cubicStroke(e, s) ? (i.recursion_depth -= 1, !0) : !1 : (i.addDegenerateLine(n), i.recursion_depth -= 1, !0) : !1 : (i.addDegenerateLine(n), i.recursion_depth -= 1, !0);
  }
  cubicMidOnLine(e, n) {
    let i = this, s = O.zero();
    return i.cubicQuadMid(e, n, s), pr(s, n.quad[0], n.quad[2]) < i.inv_res_scale_squared;
  }
  cubicQuadMid(e, n, i) {
    let s = O.zero();
    this.cubicPerpRay(e, n.mid_t, s, i);
  }
  compareQuadCubic(e, n) {
    let i = this;
    i.cubicQuadEnds(e, n);
    let s = i.intersectRay(0, n);
    if (s != 2)
      return s;
    let o = O.zero(), a = O.zero();
    return i.cubicPerpRay(e, n.mid_t, a, o), i.strokeCloseEnough(n.quad.slice(), [o, a], n);
  }
  // Given a cubic and a t range, find the start and end if they haven't been found already.
  cubicQuadEnds(e, n) {
    const i = this;
    if (!n.start_set) {
      let s = O.zero();
      i.cubicPerpRay(
        e,
        n.start_t,
        s,
        n.quad[0],
        n.tangent_start
      ), n.start_set = !0;
    }
    if (!n.end_set) {
      let s = O.zero();
      i.cubicPerpRay(
        e,
        n.end_t,
        s,
        n.quad[2],
        n.tangent_end
      ), n.end_set = !0;
    }
  }
  tangentsMeet(e, n) {
    return this.cubicQuadEnds(e, n), this.intersectRay(1, n);
  }
  // Given a cubic and t, return the point on curve,
  // its perpendicular, and the perpendicular tangent.
  cubicPerpRay(e, n, i, s, o) {
    let a = this;
    i.copy(hh(e, n));
    let h = N1(e, n), c = Array.from({ length: 7 }, () => O.zero());
    if (h.x == 0 && h.y == 0) {
      let l = e;
      ud(n) ? h = e[2].clone().sub(e[0]) : ud(1 - n) ? h = e[3].clone().sub(e[1]) : (vu(e, n, c), h = c[3].clone().sub(c[2]), h.x == 0 && h.y == 0 && (h = c[3].clone().sub(c[1]), l = c)), h.x == 0 && h.y == 0 && (h = l[3].clone().sub(l[0]));
    }
    a.setRayPoints(i, h, s, o);
  }
  stroke(e, n) {
    return this.strokeInner(e, n.strokeWidth, n.miterLimit, n.lineCap, n.lineJoin, this.res_scale);
  }
  strokeInner(e, n, i, s, o, a) {
    const h = this;
    let c = 0;
    o == "miter" && (i <= 1 ? o = "bevel" : c = 1 / i), o == "miter-clip" && (c = 1 / i), h.res_scale = a, h.inv_res_scale = 1 / (a * 4), h.inv_res_scale_squared = h.inv_res_scale ** 2, h.radius = n * 0.5, h.inv_miter_limit = c, h.first_normal = O.default(), h.prev_normal = O.default(), h.first_unit_normal = O.default(), h.prev_unit_normal = O.default(), h.first_pt = O.default(), h.prev_pt = O.default(), h.first_outer_pt = O.default(), h.first_outer_pt_index_in_contour = 0, h.segment_count = -1, h.prev_is_line = !1, h.capper = Ub[s], h.joiner = Vb[o], h.inner.clear(), h.outer.clear(), h.cusper.clear(), h.stroke_type = 1, h.recursion_depth = 0, h.found_tangents = !1, h.join_completed = !1;
    let l = !1, u = new Lh({
      path: e,
      verbIndex: 0,
      pointsIndex: 0,
      isAutoClose: !0
    });
    u.setAutoClose(!0);
    for (let f of u)
      switch (f.type) {
        case ie.MoveTo:
          h.moveTo(f.p0);
          break;
        case ie.LineTo:
          h.lineTo(f.p0, u), l = !0;
          break;
        case ie.QuadCurveTo:
          h.quadraticCurveTo(f.p1, f.p2), l = !1;
          break;
        case ie.CubicCurveTo:
          h.bezierCurveTo(f.p1, f.p2, f.p3), l = !1;
          break;
        case ie.Close:
          if (s != "butt") {
            if (h.hasOnlyMoveTo()) {
              h.lineTo(h.moveToPt), l = !0;
              continue;
            }
            if (h.isCurrentContourEmpty()) {
              l = !0;
              continue;
            }
          }
          h.close(l);
          break;
      }
    return h.finish(l);
  }
  finish(e) {
    return this.finishContour(!1, e), this.outer.clone();
  }
  hasOnlyMoveTo() {
    return this.segment_count == 0;
  }
  isCurrentContourEmpty() {
    return this.inner.isZeroLengthSincePoint(0) && this.outer.isZeroLengthSincePoint(this.first_outer_pt_index_in_contour);
  }
}
const Ei = {
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7,
  Z: 0
}, Yb = new Set(Object.keys(Ei).concat(Object.keys(Ei).map((r) => r.toLowerCase()))), Hb = /([mlhvaqtcsz])([^mlhvaqtcsz]+)?/gi, Xb = /-?\d*\.?\d+(e[-+]?\d+)?/gi;
function Tu(r, e, n) {
  return r >= e && r <= n;
}
function H1(r) {
  return Tu(r.charCodeAt(0), 1, 32);
}
function Wa(r) {
  return Tu(r.charCodeAt(0), 48, 57);
}
function X1(r) {
  return H1(r) || r === ",";
}
function Zb(r) {
  return Tu(r.charCodeAt(0), 97, 122);
}
function Gb(r) {
  return String.fromCharCode(r.charCodeAt(0) - 97 + 65);
}
function Eu(r) {
  let e = 0;
  for (; r.length > 0 && H1(r[e]); )
    e++;
  return r.slice(e);
}
function lh(r) {
  let e = 0;
  for (; r.length > 0 && X1(r[e]); )
    e++;
  return r.slice(e);
}
function Jb(r, e) {
  r = Eu(r);
  let n = 0;
  for (n < r.length && (r[n] === "+" || r[n] === "-") && n++; n < r.length && Wa(r[n]); )
    n++;
  if (n < r.length && r[n] === ".")
    for (n++; n < r.length && Wa(r[n]); )
      n++;
  if (n < r.length && (r[n] === "e" || r[n] === "E"))
    for (n++, n < r.length && (r[n] === "+" || r[n] === "-") && n++; n < r.length && Wa(r[n]); )
      n++;
  return n == 0 ? (e.value = r, 0) : (e.value = r.substring(n), Number(r.substring(0, n)));
}
function Z1(r, e) {
  r = Eu(r);
  let n = { value: "" }, i = Jb(r, n);
  return r == n.value ? "" : (e && (e.value = i), n.value);
}
function xd(r, e, n, i) {
  return r = Z1(r, e), r ? (n && (e.value += i), r = lh(r), r) : "";
}
function Qb(r, e, n) {
  if (n > 0) {
    let i = 0, s = { value: 0 };
    for (; r = Z1(r, s), e[i] = s.value, !(--n == 0 || r.length <= 0); )
      r = lh(r), i++;
  }
  return r;
}
function Bi(r, e, n, i, s) {
  if (r = Qb(r, e, n), i)
    for (let o = 0; o < n; o += 2)
      e[o] += s.x, e[o + 1] += s.y;
  return r;
}
function G1(r, e) {
  let n = 0, i = 0, s = 0, o = 0, a = 0, h = 0, c = 0, l = 0, u = "";
  for (let f = 0, d = e.length; f < d; f++) {
    const p = e[f];
    switch (p[0]) {
      case "M":
        r.moveTo(p[1], p[2]), n = p[1], i = p[2], s = n, o = i;
        break;
      case "L":
        r.lineTo(p[1], p[2]), n = p[1], i = p[2];
        break;
      case "H":
        r.lineTo(p[1], i), n = p[1];
        break;
      case "V":
        r.lineTo(n, p[1]), i = p[1];
        break;
      case "Q":
        r.quadraticCurveTo(p[1], p[2], p[3], p[4]), a = p[1], h = p[2], n = p[3], i = p[4];
        break;
      case "T":
        c = n, l = i, (u === "Q" || u === "T") && (c -= a - n, l -= h - i), r.quadraticCurveTo(c, l, p[1], p[2]), a = c, h = l, n = p[1], i = p[2];
        break;
      case "C":
        r.bezierCurveTo(p[1], p[2], p[3], p[4], p[5], p[6]), a = p[3], h = p[4], n = p[5], i = p[6];
        break;
      case "S":
        c = n, l = i, (u === "C" || u === "S") && (c -= a - n, l -= h - i), r.bezierCurveTo(c, l, p[1], p[2], p[3], p[4]), a = p[1], h = p[2], n = p[3], i = p[4];
        break;
      case "A":
        {
          let y = n, x = i, m = p[1], g = p[2], w = p[3], M = !!p[4], S = !!p[5], E = p[6], A = p[7], I = E, b = A;
          Rh(y, x, E, A, m, g, w, M, S, (v, _, z, P, k, B, R, L, N) => {
            r.bezierCurveTo(z, P, k, B, R, L), I = R, b = L;
          }), n = I, i = b;
        }
        break;
      case "Z":
        r.closePath(), n = s, i = o;
        break;
    }
    u = p[0];
  }
}
function Kb(r, e) {
  const n = Q1(e);
  G1(r, n);
}
function tv(r) {
  const e = r.match(Xb);
  return e ? e.map(Number) : [];
}
function J1(r) {
  const e = [], n = String(r).trim();
  return n[0] !== "M" && n[0] !== "m" || n.replace(Hb, (i, s, o) => {
    const a = tv(o);
    let h = s.toUpperCase(), c = s;
    if (h === "M" && a.length > 2 && (e.push([c, ...a.splice(0, 2)]), c = c === "m" ? "l" : "L"), a.length < Ei[h])
      return "";
    for (e.push([c, ...a.splice(0, Ei[h])]); a.length >= Ei[h] && a.length && Ei[h]; )
      e.push([c, ...a.splice(0, Ei[h])]);
    return "";
  }), e;
}
function Tl(r, e) {
  let n = { x: 0, y: 0 }, i = { x: 0, y: 0 }, s = { x: 0, y: 0 }, o = new Float32Array(7), a = { value: 0 }, h = "", c = "", l = !1;
  for (; e.length && (e = Eu(e), e[0] !== ""); ) {
    let u = e[0];
    if (Wa(u) || u === "-" || u === "+" || u === ".") {
      if (h == "" || h == "Z")
        return !1;
    } else X1(u) || (h = u, l = !1, Zb(u) && (l = !0, h = Gb(u)), e = e.substring(1)), e = lh(e);
    switch (h) {
      case "M":
        e = Bi(e, o, 2, l, i), r.moveTo(o[0], o[1]), c = "", h = "L", i.x = o[0], i.y = o[1];
        break;
      case "L":
        e = Bi(e, o, 2, l, i), r.lineTo(o[0], o[1]), i.x = o[0], i.y = o[1];
        break;
      case "H":
        e = xd(e, a, l, i.x), r.lineTo(a.value, i.y), i.x = a.value;
        break;
      case "V":
        e = xd(e, a, l, i.y), r.lineTo(i.x, a.value), i.y = a.value;
        break;
      case "C":
        e = Bi(e, o, 6, l, i), r.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]), s.x = o[2], s.y = o[3], i.x = o[4], i.y = o[5];
        break;
      case "S":
        e = Bi(e, o.subarray(2), 4, l, i), o[0] = i.x, o[1] = i.y, (c == "C" || c == "S") && (o[0] -= s.x - i.x, o[1] -= s.y - i.y), r.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]), s.x = o[2], s.y = o[3], i.x = o[4], i.y = o[5];
        break;
      case "Q":
        e = Bi(e, o, 4, l, i), r.quadraticCurveTo(o[0], o[1], o[2], o[3]), s.x = o[0], s.y = o[1], i.x = o[2], i.y = o[3];
        break;
      case "T":
        e = Bi(e, o.subarray(1), 2, l, i), o[0] = i.x, o[1] = i.y, (c == "Q" || c == "T") && (o[0] -= s.x - i.x, o[1] -= s.y - i.y), r.quadraticCurveTo(o[0], o[1], o[2], o[3]), s.x = o[0], s.y = o[1], i.x = o[2], i.y = o[3];
        break;
      case "A":
        e = Bi(e, o, 7, !1);
        let f = i.x, d = i.y, p = o[0], y = o[1], x = o[2], m = !!o[3], g = !!o[4], w = o[5], M = o[6];
        w = l ? w + i.x : w, M = l ? M + i.y : M, Rh(f, d, w, M, p, y, x, m, g, (S, E, A, I, b, v, _, z, P) => {
          r.bezierCurveTo(A, I, b, v, _, z), i.x = _, i.y = z;
        });
        break;
      case "Z":
        r.closePath(), i.x = n.x, i.y = n.y;
        break;
      default:
        return !1;
    }
    c == "" && (n.x = i.x, n.y = i.y), c = h;
  }
  return !0;
}
function Q1(r) {
  const e = [];
  let n = J1(r), i = 0, s = 0, o = 0, a = 0, h = 0, c = 0, l = 0, u = 0;
  for (let f = 0, d = n.length; f < d; f++) {
    const p = n[f];
    let y = p[0].toUpperCase(), x = y !== p[0], m = p.slice(1);
    switch (y) {
      case "M":
        i = x ? i + m[0] : m[0], s = x ? s + m[1] : m[1], m[0] = i, m[1] = s, o = i, a = s;
        break;
      case "L":
        i = x ? i + m[0] : m[0], s = x ? s + m[1] : m[1], m[0] = i, m[1] = s;
        break;
      case "H":
        i = x ? i + m[0] : m[0], m[0] = i;
        break;
      case "V":
        s = x ? s + m[0] : m[0], m[0] = s;
        break;
      case "Q":
        h = x ? i + m[0] : m[0], c = x ? s + m[1] : m[1], i = x ? i + m[2] : m[2], s = x ? s + m[3] : m[3], m[0] = h, m[1] = c, m[2] = i, m[3] = s;
        break;
      case "T":
        i = x ? i + m[0] : m[0], s = x ? s + m[1] : m[1], m[0] = i, m[1] = s;
        break;
      case "C":
        h = x ? i + m[0] : m[0], c = x ? s + m[1] : m[1], l = x ? i + m[2] : m[2], u = x ? s + m[3] : m[3], i = x ? i + m[4] : m[4], s = x ? s + m[5] : m[5], m[0] = h, m[1] = c, m[2] = l, m[3] = u, m[4] = i, m[5] = s;
        break;
      case "S":
        l = x ? i + m[0] : m[0], u = x ? s + m[1] : m[1], i = x ? i + m[2] : m[2], s = x ? s + m[3] : m[3], m[0] = l, m[1] = u, m[2] = i, m[3] = s;
        break;
      case "A":
        let g = m[0], w = m[1], M = m[2], S = m[3], E = m[4];
        i = x ? i + m[5] : m[5], s = x ? s + m[6] : m[6], m[0] = g, m[1] = w, m[2] = M, m[3] = S, m[4] = E, m[5] = i, m[6] = s;
        break;
      case "Z":
        i = o, s = a;
        break;
    }
    e.push([y].concat(m));
  }
  return e;
}
class zu {
  commands = [];
  dirty = !1;
  _cb = null;
  constructor(e) {
    typeof e == "string" ? Tl(this, e) : e instanceof zu && (this.commands = [...e.commands]);
  }
  fromSvgPath(e) {
    Tl(this, e);
  }
  onChange(e) {
    this._cb = e;
  }
  equals(e) {
    if (this.commands.length !== e.commands.length) return !1;
    for (let n = 0; n < this.commands.length; n++) {
      const i = this.commands[n], s = e.commands[n];
      if (i[0] !== s[0]) return !1;
      for (let o = 1; o < i.length; o++)
        if (i[o] !== s[o]) return !1;
    }
    return !0;
  }
  reset() {
    this.commands.length = 0, this.dirty = !0, this._cb?.();
  }
  clone() {
    return new this.constructor(this);
  }
  addCmd(e, n) {
    this.commands.push([e].concat(n)), this.dirty = !0, this._cb?.();
  }
  addPath(e, n) {
    this.commands = e.commands.slice();
  }
  arc(e, n, i, s, o, a = !1) {
    this.addCmd("AC", [e, n, i, s, o, a]);
  }
  arcTo(e, n, i, s, o) {
    this.addCmd("AT", [e, n, i, s, o]);
  }
  bezierCurveTo(e, n, i, s, o, a) {
    this.addCmd("C", [e, n, i, s, o, a]);
  }
  closePath() {
    this.commands.length > 0 && this.commands[this.commands.length - 1][0] !== "Z" && this.addCmd("Z", []);
  }
  ellipse(e, n, i, s, o, a, h, c = !1) {
    this.addCmd("E", [e, n, i, s, o, a, h, c]);
  }
  lineTo(e, n) {
    this.addCmd("L", [e, n]);
  }
  moveTo(e, n) {
    this.addCmd("M", [e, n]);
  }
  quadraticCurveTo(e, n, i, s) {
    this.addCmd("Q", [e, n, i, s]);
  }
  rect(e, n, i, s) {
    this.addCmd("R", [e, n, i, s]);
  }
  roundRect(e, n, i, s, o) {
    this.addCmd("RR", [e, n, i, s, o]);
  }
  toPath2D(e = new Path2D()) {
    return this.toCanvas(e);
  }
  toCanvas(e) {
    for (const n of this.commands)
      switch (n[0]) {
        case "M":
          e.moveTo(n[1], n[2]);
          break;
        case "L":
          e.lineTo(n[1], n[2]);
          break;
        case "Q":
          e.quadraticCurveTo(n[1], n[2], n[3], n[4]);
          break;
        case "C":
          e.bezierCurveTo(n[1], n[2], n[3], n[4], n[5], n[6]);
          break;
        case "AC":
          e.arc(n[1], n[2], n[3], n[4], n[5], n[6]);
          break;
        case "E":
          e.ellipse(n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8]);
          break;
        case "AT":
          e.arcTo(n[1], n[2], n[3], n[4], n[5]);
          break;
        case "RR":
          e.roundRect(n[1], n[2], n[3], n[4], n[5]);
          break;
        case "R":
          e.rect(n[1], n[2], n[3], n[4]);
          break;
        case "Z":
          e.closePath();
          break;
      }
    return e;
  }
}
const ev = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AutoConicToQuads: zb,
  Command: Ei,
  CommandSet: Yb,
  Conic: vn,
  CubicCoeff: O1,
  FillRule: W1,
  LineCap: U1,
  LineJoin: V1,
  PathBuilder: _s,
  PathDirection: ah,
  PathIterVerb: k1,
  PathSegmentsIter: Lh,
  PathStroker: jb,
  PathVerb: ie,
  ProxyPath2D: zu,
  QuadCoeff: bu,
  SCALAR_MAX: yb,
  SCALAR_NEARLY_ZERO: gu,
  SCALAR_ROOT_2_OVER_2: wu,
  SegmentMask: R1,
  build_unit_arc: Tb,
  chop_cubic_at: Ab,
  chop_cubic_at2: vu,
  chop_quad_at: mb,
  eval_cubic_pos_at: hh,
  eval_cubic_tangent_at: N1,
  eval_quad_at: oo,
  eval_quad_tangent_at: F1,
  find_cubic_cusp: $1,
  find_cubic_extrema: _b,
  find_cubic_inflections: D1,
  find_cubic_max_curvature: Mu,
  find_quad_extrema: gb,
  find_quad_max_curvature: B1,
  find_unit_quad_roots: No,
  new_t_values: L1,
  parseSvgPath: Q1,
  parseSvgPathData: J1,
  pathFromSvgPath: Tl,
  pathFromSvgPath2: Kb,
  pathFromSvgPathCommand: G1
}, Symbol.toStringTag, { value: "Module" })), md = Math.PI * 2;
function sa(r) {
  return r %= md, r < 0 && (r += md), r;
}
const Fr = Math.PI * 2;
function K1(r, e, n, i, s, o, a, h, c) {
  if (a === 0)
    return !1;
  const l = a;
  h -= r, c -= e;
  const u = Math.sqrt(h * h + c * c);
  if (u - l > n || u + l < n)
    return !1;
  if (Math.abs(i - s) % Fr < 1e-4)
    return !0;
  if (o) {
    const d = i;
    i = sa(s), s = sa(d);
  } else
    i = sa(i), s = sa(s);
  i > s && (s += Fr);
  let f = Math.atan2(c, h);
  return f < 0 && (f += Fr), f >= i && f <= s || f + Fr >= i && f + Fr <= s;
}
const nv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: K1
}, Symbol.toStringTag, { value: "Module" }));
function ty(r, e, n, i, s, o, a, h, c, l, u) {
  if (c === 0)
    return !1;
  const f = c;
  return u > e + f && u > i + f && u > o + f && u > h + f || u < e - f && u < i - f && u < o - f && u < h - f || l > r + f && l > n + f && l > s + f && l > a + f || l < r - f && l < n - f && l < s - f && l < a - f ? !1 : S1(
    r,
    e,
    n,
    i,
    s,
    o,
    a,
    h,
    l,
    u,
    null
  ) <= f / 2;
}
const iv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: ty
}, Symbol.toStringTag, { value: "Module" }));
function rs(r, e, n, i, s, o, a) {
  if (s === 0)
    return !1;
  const h = s;
  let c = 0, l = r;
  if (a > e + h && a > i + h || a < e - h && a < i - h || o > r + h && o > n + h || o < r - h && o < n - h)
    return !1;
  if (r !== n)
    c = (e - i) / (r - n), l = (r * i - n * e) / (r - n);
  else
    return Math.abs(o - r) <= h / 2;
  const u = c * o - a + l;
  return u * u / (c * c + 1) <= h / 2 * h / 2;
}
const sv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: rs
}, Symbol.toStringTag, { value: "Module" }));
function ey(r, e, n, i, s, o, a, h, c) {
  if (a === 0)
    return !1;
  const l = a;
  return c > e + l && c > i + l && c > o + l || c < e - l && c < i - l && c < o - l || h > r + l && h > n + l && h > s + l || h < r - l && h < n - l && h < s - l ? !1 : _1(
    r,
    e,
    n,
    i,
    s,
    o,
    h,
    c,
    null
  ) <= l / 2;
}
const rv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: ey
}, Symbol.toStringTag, { value: "Module" }));
function ii(r, e, n, i, s, o) {
  if (o > e && o > i || o < e && o < i || i === e)
    return 0;
  const a = (o - e) / (i - e);
  let h = i < e ? 1 : -1;
  (a === 1 || a === 0) && (h = i < e ? 0.5 : -0.5);
  const c = a * (n - r) + r;
  return c === s ? 1 / 0 : c > s ? h : 0;
}
const ov = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ii
}, Symbol.toStringTag, { value: "Module" })), Fi = {
  M: "M",
  L: "L",
  C: "C",
  Q: "Q",
  Z: "Z",
  R: "R",
  E: "E"
}, Ni = Math.PI * 2, av = 1e-4;
function hv(r, e) {
  return Math.abs(r - e) < av;
}
const Ae = [-1, -1, -1], nn = [-1, -1];
function cv() {
  const r = nn[0];
  nn[0] = nn[1], nn[1] = r;
}
function ny(r, e, n, i, s, o, a, h, c, l) {
  if (l > e && l > i && l > o && l > h || l < e && l < i && l < o && l < h)
    return 0;
  const u = A1(e, i, o, h, l, Ae);
  if (u === 0)
    return 0;
  {
    let f = 0, d = -1, p = 0, y = 0;
    for (let x = 0; x < u; x++) {
      let m = Ae[x], g = m === 0 || m === 1 ? 0.5 : 1;
      Ee(r, n, s, a, m) < c || (d < 0 && (d = yu(e, i, o, h, nn), nn[1] < nn[0] && d > 1 && cv(), p = Ee(e, i, o, h, nn[0]), d > 1 && (y = Ee(e, i, o, h, nn[1]))), d === 2 ? m < nn[0] ? f += p < e ? g : -g : m < nn[1] ? f += y < p ? g : -g : f += h < y ? g : -g : m < nn[0] ? f += p < e ? g : -g : f += h < p ? g : -g);
    }
    return f;
  }
}
function iy(r, e, n, i, s, o, a, h) {
  if (h > e && h > i && h > o || h < e && h < i && h < o)
    return 0;
  const c = P1(e, i, o, h, Ae);
  if (c === 0)
    return 0;
  {
    const l = xu(e, i, o);
    if (l >= 0 && l <= 1) {
      let u = 0, f = ze(e, i, o, l);
      for (let d = 0; d < c; d++) {
        let p = Ae[d] === 0 || Ae[d] === 1 ? 0.5 : 1;
        ze(r, n, s, Ae[d]) < a || (Ae[d] < l ? u += f < e ? p : -p : u += o < f ? p : -p);
      }
      return u;
    } else {
      const u = Ae[0] === 0 || Ae[0] === 1 ? 0.5 : 1;
      return ze(r, n, s, Ae[0]) < a ? 0 : o < e ? u : -u;
    }
  }
}
function sy(r, e, n, i, s, o, a, h) {
  if (h -= e, h > n || h < -n)
    return 0;
  const c = Math.sqrt(n * n - h * h);
  Ae[0] = -c, Ae[1] = c;
  const l = Math.abs(i - s);
  if (l < 1e-4)
    return 0;
  if (l >= Ni - 1e-4) {
    i = 0, s = Ni;
    const f = o ? 1 : -1;
    return a >= Ae[0] + r && a <= Ae[1] + r ? f : 0;
  }
  if (i > s) {
    const f = i;
    i = s, s = f;
  }
  i < 0 && (i += Ni, s += Ni);
  let u = 0;
  for (let f = 0; f < 2; f++) {
    const d = Ae[f];
    if (d + r > a) {
      let p = Math.atan2(h, d), y = o ? 1 : -1;
      p < 0 && (p = Ni + p), (p >= i && p <= s || p + Ni >= i && p + Ni <= s) && (p > Math.PI / 2 && p < Math.PI * 1.5 && (y = -y), u += y);
    }
  }
  return u;
}
function ry(r, e, n, i, s) {
  const o = r.commands, a = r.commands.length;
  let h = 0, c = 0, l = 0, u = 0, f = 0, d, p;
  for (let y = 0; y < a; ) {
    let x = 0, m = o[y];
    const g = m[x++];
    switch (c = m[x], l = m[x + 1], u = c, f = l, g) {
      case Fi.M:
        u = m[x++], f = m[x++], c = u, l = f;
        break;
      case Fi.L:
        if (n) {
          if (rs(c, l, m[x], m[x + 1], e, i, s))
            return !0;
        } else
          h += ii(c, l, m[x], m[x + 1], i, s) || 0;
        c = m[x++], l = m[x++];
        break;
      case Fi.C:
        if (n) {
          if (ty(
            c,
            l,
            m[x++],
            m[x++],
            m[x++],
            m[x++],
            m[x],
            m[x + 1],
            e,
            i,
            s
          ))
            return !0;
        } else
          h += ny(
            c,
            l,
            m[x++],
            m[x++],
            m[x++],
            m[x++],
            m[x],
            m[x + 1],
            i,
            s
          ) || 0;
        c = m[x++], l = m[x++];
        break;
      case Fi.Q:
        if (n) {
          if (ey(
            c,
            l,
            m[x++],
            m[x++],
            m[x],
            m[x + 1],
            e,
            i,
            s
          ))
            return !0;
        } else
          h += iy(
            c,
            l,
            m[x++],
            m[x++],
            m[x],
            m[x + 1],
            i,
            s
          ) || 0;
        c = m[x++], l = m[x++];
        break;
      case Fi.E:
        const w = m[x++], M = m[x++], S = m[x++], E = m[x++], A = m[x++], I = m[x++];
        x += 1;
        const b = !!(1 - m[x++]);
        d = Math.cos(A) * S + w, p = Math.sin(A) * E + M, u = d, f = p;
        const v = (i - w) * E / S + w;
        if (n) {
          if (K1(
            w,
            M,
            E,
            A,
            A + I,
            b,
            e,
            v,
            s
          ))
            return !0;
        } else
          h += sy(
            w,
            M,
            E,
            A,
            A + I,
            b,
            v,
            s
          );
        c = Math.cos(A + I) * S + w, l = Math.sin(A + I) * E + M;
        break;
      case Fi.R:
        u = c = m[x++], f = l = m[x++];
        const _ = m[x++], z = m[x++];
        if (d = u + _, p = f + z, n) {
          if (rs(u, f, d, f, e, i, s) || rs(d, f, d, p, e, i, s) || rs(d, p, u, p, e, i, s) || rs(u, p, u, f, e, i, s))
            return !0;
        } else
          h += ii(d, f, d, p, i, s), h += ii(u, p, u, f, i, s);
        break;
      case Fi.Z:
        if (n) {
          if (rs(
            c,
            l,
            u,
            f,
            e,
            i,
            s
          ))
            return !0;
        } else
          h += ii(c, l, u, f, i, s);
        c = u, l = f;
        break;
    }
  }
  return !n && !hv(l, f) && (h += ii(c, l, u, f, i, s) || 0), h !== 0;
}
function lv(r, e, n) {
  return ry(r, 0, !1, e, n);
}
function uv(r, e, n, i) {
  return ry(r, e, !0, n, i);
}
const fv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contain: lv,
  containStroke: uv,
  windingArc: sy,
  windingCubic: ny,
  windingLine: ii,
  windingQuadratic: iy
}, Symbol.toStringTag, { value: "Module" })), dv = 1e-8;
function gd(r, e) {
  return Math.abs(r - e) < dv;
}
function pv(r, e, n) {
  let i = 0, s = r[0];
  if (!s)
    return !1;
  for (let a = 1; a < r.length; a++) {
    const h = r[a];
    i += ii(s[0], s[1], h[0], h[1], e, n), s = h;
  }
  const o = r[0];
  return (!gd(s[0], o[0]) || !gd(s[1], o[1])) && (i += ii(s[0], s[1], o[0], o[1], e, n)), i !== 0;
}
const yv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contain: pv
}, Symbol.toStringTag, { value: "Module" }));
let wn = class oy {
  x;
  y;
  constructor(e, n) {
    this.x = e || 0, this.y = n || 0;
  }
  /**
   * Copy from another point
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Clone a point
   */
  clone() {
    return new oy(this.x, this.y);
  }
  /**
   * Set x and y
   */
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  /**
   * If equal to another point
   */
  equal(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Add another point
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scale(e) {
    this.x *= e, this.y *= e;
  }
  scaleAndAdd(e, n) {
    this.x += e.x * n, this.y += e.y * n;
  }
  /**
   * Sub another point
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Dot product with other point
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Get length of point
   */
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Get squared length
   */
  lenSquare() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Normalize
   */
  normalize() {
    const e = this.len();
    return this.x /= e, this.y /= e, this;
  }
  /**
   * Distance to another point
   */
  distance(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return Math.sqrt(n * n + i * i);
  }
  /**
   * Square distance to another point
   */
  distanceSquare(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  /**
   * Negate
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Apply a transform matrix array.
   */
  transform(e) {
    if (!e)
      return;
    const n = this.x, i = this.y;
    return this.x = e[0] * n + e[2] * i + e[4], this.y = e[1] * n + e[3] * i + e[5], this;
  }
  toArray(e) {
    return e[0] = this.x, e[1] = this.y, e;
  }
  fromArray(e) {
    this.x = e[0], this.y = e[1];
  }
  static set(e, n, i) {
    e.x = n, e.y = i;
  }
  static copy(e, n) {
    e.x = n.x, e.y = n.y;
  }
  static len(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }
  static lenSquare(e) {
    return e.x * e.x + e.y * e.y;
  }
  static dot(e, n) {
    return e.x * n.x + e.y * n.y;
  }
  static add(e, n, i) {
    e.x = n.x + i.x, e.y = n.y + i.y;
  }
  static sub(e, n, i) {
    e.x = n.x - i.x, e.y = n.y - i.y;
  }
  static scale(e, n, i) {
    e.x = n.x * i, e.y = n.y * i;
  }
  static scaleAndAdd(e, n, i, s) {
    e.x = n.x + i.x * s, e.y = n.y + i.y * s;
  }
  static lerp(e, n, i, s) {
    const o = 1 - s;
    e.x = o * n.x + s * i.x, e.y = o * n.y + s * i.y;
  }
};
const ps = Math.min, ar = Math.max, El = Math.abs, wd = ["x", "y"], xv = ["width", "height"], qi = new wn(), Di = new wn(), $i = new wn(), Vi = new wn(), Ye = ay(), Zr = Ye.minTv, zl = Ye.maxTv, ao = [0, 0];
class ce {
  x = 0;
  y = 0;
  width = 0;
  height = 0;
  constructor(e, n, i, s) {
    ce.set(this, e, n, i, s);
  }
  static set(e, n, i, s, o) {
    return s < 0 && (n = n + s, s = -s), o < 0 && (i = i + o, o = -o), e.x = n, e.y = i, e.width = s, e.height = o, e;
  }
  union(e) {
    const n = ps(e.x, this.x), i = ps(e.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = ar(
      e.x + e.width,
      this.x + this.width
    ) - n : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = ar(
      e.y + e.height,
      this.y + this.height
    ) - i : this.height = e.height, this.x = n, this.y = i;
  }
  applyTransform(e) {
    ce.applyTransform(this, this, e);
  }
  calculateTransform(e) {
    const n = this, i = e.width / n.width, s = e.height / n.height, o = ue.default();
    return ue.translate(o, o, [-n.x, -n.y]), ue.scale(o, o, [i, s]), ue.translate(o, o, [e.x, e.y]), o;
  }
  /**
   * @see `static intersect`
   */
  intersect(e, n, i) {
    return ce.intersect(this, e, n, i);
  }
  /**
   * [NOTICE]
   *  Touching the edge is considered an intersection.
   *  zero-width/height can still cause intersection if `touchThreshold` is 0.
   *  See more in `BoundingRectIntersectOpt['touchThreshold']`
   *
   * @param mtv
   *  If it's not overlapped. it means needs to move `b` rect with Maximum Translation Vector to be overlapped.
   *  Else it means needs to move `b` rect with Minimum Translation Vector to be not overlapped.
   */
  static intersect(e, n, i, s) {
    i && wn.set(i, 0, 0);
    const o = s && s.outIntersectRect || null, a = s && s.clamp;
    if (o && (o.x = o.y = o.width = o.height = NaN), !e || !n)
      return !1;
    e instanceof ce || (e = ce.set(mv, e.x, e.y, e.width, e.height)), n instanceof ce || (n = ce.set(gv, n.x, n.y, n.width, n.height));
    const h = !!i;
    Ye.reset(s, h);
    const c = Ye.touchThreshold, l = e.x + c, u = e.x + e.width - c, f = e.y + c, d = e.y + e.height - c, p = n.x + c, y = n.x + n.width - c, x = n.y + c, m = n.y + n.height - c;
    if (l > u || f > d || p > y || x > m)
      return !1;
    const g = !(u < p || y < l || d < x || m < f);
    return (h || o) && (ao[0] = 1 / 0, ao[1] = 0, bd(l, u, p, y, 0, h, o, a), bd(f, d, x, m, 1, h, o, a), h && wn.copy(
      i,
      g ? Ye.useDir ? Ye.dirMinTv : Zr : zl
    )), g;
  }
  static contain(e, n, i) {
    return n >= e.x && n <= e.x + e.width && i >= e.y && i <= e.y + e.height;
  }
  contain(e, n) {
    return ce.contain(this, e, n);
  }
  clone() {
    return new ce(this.x, this.y, this.width, this.height);
  }
  /**
   * Copy from another rect
   */
  copy(e) {
    ce.copy(this, e);
  }
  plain() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
  /**
   * If not having NaN or Infinity with attributes
   */
  isFinite() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }
  isZero() {
    return this.width === 0 || this.height === 0;
  }
  static create(e) {
    return new ce(e.x, e.y, e.width, e.height);
  }
  static copy(e, n) {
    return e.x = n.x, e.y = n.y, e.width = n.width, e.height = n.height, e;
  }
  static applyTransform(e, n, i) {
    if (!i) {
      e !== n && ce.copy(e, n);
      return;
    }
    if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
      const a = i[0], h = i[3], c = i[4], l = i[5];
      e.x = n.x * a + c, e.y = n.y * h + l, e.width = n.width * a, e.height = n.height * h, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
      return;
    }
    qi.x = $i.x = n.x, qi.y = Vi.y = n.y, Di.x = Vi.x = n.x + n.width, Di.y = $i.y = n.y + n.height, qi.transform(i), Vi.transform(i), Di.transform(i), $i.transform(i), e.x = ps(qi.x, Di.x, $i.x, Vi.x), e.y = ps(qi.y, Di.y, $i.y, Vi.y);
    const s = ar(qi.x, Di.x, $i.x, Vi.x), o = ar(qi.y, Di.y, $i.y, Vi.y);
    e.width = s - e.x, e.height = o - e.y;
  }
}
const mv = new ce(0, 0, 0, 0), gv = new ce(0, 0, 0, 0);
function bd(r, e, n, i, s, o, a, h) {
  const c = El(e - n), l = El(i - r), u = ps(c, l), f = wd[s], d = wd[1 - s], p = xv[s];
  e < n || i < r ? c < l ? (o && (zl[f] = -c), h && (a[f] = e, a[p] = 0)) : (o && (zl[f] = l), h && (a[f] = r, a[p] = 0)) : (a && (a[f] = ar(r, n), a[p] = ps(e, i) - a[f]), o && (u < ao[0] || Ye.useDir) && (ao[0] = ps(u, ao[0]), (c < l || !Ye.bidirectional) && (Zr[f] = c, Zr[d] = 0, Ye.useDir && Ye.calcDirMTV()), (c >= l || !Ye.bidirectional) && (Zr[f] = -l, Zr[d] = 0, Ye.useDir && Ye.calcDirMTV())));
}
function ay() {
  let r = 0;
  const e = new wn(), n = new wn(), i = {
    minTv: new wn(),
    maxTv: new wn(),
    useDir: !1,
    dirMinTv: new wn(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset(o, a) {
      i.touchThreshold = 0, o && o.touchThreshold != null && (i.touchThreshold = ar(0, o.touchThreshold)), i.negativeSize = !1, a && (i.minTv.set(1 / 0, 1 / 0), i.maxTv.set(0, 0), i.useDir = !1, o && o.direction != null && (i.useDir = !0, i.dirMinTv.copy(i.minTv), n.copy(i.minTv), r = o.direction, i.bidirectional = o.bidirectional == null || !!o.bidirectional, i.bidirectional || e.set(Math.cos(r), Math.sin(r))));
    },
    calcDirMTV() {
      const o = i.minTv, a = i.dirMinTv, h = o.y * o.y + o.x * o.x, c = Math.sin(r), l = Math.cos(r), u = c * o.y + l * o.x;
      if (s(u)) {
        s(o.x) && s(o.y) && a.set(0, 0);
        return;
      }
      if (n.x = h * l / u, n.y = h * c / u, s(n.x) && s(n.y)) {
        a.set(0, 0);
        return;
      }
      (i.bidirectional || e.dot(n) > 0) && n.len() < a.len() && a.copy(n);
    }
  };
  function s(o) {
    return El(o) < 1e-10;
  }
  return i;
}
class Au {
  value;
  key;
  next;
  prev;
  constructor(e) {
    this.value = e;
  }
}
let hy = class {
  head;
  tail;
  _len = 0;
  /**
   * Insert a new value at the tail
   */
  insert(e) {
    const n = new Au(e);
    return this.insertEntry(n), n;
  }
  /**
   * Insert an entry at the tail
   */
  insertEntry(e) {
    this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
  }
  /**
   * Remove entry.
   */
  remove(e) {
    const n = e.prev, i = e.next;
    n ? n.next = i : this.head = i, i ? i.prev = n : this.tail = n, e.next = e.prev = null, this._len--;
  }
  /**
   * Get length
   */
  len() {
    return this._len;
  }
  /**
   * Clear list
   */
  clear() {
    this.head = this.tail = null, this._len = 0;
  }
};
class vd {
  _list = new hy();
  _maxSize = 10;
  _lastRemovedEntry;
  _map = {};
  constructor(e) {
    this._maxSize = e;
  }
  /**
   * @return Removed value
   */
  put(e, n) {
    const i = this._list, s = this._map;
    let o = null;
    if (s[e] == null) {
      const a = i.len();
      let h = this._lastRemovedEntry;
      if (a >= this._maxSize && a > 0) {
        const c = i.head;
        i.remove(c), delete s[c.key], o = c.value, this._lastRemovedEntry = c;
      }
      h ? h.value = n : h = new Au(n), h.key = e, i.insertEntry(h), s[e] = h;
    }
    return o;
  }
  get(e) {
    const n = this._map[e], i = this._list;
    if (n != null)
      return n !== i.tail && (i.remove(n), i.insertEntry(n)), n.value;
  }
  /**
   * Clear the cache
   */
  clear() {
    this._list.clear(), this._map = {};
  }
  len() {
    return this._list.len();
  }
}
const cy = 12, wv = "sans-serif", uh = `${cy}px ${wv}`, bv = 20, vv = 100, Mv = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function _v(r) {
  const e = {};
  if (typeof JSON > "u")
    return e;
  for (let n = 0; n < r.length; n++) {
    const i = String.fromCharCode(n + 32), s = (r.charCodeAt(n) - bv) / vv;
    e[i] = s;
  }
  return e;
}
const Sv = _v(Mv), br = {
  // Export methods
  createCanvas() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    let r, e;
    return (n, i) => {
      if (!r) {
        const s = br.createCanvas();
        r = s && s.getContext("2d");
      }
      if (r)
        return e !== i && (e = r.font = i || uh), r.measureText(n);
      {
        n = n || "", i = i || uh;
        const s = /((?:\d+)?\.?\d*)px/.exec(i), o = s && +s[1] || cy;
        let a = 0;
        if (i.indexOf("mono") >= 0)
          a = o * n.length;
        else
          for (let h = 0; h < n.length; h++) {
            const c = Sv[n[h]];
            a += c == null ? o : c * o;
          }
        return { width: a };
      }
    };
  }(),
  loadImage(r, e, n) {
    const i = new Image();
    return i.onload = e, i.onerror = n, i.src = r, i;
  }
};
function Tv(r, e) {
  return Cu(Bh(e), r);
}
function Bh(r) {
  ra || (ra = new vd(100)), r = r || uh;
  let e = ra.get(r);
  return e || (e = {
    font: r,
    strWidthCache: new vd(500),
    asciiWidthMap: null,
    // Init lazily for performance.
    asciiWidthMapTried: !1,
    // FIXME
    // Other languages?
    // FIXME
    // Consider proportional font?
    stWideCharWidth: br.measureText("国", r).width,
    asciiCharWidth: br.measureText("a", r).width
  }, ra.put(r, e)), e;
}
let ra;
function Ev(r) {
  if (pc >= Md)
    return;
  r = r || uh;
  const e = [], n = +/* @__PURE__ */ new Date();
  for (let s = 0; s <= 127; s++)
    e[s] = br.measureText(String.fromCharCode(s), r).width;
  const i = +/* @__PURE__ */ new Date() - n;
  return i > 16 ? pc = Md : i > 2 && pc++, e;
}
let pc = 0;
const Md = 5;
function zv(r, e) {
  return r.asciiWidthMapTried || (r.asciiWidthMap = Ev(r.font), r.asciiWidthMapTried = !0), 0 <= e && e <= 127 ? r.asciiWidthMap != null ? r.asciiWidthMap[e] : r.asciiCharWidth : r.stWideCharWidth;
}
function Cu(r, e) {
  const n = r.strWidthCache;
  let i = n.get(e);
  return i == null && (i = br.measureText(e, r.font).width, n.put(e, i)), i;
}
function Al(r, e, n, i) {
  const s = Cu(Bh(e), r), o = fy(e), a = ly(0, s, n), h = uy(0, o, i);
  return new ce(a, h, s, o);
}
function Av(r, e, n, i) {
  const s = ((r || "") + "").split(`
`);
  if (s.length === 1)
    return Al(s[0], e, n, i);
  {
    const a = new ce(0, 0, 0, 0);
    for (let h = 0; h < s.length; h++) {
      const c = Al(s[h], e, n, i);
      h === 0 ? a.copy(c) : a.union(c);
    }
    return a;
  }
}
function ly(r, e, n, i) {
  return n === "right" ? i ? r += e : r -= e : n === "center" && (i ? r += e / 2 : r -= e / 2), r;
}
function uy(r, e, n, i) {
  return n === "middle" ? i ? r += e / 2 : r -= e / 2 : n === "bottom" && (i ? r += e : r -= e), r;
}
function fy(r) {
  return Bh(r).stWideCharWidth;
}
function Cv(r, e) {
  return br.measureText(r, e);
}
function Cl(r, e) {
  return typeof r == "string" ? r.lastIndexOf("%") >= 0 ? parseFloat(r) / 100 * e : parseFloat(r) : r;
}
function Pv(r, e, n) {
  const i = e.position || "inside", s = e.distance != null ? e.distance : 5, o = n.height, a = n.width, h = o / 2;
  let c = n.x, l = n.y, u = "left", f = "top";
  if (i instanceof Array)
    c += Cl(i[0], n.width), l += Cl(i[1], n.height), u = null, f = null;
  else
    switch (i) {
      case "left":
        c -= s, l += h, u = "right", f = "middle";
        break;
      case "right":
        c += s + a, l += h, f = "middle";
        break;
      case "top":
        c += a / 2, l -= s, u = "center", f = "bottom";
        break;
      case "bottom":
        c += a / 2, l += o + s, u = "center";
        break;
      case "inside":
        c += a / 2, l += h, u = "center", f = "middle";
        break;
      case "insideLeft":
        c += s, l += h, f = "middle";
        break;
      case "insideRight":
        c += a - s, l += h, u = "right", f = "middle";
        break;
      case "insideTop":
        c += a / 2, l += s, u = "center";
        break;
      case "insideBottom":
        c += a / 2, l += o - s, u = "center", f = "bottom";
        break;
      case "insideTopLeft":
        c += s, l += s;
        break;
      case "insideTopRight":
        c += a - s, l += s, u = "right";
        break;
      case "insideBottomLeft":
        c += s, l += o - s, f = "bottom";
        break;
      case "insideBottomRight":
        c += a - s, l += o - s, u = "right", f = "bottom";
        break;
    }
  return r = r || {}, r.x = c, r.y = l, r.align = u, r.verticalAlign = f, r;
}
const Iv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  adjustTextX: ly,
  adjustTextY: uy,
  calculateTextPosition: Pv,
  ensureFontMeasureInfo: Bh,
  getBoundingRect: Av,
  getLineHeight: fy,
  getWidth: Tv,
  innerGetBoundingRect: Al,
  measureCharWidth: zv,
  measureText: Cv,
  measureWidth: Cu,
  parsePercent: Cl
}, Symbol.toStringTag, { value: "Module" })), kv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arc: nv,
  cubic: iv,
  line: sv,
  path: fv,
  polygon: yv,
  quadratic: rv,
  text: Iv,
  windingLine: ov
}, Symbol.toStringTag, { value: "Module" })), Ne = Math.min, qe = Math.max, yc = Math.sin, xc = Math.cos, Ui = Math.PI * 2, oa = et.create(), aa = et.create(), ha = et.create();
function Rv(r, e, n) {
  if (r.length === 0)
    return;
  let i = r[0], s = i[0], o = i[0], a = i[1], h = i[1];
  for (let c = 1; c < r.length; c++)
    i = r[c], s = Ne(s, i[0]), o = qe(o, i[0]), a = Ne(a, i[1]), h = qe(h, i[1]);
  e[0] = s, e[1] = a, n[0] = o, n[1] = h;
}
function Pl(r, e, n, i, s, o) {
  s[0] = Ne(r, n), s[1] = Ne(e, i), o[0] = qe(r, n), o[1] = qe(e, i);
}
const _d = [], Sd = [];
function dy(r, e, n, i, s, o, a, h, c, l) {
  const u = yu, f = Ee;
  let d = u(r, n, s, a, _d);
  c[0] = 1 / 0, c[1] = 1 / 0, l[0] = -1 / 0, l[1] = -1 / 0;
  for (let p = 0; p < d; p++) {
    const y = f(r, n, s, a, _d[p]);
    c[0] = Ne(y, c[0]), l[0] = qe(y, l[0]);
  }
  d = u(e, i, o, h, Sd);
  for (let p = 0; p < d; p++) {
    const y = f(e, i, o, h, Sd[p]);
    c[1] = Ne(y, c[1]), l[1] = qe(y, l[1]);
  }
  c[0] = Ne(r, c[0]), l[0] = qe(r, l[0]), c[0] = Ne(a, c[0]), l[0] = qe(a, l[0]), c[1] = Ne(e, c[1]), l[1] = qe(e, l[1]), c[1] = Ne(h, c[1]), l[1] = qe(h, l[1]);
}
function py(r, e, n, i, s, o, a, h) {
  const c = xu, l = ze, u = qe(
    Ne(c(r, n, s), 1),
    0
  ), f = qe(
    Ne(c(e, i, o), 1),
    0
  ), d = l(r, n, s, u), p = l(e, i, o, f);
  a[0] = Ne(r, s, d), a[1] = Ne(e, o, p), h[0] = qe(r, s, d), h[1] = qe(e, o, p);
}
function yy(r, e, n, i, s, o, a, h, c) {
  const l = et.min, u = et.max, f = Math.abs(s - o);
  if (f % Ui < 1e-4 && f > 1e-4) {
    h[0] = r - n, h[1] = e - i, c[0] = r + n, c[1] = e + i;
    return;
  }
  if (oa[0] = xc(s) * n + r, oa[1] = yc(s) * i + e, aa[0] = xc(o) * n + r, aa[1] = yc(o) * i + e, l(h, oa, aa), u(c, oa, aa), s = s % Ui, s < 0 && (s = s + Ui), o = o % Ui, o < 0 && (o = o + Ui), s > o && !a ? o += Ui : s < o && a && (s += Ui), a) {
    const d = o;
    o = s, s = d;
  }
  for (let d = 0; d < o; d += Math.PI / 2)
    d > s && (ha[0] = xc(d) * n + r, ha[1] = yc(d) * i + e, l(h, ha, h), u(c, ha, c));
}
const Ov = () => typeof window < "u" && typeof window.document < "u";
let Il = 1;
Ov() && (Il = Math.max(
  window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1,
  1
));
const Bt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  // Rect
  R: 7
}, Wi = et.create(), ji = et.create(), In = et.create(), yi = et.create(), kn = et.create(), Rn = et.create(), mc = Math.min, gc = Math.max, Yi = Math.cos, Hi = Math.sin, Hn = Math.abs, kl = Math.PI, Ti = kl * 2, wc = typeof Float32Array < "u", Nr = [];
function bc(r) {
  return Math.round(r / kl * 1e8) / 1e8 % 2 * kl;
}
function xy(r, e) {
  let n = bc(r[0]);
  n < 0 && (n += Ti);
  let i = n - r[0], s = r[1];
  s += i, !e && s - n >= Ti ? s = n + Ti : e && n - s >= Ti ? s = n - Ti : !e && n > s ? s = n + (Ti - bc(n - s)) : e && n < s && (s = n - (Ti - bc(s - n))), r[0] = n, r[1] = s;
}
class Rl {
  dpr = 1;
  data;
  /**
   * Version is for tracking if the path has been changed.
   */
  _version;
  /**
   * If save path data.
   */
  _saveData;
  /**
   * If the line segment is too small to draw. It will be added to the pending pt.
   * It will be added if the subpath needs to be finished before stroke, fill, or starting a new subpath.
   */
  _pendingPtX;
  _pendingPtY;
  // Distance of pending pt to previous point.
  // 0 if there is no pending point.
  // Only update the pending pt when distance is larger.
  _pendingPtDist;
  _ctx;
  _xi = 0;
  _yi = 0;
  _x0 = 0;
  _y0 = 0;
  _len = 0;
  // Calculating path len and seg len.
  _pathSegLen;
  _pathLen;
  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
  _ux;
  _uy;
  static CMD = Bt;
  constructor(e) {
    e && (this._saveData = !1), this._saveData && (this.data = []);
  }
  increaseVersion() {
    this._version++;
  }
  /**
   * Version can be used outside for compare if the path is changed.
   * For example to determine if need to update svg d str in svg renderer.
   */
  getVersion() {
    return this._version;
  }
  /**
   * @readOnly
   */
  setScale(e, n, i) {
    i = i || 0, i > 0 && (this._ux = Hn(i / Il / e) || 0, this._uy = Hn(i / Il / n) || 0);
  }
  setDPR(e) {
    this.dpr = e;
  }
  setContext(e) {
    this._ctx = e;
  }
  getContext() {
    return this._ctx;
  }
  beginPath() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }
  /**
   * Reset path data.
   */
  reset() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }
  moveTo(e, n) {
    return this._drawPendingPt(), this.addData(Bt.M, e, n), this._ctx && this._ctx.moveTo(e, n), this._x0 = e, this._y0 = n, this._xi = e, this._yi = n, this;
  }
  lineTo(e, n) {
    const i = Hn(e - this._xi), s = Hn(n - this._yi), o = i > this._ux || s > this._uy;
    if (this.addData(Bt.L, e, n), this._ctx && o && this._ctx.lineTo(e, n), o)
      this._xi = e, this._yi = n, this._pendingPtDist = 0;
    else {
      const a = i * i + s * s;
      a > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = n, this._pendingPtDist = a);
    }
    return this;
  }
  bezierCurveTo(e, n, i, s, o, a) {
    return this._drawPendingPt(), this.addData(Bt.C, e, n, i, s, o, a), this._ctx && this._ctx.bezierCurveTo(e, n, i, s, o, a), this._xi = o, this._yi = a, this;
  }
  quadraticCurveTo(e, n, i, s) {
    return this._drawPendingPt(), this.addData(Bt.Q, e, n, i, s), this._ctx && this._ctx.quadraticCurveTo(e, n, i, s), this._xi = i, this._yi = s, this;
  }
  arc(e, n, i, s, o, a = !1) {
    this._drawPendingPt(), Nr[0] = s, Nr[1] = o, xy(Nr, a), s = Nr[0], o = Nr[1];
    let h = o - s;
    return this.addData(
      Bt.A,
      e,
      n,
      i,
      i,
      s,
      h,
      0,
      a ? 0 : 1
    ), this._ctx && this._ctx.arc(e, n, i, s, o, a), this._xi = Yi(o) * i + e, this._yi = Hi(o) * i + n, this;
  }
  // TODO
  arcTo(e, n, i, s, o) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, n, i, s, o), this;
  }
  // TODO
  rect(e, n, i, s) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(e, n, i, s), this.addData(Bt.R, e, n, i, s), this;
  }
  closePath() {
    this._drawPendingPt(), this.addData(Bt.Z);
    const e = this._ctx, n = this._x0, i = this._y0;
    return e && e.closePath(), this._xi = n, this._yi = i, this;
  }
  fill(e) {
    e && e.fill(), this.toStatic();
  }
  stroke(e) {
    e && e.stroke(), this.toStatic();
  }
  len() {
    return this._len;
  }
  setData(e) {
    if (!this._saveData)
      return;
    const n = e.length;
    !(this.data && this.data.length === n) && wc && (this.data = new Float32Array(n));
    for (let i = 0; i < n; i++)
      this.data[i] = e[i];
    this._len = n;
  }
  appendPath(e) {
    if (!this._saveData)
      return;
    e instanceof Array || (e = [e]);
    const n = e.length;
    let i = 0, s = this._len;
    for (let a = 0; a < n; a++)
      i += e[a].len();
    const o = this.data;
    if (wc && (o instanceof Float32Array || !o) && (this.data = new Float32Array(s + i), s > 0 && o))
      for (let a = 0; a < s; a++)
        this.data[a] = o[a];
    for (let a = 0; a < n; a++) {
      const h = e[a].data;
      for (let c = 0; c < h.length; c++)
        this.data[s++] = h[c];
    }
    this._len = s;
  }
  /**
   * 填充 Path 数据。
   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
   */
  addData(e, n, i, s, o, a, h, c, l) {
    if (!this._saveData)
      return;
    let u = this.data;
    this._len + arguments.length > u.length && (this._expandData(), u = this.data);
    for (let f = 0; f < arguments.length; f++)
      u[this._len++] = arguments[f];
  }
  _drawPendingPt() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }
  _expandData() {
    if (!(this.data instanceof Array)) {
      const e = [];
      for (let n = 0; n < this._len; n++)
        e[n] = this.data[n];
      this.data = e;
    }
  }
  /**
   * Convert dynamic array to static Float32Array
   *
   * It will still use a normal array if command buffer length is less than 10
   * Because Float32Array itself may take more memory than a normal array.
   *
   * 10 length will make sure at least one M command and one A(arc) command.
   */
  toStatic() {
    if (!this._saveData)
      return;
    this._drawPendingPt();
    const e = this.data;
    e instanceof Array && (e.length = this._len, wc && this._len > 11 && (this.data = new Float32Array(e)));
  }
  getBoundingRect() {
    In[0] = In[1] = kn[0] = kn[1] = Number.MAX_VALUE, yi[0] = yi[1] = Rn[0] = Rn[1] = -Number.MAX_VALUE;
    const e = this.data;
    let n = 0, i = 0, s = 0, o = 0, a;
    for (a = 0; a < this._len; ) {
      const h = e[a++], c = a === 1;
      switch (c && (n = e[a], i = e[a + 1], s = n, o = i), h) {
        case Bt.M:
          n = s = e[a++], i = o = e[a++], kn[0] = s, kn[1] = o, Rn[0] = s, Rn[1] = o;
          break;
        case Bt.L:
          Pl(n, i, e[a], e[a + 1], kn, Rn), n = e[a++], i = e[a++];
          break;
        case Bt.C:
          dy(
            n,
            i,
            e[a++],
            e[a++],
            e[a++],
            e[a++],
            e[a],
            e[a + 1],
            kn,
            Rn
          ), n = e[a++], i = e[a++];
          break;
        case Bt.Q:
          py(
            n,
            i,
            e[a++],
            e[a++],
            e[a],
            e[a + 1],
            kn,
            Rn
          ), n = e[a++], i = e[a++];
          break;
        case Bt.A:
          const l = e[a++], u = e[a++], f = e[a++], d = e[a++], p = e[a++], y = e[a++] + p;
          a += 1;
          const x = !e[a++];
          c && (s = Yi(p) * f + l, o = Hi(p) * d + u), yy(
            l,
            u,
            f,
            d,
            p,
            y,
            x,
            kn,
            Rn
          ), n = Yi(y) * f + l, i = Hi(y) * d + u;
          break;
        case Bt.R:
          s = n = e[a++], o = i = e[a++];
          const m = e[a++], g = e[a++];
          Pl(s, o, s + m, o + g, kn, Rn);
          break;
        case Bt.Z:
          n = s, i = o;
          break;
      }
      et.min(In, In, kn), et.max(yi, yi, Rn);
    }
    return a === 0 && (In[0] = In[1] = yi[0] = yi[1] = 0), new ce(
      In[0],
      In[1],
      yi[0] - In[0],
      yi[1] - In[1]
    );
  }
  _calculateLength() {
    const e = this.data, n = this._len, i = this._ux, s = this._uy;
    let o = 0, a = 0, h = 0, c = 0;
    this._pathSegLen || (this._pathSegLen = []);
    const l = this._pathSegLen;
    let u = 0, f = 0;
    for (let d = 0; d < n; ) {
      const p = e[d++], y = d === 1;
      y && (o = e[d], a = e[d + 1], h = o, c = a);
      let x = -1;
      switch (p) {
        case Bt.M:
          o = h = e[d++], a = c = e[d++];
          break;
        case Bt.L: {
          const I = e[d++], b = e[d++], v = I - o, _ = b - a;
          (Hn(v) > i || Hn(_) > s || d === n - 1) && (x = Math.sqrt(v * v + _ * _), o = I, a = b);
          break;
        }
        case Bt.C: {
          const I = e[d++], b = e[d++], v = e[d++], _ = e[d++], z = e[d++], P = e[d++];
          x = C1(o, a, I, b, v, _, z, P, 10), o = z, a = P;
          break;
        }
        case Bt.Q: {
          const I = e[d++], b = e[d++], v = e[d++], _ = e[d++];
          x = I1(o, a, I, b, v, _, 10), o = v, a = _;
          break;
        }
        case Bt.A:
          const m = e[d++], g = e[d++], w = e[d++], M = e[d++], S = e[d++];
          let E = e[d++];
          const A = E + S;
          d += 1, y && (h = Yi(S) * w + m, c = Hi(S) * M + g), x = gc(w, M) * mc(Ti, Math.abs(E)), o = Yi(A) * w + m, a = Hi(A) * M + g;
          break;
        case Bt.R: {
          h = o = e[d++], c = a = e[d++];
          const I = e[d++], b = e[d++];
          x = I * 2 + b * 2;
          break;
        }
        case Bt.Z: {
          const I = h - o, b = c - a;
          x = Math.sqrt(I * I + b * b), o = h, a = c;
          break;
        }
      }
      x >= 0 && (l[f++] = x, u += x);
    }
    return this._pathLen = u, u;
  }
  /**
   * Rebuild path from current data
   * Rebuild path will not consider javascript implemented line dash.
   * @param {CanvasRenderingContext2D} ctx
   */
  rebuildPath(e, n) {
    const i = this.data, s = this._ux, o = this._uy, a = this._len;
    let h = 0, c = 0, l = 0, u = 0, f = 0, d = 0;
    const p = n < 1;
    let y = [], x, m = 0, g = 0, w = 0, M = 0, S = 0, E = 0;
    if (!(p && (this._pathSegLen || this._calculateLength(), y = this._pathSegLen, x = this._pathLen, w = n * x, !w)))
      t: for (let A = 0; A < a; ) {
        const I = i[A++], b = A === 1;
        switch (b && (l = i[A], u = i[A + 1], h = l, c = u), I !== Bt.L && M > 0 && (e.lineTo(S, E), M = 0), I) {
          case Bt.M:
            h = l = i[A++], c = u = i[A++], e.moveTo(l, u);
            break;
          case Bt.L: {
            f = i[A++], d = i[A++];
            const ot = Hn(f - l), ut = Hn(d - u);
            if (ot > s || ut > o) {
              if (p) {
                const ct = y[g++];
                if (m + ct > w) {
                  const gt = (w - m) / ct;
                  e.lineTo(l * (1 - gt) + f * gt, u * (1 - gt) + d * gt);
                  break t;
                }
                m += ct;
              }
              e.lineTo(f, d), l = f, u = d, M = 0;
            } else {
              const ct = ot * ot + ut * ut;
              ct > M && (S = f, E = d, M = ct);
            }
            break;
          }
          case Bt.C: {
            const ot = i[A++], ut = i[A++], ct = i[A++], gt = i[A++], Nt = i[A++], ne = i[A++];
            if (p) {
              const Qt = y[g++];
              if (m + Qt > w) {
                const Oe = (w - m) / Qt;
                wl(l, ot, ct, Nt, Oe, Wi), wl(u, ut, gt, ne, Oe, ji), e.bezierCurveTo(Wi[1], ji[1], Wi[2], ji[2], Wi[3], ji[3]);
                break t;
              }
              m += Qt;
            }
            e.bezierCurveTo(ot, ut, ct, gt, Nt, ne), l = Nt, u = ne;
            break;
          }
          case Bt.Q: {
            const ot = i[A++], ut = i[A++], ct = i[A++], gt = i[A++];
            if (p) {
              const Nt = y[g++];
              if (m + Nt > w) {
                const ne = (w - m) / Nt;
                bl(l, ot, ct, ne, Wi), bl(u, ut, gt, ne, ji), e.quadraticCurveTo(Wi[1], ji[1], Wi[2], ji[2]);
                break t;
              }
              m += Nt;
            }
            e.quadraticCurveTo(ot, ut, ct, gt), l = ct, u = gt;
            break;
          }
          case Bt.A:
            const v = i[A++], _ = i[A++], z = i[A++], P = i[A++];
            let k = i[A++], B = i[A++];
            const R = i[A++], L = !i[A++], N = z > P ? z : P, q = Hn(z - P) > 1e-3;
            let U = k + B, J = !1;
            if (p) {
              const ot = y[g++];
              m + ot > w && (U = k + B * (w - m) / ot, J = !0), m += ot;
            }
            if (q && e.ellipse ? e.ellipse(v, _, z, P, R, k, U, L) : e.arc(v, _, N, k, U, L), J)
              break t;
            b && (h = Yi(k) * z + v, c = Hi(k) * P + _), l = Yi(U) * z + v, u = Hi(U) * P + _;
            break;
          case Bt.R:
            h = l = i[A], c = u = i[A + 1], f = i[A++], d = i[A++];
            const X = i[A++], lt = i[A++];
            if (p) {
              const ot = y[g++];
              if (m + ot > w) {
                let ut = w - m;
                e.moveTo(f, d), e.lineTo(f + mc(ut, X), d), ut -= X, ut > 0 && e.lineTo(f + X, d + mc(ut, lt)), ut -= lt, ut > 0 && e.lineTo(f + gc(X - ut, 0), d + lt), ut -= X, ut > 0 && e.lineTo(f, d + gc(lt - ut, 0));
                break t;
              }
              m += ot;
            }
            e.rect(f, d, X, lt);
            break;
          case Bt.Z:
            if (p) {
              const ot = y[g++];
              if (m + ot > w) {
                const ut = (w - m) / ot;
                e.lineTo(l * (1 - ut) + h * ut, u * (1 - ut) + c * ut);
                break t;
              }
              m += ot;
            }
            e.closePath(), l = h, u = c;
        }
      }
  }
  clone() {
    const e = new Rl(), n = this.data;
    return e.data = n.slice ? n.slice() : Array.prototype.slice.call(n), e._len = this._len, e;
  }
  canSave() {
    return !!this._saveData;
  }
  static initDefaultProps = function() {
    const e = Rl.prototype;
    e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
  }();
}
const Lv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Entry: Au,
  LinkedList: hy,
  createIntersectContext: ay,
  fromArc: yy,
  fromCubic: dy,
  fromLine: Pl,
  fromPoints: Rv,
  fromQuadratic: py,
  normalizeArcAngles: xy
}, Symbol.toStringTag, { value: "Module" })), my = (r) => () => r, Ol = (r) => {
  const e = r ? (n, i) => i.minus(n).abs().isLessThanOrEqualTo(r) : my(!1);
  return (n, i) => e(n, i) ? 0 : n.comparedTo(i);
};
function Bv(r) {
  const e = r ? (n, i, s, o, a) => n.exponentiatedBy(2).isLessThanOrEqualTo(
    o.minus(i).exponentiatedBy(2).plus(a.minus(s).exponentiatedBy(2)).times(r)
  ) : my(!1);
  return (n, i, s) => {
    const o = n.x, a = n.y, h = s.x, c = s.y, l = a.minus(c).times(i.x.minus(h)).minus(o.minus(h).times(i.y.minus(c)));
    return e(l, o, a, h, c) ? 0 : l.comparedTo(0);
  };
}
var Fv = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, vc = Math.ceil, Je = Math.floor, Fe = "[BigNumber Error] ", Td = Fe + "Number primitive has more than 15 significant digits: ", un = 1e14, vt = 14, Mc = 9007199254740991, _c = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], xi = 1e7, oe = 1e9;
function gy(r) {
  var e, n, i, s = w.prototype = { constructor: w, toString: null, valueOf: null }, o = new w(1), a = 20, h = 4, c = -7, l = 21, u = -1e7, f = 1e7, d = !1, p = 1, y = 0, x = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, m = "0123456789abcdefghijklmnopqrstuvwxyz", g = !0;
  function w(b, v) {
    var _, z, P, k, B, R, L, N, q = this;
    if (!(q instanceof w)) return new w(b, v);
    if (v == null) {
      if (b && b._isBigNumber === !0) {
        q.s = b.s, !b.c || b.e > f ? q.c = q.e = null : b.e < u ? q.c = [q.e = 0] : (q.e = b.e, q.c = b.c.slice());
        return;
      }
      if ((R = typeof b == "number") && b * 0 == 0) {
        if (q.s = 1 / b < 0 ? (b = -b, -1) : 1, b === ~~b) {
          for (k = 0, B = b; B >= 10; B /= 10, k++) ;
          k > f ? q.c = q.e = null : (q.e = k, q.c = [b]);
          return;
        }
        N = String(b);
      } else {
        if (!Fv.test(N = String(b))) return i(q, N, R);
        q.s = N.charCodeAt(0) == 45 ? (N = N.slice(1), -1) : 1;
      }
      (k = N.indexOf(".")) > -1 && (N = N.replace(".", "")), (B = N.search(/e/i)) > 0 ? (k < 0 && (k = B), k += +N.slice(B + 1), N = N.substring(0, B)) : k < 0 && (k = N.length);
    } else {
      if (jt(v, 2, m.length, "Base"), v == 10 && g)
        return q = new w(b), A(q, a + q.e + 1, h);
      if (N = String(b), R = typeof b == "number") {
        if (b * 0 != 0) return i(q, N, R, v);
        if (q.s = 1 / b < 0 ? (N = N.slice(1), -1) : 1, w.DEBUG && N.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Td + b);
      } else
        q.s = N.charCodeAt(0) === 45 ? (N = N.slice(1), -1) : 1;
      for (_ = m.slice(0, v), k = B = 0, L = N.length; B < L; B++)
        if (_.indexOf(z = N.charAt(B)) < 0) {
          if (z == ".") {
            if (B > k) {
              k = L;
              continue;
            }
          } else if (!P && (N == N.toUpperCase() && (N = N.toLowerCase()) || N == N.toLowerCase() && (N = N.toUpperCase()))) {
            P = !0, B = -1, k = 0;
            continue;
          }
          return i(q, String(b), R, v);
        }
      R = !1, N = n(N, v, 10, q.s), (k = N.indexOf(".")) > -1 ? N = N.replace(".", "") : k = N.length;
    }
    for (B = 0; N.charCodeAt(B) === 48; B++) ;
    for (L = N.length; N.charCodeAt(--L) === 48; ) ;
    if (N = N.slice(B, ++L)) {
      if (L -= B, R && w.DEBUG && L > 15 && (b > Mc || b !== Je(b)))
        throw Error(Td + q.s * b);
      if ((k = k - B - 1) > f)
        q.c = q.e = null;
      else if (k < u)
        q.c = [q.e = 0];
      else {
        if (q.e = k, q.c = [], B = (k + 1) % vt, k < 0 && (B += vt), B < L) {
          for (B && q.c.push(+N.slice(0, B)), L -= vt; B < L; )
            q.c.push(+N.slice(B, B += vt));
          B = vt - (N = N.slice(B)).length;
        } else
          B -= L;
        for (; B--; N += "0") ;
        q.c.push(+N);
      }
    } else
      q.c = [q.e = 0];
  }
  w.clone = gy, w.ROUND_UP = 0, w.ROUND_DOWN = 1, w.ROUND_CEIL = 2, w.ROUND_FLOOR = 3, w.ROUND_HALF_UP = 4, w.ROUND_HALF_DOWN = 5, w.ROUND_HALF_EVEN = 6, w.ROUND_HALF_CEIL = 7, w.ROUND_HALF_FLOOR = 8, w.EUCLID = 9, w.config = w.set = function(b) {
    var v, _;
    if (b != null)
      if (typeof b == "object") {
        if (b.hasOwnProperty(v = "DECIMAL_PLACES") && (_ = b[v], jt(_, 0, oe, v), a = _), b.hasOwnProperty(v = "ROUNDING_MODE") && (_ = b[v], jt(_, 0, 8, v), h = _), b.hasOwnProperty(v = "EXPONENTIAL_AT") && (_ = b[v], _ && _.pop ? (jt(_[0], -oe, 0, v), jt(_[1], 0, oe, v), c = _[0], l = _[1]) : (jt(_, -oe, oe, v), c = -(l = _ < 0 ? -_ : _))), b.hasOwnProperty(v = "RANGE"))
          if (_ = b[v], _ && _.pop)
            jt(_[0], -oe, -1, v), jt(_[1], 1, oe, v), u = _[0], f = _[1];
          else if (jt(_, -oe, oe, v), _)
            u = -(f = _ < 0 ? -_ : _);
          else
            throw Error(Fe + v + " cannot be zero: " + _);
        if (b.hasOwnProperty(v = "CRYPTO"))
          if (_ = b[v], _ === !!_)
            if (_)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                d = _;
              else
                throw d = !_, Error(Fe + "crypto unavailable");
            else
              d = _;
          else
            throw Error(Fe + v + " not true or false: " + _);
        if (b.hasOwnProperty(v = "MODULO_MODE") && (_ = b[v], jt(_, 0, 9, v), p = _), b.hasOwnProperty(v = "POW_PRECISION") && (_ = b[v], jt(_, 0, oe, v), y = _), b.hasOwnProperty(v = "FORMAT"))
          if (_ = b[v], typeof _ == "object") x = _;
          else throw Error(Fe + v + " not an object: " + _);
        if (b.hasOwnProperty(v = "ALPHABET"))
          if (_ = b[v], typeof _ == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(_))
            g = _.slice(0, 10) == "0123456789", m = _;
          else
            throw Error(Fe + v + " invalid: " + _);
      } else
        throw Error(Fe + "Object expected: " + b);
    return {
      DECIMAL_PLACES: a,
      ROUNDING_MODE: h,
      EXPONENTIAL_AT: [c, l],
      RANGE: [u, f],
      CRYPTO: d,
      MODULO_MODE: p,
      POW_PRECISION: y,
      FORMAT: x,
      ALPHABET: m
    };
  }, w.isBigNumber = function(b) {
    if (!b || b._isBigNumber !== !0) return !1;
    if (!w.DEBUG) return !0;
    var v, _, z = b.c, P = b.e, k = b.s;
    t: if ({}.toString.call(z) == "[object Array]") {
      if ((k === 1 || k === -1) && P >= -oe && P <= oe && P === Je(P)) {
        if (z[0] === 0) {
          if (P === 0 && z.length === 1) return !0;
          break t;
        }
        if (v = (P + 1) % vt, v < 1 && (v += vt), String(z[0]).length == v) {
          for (v = 0; v < z.length; v++)
            if (_ = z[v], _ < 0 || _ >= un || _ !== Je(_)) break t;
          if (_ !== 0) return !0;
        }
      }
    } else if (z === null && P === null && (k === null || k === 1 || k === -1))
      return !0;
    throw Error(Fe + "Invalid BigNumber: " + b);
  }, w.maximum = w.max = function() {
    return S(arguments, -1);
  }, w.minimum = w.min = function() {
    return S(arguments, 1);
  }, w.random = function() {
    var b = 9007199254740992, v = Math.random() * b & 2097151 ? function() {
      return Je(Math.random() * b);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(_) {
      var z, P, k, B, R, L = 0, N = [], q = new w(o);
      if (_ == null ? _ = a : jt(_, 0, oe), B = vc(_ / vt), d)
        if (crypto.getRandomValues) {
          for (z = crypto.getRandomValues(new Uint32Array(B *= 2)); L < B; )
            R = z[L] * 131072 + (z[L + 1] >>> 11), R >= 9e15 ? (P = crypto.getRandomValues(new Uint32Array(2)), z[L] = P[0], z[L + 1] = P[1]) : (N.push(R % 1e14), L += 2);
          L = B / 2;
        } else if (crypto.randomBytes) {
          for (z = crypto.randomBytes(B *= 7); L < B; )
            R = (z[L] & 31) * 281474976710656 + z[L + 1] * 1099511627776 + z[L + 2] * 4294967296 + z[L + 3] * 16777216 + (z[L + 4] << 16) + (z[L + 5] << 8) + z[L + 6], R >= 9e15 ? crypto.randomBytes(7).copy(z, L) : (N.push(R % 1e14), L += 7);
          L = B / 7;
        } else
          throw d = !1, Error(Fe + "crypto unavailable");
      if (!d)
        for (; L < B; )
          R = v(), R < 9e15 && (N[L++] = R % 1e14);
      for (B = N[--L], _ %= vt, B && _ && (R = _c[vt - _], N[L] = Je(B / R) * R); N[L] === 0; N.pop(), L--) ;
      if (L < 0)
        N = [k = 0];
      else {
        for (k = -1; N[0] === 0; N.splice(0, 1), k -= vt) ;
        for (L = 1, R = N[0]; R >= 10; R /= 10, L++) ;
        L < vt && (k -= vt - L);
      }
      return q.e = k, q.c = N, q;
    };
  }(), w.sum = function() {
    for (var b = 1, v = arguments, _ = new w(v[0]); b < v.length; ) _ = _.plus(v[b++]);
    return _;
  }, n = /* @__PURE__ */ function() {
    var b = "0123456789";
    function v(_, z, P, k) {
      for (var B, R = [0], L, N = 0, q = _.length; N < q; ) {
        for (L = R.length; L--; R[L] *= z) ;
        for (R[0] += k.indexOf(_.charAt(N++)), B = 0; B < R.length; B++)
          R[B] > P - 1 && (R[B + 1] == null && (R[B + 1] = 0), R[B + 1] += R[B] / P | 0, R[B] %= P);
      }
      return R.reverse();
    }
    return function(_, z, P, k, B) {
      var R, L, N, q, U, J, X, lt, ot = _.indexOf("."), ut = a, ct = h;
      for (ot >= 0 && (q = y, y = 0, _ = _.replace(".", ""), lt = new w(z), J = lt.pow(_.length - ot), y = q, lt.c = v(
        Xn(Ze(J.c), J.e, "0"),
        10,
        P,
        b
      ), lt.e = lt.c.length), X = v(_, z, P, B ? (R = m, b) : (R = b, m)), N = q = X.length; X[--q] == 0; X.pop()) ;
      if (!X[0]) return R.charAt(0);
      if (ot < 0 ? --N : (J.c = X, J.e = N, J.s = k, J = e(J, lt, ut, ct, P), X = J.c, U = J.r, N = J.e), L = N + ut + 1, ot = X[L], q = P / 2, U = U || L < 0 || X[L + 1] != null, U = ct < 4 ? (ot != null || U) && (ct == 0 || ct == (J.s < 0 ? 3 : 2)) : ot > q || ot == q && (ct == 4 || U || ct == 6 && X[L - 1] & 1 || ct == (J.s < 0 ? 8 : 7)), L < 1 || !X[0])
        _ = U ? Xn(R.charAt(1), -ut, R.charAt(0)) : R.charAt(0);
      else {
        if (X.length = L, U)
          for (--P; ++X[--L] > P; )
            X[L] = 0, L || (++N, X = [1].concat(X));
        for (q = X.length; !X[--q]; ) ;
        for (ot = 0, _ = ""; ot <= q; _ += R.charAt(X[ot++])) ;
        _ = Xn(_, N, R.charAt(0));
      }
      return _;
    };
  }(), e = /* @__PURE__ */ function() {
    function b(z, P, k) {
      var B, R, L, N, q = 0, U = z.length, J = P % xi, X = P / xi | 0;
      for (z = z.slice(); U--; )
        L = z[U] % xi, N = z[U] / xi | 0, B = X * L + N * J, R = J * L + B % xi * xi + q, q = (R / k | 0) + (B / xi | 0) + X * N, z[U] = R % k;
      return q && (z = [q].concat(z)), z;
    }
    function v(z, P, k, B) {
      var R, L;
      if (k != B)
        L = k > B ? 1 : -1;
      else
        for (R = L = 0; R < k; R++)
          if (z[R] != P[R]) {
            L = z[R] > P[R] ? 1 : -1;
            break;
          }
      return L;
    }
    function _(z, P, k, B) {
      for (var R = 0; k--; )
        z[k] -= R, R = z[k] < P[k] ? 1 : 0, z[k] = R * B + z[k] - P[k];
      for (; !z[0] && z.length > 1; z.splice(0, 1)) ;
    }
    return function(z, P, k, B, R) {
      var L, N, q, U, J, X, lt, ot, ut, ct, gt, Nt, ne, Qt, Oe, xe, re, Ut = z.s == P.s ? 1 : -1, G = z.c, Q = P.c;
      if (!G || !G[0] || !Q || !Q[0])
        return new w(
          // Return NaN if either NaN, or both Infinity or 0.
          !z.s || !P.s || (G ? Q && G[0] == Q[0] : !Q) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            G && G[0] == 0 || !Q ? Ut * 0 : Ut / 0
          )
        );
      for (ot = new w(Ut), ut = ot.c = [], N = z.e - P.e, Ut = k + N + 1, R || (R = un, N = Qe(z.e / vt) - Qe(P.e / vt), Ut = Ut / vt | 0), q = 0; Q[q] == (G[q] || 0); q++) ;
      if (Q[q] > (G[q] || 0) && N--, Ut < 0)
        ut.push(1), U = !0;
      else {
        for (Qt = G.length, xe = Q.length, q = 0, Ut += 2, J = Je(R / (Q[0] + 1)), J > 1 && (Q = b(Q, J, R), G = b(G, J, R), xe = Q.length, Qt = G.length), ne = xe, ct = G.slice(0, xe), gt = ct.length; gt < xe; ct[gt++] = 0) ;
        re = Q.slice(), re = [0].concat(re), Oe = Q[0], Q[1] >= R / 2 && Oe++;
        do {
          if (J = 0, L = v(Q, ct, xe, gt), L < 0) {
            if (Nt = ct[0], xe != gt && (Nt = Nt * R + (ct[1] || 0)), J = Je(Nt / Oe), J > 1)
              for (J >= R && (J = R - 1), X = b(Q, J, R), lt = X.length, gt = ct.length; v(X, ct, lt, gt) == 1; )
                J--, _(X, xe < lt ? re : Q, lt, R), lt = X.length, L = 1;
            else
              J == 0 && (L = J = 1), X = Q.slice(), lt = X.length;
            if (lt < gt && (X = [0].concat(X)), _(ct, X, gt, R), gt = ct.length, L == -1)
              for (; v(Q, ct, xe, gt) < 1; )
                J++, _(ct, xe < gt ? re : Q, gt, R), gt = ct.length;
          } else L === 0 && (J++, ct = [0]);
          ut[q++] = J, ct[0] ? ct[gt++] = G[ne] || 0 : (ct = [G[ne]], gt = 1);
        } while ((ne++ < Qt || ct[0] != null) && Ut--);
        U = ct[0] != null, ut[0] || ut.splice(0, 1);
      }
      if (R == un) {
        for (q = 1, Ut = ut[0]; Ut >= 10; Ut /= 10, q++) ;
        A(ot, k + (ot.e = q + N * vt - 1) + 1, B, U);
      } else
        ot.e = N, ot.r = +U;
      return ot;
    };
  }();
  function M(b, v, _, z) {
    var P, k, B, R, L;
    if (_ == null ? _ = h : jt(_, 0, 8), !b.c) return b.toString();
    if (P = b.c[0], B = b.e, v == null)
      L = Ze(b.c), L = z == 1 || z == 2 && (B <= c || B >= l) ? la(L, B) : Xn(L, B, "0");
    else if (b = A(new w(b), v, _), k = b.e, L = Ze(b.c), R = L.length, z == 1 || z == 2 && (v <= k || k <= c)) {
      for (; R < v; L += "0", R++) ;
      L = la(L, k);
    } else if (v -= B, L = Xn(L, k, "0"), k + 1 > R) {
      if (--v > 0) for (L += "."; v--; L += "0") ;
    } else if (v += k - R, v > 0)
      for (k + 1 == R && (L += "."); v--; L += "0") ;
    return b.s < 0 && P ? "-" + L : L;
  }
  function S(b, v) {
    for (var _, z, P = 1, k = new w(b[0]); P < b.length; P++)
      z = new w(b[P]), (!z.s || (_ = Xi(k, z)) === v || _ === 0 && k.s === v) && (k = z);
    return k;
  }
  function E(b, v, _) {
    for (var z = 1, P = v.length; !v[--P]; v.pop()) ;
    for (P = v[0]; P >= 10; P /= 10, z++) ;
    return (_ = z + _ * vt - 1) > f ? b.c = b.e = null : _ < u ? b.c = [b.e = 0] : (b.e = _, b.c = v), b;
  }
  i = /* @__PURE__ */ function() {
    var b = /^(-?)0([xbo])(?=\w[\w.]*$)/i, v = /^([^.]+)\.$/, _ = /^\.([^.]+)$/, z = /^-?(Infinity|NaN)$/, P = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(k, B, R, L) {
      var N, q = R ? B : B.replace(P, "");
      if (z.test(q))
        k.s = isNaN(q) ? null : q < 0 ? -1 : 1;
      else {
        if (!R && (q = q.replace(b, function(U, J, X) {
          return N = (X = X.toLowerCase()) == "x" ? 16 : X == "b" ? 2 : 8, !L || L == N ? J : U;
        }), L && (N = L, q = q.replace(v, "$1").replace(_, "0.$1")), B != q))
          return new w(q, N);
        if (w.DEBUG)
          throw Error(Fe + "Not a" + (L ? " base " + L : "") + " number: " + B);
        k.s = null;
      }
      k.c = k.e = null;
    };
  }();
  function A(b, v, _, z) {
    var P, k, B, R, L, N, q, U = b.c, J = _c;
    if (U) {
      t: {
        for (P = 1, R = U[0]; R >= 10; R /= 10, P++) ;
        if (k = v - P, k < 0)
          k += vt, B = v, L = U[N = 0], q = Je(L / J[P - B - 1] % 10);
        else if (N = vc((k + 1) / vt), N >= U.length)
          if (z) {
            for (; U.length <= N; U.push(0)) ;
            L = q = 0, P = 1, k %= vt, B = k - vt + 1;
          } else
            break t;
        else {
          for (L = R = U[N], P = 1; R >= 10; R /= 10, P++) ;
          k %= vt, B = k - vt + P, q = B < 0 ? 0 : Je(L / J[P - B - 1] % 10);
        }
        if (z = z || v < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        U[N + 1] != null || (B < 0 ? L : L % J[P - B - 1]), z = _ < 4 ? (q || z) && (_ == 0 || _ == (b.s < 0 ? 3 : 2)) : q > 5 || q == 5 && (_ == 4 || z || _ == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (k > 0 ? B > 0 ? L / J[P - B] : 0 : U[N - 1]) % 10 & 1 || _ == (b.s < 0 ? 8 : 7)), v < 1 || !U[0])
          return U.length = 0, z ? (v -= b.e + 1, U[0] = J[(vt - v % vt) % vt], b.e = -v || 0) : U[0] = b.e = 0, b;
        if (k == 0 ? (U.length = N, R = 1, N--) : (U.length = N + 1, R = J[vt - k], U[N] = B > 0 ? Je(L / J[P - B] % J[B]) * R : 0), z)
          for (; ; )
            if (N == 0) {
              for (k = 1, B = U[0]; B >= 10; B /= 10, k++) ;
              for (B = U[0] += R, R = 1; B >= 10; B /= 10, R++) ;
              k != R && (b.e++, U[0] == un && (U[0] = 1));
              break;
            } else {
              if (U[N] += R, U[N] != un) break;
              U[N--] = 0, R = 1;
            }
        for (k = U.length; U[--k] === 0; U.pop()) ;
      }
      b.e > f ? b.c = b.e = null : b.e < u && (b.c = [b.e = 0]);
    }
    return b;
  }
  function I(b) {
    var v, _ = b.e;
    return _ === null ? b.toString() : (v = Ze(b.c), v = _ <= c || _ >= l ? la(v, _) : Xn(v, _, "0"), b.s < 0 ? "-" + v : v);
  }
  return s.absoluteValue = s.abs = function() {
    var b = new w(this);
    return b.s < 0 && (b.s = 1), b;
  }, s.comparedTo = function(b, v) {
    return Xi(this, new w(b, v));
  }, s.decimalPlaces = s.dp = function(b, v) {
    var _, z, P, k = this;
    if (b != null)
      return jt(b, 0, oe), v == null ? v = h : jt(v, 0, 8), A(new w(k), b + k.e + 1, v);
    if (!(_ = k.c)) return null;
    if (z = ((P = _.length - 1) - Qe(this.e / vt)) * vt, P = _[P]) for (; P % 10 == 0; P /= 10, z--) ;
    return z < 0 && (z = 0), z;
  }, s.dividedBy = s.div = function(b, v) {
    return e(this, new w(b, v), a, h);
  }, s.dividedToIntegerBy = s.idiv = function(b, v) {
    return e(this, new w(b, v), 0, 1);
  }, s.exponentiatedBy = s.pow = function(b, v) {
    var _, z, P, k, B, R, L, N, q, U = this;
    if (b = new w(b), b.c && !b.isInteger())
      throw Error(Fe + "Exponent not an integer: " + I(b));
    if (v != null && (v = new w(v)), R = b.e > 14, !U.c || !U.c[0] || U.c[0] == 1 && !U.e && U.c.length == 1 || !b.c || !b.c[0])
      return q = new w(Math.pow(+I(U), R ? b.s * (2 - ca(b)) : +I(b))), v ? q.mod(v) : q;
    if (L = b.s < 0, v) {
      if (v.c ? !v.c[0] : !v.s) return new w(NaN);
      z = !L && U.isInteger() && v.isInteger(), z && (U = U.mod(v));
    } else {
      if (b.e > 9 && (U.e > 0 || U.e < -1 || (U.e == 0 ? U.c[0] > 1 || R && U.c[1] >= 24e7 : U.c[0] < 8e13 || R && U.c[0] <= 9999975e7)))
        return k = U.s < 0 && ca(b) ? -0 : 0, U.e > -1 && (k = 1 / k), new w(L ? 1 / k : k);
      y && (k = vc(y / vt + 2));
    }
    for (R ? (_ = new w(0.5), L && (b.s = 1), N = ca(b)) : (P = Math.abs(+I(b)), N = P % 2), q = new w(o); ; ) {
      if (N) {
        if (q = q.times(U), !q.c) break;
        k ? q.c.length > k && (q.c.length = k) : z && (q = q.mod(v));
      }
      if (P) {
        if (P = Je(P / 2), P === 0) break;
        N = P % 2;
      } else if (b = b.times(_), A(b, b.e + 1, 1), b.e > 14)
        N = ca(b);
      else {
        if (P = +I(b), P === 0) break;
        N = P % 2;
      }
      U = U.times(U), k ? U.c && U.c.length > k && (U.c.length = k) : z && (U = U.mod(v));
    }
    return z ? q : (L && (q = o.div(q)), v ? q.mod(v) : k ? A(q, y, h, B) : q);
  }, s.integerValue = function(b) {
    var v = new w(this);
    return b == null ? b = h : jt(b, 0, 8), A(v, v.e + 1, b);
  }, s.isEqualTo = s.eq = function(b, v) {
    return Xi(this, new w(b, v)) === 0;
  }, s.isFinite = function() {
    return !!this.c;
  }, s.isGreaterThan = s.gt = function(b, v) {
    return Xi(this, new w(b, v)) > 0;
  }, s.isGreaterThanOrEqualTo = s.gte = function(b, v) {
    return (v = Xi(this, new w(b, v))) === 1 || v === 0;
  }, s.isInteger = function() {
    return !!this.c && Qe(this.e / vt) > this.c.length - 2;
  }, s.isLessThan = s.lt = function(b, v) {
    return Xi(this, new w(b, v)) < 0;
  }, s.isLessThanOrEqualTo = s.lte = function(b, v) {
    return (v = Xi(this, new w(b, v))) === -1 || v === 0;
  }, s.isNaN = function() {
    return !this.s;
  }, s.isNegative = function() {
    return this.s < 0;
  }, s.isPositive = function() {
    return this.s > 0;
  }, s.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, s.minus = function(b, v) {
    var _, z, P, k, B = this, R = B.s;
    if (b = new w(b, v), v = b.s, !R || !v) return new w(NaN);
    if (R != v)
      return b.s = -v, B.plus(b);
    var L = B.e / vt, N = b.e / vt, q = B.c, U = b.c;
    if (!L || !N) {
      if (!q || !U) return q ? (b.s = -v, b) : new w(U ? B : NaN);
      if (!q[0] || !U[0])
        return U[0] ? (b.s = -v, b) : new w(q[0] ? B : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          h == 3 ? -0 : 0
        ));
    }
    if (L = Qe(L), N = Qe(N), q = q.slice(), R = L - N) {
      for ((k = R < 0) ? (R = -R, P = q) : (N = L, P = U), P.reverse(), v = R; v--; P.push(0)) ;
      P.reverse();
    } else
      for (z = (k = (R = q.length) < (v = U.length)) ? R : v, R = v = 0; v < z; v++)
        if (q[v] != U[v]) {
          k = q[v] < U[v];
          break;
        }
    if (k && (P = q, q = U, U = P, b.s = -b.s), v = (z = U.length) - (_ = q.length), v > 0) for (; v--; q[_++] = 0) ;
    for (v = un - 1; z > R; ) {
      if (q[--z] < U[z]) {
        for (_ = z; _ && !q[--_]; q[_] = v) ;
        --q[_], q[z] += un;
      }
      q[z] -= U[z];
    }
    for (; q[0] == 0; q.splice(0, 1), --N) ;
    return q[0] ? E(b, q, N) : (b.s = h == 3 ? -1 : 1, b.c = [b.e = 0], b);
  }, s.modulo = s.mod = function(b, v) {
    var _, z, P = this;
    return b = new w(b, v), !P.c || !b.s || b.c && !b.c[0] ? new w(NaN) : !b.c || P.c && !P.c[0] ? new w(P) : (p == 9 ? (z = b.s, b.s = 1, _ = e(P, b, 0, 3), b.s = z, _.s *= z) : _ = e(P, b, 0, p), b = P.minus(_.times(b)), !b.c[0] && p == 1 && (b.s = P.s), b);
  }, s.multipliedBy = s.times = function(b, v) {
    var _, z, P, k, B, R, L, N, q, U, J, X, lt, ot, ut, ct = this, gt = ct.c, Nt = (b = new w(b, v)).c;
    if (!gt || !Nt || !gt[0] || !Nt[0])
      return !ct.s || !b.s || gt && !gt[0] && !Nt || Nt && !Nt[0] && !gt ? b.c = b.e = b.s = null : (b.s *= ct.s, !gt || !Nt ? b.c = b.e = null : (b.c = [0], b.e = 0)), b;
    for (z = Qe(ct.e / vt) + Qe(b.e / vt), b.s *= ct.s, L = gt.length, U = Nt.length, L < U && (lt = gt, gt = Nt, Nt = lt, P = L, L = U, U = P), P = L + U, lt = []; P--; lt.push(0)) ;
    for (ot = un, ut = xi, P = U; --P >= 0; ) {
      for (_ = 0, J = Nt[P] % ut, X = Nt[P] / ut | 0, B = L, k = P + B; k > P; )
        N = gt[--B] % ut, q = gt[B] / ut | 0, R = X * N + q * J, N = J * N + R % ut * ut + lt[k] + _, _ = (N / ot | 0) + (R / ut | 0) + X * q, lt[k--] = N % ot;
      lt[k] = _;
    }
    return _ ? ++z : lt.splice(0, 1), E(b, lt, z);
  }, s.negated = function() {
    var b = new w(this);
    return b.s = -b.s || null, b;
  }, s.plus = function(b, v) {
    var _, z = this, P = z.s;
    if (b = new w(b, v), v = b.s, !P || !v) return new w(NaN);
    if (P != v)
      return b.s = -v, z.minus(b);
    var k = z.e / vt, B = b.e / vt, R = z.c, L = b.c;
    if (!k || !B) {
      if (!R || !L) return new w(P / 0);
      if (!R[0] || !L[0]) return L[0] ? b : new w(R[0] ? z : P * 0);
    }
    if (k = Qe(k), B = Qe(B), R = R.slice(), P = k - B) {
      for (P > 0 ? (B = k, _ = L) : (P = -P, _ = R), _.reverse(); P--; _.push(0)) ;
      _.reverse();
    }
    for (P = R.length, v = L.length, P - v < 0 && (_ = L, L = R, R = _, v = P), P = 0; v; )
      P = (R[--v] = R[v] + L[v] + P) / un | 0, R[v] = un === R[v] ? 0 : R[v] % un;
    return P && (R = [P].concat(R), ++B), E(b, R, B);
  }, s.precision = s.sd = function(b, v) {
    var _, z, P, k = this;
    if (b != null && b !== !!b)
      return jt(b, 1, oe), v == null ? v = h : jt(v, 0, 8), A(new w(k), b, v);
    if (!(_ = k.c)) return null;
    if (P = _.length - 1, z = P * vt + 1, P = _[P]) {
      for (; P % 10 == 0; P /= 10, z--) ;
      for (P = _[0]; P >= 10; P /= 10, z++) ;
    }
    return b && k.e + 1 > z && (z = k.e + 1), z;
  }, s.shiftedBy = function(b) {
    return jt(b, -Mc, Mc), this.times("1e" + b);
  }, s.squareRoot = s.sqrt = function() {
    var b, v, _, z, P, k = this, B = k.c, R = k.s, L = k.e, N = a + 4, q = new w("0.5");
    if (R !== 1 || !B || !B[0])
      return new w(!R || R < 0 && (!B || B[0]) ? NaN : B ? k : 1 / 0);
    if (R = Math.sqrt(+I(k)), R == 0 || R == 1 / 0 ? (v = Ze(B), (v.length + L) % 2 == 0 && (v += "0"), R = Math.sqrt(+v), L = Qe((L + 1) / 2) - (L < 0 || L % 2), R == 1 / 0 ? v = "5e" + L : (v = R.toExponential(), v = v.slice(0, v.indexOf("e") + 1) + L), _ = new w(v)) : _ = new w(R + ""), _.c[0]) {
      for (L = _.e, R = L + N, R < 3 && (R = 0); ; )
        if (P = _, _ = q.times(P.plus(e(k, P, N, 1))), Ze(P.c).slice(0, R) === (v = Ze(_.c)).slice(0, R))
          if (_.e < L && --R, v = v.slice(R - 3, R + 1), v == "9999" || !z && v == "4999") {
            if (!z && (A(P, P.e + a + 2, 0), P.times(P).eq(k))) {
              _ = P;
              break;
            }
            N += 4, R += 4, z = 1;
          } else {
            (!+v || !+v.slice(1) && v.charAt(0) == "5") && (A(_, _.e + a + 2, 1), b = !_.times(_).eq(k));
            break;
          }
    }
    return A(_, _.e + a + 1, h, b);
  }, s.toExponential = function(b, v) {
    return b != null && (jt(b, 0, oe), b++), M(this, b, v, 1);
  }, s.toFixed = function(b, v) {
    return b != null && (jt(b, 0, oe), b = b + this.e + 1), M(this, b, v);
  }, s.toFormat = function(b, v, _) {
    var z, P = this;
    if (_ == null)
      b != null && v && typeof v == "object" ? (_ = v, v = null) : b && typeof b == "object" ? (_ = b, b = v = null) : _ = x;
    else if (typeof _ != "object")
      throw Error(Fe + "Argument not an object: " + _);
    if (z = P.toFixed(b, v), P.c) {
      var k, B = z.split("."), R = +_.groupSize, L = +_.secondaryGroupSize, N = _.groupSeparator || "", q = B[0], U = B[1], J = P.s < 0, X = J ? q.slice(1) : q, lt = X.length;
      if (L && (k = R, R = L, L = k, lt -= k), R > 0 && lt > 0) {
        for (k = lt % R || R, q = X.substr(0, k); k < lt; k += R) q += N + X.substr(k, R);
        L > 0 && (q += N + X.slice(k)), J && (q = "-" + q);
      }
      z = U ? q + (_.decimalSeparator || "") + ((L = +_.fractionGroupSize) ? U.replace(
        new RegExp("\\d{" + L + "}\\B", "g"),
        "$&" + (_.fractionGroupSeparator || "")
      ) : U) : q;
    }
    return (_.prefix || "") + z + (_.suffix || "");
  }, s.toFraction = function(b) {
    var v, _, z, P, k, B, R, L, N, q, U, J, X = this, lt = X.c;
    if (b != null && (R = new w(b), !R.isInteger() && (R.c || R.s !== 1) || R.lt(o)))
      throw Error(Fe + "Argument " + (R.isInteger() ? "out of range: " : "not an integer: ") + I(R));
    if (!lt) return new w(X);
    for (v = new w(o), N = _ = new w(o), z = L = new w(o), J = Ze(lt), k = v.e = J.length - X.e - 1, v.c[0] = _c[(B = k % vt) < 0 ? vt + B : B], b = !b || R.comparedTo(v) > 0 ? k > 0 ? v : N : R, B = f, f = 1 / 0, R = new w(J), L.c[0] = 0; q = e(R, v, 0, 1), P = _.plus(q.times(z)), P.comparedTo(b) != 1; )
      _ = z, z = P, N = L.plus(q.times(P = N)), L = P, v = R.minus(q.times(P = v)), R = P;
    return P = e(b.minus(_), z, 0, 1), L = L.plus(P.times(N)), _ = _.plus(P.times(z)), L.s = N.s = X.s, k = k * 2, U = e(N, z, k, h).minus(X).abs().comparedTo(
      e(L, _, k, h).minus(X).abs()
    ) < 1 ? [N, z] : [L, _], f = B, U;
  }, s.toNumber = function() {
    return +I(this);
  }, s.toPrecision = function(b, v) {
    return b != null && jt(b, 1, oe), M(this, b, v, 2);
  }, s.toString = function(b) {
    var v, _ = this, z = _.s, P = _.e;
    return P === null ? z ? (v = "Infinity", z < 0 && (v = "-" + v)) : v = "NaN" : (b == null ? v = P <= c || P >= l ? la(Ze(_.c), P) : Xn(Ze(_.c), P, "0") : b === 10 && g ? (_ = A(new w(_), a + P + 1, h), v = Xn(Ze(_.c), _.e, "0")) : (jt(b, 2, m.length, "Base"), v = n(Xn(Ze(_.c), P, "0"), 10, b, z, !0)), z < 0 && _.c[0] && (v = "-" + v)), v;
  }, s.valueOf = s.toJSON = function() {
    return I(this);
  }, s._isBigNumber = !0, s[Symbol.toStringTag] = "BigNumber", s[Symbol.for("nodejs.util.inspect.custom")] = s.valueOf, r != null && w.set(r), w;
}
function Qe(r) {
  var e = r | 0;
  return r > 0 || r === e ? e : e - 1;
}
function Ze(r) {
  for (var e, n, i = 1, s = r.length, o = r[0] + ""; i < s; ) {
    for (e = r[i++] + "", n = vt - e.length; n--; e = "0" + e) ;
    o += e;
  }
  for (s = o.length; o.charCodeAt(--s) === 48; ) ;
  return o.slice(0, s + 1 || 1);
}
function Xi(r, e) {
  var n, i, s = r.c, o = e.c, a = r.s, h = e.s, c = r.e, l = e.e;
  if (!a || !h) return null;
  if (n = s && !s[0], i = o && !o[0], n || i) return n ? i ? 0 : -h : a;
  if (a != h) return a;
  if (n = a < 0, i = c == l, !s || !o) return i ? 0 : !s ^ n ? 1 : -1;
  if (!i) return c > l ^ n ? 1 : -1;
  for (h = (c = s.length) < (l = o.length) ? c : l, a = 0; a < h; a++) if (s[a] != o[a]) return s[a] > o[a] ^ n ? 1 : -1;
  return c == l ? 0 : c > l ^ n ? 1 : -1;
}
function jt(r, e, n, i) {
  if (r < e || r > n || r !== Je(r))
    throw Error(Fe + (i || "Argument") + (typeof r == "number" ? r < e || r > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(r));
}
function ca(r) {
  var e = r.c.length - 1;
  return Qe(r.e / vt) == e && r.c[e] % 2 != 0;
}
function la(r, e) {
  return (r.length > 1 ? r.charAt(0) + "." + r.slice(1) : r) + (e < 0 ? "e" : "e+") + e;
}
function Xn(r, e, n) {
  var i, s;
  if (e < 0) {
    for (s = n + "."; ++e; s += n) ;
    r = s + r;
  } else if (i = r.length, ++e > i) {
    for (s = n, e -= i; --e; s += n) ;
    r += s;
  } else e < i && (r = r.slice(0, e) + "." + r.slice(e));
  return r;
}
var Mn = gy(), Nv = class {
  key;
  left = null;
  right = null;
  constructor(r) {
    this.key = r;
  }
}, qr = class extends Nv {
  constructor(r) {
    super(r);
  }
}, qv = class {
  size = 0;
  modificationCount = 0;
  splayCount = 0;
  splay(r) {
    const e = this.root;
    if (e == null)
      return this.compare(r, r), -1;
    let n = null, i = null, s = null, o = null, a = e;
    const h = this.compare;
    let c;
    for (; ; )
      if (c = h(a.key, r), c > 0) {
        let l = a.left;
        if (l == null || (c = h(l.key, r), c > 0 && (a.left = l.right, l.right = a, a = l, l = a.left, l == null)))
          break;
        n == null ? i = a : n.left = a, n = a, a = l;
      } else if (c < 0) {
        let l = a.right;
        if (l == null || (c = h(l.key, r), c < 0 && (a.right = l.left, l.left = a, a = l, l = a.right, l == null)))
          break;
        s == null ? o = a : s.right = a, s = a, a = l;
      } else
        break;
    return s != null && (s.right = a.left, a.left = o), n != null && (n.left = a.right, a.right = i), this.root !== a && (this.root = a, this.splayCount++), c;
  }
  splayMin(r) {
    let e = r, n = e.left;
    for (; n != null; ) {
      const i = n;
      e.left = i.right, i.right = e, e = i, n = e.left;
    }
    return e;
  }
  splayMax(r) {
    let e = r, n = e.right;
    for (; n != null; ) {
      const i = n;
      e.right = i.left, i.left = e, e = i, n = e.right;
    }
    return e;
  }
  _delete(r) {
    if (this.root == null || this.splay(r) != 0) return null;
    let n = this.root;
    const i = n, s = n.left;
    if (this.size--, s == null)
      this.root = n.right;
    else {
      const o = n.right;
      n = this.splayMax(s), n.right = o, this.root = n;
    }
    return this.modificationCount++, i;
  }
  addNewRoot(r, e) {
    this.size++, this.modificationCount++;
    const n = this.root;
    if (n == null) {
      this.root = r;
      return;
    }
    e < 0 ? (r.left = n, r.right = n.right, n.right = null) : (r.right = n, r.left = n.left, n.left = null), this.root = r;
  }
  _first() {
    const r = this.root;
    return r == null ? null : (this.root = this.splayMin(r), this.root);
  }
  _last() {
    const r = this.root;
    return r == null ? null : (this.root = this.splayMax(r), this.root);
  }
  clear() {
    this.root = null, this.size = 0, this.modificationCount++;
  }
  has(r) {
    return this.validKey(r) && this.splay(r) == 0;
  }
  defaultCompare() {
    return (r, e) => r < e ? -1 : r > e ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => this.root,
      setRoot: (r) => {
        this.root = r;
      },
      getSize: () => this.size,
      getModificationCount: () => this.modificationCount,
      getSplayCount: () => this.splayCount,
      setSplayCount: (r) => {
        this.splayCount = r;
      },
      splay: (r) => this.splay(r),
      has: (r) => this.has(r)
    };
  }
}, fh = class Gr extends qv {
  root = null;
  compare;
  validKey;
  constructor(e, n) {
    super(), this.compare = e ?? this.defaultCompare(), this.validKey = n ?? ((i) => i != null && i != null);
  }
  delete(e) {
    return this.validKey(e) ? this._delete(e) != null : !1;
  }
  deleteAll(e) {
    for (const n of e)
      this.delete(n);
  }
  forEach(e) {
    const n = this[Symbol.iterator]();
    let i;
    for (; i = n.next(), !i.done; )
      e(i.value, i.value, this);
  }
  add(e) {
    const n = this.splay(e);
    return n != 0 && this.addNewRoot(new qr(e), n), this;
  }
  addAndReturn(e) {
    const n = this.splay(e);
    return n != 0 && this.addNewRoot(new qr(e), n), this.root.key;
  }
  addAll(e) {
    for (const n of e)
      this.add(n);
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) < 0) return this.root.key;
    let i = this.root.left;
    if (i == null) return null;
    let s = i.right;
    for (; s != null; )
      i = s, s = i.right;
    return i.key;
  }
  firstAfter(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) > 0) return this.root.key;
    let i = this.root.right;
    if (i == null) return null;
    let s = i.left;
    for (; s != null; )
      i = s, s = i.left;
    return i.key;
  }
  retainAll(e) {
    const n = new Gr(this.compare, this.validKey), i = this.modificationCount;
    for (const s of e) {
      if (i != this.modificationCount)
        throw "Concurrent modification during iteration.";
      this.validKey(s) && this.splay(s) == 0 && n.add(this.root.key);
    }
    n.size != this.size && (this.root = n.root, this.size = n.size, this.modificationCount++);
  }
  lookup(e) {
    return !this.validKey(e) || this.splay(e) != 0 ? null : this.root.key;
  }
  intersection(e) {
    const n = new Gr(this.compare, this.validKey);
    for (const i of this)
      e.has(i) && n.add(i);
    return n;
  }
  difference(e) {
    const n = new Gr(this.compare, this.validKey);
    for (const i of this)
      e.has(i) || n.add(i);
    return n;
  }
  union(e) {
    const n = this.clone();
    return n.addAll(e), n;
  }
  clone() {
    const e = new Gr(this.compare, this.validKey);
    return e.size = this.size, e.root = this.copyNode(this.root), e;
  }
  copyNode(e) {
    if (e == null) return null;
    function n(s, o) {
      let a, h;
      do {
        if (a = s.left, h = s.right, a != null) {
          const c = new qr(a.key);
          o.left = c, n(a, c);
        }
        if (h != null) {
          const c = new qr(h.key);
          o.right = c, s = h, o = c;
        }
      } while (h != null);
    }
    const i = new qr(e.key);
    return n(e, i), i;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new $v(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new Dv(this.wrap());
  }
  [Symbol.toStringTag] = "[object Set]";
}, wy = class {
  tree;
  path = new Array();
  modificationCount = null;
  splayCount;
  constructor(r) {
    this.tree = r, this.splayCount = r.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const r = this.path[this.path.length - 1];
    return this.getValue(r);
  }
  rebuildPath(r) {
    this.path.splice(0, this.path.length), this.tree.splay(r), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(r) {
    for (; r != null; )
      this.path.push(r), r = r.left;
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let n = this.tree.getRoot();
        for (; n != null; )
          this.path.push(n), n = n.left;
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return !1;
    this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
    let r = this.path[this.path.length - 1], e = r.right;
    if (e != null) {
      for (; e != null; )
        this.path.push(e), e = e.left;
      return !0;
    }
    for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === r; )
      r = this.path.pop();
    return this.path.length > 0;
  }
}, Dv = class extends wy {
  getValue(r) {
    return r.key;
  }
}, $v = class extends wy {
  getValue(r) {
    return [r.key, r.key];
  }
};
const Vv = (r) => r, Uv = (r) => {
  if (r) {
    const e = new fh(Ol(r)), n = new fh(Ol(r)), i = (o, a) => a.addAndReturn(o), s = (o) => ({
      x: i(o.x, e),
      y: i(o.y, n)
    });
    return s({ x: new Mn(0), y: new Mn(0) }), s;
  }
  return Vv;
}, Ll = (r) => ({
  set: (e) => {
    ui = Ll(e);
  },
  reset: () => Ll(r),
  compare: Ol(r),
  snap: Uv(r),
  orient: Bv(r)
});
let ui = Ll();
const Dr = (r, e) => r.ll.x.isLessThanOrEqualTo(e.x) && e.x.isLessThanOrEqualTo(r.ur.x) && r.ll.y.isLessThanOrEqualTo(e.y) && e.y.isLessThanOrEqualTo(r.ur.y), Bl = (r, e) => {
  if (e.ur.x.isLessThan(r.ll.x) || r.ur.x.isLessThan(e.ll.x) || e.ur.y.isLessThan(r.ll.y) || r.ur.y.isLessThan(e.ll.y))
    return null;
  const n = r.ll.x.isLessThan(e.ll.x) ? e.ll.x : r.ll.x, i = r.ur.x.isLessThan(e.ur.x) ? r.ur.x : e.ur.x, s = r.ll.y.isLessThan(e.ll.y) ? e.ll.y : r.ll.y, o = r.ur.y.isLessThan(e.ur.y) ? r.ur.y : e.ur.y;
  return { ll: { x: n, y: s }, ur: { x: i, y: o } };
}, ja = (r, e) => r.x.times(e.y).minus(r.y.times(e.x)), by = (r, e) => r.x.times(e.x).plus(r.y.times(e.y)), dh = (r) => by(r, r).sqrt(), Wv = (r, e, n) => {
  const i = { x: e.x.minus(r.x), y: e.y.minus(r.y) }, s = { x: n.x.minus(r.x), y: n.y.minus(r.y) };
  return ja(s, i).div(dh(s)).div(dh(i));
}, jv = (r, e, n) => {
  const i = { x: e.x.minus(r.x), y: e.y.minus(r.y) }, s = { x: n.x.minus(r.x), y: n.y.minus(r.y) };
  return by(s, i).div(dh(s)).div(dh(i));
}, Ed = (r, e, n) => e.y.isZero() ? null : { x: r.x.plus(e.x.div(e.y).times(n.minus(r.y))), y: n }, zd = (r, e, n) => e.x.isZero() ? null : { x: n, y: r.y.plus(e.y.div(e.x).times(n.minus(r.x))) }, Yv = (r, e, n, i) => {
  if (e.x.isZero()) return zd(n, i, r.x);
  if (i.x.isZero()) return zd(r, e, n.x);
  if (e.y.isZero()) return Ed(n, i, r.y);
  if (i.y.isZero()) return Ed(r, e, n.y);
  const s = ja(e, i);
  if (s.isZero()) return null;
  const o = { x: n.x.minus(r.x), y: n.y.minus(r.y) }, a = ja(o, e).div(s), h = ja(o, i).div(s), c = r.x.plus(h.times(e.x)), l = n.x.plus(a.times(i.x)), u = r.y.plus(h.times(e.y)), f = n.y.plus(a.times(i.y)), d = c.plus(l).div(2), p = u.plus(f).div(2);
  return { x: d, y: p };
};
class sn {
  point;
  isLeft;
  segment;
  otherSE;
  consumedBy;
  // for ordering sweep events in the sweep event queue
  static compare(e, n) {
    const i = sn.comparePoints(e.point, n.point);
    return i !== 0 ? i : (e.point !== n.point && e.link(n), e.isLeft !== n.isLeft ? e.isLeft ? 1 : -1 : ph.compare(e.segment, n.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(e, n) {
    return e.x.isLessThan(n.x) ? -1 : e.x.isGreaterThan(n.x) ? 1 : e.y.isLessThan(n.y) ? -1 : e.y.isGreaterThan(n.y) ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(e, n) {
    e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = n;
  }
  link(e) {
    if (e.point === this.point)
      throw new Error("Tried to link already linked events");
    const n = e.point.events;
    for (let i = 0, s = n.length; i < s; i++) {
      const o = n[i];
      this.point.events.push(o), o.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const e = this.point.events.length;
    for (let n = 0; n < e; n++) {
      const i = this.point.events[n];
      if (i.segment.consumedBy === void 0)
        for (let s = n + 1; s < e; s++) {
          const o = this.point.events[s];
          o.consumedBy === void 0 && i.otherSE.point.events === o.otherSE.point.events && i.segment.consume(o.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const e = [];
    for (let n = 0, i = this.point.events.length; n < i; n++) {
      const s = this.point.events[n];
      s !== this && !s.segment.ringOut && s.segment.isInResult() && e.push(s);
    }
    return e;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(e) {
    const n = /* @__PURE__ */ new Map(), i = (s) => {
      const o = s.otherSE;
      n.set(s, {
        sine: Wv(this.point, e.point, o.point),
        cosine: jv(this.point, e.point, o.point)
      });
    };
    return (s, o) => {
      n.has(s) || i(s), n.has(o) || i(o);
      const { sine: a, cosine: h } = n.get(s), { sine: c, cosine: l } = n.get(o);
      return a.isGreaterThanOrEqualTo(0) && c.isGreaterThanOrEqualTo(0) ? h.isLessThan(l) ? 1 : h.isGreaterThan(l) ? -1 : 0 : a.isLessThan(0) && c.isLessThan(0) ? h.isLessThan(l) ? -1 : h.isGreaterThan(l) ? 1 : 0 : c.isLessThan(a) ? -1 : c.isGreaterThan(a) ? 1 : 0;
    };
  }
}
let Hv = 0, ph = class Ya {
  id;
  leftSE;
  rightSE;
  rings;
  windings;
  ringOut;
  consumedBy;
  prev;
  _prevInResult;
  _beforeState;
  _afterState;
  _isInResult;
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(e, n) {
    const i = e.leftSE.point.x, s = n.leftSE.point.x, o = e.rightSE.point.x, a = n.rightSE.point.x;
    if (a.isLessThan(i)) return 1;
    if (o.isLessThan(s)) return -1;
    const h = e.leftSE.point.y, c = n.leftSE.point.y, l = e.rightSE.point.y, u = n.rightSE.point.y;
    if (i.isLessThan(s)) {
      if (c.isLessThan(h) && c.isLessThan(l)) return 1;
      if (c.isGreaterThan(h) && c.isGreaterThan(l)) return -1;
      const f = e.comparePoint(n.leftSE.point);
      if (f < 0) return 1;
      if (f > 0) return -1;
      const d = n.comparePoint(e.rightSE.point);
      return d !== 0 ? d : -1;
    }
    if (i.isGreaterThan(s)) {
      if (h.isLessThan(c) && h.isLessThan(u)) return -1;
      if (h.isGreaterThan(c) && h.isGreaterThan(u)) return 1;
      const f = n.comparePoint(e.leftSE.point);
      if (f !== 0) return f;
      const d = e.comparePoint(n.rightSE.point);
      return d < 0 ? 1 : d > 0 ? -1 : 1;
    }
    if (h.isLessThan(c)) return -1;
    if (h.isGreaterThan(c)) return 1;
    if (o.isLessThan(a)) {
      const f = n.comparePoint(e.rightSE.point);
      if (f !== 0) return f;
    }
    if (o.isGreaterThan(a)) {
      const f = e.comparePoint(n.rightSE.point);
      if (f < 0) return 1;
      if (f > 0) return -1;
    }
    if (!o.eq(a)) {
      const f = l.minus(h), d = o.minus(i), p = u.minus(c), y = a.minus(s);
      if (f.isGreaterThan(d) && p.isLessThan(y)) return 1;
      if (f.isLessThan(d) && p.isGreaterThan(y)) return -1;
    }
    return o.isGreaterThan(a) ? 1 : o.isLessThan(a) || l.isLessThan(u) ? -1 : l.isGreaterThan(u) ? 1 : e.id < n.id ? -1 : e.id > n.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(e, n, i, s) {
    this.id = ++Hv, this.leftSE = e, e.segment = this, e.otherSE = n, this.rightSE = n, n.segment = this, n.otherSE = e, this.rings = i, this.windings = s;
  }
  static fromRing(e, n, i) {
    let s, o, a;
    const h = sn.comparePoints(e, n);
    if (h < 0)
      s = e, o = n, a = 1;
    else if (h > 0)
      s = n, o = e, a = -1;
    else
      throw new Error(
        `Tried to create degenerate segment at [${e.x}, ${e.y}]`
      );
    const c = new sn(s, !0), l = new sn(o, !1);
    return new Ya(c, l, [i], [a]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(e) {
    this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const e = this.leftSE.point.y, n = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: e.isLessThan(n) ? e : n },
      ur: { x: this.rightSE.point.x, y: e.isGreaterThan(n) ? e : n }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(e) {
    return e.x.eq(this.leftSE.point.x) && e.y.eq(this.leftSE.point.y) || e.x.eq(this.rightSE.point.x) && e.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(e) {
    return ui.orient(this.leftSE.point, e, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(e) {
    const n = this.bbox(), i = e.bbox(), s = Bl(n, i);
    if (s === null) return null;
    const o = this.leftSE.point, a = this.rightSE.point, h = e.leftSE.point, c = e.rightSE.point, l = Dr(n, h) && this.comparePoint(h) === 0, u = Dr(i, o) && e.comparePoint(o) === 0, f = Dr(n, c) && this.comparePoint(c) === 0, d = Dr(i, a) && e.comparePoint(a) === 0;
    if (u && l)
      return d && !f ? a : !d && f ? c : null;
    if (u)
      return f && o.x.eq(c.x) && o.y.eq(c.y) ? null : o;
    if (l)
      return d && a.x.eq(h.x) && a.y.eq(h.y) ? null : h;
    if (d && f) return null;
    if (d) return a;
    if (f) return c;
    const p = Yv(o, this.vector(), h, e.vector());
    return p === null || !Dr(s, p) ? null : ui.snap(p);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(e) {
    const n = [], i = e.events !== void 0, s = new sn(e, !0), o = new sn(e, !1), a = this.rightSE;
    this.replaceRightSE(o), n.push(o), n.push(s);
    const h = new Ya(
      s,
      a,
      this.rings.slice(),
      this.windings.slice()
    );
    return sn.comparePoints(h.leftSE.point, h.rightSE.point) > 0 && h.swapEvents(), sn.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), i && (s.checkForConsuming(), o.checkForConsuming()), n;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const e = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let n = 0, i = this.windings.length; n < i; n++)
      this.windings[n] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(e) {
    let n = this, i = e;
    for (; n.consumedBy; ) n = n.consumedBy;
    for (; i.consumedBy; ) i = i.consumedBy;
    const s = Ya.compare(n, i);
    if (s !== 0) {
      if (s > 0) {
        const o = n;
        n = i, i = o;
      }
      if (n.prev === i) {
        const o = n;
        n = i, i = o;
      }
      for (let o = 0, a = i.rings.length; o < a; o++) {
        const h = i.rings[o], c = i.windings[o], l = n.rings.indexOf(h);
        l === -1 ? (n.rings.push(h), n.windings.push(c)) : n.windings[l] += c;
      }
      i.rings = null, i.windings = null, i.consumedBy = n, i.leftSE.consumedBy = n.leftSE, i.rightSE.consumedBy = n.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const e = this.prev.consumedBy || this.prev;
      this._beforeState = e.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const e = this.beforeState();
    this._afterState = {
      rings: e.rings.slice(0),
      windings: e.windings.slice(0),
      multiPolys: []
    };
    const n = this._afterState.rings, i = this._afterState.windings, s = this._afterState.multiPolys;
    for (let h = 0, c = this.rings.length; h < c; h++) {
      const l = this.rings[h], u = this.windings[h], f = n.indexOf(l);
      f === -1 ? (n.push(l), i.push(u)) : i[f] += u;
    }
    const o = [], a = [];
    for (let h = 0, c = n.length; h < c; h++) {
      if (i[h] === 0) continue;
      const l = n[h], u = l.poly;
      if (a.indexOf(u) === -1)
        if (l.isExterior) o.push(u);
        else {
          a.indexOf(u) === -1 && a.push(u);
          const f = o.indexOf(l.poly);
          f !== -1 && o.splice(f, 1);
        }
    }
    for (let h = 0, c = o.length; h < c; h++) {
      const l = o[h].multiPoly;
      s.indexOf(l) === -1 && s.push(l);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const e = this.beforeState().multiPolys, n = this.afterState().multiPolys;
    switch (Nn.type) {
      case "union": {
        const i = e.length === 0, s = n.length === 0;
        this._isInResult = i !== s;
        break;
      }
      case "intersection": {
        let i, s;
        e.length < n.length ? (i = e.length, s = n.length) : (i = n.length, s = e.length), this._isInResult = s === Nn.numMultiPolys && i < s;
        break;
      }
      case "xor": {
        const i = Math.abs(e.length - n.length);
        this._isInResult = i % 2 === 1;
        break;
      }
      case "difference": {
        const i = (s) => s.length === 1 && s[0].isSubject;
        this._isInResult = i(e) !== i(n);
        break;
      }
    }
    return this._isInResult;
  }
};
class Ad {
  poly;
  isExterior;
  segments;
  bbox;
  constructor(e, n, i) {
    if (!Array.isArray(e) || e.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = n, this.isExterior = i, this.segments = [], typeof e[0][0] != "number" || typeof e[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const s = ui.snap({ x: new Mn(e[0][0]), y: new Mn(e[0][1]) });
    this.bbox = {
      ll: { x: s.x, y: s.y },
      ur: { x: s.x, y: s.y }
    };
    let o = s;
    for (let a = 1, h = e.length; a < h; a++) {
      if (typeof e[a][0] != "number" || typeof e[a][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const c = ui.snap({ x: new Mn(e[a][0]), y: new Mn(e[a][1]) });
      c.x.eq(o.x) && c.y.eq(o.y) || (this.segments.push(ph.fromRing(o, c, this)), c.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = c.x), c.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = c.y), c.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = c.x), c.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = c.y), o = c);
    }
    (!s.x.eq(o.x) || !s.y.eq(o.y)) && this.segments.push(ph.fromRing(o, s, this));
  }
  getSweepEvents() {
    const e = [];
    for (let n = 0, i = this.segments.length; n < i; n++) {
      const s = this.segments[n];
      e.push(s.leftSE), e.push(s.rightSE);
    }
    return e;
  }
}
class Xv {
  multiPoly;
  exteriorRing;
  interiorRings;
  bbox;
  constructor(e, n) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new Ad(e[0], this, !0), this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    }, this.interiorRings = [];
    for (let i = 1, s = e.length; i < s; i++) {
      const o = new Ad(e[i], this, !1);
      o.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = o.bbox.ur.y), this.interiorRings.push(o);
    }
    this.multiPoly = n;
  }
  getSweepEvents() {
    const e = this.exteriorRing.getSweepEvents();
    for (let n = 0, i = this.interiorRings.length; n < i; n++) {
      const s = this.interiorRings[n].getSweepEvents();
      for (let o = 0, a = s.length; o < a; o++)
        e.push(s[o]);
    }
    return e;
  }
}
class Cd {
  isSubject;
  polys;
  bbox;
  constructor(e, n) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof e[0][0][0] == "number" && (e = [e]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: { x: new Mn(Number.POSITIVE_INFINITY), y: new Mn(Number.POSITIVE_INFINITY) },
      ur: { x: new Mn(Number.NEGATIVE_INFINITY), y: new Mn(Number.NEGATIVE_INFINITY) }
    };
    for (let i = 0, s = e.length; i < s; i++) {
      const o = new Xv(e[i], this);
      o.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = o.bbox.ur.y), this.polys.push(o);
    }
    this.isSubject = n;
  }
  getSweepEvents() {
    const e = [];
    for (let n = 0, i = this.polys.length; n < i; n++) {
      const s = this.polys[n].getSweepEvents();
      for (let o = 0, a = s.length; o < a; o++)
        e.push(s[o]);
    }
    return e;
  }
}
class yh {
  events;
  poly;
  _isExteriorRing;
  _enclosingRing;
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(e) {
    const n = [];
    for (let i = 0, s = e.length; i < s; i++) {
      const o = e[i];
      if (!o.isInResult() || o.ringOut) continue;
      let a = null, h = o.leftSE, c = o.rightSE;
      const l = [h], u = h.point, f = [];
      for (; a = h, h = c, l.push(h), h.point !== u; )
        for (; ; ) {
          const d = h.getAvailableLinkedEvents();
          if (d.length === 0) {
            const x = l[0].point, m = l[l.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${x.x}, ${x.y}]. Last matching segment found ends at [${m.x}, ${m.y}].`
            );
          }
          if (d.length === 1) {
            c = d[0].otherSE;
            break;
          }
          let p = null;
          for (let x = 0, m = f.length; x < m; x++)
            if (f[x].point === h.point) {
              p = x;
              break;
            }
          if (p !== null) {
            const x = f.splice(p)[0], m = l.splice(x.index);
            m.unshift(m[0].otherSE), n.push(new yh(m.reverse()));
            continue;
          }
          f.push({
            index: l.length,
            point: h.point
          });
          const y = h.getLeftmostComparator(a);
          c = d.sort(y)[0].otherSE;
          break;
        }
      n.push(new yh(l));
    }
    return n;
  }
  constructor(e) {
    this.events = e;
    for (let n = 0, i = e.length; n < i; n++)
      e[n].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let e = this.events[0].point;
    const n = [e];
    for (let l = 1, u = this.events.length - 1; l < u; l++) {
      const f = this.events[l].point, d = this.events[l + 1].point;
      ui.orient(f, e, d) !== 0 && (n.push(f), e = f);
    }
    if (n.length === 1) return null;
    const i = n[0], s = n[1];
    ui.orient(i, e, s) === 0 && n.shift(), n.push(n[0]);
    const o = this.isExteriorRing() ? 1 : -1, a = this.isExteriorRing() ? 0 : n.length - 1, h = this.isExteriorRing() ? n.length : -1, c = [];
    for (let l = a; l != h; l += o)
      c.push([n[l].x.toNumber(), n[l].y.toNumber()]);
    return c;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const e = this.enclosingRing();
      this._isExteriorRing = e ? !e.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let e = this.events[0];
    for (let s = 1, o = this.events.length; s < o; s++) {
      const a = this.events[s];
      sn.compare(e, a) > 0 && (e = a);
    }
    let n = e.segment.prevInResult(), i = n ? n.prevInResult() : null;
    for (; ; ) {
      if (!n) return null;
      if (!i) return n.ringOut;
      if (i.ringOut !== n.ringOut)
        return i.ringOut?.enclosingRing() !== n.ringOut ? n.ringOut : n.ringOut?.enclosingRing();
      n = i.prevInResult(), i = n ? n.prevInResult() : null;
    }
  }
}
class Pd {
  exteriorRing;
  interiorRings;
  constructor(e) {
    this.exteriorRing = e, e.poly = this, this.interiorRings = [];
  }
  addInterior(e) {
    this.interiorRings.push(e), e.poly = this;
  }
  getGeom() {
    const e = this.exteriorRing.getGeom();
    if (e === null) return null;
    const n = [e];
    for (let i = 0, s = this.interiorRings.length; i < s; i++) {
      const o = this.interiorRings[i].getGeom();
      o !== null && n.push(o);
    }
    return n;
  }
}
class Zv {
  rings;
  polys;
  constructor(e) {
    this.rings = e, this.polys = this._composePolys(e);
  }
  getGeom() {
    const e = [];
    for (let n = 0, i = this.polys.length; n < i; n++) {
      const s = this.polys[n].getGeom();
      s !== null && e.push(s);
    }
    return e;
  }
  _composePolys(e) {
    const n = [];
    for (let i = 0, s = e.length; i < s; i++) {
      const o = e[i];
      if (!o.poly)
        if (o.isExteriorRing()) n.push(new Pd(o));
        else {
          const a = o.enclosingRing();
          a?.poly || n.push(new Pd(a)), a?.poly?.addInterior(o);
        }
    }
    return n;
  }
}
class Gv {
  queue;
  tree;
  segments;
  constructor(e, n = ph.compare) {
    this.queue = e, this.tree = new fh(n), this.segments = [];
  }
  process(e) {
    const n = e.segment, i = [];
    if (e.consumedBy)
      return e.isLeft ? this.queue.delete(e.otherSE) : this.tree.delete(n), i;
    e.isLeft && this.tree.add(n);
    let s = n, o = n;
    do
      s = this.tree.lastBefore(s);
    while (s != null && s.consumedBy != null);
    do
      o = this.tree.firstAfter(o);
    while (o != null && o.consumedBy != null);
    if (e.isLeft) {
      let a = null;
      if (s) {
        const c = s.getIntersection(n);
        if (c !== null && (n.isAnEndpoint(c) || (a = c), !s.isAnEndpoint(c))) {
          const l = this._splitSafely(s, c);
          for (let u = 0, f = l.length; u < f; u++)
            i.push(l[u]);
        }
      }
      let h = null;
      if (o) {
        const c = o.getIntersection(n);
        if (c !== null && (n.isAnEndpoint(c) || (h = c), !o.isAnEndpoint(c))) {
          const l = this._splitSafely(o, c);
          for (let u = 0, f = l.length; u < f; u++)
            i.push(l[u]);
        }
      }
      if (a !== null || h !== null) {
        let c = null;
        a === null ? c = h : h === null ? c = a : c = sn.comparePoints(
          a,
          h
        ) <= 0 ? a : h, this.queue.delete(n.rightSE), i.push(n.rightSE);
        const l = n.split(c);
        for (let u = 0, f = l.length; u < f; u++)
          i.push(l[u]);
      }
      i.length > 0 ? (this.tree.delete(n), i.push(e)) : (this.segments.push(n), n.prev = s);
    } else {
      if (s && o) {
        const a = s.getIntersection(o);
        if (a !== null) {
          if (!s.isAnEndpoint(a)) {
            const h = this._splitSafely(s, a);
            for (let c = 0, l = h.length; c < l; c++)
              i.push(h[c]);
          }
          if (!o.isAnEndpoint(a)) {
            const h = this._splitSafely(o, a);
            for (let c = 0, l = h.length; c < l; c++)
              i.push(h[c]);
          }
        }
      }
      this.tree.delete(n);
    }
    return i;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(e, n) {
    this.tree.delete(e);
    const i = e.rightSE;
    this.queue.delete(i);
    const s = e.split(n);
    return s.push(i), e.consumedBy === void 0 && this.tree.add(e), s;
  }
}
class Jv {
  type;
  numMultiPolys;
  run(e, n, i) {
    Nn.type = e;
    const s = [new Cd(n, !0)];
    for (let u = 0, f = i.length; u < f; u++)
      s.push(new Cd(i[u], !1));
    if (Nn.numMultiPolys = s.length, Nn.type === "difference") {
      const u = s[0];
      let f = 1;
      for (; f < s.length; )
        Bl(s[f].bbox, u.bbox) !== null ? f++ : s.splice(f, 1);
    }
    if (Nn.type === "intersection")
      for (let u = 0, f = s.length; u < f; u++) {
        const d = s[u];
        for (let p = u + 1, y = s.length; p < y; p++)
          if (Bl(d.bbox, s[p].bbox) === null) return [];
      }
    const o = new fh(sn.compare);
    for (let u = 0, f = s.length; u < f; u++) {
      const d = s[u].getSweepEvents();
      for (let p = 0, y = d.length; p < y; p++)
        o.add(d[p]);
    }
    const a = new Gv(o);
    let h = null;
    for (o.size != 0 && (h = o.first(), o.delete(h)); h; ) {
      const u = a.process(h);
      for (let f = 0, d = u.length; f < d; f++) {
        const p = u[f];
        p.consumedBy === void 0 && o.add(p);
      }
      o.size != 0 ? (h = o.first(), o.delete(h)) : h = null;
    }
    ui.reset();
    const c = yh.factory(a.segments);
    return new Zv(c).getGeom();
  }
}
const Nn = new Jv(), Qv = (r, ...e) => Nn.run("union", r, e), Kv = (r, ...e) => Nn.run("intersection", r, e), tM = (r, ...e) => Nn.run("xor", r, e), eM = (r, ...e) => Nn.run("difference", r, e), nM = ui.set, iM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  difference: eM,
  intersection: Kv,
  setPrecision: nM,
  union: Qv,
  xor: tM
}, Symbol.toStringTag, { value: "Module" })), sM = 0, vy = 1, My = 2, _y = 4, Sy = 8;
function ua(r, e, n) {
  let i = sM;
  return r < n.left ? i |= vy : r > n.right && (i |= My), e < n.top ? i |= _y : e > n.bottom && (i |= Sy), i;
}
function xh(r, e) {
  let [[n, i], [s, o]] = r, a = ua(n, i, e), h = ua(s, o, e);
  for (; ; )
    if (a | h) {
      if (a & h)
        return !1;
      {
        const { top: c, right: l, bottom: u, left: f } = e;
        let d, p;
        const y = h > a ? h : a;
        y & Sy ? (d = n + (s - n) * (u - i) / (o - i), p = u) : y & _y ? (d = n + (s - n) * (c - i) / (o - i), p = c) : y & My ? (p = i + (o - i) * (l - n) / (s - n), d = l) : y & vy && (p = i + (o - i) * (f - n) / (s - n), d = f), y == a ? (n = d, i = p, a = ua(n, i, e)) : (s = d, o = p, h = ua(s, o, e));
      }
    } else return !0;
}
function Ha(r, e) {
  return r.left <= e.right && e.left <= r.right && r.top <= e.bottom && e.top <= r.bottom;
}
function Ty(r, e) {
  return r ? {
    top: Math.min(r.top, e.top),
    right: Math.max(r.right, e.right),
    bottom: Math.max(r.bottom, e.bottom),
    left: Math.min(r.left, e.left)
  } : e;
}
function $s(r, e) {
  return r ? {
    top: Math.min(r.top, e[1]),
    right: Math.max(r.right, e[0]),
    bottom: Math.max(r.bottom, e[1]),
    left: Math.min(r.left, e[0])
  } : {
    top: e[1],
    right: e[0],
    bottom: e[1],
    left: e[0]
  };
}
function Ey(r) {
  return Math.max(
    r.right - r.left,
    r.bottom - r.top
  );
}
function Xa(r, e) {
  return {
    top: r[1] - e,
    right: r[0] + e,
    bottom: r[1] + e,
    left: r[0] - e
  };
}
function rM(r, e) {
  return {
    top: r.top - e,
    right: r.right + e,
    bottom: r.bottom + e,
    left: r.left - e
  };
}
class ys {
  constructor(e, n, i = 16) {
    this.boundingBox = e, this.depth = n, this.innerNodeCapacity = i;
  }
  subtrees = null;
  pairs = [];
  insert(e, n) {
    if (!Ha(e, this.boundingBox)) return !1;
    if (this.depth > 0 && this.pairs.length >= this.innerNodeCapacity) {
      this.ensureSubtrees();
      for (let i = 0; i < this.subtrees.length; i++)
        this.subtrees[i].insert(e, n);
    } else
      this.pairs.push([e, n]);
    return !0;
  }
  find(e, n = /* @__PURE__ */ new Set()) {
    if (!Ha(e, this.boundingBox)) return n;
    for (let i = 0; i < this.pairs.length; i++) {
      const [s, o] = this.pairs[i];
      Ha(e, s) && n.add(o);
    }
    if (this.subtrees)
      for (let i = 0; i < this.subtrees.length; i++)
        this.subtrees[i].find(e, n);
    return n;
  }
  findOnLineSegment(e, n = /* @__PURE__ */ new Set()) {
    if (!xh(e, this.boundingBox)) return n;
    for (const [i, s] of this.pairs)
      xh(e, i) && n.add(s);
    if (this.subtrees)
      for (const i of this.subtrees)
        i.findOnLineSegment(e, n);
    return n;
  }
  ensureSubtrees() {
    if (this.subtrees) return;
    const { top: e, right: n, bottom: i, left: s } = this.boundingBox, o = (this.boundingBox.left + this.boundingBox.right) / 2, a = (this.boundingBox.top + this.boundingBox.bottom) / 2;
    this.subtrees = [
      new ys(
        { top: e, right: o, bottom: a, left: s },
        this.depth - 1,
        this.innerNodeCapacity
      ),
      new ys(
        { top: e, right: n, bottom: a, left: o },
        this.depth - 1,
        this.innerNodeCapacity
      ),
      new ys(
        { top: a, right: o, bottom: i, left: s },
        this.depth - 1,
        this.innerNodeCapacity
      ),
      new ys(
        { top: a, right: n, bottom: i, left: o },
        this.depth - 1,
        this.innerNodeCapacity
      )
    ];
  }
}
class Fh extends Error {
  constructor(e) {
    super("Assertion error: " + e);
  }
}
function Id(r, e) {
  if (!r)
    throw new Fh(`Expected 'cond' to be truthy: ${e}`);
}
function $n(r, e) {
  if (r == null)
    throw new Fh(
      `Expected 'val' to be defined, but received ${r}: ${e}`
    );
}
function zy(r, e, n) {
  if (r !== e)
    throw new Fh(
      `Expected 'lhs' to equal ${e}, but received ${r}: ${n}`
    );
}
function oM(r) {
  throw new Fh(
    `Reached code that was supposed to be unreachable: ${r}`
  );
}
const fa = 1e-12;
function Ay(r) {
  const e = r[1], n = r[2], i = r[3], s = r[4], o = -e[0] + 3 * n[0] - 3 * i[0] + s[0], a = -e[1] + 3 * n[1] - 3 * i[1] + s[1], h = 3 * e[0] - 6 * n[0] + 3 * i[0], c = 3 * e[1] - 6 * n[1] + 3 * i[1], l = -3 * e[0] + 3 * n[0], u = -3 * e[1] + 3 * n[1], f = a * h - o * c, d = o * u - a * l, p = (-3 * o * o * u * u + 6 * o * a * l * u + 4 * o * h * c * u - 4 * o * c * c * l - 3 * a * a * l * l - 4 * a * h * h * u + 4 * a * h * c * l) / (o * o * c * c - 2 * o * a * h * c + a * a * h * h);
  if (p < 0) return null;
  const y = (d / f + Math.sqrt(p)) / 2, x = (d / f - Math.sqrt(p)) / 2;
  return fa <= y && y <= 1 - fa && fa <= x && x <= 1 - fa ? [y, x] : null;
}
const kd = 2 * Math.PI;
function aM(r, e, n, i, s) {
  return (r - e) / (n - e) * (s - i) + i;
}
function gn(r, e, n) {
  return r + (e - r) * n;
}
function Cy(r) {
  return r / 180 * Math.PI;
}
function Rd(r, e) {
  const i = Math.sign(r[0] * e[1] - r[1] * e[0]);
  return i === 0 && Math.abs(r[0] + e[0]) < 1e-12 && Math.abs(r[1] + e[1]) < 1e-12 ? Math.PI : i * Math.acos(et.dot(r, e) / et.len(r) / et.len(e));
}
function $t() {
  return [0, 0];
}
function _e(r, e, n = 0) {
  return Math.abs(r[0] - e[0]) <= n && Math.abs(r[1] - e[1]) <= n;
}
function Pu(r) {
  return r[1];
}
function Py(r) {
  switch (r[0]) {
    case "L":
      return r[2];
    case "C":
      return r[4];
    case "Q":
      return r[3];
    case "A":
      return r[7];
  }
}
function mh(r) {
  switch (r[0]) {
    case "L":
      return ["L", r[2], r[1]];
    case "C":
      return ["C", r[4], r[3], r[2], r[1]];
    case "Q":
      return ["Q", r[3], r[2], r[1]];
    case "A":
      return [
        "A",
        r[7],
        r[2],
        r[3],
        r[4],
        r[5],
        !r[6],
        r[1]
      ];
  }
}
const Nh = (() => {
  const r = $t(), e = ur.create(), n = $t(), i = $t();
  return function([
    o,
    a,
    h,
    c,
    l,
    u,
    f,
    d
  ]) {
    if (h === 0 || c === 0)
      return null;
    ur.fromRotation(e, -Cy(l)), et.sub(r, a, d), et.scale(r, r, 0.5), et.transformMat2(r, r, e);
    let p = h * h, y = c * c;
    const x = r[0] * r[0], m = r[1] * r[1];
    h = Math.abs(h), c = Math.abs(c);
    const g = x / p + m / y + 1e-12;
    if (g > 1) {
      const v = Math.sqrt(g);
      h *= v, c *= v;
      const _ = Math.abs(g);
      p *= _, y *= _;
    }
    const w = u === f ? -1 : 1, M = Math.sqrt(
      (p * y - p * m - y * x) / (p * m + y * x)
    ), S = w * M * (h * r[1] / c), E = w * M * (-c * r[0] / h);
    ur.transpose(e, e), et.add(n, a, d), et.scale(n, n, 0.5), et.transformMat2(i, [S, E], e), et.add(i, i, n);
    const A = [
      (r[0] - S) / h,
      (r[1] - E) / c
    ], I = Rd([1, 0], A);
    let b = Rd(A, [
      (-r[0] - S) / h,
      (-r[1] - E) / c
    ]);
    return !f && b > 0 ? b -= kd : f && b < 0 && (b += kd), {
      center: [i[0], i[1]],
      theta1: I,
      deltaTheta: b,
      rx: h,
      ry: c,
      phi: l
    };
  };
})(), Od = (() => {
  const r = $t(), e = $t(), n = ur.create();
  return function({
    center: s,
    theta1: o,
    deltaTheta: a,
    rx: h,
    ry: c,
    phi: l
  }) {
    ur.fromRotation(n, l), et.set(r, h * Math.cos(o), c * Math.sin(o)), et.transformMat2(r, r, n), et.add(r, r, s), et.set(
      e,
      h * Math.cos(o + a),
      c * Math.sin(o + a)
    ), et.transformMat2(e, e, n), et.add(e, e, s);
    const u = Math.abs(a) > Math.PI, f = a > 0;
    return ["A", [r[0], r[1]], h, c, l, u, f, [e[0], e[1]]];
  };
})(), hr = (() => {
  const r = $t(), e = $t(), n = $t(), i = $t(), s = $t(), o = $t();
  return function(h, c) {
    switch (h[0]) {
      case "L":
        et.lerp(o, h[1], h[2], c);
        break;
      case "C":
        et.lerp(r, h[1], h[2], c), et.lerp(e, h[2], h[3], c), et.lerp(n, h[3], h[4], c), et.lerp(i, r, e, c), et.lerp(s, e, n, c), et.lerp(o, i, s, c);
        break;
      case "Q":
        et.lerp(r, h[1], h[2], c), et.lerp(e, h[2], h[3], c), et.lerp(o, r, e, c);
        break;
      case "A": {
        const l = Nh(h);
        if (!l) {
          et.lerp(o, h[1], h[7], c);
          break;
        }
        const { deltaTheta: u, phi: f, theta1: d, rx: p, ry: y, center: x } = l, m = d + c * u;
        et.set(o, p * Math.cos(m), y * Math.sin(m)), et.rotate(o, o, [0, 0], f), et.add(o, o, x);
        break;
      }
    }
    return [o[0], o[1]];
  };
})(), Iy = (() => {
  const r = Si.create(), e = Si.create();
  return function(i, s = Math.PI / 2) {
    const o = Nh(i);
    if (!o)
      return [["L", i[1], i[7]]];
    const { center: a, theta1: h, deltaTheta: c, rx: l, ry: u } = o, f = Math.ceil(Math.abs(c) / s);
    Si.fromTranslation(r, a), Si.rotate(r, r, Cy(i[4])), Si.scale(r, r, [l, u]);
    const d = [], p = c / f, y = 4 / 3 * Math.tan(p / 4), x = Math.sin(p), m = Math.cos(p);
    for (let g = 0; g < f; g++) {
      const w = [1, 0], M = [1, y], S = [
        m + y * x,
        x - y * m
      ], E = [m, x];
      Si.fromRotation(e, h + g * p), Si.mul(e, r, e), et.transformMat2d(w, w, e), et.transformMat2d(M, M, e), et.transformMat2d(S, S, e), et.transformMat2d(E, E, e), d.push(["C", w, M, S, E]);
    }
    return d;
  };
})();
function Ld(r, e, n, i, s) {
  const o = gn(r, e, s), a = gn(e, n, s), h = gn(n, i, s), c = gn(o, a, s), l = gn(a, h, s);
  return gn(c, l, s);
}
function Bd(r, e, n, i) {
  let s = Math.min(r, i), o = Math.max(r, i);
  const a = 3 * (-r + 3 * e - 3 * n + i), h = 6 * (r - 2 * e + n), c = 3 * (e - r), l = h * h - 4 * a * c;
  if (l < 0 || a === 0)
    return [s, o];
  const u = Math.sqrt(l), f = (-h - u) / (2 * a);
  if (0 < f && f < 1) {
    const p = Ld(r, e, n, i, f);
    s = Math.min(s, p), o = Math.max(o, p);
  }
  const d = (-h + u) / (2 * a);
  if (0 < d && d < 1) {
    const p = Ld(r, e, n, i, d);
    s = Math.min(s, p), o = Math.max(o, p);
  }
  return [s, o];
}
function hM(r, e, n, i) {
  const s = gn(r, e, i), o = gn(e, n, i);
  return gn(s, o, i);
}
function Fd(r, e, n) {
  let i = Math.min(r, n), s = Math.max(r, n);
  const o = r - 2 * e + n;
  if (o === 0)
    return [i, s];
  const a = (r - e) / o;
  if (0 <= a && a <= 1) {
    const h = hM(r, e, n, a);
    i = Math.min(i, h), s = Math.max(s, h);
  }
  return [i, s];
}
function mi(r, e, n) {
  const i = (r - e) / (n - e);
  return 0 <= i && i <= 1;
}
function hn(r) {
  switch (r[0]) {
    case "L":
      return {
        top: Math.min(r[1][1], r[2][1]),
        right: Math.max(r[1][0], r[2][0]),
        bottom: Math.max(r[1][1], r[2][1]),
        left: Math.min(r[1][0], r[2][0])
      };
    case "C": {
      const [e, n] = Bd(
        r[1][0],
        r[2][0],
        r[3][0],
        r[4][0]
      ), [i, s] = Bd(
        r[1][1],
        r[2][1],
        r[3][1],
        r[4][1]
      );
      return { top: i, right: n, bottom: s, left: e };
    }
    case "Q": {
      const [e, n] = Fd(
        r[1][0],
        r[2][0],
        r[3][0]
      ), [i, s] = Fd(
        r[1][1],
        r[2][1],
        r[3][1]
      );
      return { top: i, right: n, bottom: s, left: e };
    }
    case "A": {
      const e = Nh(r);
      if (!e)
        return $s(
          Xa(r[1], 0),
          r[7]
        );
      const { theta1: n, deltaTheta: i, phi: s, center: o, rx: a, ry: h } = e;
      if (s === 0 || a === h) {
        const u = n + i;
        let f = $s(
          Xa(r[1], 0),
          r[7]
        );
        return (mi(-Math.PI, n, u) || mi(Math.PI, n, u)) && (f = $s(f, [
          o[0] - a,
          o[1]
        ])), (mi(-Math.PI / 2, n, u) || mi(3 * Math.PI / 2, n, u)) && (f = $s(f, [
          o[0],
          o[1] - h
        ])), (mi(0, n, u) || mi(2 * Math.PI, n, u)) && (f = $s(f, [
          o[0] + a,
          o[1]
        ])), (mi(Math.PI / 2, n, u) || mi(5 * Math.PI / 2, n, u)) && (f = $s(f, [
          o[0],
          o[1] + h
        ])), rM(f, 1e-11);
      }
      const c = Iy(r, Math.PI / 16);
      let l = null;
      for (const u of c)
        l = Ty(
          l,
          hn(u)
        );
      return l || Xa(r[1], 0);
    }
  }
}
function ky(r, e) {
  const n = r[1], i = r[2], s = et.lerp($t(), n, i, e);
  return [
    ["L", n, s],
    ["L", s, i]
  ];
}
function Za(r, e) {
  const n = r[1], i = r[2], s = r[3], o = r[4], a = et.lerp($t(), n, i, e), h = et.lerp($t(), i, s, e), c = et.lerp($t(), s, o, e), l = et.lerp($t(), a, h, e), u = et.lerp($t(), h, c, e), f = et.lerp($t(), l, u, e);
  return [
    ["C", n, a, l, f],
    ["C", f, u, c, o]
  ];
}
function cM(r, e) {
  const n = r[1], i = r[2], s = r[3], o = et.lerp($t(), n, i, e), a = et.lerp($t(), i, s, e), h = et.lerp($t(), o, a, e);
  return [
    ["Q", n, o, h],
    ["Q", h, a, s]
  ];
}
function lM(r, e) {
  const n = Nh(r);
  if (!n)
    return ky(["L", r[1], r[7]], e);
  const i = n.deltaTheta * e;
  return [
    Od({
      ...n,
      deltaTheta: i
    }),
    Od({
      ...n,
      theta1: n.theta1 + i,
      deltaTheta: n.deltaTheta - i
    })
  ];
}
function Iu(r, e) {
  switch (r[0]) {
    case "L":
      return ky(r, e);
    case "C":
      return Za(r, e);
    case "Q":
      return cM(r, e);
    case "A":
      return lM(r, e);
  }
}
function Fl([[r, e], [n, i]], [[s, o], [a, h]], c) {
  const l = n - r, u = s - a, f = s - r, d = i - e, p = o - h, y = o - e, x = l * p - d * u;
  if (Math.abs(x) < c.collinear) return null;
  const m = (f * p - y * u) / x, g = (l * y - d * f) / x;
  return -c.param <= m && m <= 1 + c.param && -c.param <= g && g <= 1 + c.param ? [m, g] : null;
}
function uM(r, e, n) {
  return !!Fl(r, e, n);
}
function Nd(r) {
  const [e, n] = Iu(r.seg, 0.5), i = (r.startParam + r.endParam) / 2;
  return [
    {
      seg: e,
      startParam: r.startParam,
      endParam: i,
      boundingBox: hn(e)
    },
    {
      seg: n,
      startParam: i,
      endParam: r.endParam,
      boundingBox: hn(n)
    }
  ];
}
function qd(r) {
  switch (r[0]) {
    case "L":
      return [r[1], r[2]];
    case "C":
      return [r[1], r[4]];
    case "Q":
      return [r[1], r[3]];
    case "A":
      return [r[1], r[7]];
  }
}
function fM({ seg: r, boundingBox: e }, { seg: n, boundingBox: i }, s) {
  return r[0] === "L" ? n[0] === "L" ? uM(
    [r[1], r[2]],
    [n[1], n[2]],
    s
  ) : xh([r[1], r[2]], i) : n[0] === "L" ? xh([n[1], n[2]], e) : Ha(e, i);
}
function Nl(r, e, n) {
  const i = r[0];
  if (e[0] !== i) return !1;
  switch (i) {
    case "L":
      return _e(r[1], e[1], n) && _e(r[2], e[2], n);
    case "C":
      return _e(r[1], e[1], n) && _e(r[2], e[2], n) && _e(r[3], e[3], n) && _e(r[4], e[4], n);
    case "Q":
      return _e(r[1], e[1], n) && _e(r[2], e[2], n) && _e(r[3], e[3], n);
    case "A":
      return _e(r[1], e[1], n) && Math.abs(r[2] - e[2]) < n && Math.abs(r[3] - e[3]) < n && (Math.abs(r[2] - r[3]) < n || Math.abs(r[4] - e[4]) < n) && // TODO: Handle rotations by Pi/2.
      r[5] === e[5] && r[6] === e[6] && _e(r[7], e[7], n);
  }
}
function dM(r, e, n) {
  const i = et.sub([0, 0], r[1], r[0]), s = et.sub([0, 0], e[1], e[0]);
  et.normalize(i, i), et.normalize(s, s);
  const o = Math.abs(et.dot(i, s));
  return Math.abs(o - 1) < n;
}
const pM = (() => {
  const r = $t(), e = $t(), n = $t(), i = $t(), s = $t(), o = $t();
  return function(h, c) {
    et.sub(r, h[1], h[0]), et.sub(e, c[1], c[0]), et.scale(r, r, 1 / et.sqrLen(r)), et.scale(e, e, 1 / et.sqrLen(e));
    const l = [];
    et.sub(n, c[0], h[0]);
    const u = et.dot(n, r);
    u >= 0 && u <= 1 && l.push([u, 0]), et.sub(i, c[1], h[0]);
    const f = et.dot(i, r);
    f >= 0 && f <= 1 && l.push([f, 1]), et.sub(s, h[0], c[0]);
    const d = et.dot(s, e);
    d >= 0 && d <= 1 && l.push([0, d]), et.sub(o, h[1], c[0]);
    const p = et.dot(o, e);
    return p >= 0 && p <= 1 && l.push([1, p]), l;
  };
})();
function Ry(r, e, n) {
  if (r[0] === "L" && e[0] === "L") {
    const a = [r[1], r[2]], h = [e[1], e[2]];
    if (dM(a, h, n.collinear))
      return pM(a, h);
    const c = Fl(a, h, n);
    return c ? [c] : [];
  }
  let i = [
    [
      {
        seg: r,
        startParam: 0,
        endParam: 1,
        boundingBox: hn(r)
      },
      {
        seg: e,
        startParam: 0,
        endParam: 1,
        boundingBox: hn(e)
      }
    ]
  ];
  const s = [];
  function o(a) {
    return Ey(a.boundingBox) <= n.linear || a.endParam - a.startParam < n.param;
  }
  for (; i.length; ) {
    const a = [];
    for (const [h, c] of i) {
      if (Nl(h.seg, c.seg, n.point))
        continue;
      const l = o(h), u = o(c);
      if (l && u) {
        const f = qd(h.seg), d = qd(c.seg), p = Fl(
          f,
          d,
          n
        );
        p && s.push([
          gn(h.startParam, h.endParam, p[0]),
          gn(c.startParam, c.endParam, p[1])
        ]);
      } else {
        const f = l ? [h] : Nd(h), d = u ? [c] : Nd(c);
        for (const p of f)
          for (const y of d)
            fM(p, y, n) && a.push([p, y]);
      }
    }
    i = a;
  }
  return s;
}
function yM(r) {
  return typeof r == "number";
}
function xM(r) {
  return typeof r == "string";
}
function mM(r) {
  return typeof r == "boolean";
}
const ho = Object.hasOwn;
function qh(r) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n, ...i) => {
    if (e.has(n))
      return e.get(n);
    {
      const s = r(n, ...i);
      return e.set(n, s), s;
    }
  };
}
function gM(r, e) {
  return r.reduce((n, i) => n + (e(i) ? 1 : 0), 0);
}
function* gh(r, e) {
  let n = 0;
  for (const i of r)
    yield e(i, n++);
}
const wM = 8, bM = 8, De = {
  point: 1e-6,
  linear: 1e-4,
  param: 1e-8,
  collinear: Number.MIN_VALUE * 64
};
var Oy = /* @__PURE__ */ ((r) => (r[r.Union = 0] = "Union", r[r.Difference = 1] = "Difference", r[r.Intersection = 2] = "Intersection", r[r.Exclusion = 3] = "Exclusion", r[r.Division = 4] = "Division", r[r.Fracture = 5] = "Fracture", r))(Oy || {}), Ly = /* @__PURE__ */ ((r) => (r[r.NonZero = 0] = "NonZero", r[r.EvenOdd = 1] = "EvenOdd", r))(Ly || {});
function vM(r) {
  return r.values().next().value;
}
function By() {
  let r = 0;
  return qh(() => r++);
}
function Dd(r) {
  return (e) => ({ seg: e, parent: r });
}
function MM(r) {
  for (let e = 0; e < r.length; e++) {
    const n = r[e];
    if (n.seg[0] !== "C") continue;
    const i = Ay(n.seg);
    if (!i) continue;
    i[0] > i[1] && i.reverse();
    const [s, o] = i;
    if (Math.abs(s - o) < De.param) {
      const [a, h] = Za(n.seg, s);
      r[e] = {
        seg: a,
        parent: n.parent
      }, r.push({
        seg: h,
        parent: n.parent
      });
    } else {
      const [a, h] = Za(n.seg, s), [c, l] = Za(
        h,
        (o - s) / (1 - s)
      );
      r[e] = {
        seg: a,
        parent: n.parent
      }, r.push(
        {
          seg: c,
          parent: n.parent
        },
        {
          seg: l,
          parent: n.parent
        }
      );
    }
  }
}
function _M(r) {
  const e = r.map((h) => ({
    ...h,
    boundingBox: hn(h.seg)
  })), n = e.reduce(
    (h, { boundingBox: c }) => Ty(h, c),
    null
  );
  if (!n)
    return { edges: [], totalBoundingBox: null };
  const i = new ys(
    n,
    wM
  ), s = {};
  function o(h, c) {
    ho(s, h) || (s[h] = []), s[h].push(c);
  }
  for (let h = 0; h < e.length; h++) {
    const c = e[h], l = i.find(c.boundingBox);
    for (const u of l) {
      const f = r[u], d = Ry(
        c.seg,
        f.seg,
        De
      );
      for (const [p, y] of d)
        o(h, p), o(u, y);
    }
    i.insert(c.boundingBox, h);
  }
  const a = [];
  for (let h = 0; h < e.length; h++) {
    const c = e[h];
    if (!ho(s, h)) {
      a.push(c);
      continue;
    }
    const l = s[h];
    l.sort();
    let u = c.seg, f = 0;
    for (let d = 0; d < l.length; d++) {
      const p = l[d];
      if (p > 1 - De.param) break;
      const y = (p - f) / (1 - f);
      if (f = p, y < De.param || y > 1 - De.param) continue;
      const [x, m] = Iu(u, y);
      a.push({
        seg: x,
        boundingBox: hn(x),
        parent: c.parent
      }), u = m;
    }
    a.push({
      seg: u,
      boundingBox: hn(u),
      parent: c.parent
    });
  }
  return { edges: a, totalBoundingBox: n };
}
function SM(r, e) {
  const n = new ys(
    e,
    bM
  ), i = [];
  function s(c) {
    const l = Xa(c, De.point), u = n.find(l);
    if (u.size)
      return vM(u);
    {
      const f = {
        point: c,
        outgoingEdges: []
      };
      return n.insert(l, f), i.push(f), f;
    }
  }
  const o = By(), a = {};
  return {
    edges: r.flatMap((c) => {
      const l = s(Pu(c.seg)), u = s(Py(c.seg));
      if (l === u)
        switch (c.seg[0]) {
          case "L":
            return [];
          case "C":
            if (_e(c.seg[1], c.seg[2], De.point) && _e(c.seg[3], c.seg[4], De.point))
              return [];
            break;
          case "Q":
            if (_e(c.seg[1], c.seg[2], De.point))
              return [];
            break;
          case "A":
            if (c.seg[5] === !1)
              return [];
            break;
        }
      const f = `${o(l)}:${o(u)}`;
      if (ho(a, f)) {
        const x = a[f].find(
          (m) => Nl(m[0].seg, c.seg, De.point)
        );
        if (x)
          return x[1].parent |= c.parent, x[2].parent |= c.parent, [];
      }
      const d = `${o(u)}:${o(l)}`;
      if (ho(a, d)) {
        const x = mh(c.seg), m = a[d].find(
          (g) => Nl(g[0].seg, x, De.point)
        );
        if (m)
          return m[0].parent === c.parent ? [] : (m[1].parent |= c.parent, m[1].directionFlagA = c.parent === 1, m[1].directionFlagB = c.parent === 2, m[2].parent |= c.parent, m[2].directionFlagA = c.parent === 1, m[2].directionFlagB = c.parent === 2, []);
      }
      const p = {
        ...c,
        incidentVertices: [l, u],
        directionFlag: !1,
        directionFlagA: !1,
        directionFlagB: !1,
        twin: null
      }, y = {
        ...c,
        incidentVertices: [u, l],
        directionFlag: !0,
        directionFlagA: c.parent === 1,
        directionFlagB: c.parent === 2,
        twin: p
      };
      return p.twin = y, l.outgoingEdges.push(p), u.outgoingEdges.push(y), ho(a, f) ? a[f].push([c, p, y]) : a[f] = [[c, p, y]], [p, y];
    }),
    vertices: i
  };
}
function Jr(r) {
  return r.outgoingEdges.length;
}
function TM({ vertices: r }) {
  const e = [], n = [], i = qh((c) => {
    const l = { outgoingEdges: [] };
    return n.push(l), l;
  }), s = By(), o = {}, a = /* @__PURE__ */ new WeakSet();
  for (const c of r) {
    if (Jr(c) === 2) continue;
    const l = i(c);
    for (const u of c.outgoingEdges) {
      const f = [];
      let d = u;
      for (; d.parent === u.parent && d.directionFlag === u.directionFlag && d.directionFlagA === u.directionFlagA && d.directionFlagB === u.directionFlagB && Jr(d.incidentVertices[1]) === 2; ) {
        f.push(d.seg), a.add(d.incidentVertices[1]);
        const [w, M] = d.incidentVertices[1].outgoingEdges;
        Id(
          w.twin === d || M.twin === d,
          "Wrong twin structure."
        ), d = w.twin === d ? M : w;
      }
      f.push(d.seg);
      const p = i(d.incidentVertices[1]);
      $n(d.twin, "Edge doesn't have a twin."), $n(u.twin, "Edge doesn't have a twin.");
      const y = `${s(u)}-${s(d)}`, x = `${s(d.twin)}-${s(u.twin)}`, m = o[x] ?? null, g = {
        segments: f,
        parent: u.parent,
        incidentVertices: [l, p],
        directionFlag: u.directionFlag,
        directionFlagA: u.directionFlagA,
        directionFlagB: u.directionFlagB,
        twin: m
      };
      m && (m.twin = g), o[y] = g, l.outgoingEdges.push(g), e.push(g);
    }
  }
  const h = [];
  for (const c of r) {
    if (Jr(c) !== 2 || a.has(c)) continue;
    let l = c.outgoingEdges[0];
    const u = {
      segments: [],
      parent: l.parent,
      directionFlag: l.directionFlag,
      directionFlagA: l.directionFlagA,
      directionFlagB: l.directionFlagB
    };
    do {
      u.segments.push(l.seg), a.add(l.incidentVertices[0]), zy(
        Jr(l.incidentVertices[1]),
        2,
        "Found an unvisited vertex of order != 2."
      );
      const [f, d] = l.incidentVertices[1].outgoingEdges;
      Id(
        f.twin === l || d.twin === l,
        "Wrong twin structure."
      ), l = f.twin === l ? d : f;
    } while (l.incidentVertices[0] !== c);
    h.push(u);
  }
  return {
    edges: e,
    vertices: n,
    cycles: h
  };
}
function EM(r) {
  function e(a) {
    const h = /* @__PURE__ */ new WeakSet(), c = /* @__PURE__ */ new WeakMap();
    function l(u, f, d) {
      if (c.has(u))
        return c.get(u);
      c.set(u, d);
      let p = 1 / 0;
      for (const y of u.outgoingEdges)
        y.parent & a && y !== f && (p = Math.min(
          p,
          l(y.incidentVertices[1], y.twin, d + 1)
        ));
      return p <= d && h.add(u), p;
    }
    for (const u of r.edges)
      u.parent & a && l(u.incidentVertices[0], null, 0);
    return h;
  }
  const n = e(1), i = e(2);
  function s(a) {
    return n.has(a) || i.has(a);
  }
  function o(a) {
    return (a.parent & 1) === 1 && n.has(a.incidentVertices[0]) && n.has(a.incidentVertices[1]) || (a.parent & 2) === 2 && i.has(a.incidentVertices[0]) && i.has(a.incidentVertices[1]);
  }
  r.vertices = r.vertices.filter(s);
  for (const a of r.vertices)
    a.outgoingEdges = a.outgoingEdges.filter(o);
  r.edges = r.edges.filter(o);
}
function zM({ directionFlag: r, segments: e }) {
  let n, i;
  const s = e[0];
  return r ? (n = hr(s, 1), i = hr(s, 1 - De.param)) : (n = hr(s, 0), i = hr(s, De.param)), Math.atan2(i[1] - n[1], i[0] - n[0]);
}
function AM({ vertices: r }) {
  const e = qh(zM);
  for (const n of r)
    Jr(n) > 2 && n.outgoingEdges.sort((i, s) => e(i) - e(s));
}
function CM(r) {
  const { outgoingEdges: e } = r.incidentVertices[1], n = e.findIndex((i) => i.twin === r);
  return e[(n + 1) % e.length];
}
const PM = qh(
  (r) => r.incidentEdges.flatMap((e) => {
    const i = [];
    for (const s of e.segments)
      for (let o = 0; o < 64; o++) {
        const a = o / 64, h = e.directionFlag ? 1 - a : a;
        i.push(hr(s, h));
      }
    return i;
  })
);
function Fy(r, e, n) {
  const i = r >= n, s = e < n;
  return i === s;
}
function Ny(r, e, n) {
  return Fy(r[1], e[1], n[1]) ? aM(n[1], r[1], e[1], r[0], e[0]) >= n[0] : !1;
}
function IM(r, e) {
  if (r.length <= 2) return 0;
  let n = r[r.length - 1], i = 0;
  for (const s of r)
    Ny(n, s, e) && (i += s[1] > n[1] ? -1 : 1), n = s;
  return i;
}
function $d(r) {
  const e = PM(r);
  for (let n = 0; n < e.length; n++) {
    const i = e[n], s = e[(n + 1) % e.length], o = e[(n + 2) % e.length], a = [
      (i[0] + s[0] + o[0]) / 3,
      (i[1] + s[1] + o[1]) / 3
    ], h = IM(e, a);
    if (h !== 0)
      return {
        winding: h,
        point: a
      };
  }
  oM("No ear in polygon found.");
}
function kM({ edges: r, cycles: e }) {
  const n = [], i = /* @__PURE__ */ new WeakMap();
  for (const h of r) {
    if (i.has(h)) continue;
    const c = {
      incidentEdges: [],
      flag: 0
    };
    let l = h;
    do {
      $n(l.twin, "Edge doesn't have a twin");
      const u = i.get(l.twin) ?? null, f = {
        segments: l.segments,
        parent: l.parent,
        incidentVertex: c,
        directionFlag: l.directionFlag,
        directionFlagA: l.directionFlagA,
        directionFlagB: l.directionFlagB,
        twin: u
      };
      u && (u.twin = f), i.set(l, f), c.incidentEdges.push(f), l = CM(l);
    } while (l !== h);
    n.push(c);
  }
  for (const h of e) {
    const c = {
      incidentEdges: [],
      flag: 0
    }, l = {
      segments: h.segments,
      parent: h.parent,
      incidentVertex: c,
      directionFlag: h.directionFlag,
      directionFlagA: h.directionFlagA,
      directionFlagB: h.directionFlagB,
      twin: null
    }, u = {
      incidentEdges: [],
      flag: 0
    }, f = {
      segments: [...h.segments].reverse(),
      parent: h.parent,
      incidentVertex: u,
      directionFlag: !h.directionFlag,
      directionFlagA: !h.directionFlagA,
      directionFlagB: !h.directionFlagB,
      twin: l
    };
    l.twin = f, c.incidentEdges.push(l), u.incidentEdges.push(f), n.push(c, u);
  }
  const s = [], o = /* @__PURE__ */ new WeakSet(), a = /* @__PURE__ */ new WeakSet();
  for (const h of n) {
    if (o.has(h)) continue;
    const c = [], l = [], u = (d) => {
      o.has(d) || c.push(d), o.add(d);
      for (const p of d.incidentEdges) {
        if (a.has(p))
          continue;
        const { twin: y } = p;
        $n(y, "Edge doesn't have a twin."), l.push(p, y), a.add(p), a.add(y), u(y.incidentVertex);
      }
    };
    u(h);
    const f = c.find(
      (d) => $d(d).winding < 0
    );
    $n(f, "No outer face of a component found."), zy(
      gM(
        c,
        (d) => $d(d).winding < 0
      ),
      1,
      "Multiple outer faces found."
    ), s.push({
      vertices: c,
      edges: l,
      outerFace: f
    });
  }
  return s;
}
function Sc(r, e) {
  return Fy(r.top, r.bottom, e[1]) && r.right >= e[0];
}
function RM(r, e) {
  const n = hn(r);
  if (!Sc(n, e)) return 0;
  let i = [
    { boundingBox: n, seg: r }
  ], s = 0;
  for (; i.length > 0; ) {
    const o = [];
    for (const { boundingBox: a, seg: h } of i)
      if (Ey(a) < De.linear)
        Ny(
          Pu(h),
          Py(h),
          e
        ) && s++;
      else {
        const c = Iu(h, 0.5), l = hn(c[0]);
        Sc(l, e) && o.push({
          boundingBox: l,
          seg: c[0]
        });
        const u = hn(c[1]);
        Sc(u, e) && o.push({
          boundingBox: u,
          seg: c[1]
        });
      }
    i = o;
  }
  return s;
}
function Vd(r, e) {
  const n = Pu(r.edges[0].segments[0]);
  for (const i of e.vertices) {
    if (i === e.outerFace) continue;
    let s = 0;
    for (const o of i.incidentEdges)
      for (const a of o.segments)
        s += RM(
          a,
          n
        );
    if (s % 2 === 1) return i;
  }
  return null;
}
function OM(r) {
  let e = [];
  function n(i, s) {
    let o = !1;
    for (const a of i) {
      const h = Vd(s, a.component);
      if (h) {
        if (a.outgoingEdges.has(h)) {
          const c = a.outgoingEdges.get(h);
          a.outgoingEdges.set(h, n(c, s));
        } else
          a.outgoingEdges.set(h, [
            { component: s, outgoingEdges: /* @__PURE__ */ new Map() }
          ]);
        o = !0;
        break;
      }
    }
    if (o)
      return i;
    {
      const a = {
        component: s,
        outgoingEdges: /* @__PURE__ */ new Map()
      }, h = [a];
      for (const c of i) {
        const l = Vd(c.component, s);
        l ? a.outgoingEdges.has(l) ? a.outgoingEdges.get(l).push(c) : a.outgoingEdges.set(l, [c]) : h.push(c);
      }
      return h;
    }
  }
  for (const i of r)
    e = n(e, i);
  return e;
}
function Ud(r, e) {
  switch (e) {
    case 0:
      return r === 0 ? 0 : 1;
    case 1:
      return r % 2 === 0 ? 0 : 1;
  }
}
function LM(r, e, n) {
  function i(s, o, a) {
    const h = /* @__PURE__ */ new WeakSet();
    function c(l, u, f) {
      if (h.has(l)) return;
      h.add(l);
      const d = Ud(u, e), p = Ud(f, n);
      l.flag = d | p << 1;
      for (const y of l.incidentEdges) {
        const x = y.twin;
        $n(x, "Edge doesn't have a twin.");
        let m = u;
        y.parent & 1 && (m += y.directionFlagA ? -1 : 1);
        let g = f;
        y.parent & 2 && (g += y.directionFlagB ? -1 : 1), c(x.incidentVertex, m, g);
      }
      if (s.outgoingEdges.has(l)) {
        const y = s.outgoingEdges.get(l);
        for (const x of y)
          i(x, u, f);
      }
    }
    $n(
      s.component.outerFace,
      "Component doesn't have an outer face."
    ), c(s.component.outerFace, o, a);
  }
  for (const s of r)
    i(s, 0, 0);
}
function* BM(r, e) {
  function* n(i) {
    for (const s of i.component.vertices)
      e(s) && (yield s);
    for (const s of i.outgoingEdges.values())
      for (const o of s)
        yield* n(o);
  }
  for (const i of r)
    yield* n(i);
}
function* FM(r) {
  function e(s) {
    return $n(s.twin, "Edge doesn't have a twin."), r.has(s.incidentVertex) === r.has(s.twin.incidentVertex);
  }
  const n = /* @__PURE__ */ new WeakMap();
  for (const s of r) {
    let o = s.incidentEdges[s.incidentEdges.length - 1];
    for (const a of s.incidentEdges)
      n.set(o, a), o = a;
  }
  const i = /* @__PURE__ */ new WeakSet();
  for (const s of r)
    for (const o of s.incidentEdges) {
      if (e(o) || i.has(o))
        continue;
      let a = o;
      do
        for (a.directionFlag ? yield* gh(a.segments, mh) : yield* a.segments, i.add(a), a = n.get(a); e(a); )
          $n(a.twin, "Edge doesn't have a twin."), a = n.get(a.twin);
      while (a !== o);
    }
}
function NM(r, e) {
  const n = [];
  function i(s) {
    for (const o of s.component.vertices) {
      if (!e(o) || o === s.component.outerFace)
        continue;
      const a = [];
      for (const h of o.incidentEdges)
        h.directionFlag ? a.push(...h.segments.map(mh)) : a.push(...h.segments);
      if (s.outgoingEdges.has(o))
        for (const h of s.outgoingEdges.get(o)) {
          const { outerFace: c } = h.component;
          $n(c, "Component has no outer face.");
          for (const l of c.incidentEdges)
            l.directionFlag ? a.push(...l.segments.map(mh)) : a.push(...l.segments);
        }
      n.push(a);
    }
    for (const o of s.outgoingEdges.values())
      for (const a of o)
        i(a);
  }
  for (const s of r)
    i(s);
  return n;
}
const qM = {
  0: ({ flag: r }) => r > 0,
  1: ({ flag: r }) => r === 1,
  2: ({ flag: r }) => r === 3,
  3: ({ flag: r }) => r === 1 || r === 2,
  4: ({ flag: r }) => (r & 1) === 1,
  5: ({ flag: r }) => r > 0
};
function DM(r, e, n, i, s) {
  const o = [
    ...gh(r, Dd(1)),
    ...gh(n, Dd(2))
  ];
  MM(o);
  const { edges: a, totalBoundingBox: h } = _M(o);
  if (!h)
    return [];
  const c = SM(a, h), l = TM(c);
  EM(l), AM(l);
  const u = kM(l), f = OM(u);
  LM(f, e, i);
  const d = qM[s];
  switch (s) {
    case 4:
    case 5:
      return NM(f, d);
    default: {
      const p = new Set(
        BM(f, d)
      );
      return [[...FM(p)]];
    }
  }
}
function* $M(r) {
  let e = [0, 0], n = e;
  for (const i of r)
    switch (i[0]) {
      case "M":
        yield i, e = n = i[1];
        break;
      case "L":
        yield i, e = i[1];
        break;
      case "C":
        yield i, e = i[3];
        break;
      case "S":
        yield i, e = i[2];
        break;
      case "Q":
        yield i, e = i[2];
        break;
      case "T":
        yield i, e = i[1];
        break;
      case "A":
        yield i, e = i[6];
        break;
      case "Z":
      case "z":
        e = n, yield ["Z"];
        break;
      case "H":
        e = [i[1], e[1]], yield ["L", e];
        break;
      case "V":
        e = [e[0], i[1]], yield ["L", e];
        break;
      case "m":
        e = n = [
          e[0] + i[1],
          e[1] + i[2]
        ], yield ["M", e];
        break;
      case "l":
        e = [e[0] + i[1], e[1] + i[2]], yield ["L", e];
        break;
      case "h":
        e = [e[0] + i[1], e[1]], yield ["L", e];
        break;
      case "v":
        e = [e[0], e[1] + i[1]], yield ["L", e];
        break;
      case "c":
        yield [
          "C",
          [e[0] + i[1], e[1] + i[2]],
          [e[0] + i[3], e[1] + i[4]],
          e = [
            e[0] + i[5],
            e[1] + i[6]
          ]
        ];
        break;
      case "s":
        yield [
          "S",
          [e[0] + i[1], e[1] + i[2]],
          e = [
            e[0] + i[3],
            e[1] + i[4]
          ]
        ];
        break;
      case "q":
        yield [
          "Q",
          [e[0] + i[1], e[1] + i[2]],
          e = [
            e[0] + i[3],
            e[1] + i[4]
          ]
        ];
        break;
      case "t":
        yield [
          "T",
          e = [
            e[0] + i[1],
            e[1] + i[2]
          ]
        ];
        break;
      case "a":
        yield [
          "A",
          i[1],
          i[2],
          i[3],
          i[4],
          i[5],
          e = [
            e[0] + i[6],
            e[1] + i[7]
          ]
        ];
        break;
    }
}
function Wd(r, e) {
  return [2 * r[0] - e[0], 2 * r[1] - e[1]];
}
function* qy(r) {
  let e = null, n = null, i = null;
  function s() {
    throw new Error("Bad SVG path data sequence.");
  }
  for (const o of $M(r))
    switch (o[0]) {
      case "M":
        n = e = o[1], i = null;
        break;
      case "L":
        n || s(), yield ["L", n, o[1]], n = o[1], i = null;
        break;
      case "C":
        n || s(), yield ["C", n, o[1], o[2], o[3]], n = o[3], i = o[2];
        break;
      case "S":
        n || s(), i || s(), yield [
          "C",
          n,
          Wd(n, i),
          o[1],
          o[2]
        ], n = o[2], i = o[1];
        break;
      case "Q":
        n || s(), yield ["Q", n, o[1], o[2]], n = o[2], i = o[1];
        break;
      case "T":
        n || s(), i || s(), i = Wd(
          n,
          i
        ), yield ["Q", n, i, o[1]], n = o[1];
        break;
      case "A":
        n || s(), yield [
          "A",
          n,
          o[1],
          o[2],
          o[3],
          o[4],
          o[5],
          o[6]
        ], n = o[6], i = null;
        break;
      case "Z":
      case "z":
        n || s(), e || s(), yield ["L", n, e], n = e, i = null;
        break;
    }
}
function* Dy(r, e = 1e-4) {
  let n = null;
  for (const i of r)
    switch ((!n || !_e(i[1], n, e)) && (yield ["M", i[1]]), i[0]) {
      case "L":
        yield ["L", n = i[2]];
        break;
      case "C":
        yield ["C", i[2], i[3], n = i[4]];
        break;
      case "Q":
        yield ["Q", i[2], n = i[3]];
        break;
      case "A":
        yield [
          "A",
          i[2],
          i[3],
          i[4],
          i[5],
          i[6],
          n = i[7]
        ];
        break;
    }
}
const jd = Symbol();
function* $y(r) {
  const e = /(-?\d*(?:\d\.|\.\d|\d)\d*(?:[eE][+\-]?\d+)?)/y, n = /([MLCSQTAZHVmlhvcsqtaz])/y, i = /([01])/y, s = /\s*,?\s*/y;
  let o = 0;
  function a() {
    s.lastIndex = o, s.exec(r) !== null && (o = s.lastIndex);
  }
  let h = "M", c = -1;
  function l() {
    if (a(), o > r.length - 1) return jd;
    n.lastIndex = o;
    const d = n.exec(r);
    if (!d)
      switch (h) {
        case "M":
          return "L";
        case "m":
          return "l";
        case "Z":
        case "z":
          if (o === c)
            throw new Error(
              `Invalid path data. Invalid syntax at index ${o}.`
            );
          return c = o, h;
        default:
          return h;
      }
    return o = n.lastIndex, d[1];
  }
  function u() {
    a(), e.lastIndex = o;
    const d = e.exec(r);
    if (!d)
      throw new Error(
        `Invalid path data. Expected a number at index ${o}.`
      );
    return o = e.lastIndex, Number(d[1]);
  }
  function f() {
    a(), i.lastIndex = o;
    const d = i.exec(r);
    if (!d)
      throw new Error(
        `Invalid path data. Expected a flag at index ${o}.`
      );
    return o = i.lastIndex, d[1] === "1";
  }
  for (; ; )
    switch (l()) {
      case "M":
        yield [h = "M", [u(), u()]];
        break;
      case "L":
        yield [h = "L", [u(), u()]];
        break;
      case "C":
        yield [
          h = "C",
          [u(), u()],
          [u(), u()],
          [u(), u()]
        ];
        break;
      case "S":
        yield [
          h = "S",
          [u(), u()],
          [u(), u()]
        ];
        break;
      case "Q":
        yield [
          h = "Q",
          [u(), u()],
          [u(), u()]
        ];
        break;
      case "T":
        yield [h = "T", [u(), u()]];
        break;
      case "A":
        yield [
          h = "A",
          u(),
          u(),
          u(),
          f(),
          f(),
          [u(), u()]
        ];
        break;
      case "Z":
      case "z":
        yield [h = "Z"];
        break;
      case "H":
        yield [h = "H", u()];
        break;
      case "V":
        yield [h = "V", u()];
        break;
      case "m":
        yield [h = "m", u(), u()];
        break;
      case "l":
        yield [h = "l", u(), u()];
        break;
      case "h":
        yield [h = "h", u()];
        break;
      case "v":
        yield [h = "v", u()];
        break;
      case "c":
        yield [
          h = "c",
          u(),
          u(),
          u(),
          u(),
          u(),
          u()
        ];
        break;
      case "s":
        yield [
          h = "s",
          u(),
          u(),
          u(),
          u()
        ];
        break;
      case "q":
        yield [
          h = "q",
          u(),
          u(),
          u(),
          u()
        ];
        break;
      case "t":
        yield [h = "t", u(), u()];
        break;
      case "a":
        yield [
          h = "a",
          u(),
          u(),
          u(),
          f(),
          f(),
          u(),
          u()
        ];
        break;
      case jd:
        return;
    }
}
function VM(r) {
  return [...qy($y(r))];
}
function UM(r, e = 1e-4) {
  function n(i) {
    return xM(i) ? i : yM(i) ? i.toFixed(12) : mM(i) ? i ? "1" : "0" : i.map((s) => s.toFixed(12)).join(",");
  }
  return [
    ...gh(Dy(r, e), (i) => i.map(n).join(" "))
  ].join(" ");
}
const WM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FillRule: Ly,
  PathBooleanOperation: Oy,
  arcSegmentToCubics: Iy,
  commandsFromPathData: $y,
  pathBoolean: DM,
  pathCubicSegmentSelfIntersection: Ay,
  pathFromCommands: qy,
  pathFromPathData: VM,
  pathSegmentBoundingBox: hn,
  pathSegmentIntersection: Ry,
  pathToCommands: Dy,
  pathToPathData: UM,
  samplePathSegmentAt: hr
}, Symbol.toStringTag, { value: "Module" }));
function Vy(r) {
  return "(" + r.x + ";" + r.y + ")";
}
function ku(r) {
  var e = r.toString();
  return e === "[object Object]" ? Vy(r) : e;
}
function Uy(r, e) {
  return r.y === e.y ? r.x - e.x : r.y - e.y;
}
function jM(r, e) {
  return r.x === e.x && r.y === e.y;
}
var fi = function(r, e) {
  this.name = "PointError", this.points = e = e || [], this.message = r || "Invalid Points!";
  for (var n = 0; n < e.length; n++)
    this.message += " " + ku(e[n]);
};
fi.prototype = new Error();
fi.prototype.constructor = fi;
var It = function(r, e) {
  this.x = +r || 0, this.y = +e || 0, this._p2t_edge_list = null;
};
It.prototype.toString = function() {
  return Vy(this);
};
It.prototype.toJSON = function() {
  return { x: this.x, y: this.y };
};
It.prototype.clone = function() {
  return new It(this.x, this.y);
};
It.prototype.set_zero = function() {
  return this.x = 0, this.y = 0, this;
};
It.prototype.set = function(r, e) {
  return this.x = +r || 0, this.y = +e || 0, this;
};
It.prototype.negate = function() {
  return this.x = -this.x, this.y = -this.y, this;
};
It.prototype.add = function(r) {
  return this.x += r.x, this.y += r.y, this;
};
It.prototype.sub = function(r) {
  return this.x -= r.x, this.y -= r.y, this;
};
It.prototype.mul = function(r) {
  return this.x *= r, this.y *= r, this;
};
It.prototype.length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y);
};
It.prototype.normalize = function() {
  var r = this.length();
  return this.x /= r, this.y /= r, r;
};
It.prototype.equals = function(r) {
  return this.x === r.x && this.y === r.y;
};
It.negate = function(r) {
  return new It(-r.x, -r.y);
};
It.add = function(r, e) {
  return new It(r.x + e.x, r.y + e.y);
};
It.sub = function(r, e) {
  return new It(r.x - e.x, r.y - e.y);
};
It.mul = function(r, e) {
  return new It(r * e.x, r * e.y);
};
It.cross = function(r, e) {
  return typeof r == "number" ? typeof e == "number" ? r * e : new It(-r * e.y, r * e.x) : typeof e == "number" ? new It(e * r.y, -e * r.x) : r.x * e.y - r.y * e.x;
};
It.toString = ku;
It.compare = Uy;
It.cmp = Uy;
It.equals = jM;
It.dot = function(r, e) {
  return r.x * e.x + r.y * e.y;
};
var zt = function(r, e, n) {
  this.points_ = [r, e, n], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1];
}, Tc = ku;
zt.prototype.toString = function() {
  return "[" + Tc(this.points_[0]) + Tc(this.points_[1]) + Tc(this.points_[2]) + "]";
};
zt.prototype.getPoint = function(r) {
  return this.points_[r];
};
zt.prototype.GetPoint = zt.prototype.getPoint;
zt.prototype.getPoints = function() {
  return this.points_;
};
zt.prototype.getNeighbor = function(r) {
  return this.neighbors_[r];
};
zt.prototype.containsPoint = function(r) {
  var e = this.points_;
  return r === e[0] || r === e[1] || r === e[2];
};
zt.prototype.containsEdge = function(r) {
  return this.containsPoint(r.p) && this.containsPoint(r.q);
};
zt.prototype.containsPoints = function(r, e) {
  return this.containsPoint(r) && this.containsPoint(e);
};
zt.prototype.isInterior = function() {
  return this.interior_;
};
zt.prototype.setInterior = function(r) {
  return this.interior_ = r, this;
};
zt.prototype.markNeighborPointers = function(r, e, n) {
  var i = this.points_;
  if (r === i[2] && e === i[1] || r === i[1] && e === i[2])
    this.neighbors_[0] = n;
  else if (r === i[0] && e === i[2] || r === i[2] && e === i[0])
    this.neighbors_[1] = n;
  else if (r === i[0] && e === i[1] || r === i[1] && e === i[0])
    this.neighbors_[2] = n;
  else
    throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");
};
zt.prototype.markNeighbor = function(r) {
  var e = this.points_;
  r.containsPoints(e[1], e[2]) ? (this.neighbors_[0] = r, r.markNeighborPointers(e[1], e[2], this)) : r.containsPoints(e[0], e[2]) ? (this.neighbors_[1] = r, r.markNeighborPointers(e[0], e[2], this)) : r.containsPoints(e[0], e[1]) && (this.neighbors_[2] = r, r.markNeighborPointers(e[0], e[1], this));
};
zt.prototype.clearNeighbors = function() {
  this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null;
};
zt.prototype.clearDelaunayEdges = function() {
  this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1;
};
zt.prototype.pointCW = function(r) {
  var e = this.points_;
  return r === e[0] ? e[2] : r === e[1] ? e[0] : r === e[2] ? e[1] : null;
};
zt.prototype.pointCCW = function(r) {
  var e = this.points_;
  return r === e[0] ? e[1] : r === e[1] ? e[2] : r === e[2] ? e[0] : null;
};
zt.prototype.neighborCW = function(r) {
  return r === this.points_[0] ? this.neighbors_[1] : r === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0];
};
zt.prototype.neighborCCW = function(r) {
  return r === this.points_[0] ? this.neighbors_[2] : r === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1];
};
zt.prototype.getConstrainedEdgeCW = function(r) {
  return r === this.points_[0] ? this.constrained_edge[1] : r === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0];
};
zt.prototype.getConstrainedEdgeCCW = function(r) {
  return r === this.points_[0] ? this.constrained_edge[2] : r === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1];
};
zt.prototype.getConstrainedEdgeAcross = function(r) {
  return r === this.points_[0] ? this.constrained_edge[0] : r === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2];
};
zt.prototype.setConstrainedEdgeCW = function(r, e) {
  r === this.points_[0] ? this.constrained_edge[1] = e : r === this.points_[1] ? this.constrained_edge[2] = e : this.constrained_edge[0] = e;
};
zt.prototype.setConstrainedEdgeCCW = function(r, e) {
  r === this.points_[0] ? this.constrained_edge[2] = e : r === this.points_[1] ? this.constrained_edge[0] = e : this.constrained_edge[1] = e;
};
zt.prototype.getDelaunayEdgeCW = function(r) {
  return r === this.points_[0] ? this.delaunay_edge[1] : r === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0];
};
zt.prototype.getDelaunayEdgeCCW = function(r) {
  return r === this.points_[0] ? this.delaunay_edge[2] : r === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1];
};
zt.prototype.setDelaunayEdgeCW = function(r, e) {
  r === this.points_[0] ? this.delaunay_edge[1] = e : r === this.points_[1] ? this.delaunay_edge[2] = e : this.delaunay_edge[0] = e;
};
zt.prototype.setDelaunayEdgeCCW = function(r, e) {
  r === this.points_[0] ? this.delaunay_edge[2] = e : r === this.points_[1] ? this.delaunay_edge[0] = e : this.delaunay_edge[1] = e;
};
zt.prototype.neighborAcross = function(r) {
  return r === this.points_[0] ? this.neighbors_[0] : r === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2];
};
zt.prototype.oppositePoint = function(r, e) {
  var n = r.pointCW(e);
  return this.pointCW(n);
};
zt.prototype.legalize = function(r, e) {
  var n = this.points_;
  if (r === n[0])
    n[1] = n[0], n[0] = n[2], n[2] = e;
  else if (r === n[1])
    n[2] = n[1], n[1] = n[0], n[0] = e;
  else if (r === n[2])
    n[0] = n[2], n[2] = n[1], n[1] = e;
  else
    throw new Error("poly2tri Invalid Triangle.legalize() call");
};
zt.prototype.index = function(r) {
  var e = this.points_;
  if (r === e[0])
    return 0;
  if (r === e[1])
    return 1;
  if (r === e[2])
    return 2;
  throw new Error("poly2tri Invalid Triangle.index() call");
};
zt.prototype.edgeIndex = function(r, e) {
  var n = this.points_;
  if (r === n[0]) {
    if (e === n[1])
      return 2;
    if (e === n[2])
      return 1;
  } else if (r === n[1]) {
    if (e === n[2])
      return 0;
    if (e === n[0])
      return 2;
  } else if (r === n[2]) {
    if (e === n[0])
      return 1;
    if (e === n[1])
      return 0;
  }
  return -1;
};
zt.prototype.markConstrainedEdgeByIndex = function(r) {
  this.constrained_edge[r] = !0;
};
zt.prototype.markConstrainedEdgeByEdge = function(r) {
  this.markConstrainedEdgeByPoints(r.p, r.q);
};
zt.prototype.markConstrainedEdgeByPoints = function(r, e) {
  var n = this.points_;
  e === n[0] && r === n[1] || e === n[1] && r === n[0] ? this.constrained_edge[2] = !0 : e === n[0] && r === n[2] || e === n[2] && r === n[0] ? this.constrained_edge[1] = !0 : (e === n[1] && r === n[2] || e === n[2] && r === n[1]) && (this.constrained_edge[0] = !0);
};
function Ru(r, e) {
  if (!r)
    throw new Error(e || "Assert Failed");
}
var Ou = function(r, e) {
  this.point = r, this.triangle = e || null, this.next = null, this.prev = null, this.value = r.x;
}, Un = function(r, e) {
  this.head_ = r, this.tail_ = e, this.search_node_ = r;
};
Un.prototype.head = function() {
  return this.head_;
};
Un.prototype.setHead = function(r) {
  this.head_ = r;
};
Un.prototype.tail = function() {
  return this.tail_;
};
Un.prototype.setTail = function(r) {
  this.tail_ = r;
};
Un.prototype.search = function() {
  return this.search_node_;
};
Un.prototype.setSearch = function(r) {
  this.search_node_ = r;
};
Un.prototype.findSearchNode = function() {
  return this.search_node_;
};
Un.prototype.locateNode = function(r) {
  var e = this.search_node_;
  if (r < e.value) {
    for (; e = e.prev; )
      if (r >= e.value)
        return this.search_node_ = e, e;
  } else
    for (; e = e.next; )
      if (r < e.value)
        return this.search_node_ = e.prev, e.prev;
  return null;
};
Un.prototype.locatePoint = function(r) {
  var e = r.x, n = this.findSearchNode(e), i = n.point.x;
  if (e === i) {
    if (r !== n.point)
      if (r === n.prev.point)
        n = n.prev;
      else if (r === n.next.point)
        n = n.next;
      else
        throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");
  } else if (e < i)
    for (; (n = n.prev) && r !== n.point; )
      ;
  else
    for (; (n = n.next) && r !== n.point; )
      ;
  return n && (this.search_node_ = n), n;
};
const YM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AdvancingFront: Un,
  Node: Ou
}, Symbol.toStringTag, { value: "Module" }));
var mo = 1e-12, Ga = {
  CW: 1,
  CCW: -1,
  COLLINEAR: 0
};
function HM(r, e, n) {
  var i = (r.x - n.x) * (e.y - n.y), s = (r.y - n.y) * (e.x - n.x), o = i - s;
  return o > -mo && o < mo ? Ga.COLLINEAR : o > 0 ? Ga.CCW : Ga.CW;
}
function XM(r, e, n, i) {
  var s = (r.x - e.x) * (i.y - e.y) - (i.x - e.x) * (r.y - e.y);
  if (s >= -mo)
    return !1;
  var o = (r.x - n.x) * (i.y - n.y) - (i.x - n.x) * (r.y - n.y);
  return !(o <= mo);
}
function ZM(r, e, n) {
  var i = e.x - r.x, s = e.y - r.y, o = n.x - r.x, a = n.y - r.y;
  return i * o + s * a < 0;
}
var GM = mo, Jt = Ga, se = HM, Wy = XM, Yd = ZM;
function jy(r) {
  r.initTriangulation(), r.createAdvancingFront(), JM(r), QM(r);
}
function JM(r) {
  var e, n = r.pointCount();
  for (e = 1; e < n; ++e)
    for (var i = r.getPoint(e), s = KM(r, i), o = i._p2t_edge_list, a = 0; o && a < o.length; ++a)
      t_(r, o[a], s);
}
function QM(r) {
  for (var e = r.front().head().next.triangle, n = r.front().head().next.point; !e.getConstrainedEdgeCW(n); )
    e = e.neighborCCW(n);
  r.meshClean(e);
}
function KM(r, e) {
  var n = r.locateNode(e), i = e_(r, e, n);
  return e.x <= n.point.x + GM && vr(r, n), n_(r, i), i;
}
function t_(r, e, n) {
  r.edge_event.constrained_edge = e, r.edge_event.right = e.p.x > e.q.x, !Yy(n.triangle, e.p, e.q) && (a_(r, e, n), Lu(r, e.p, e.q, n.triangle, e.q));
}
function Lu(r, e, n, i, s) {
  if (!Yy(i, e, n)) {
    var o = i.pointCCW(s), a = se(n, o, e);
    if (a === Jt.COLLINEAR)
      throw new fi("poly2tri EdgeEvent: Collinear not supported!", [n, o, e]);
    var h = i.pointCW(s), c = se(n, h, e);
    if (c === Jt.COLLINEAR)
      throw new fi("poly2tri EdgeEvent: Collinear not supported!", [n, h, e]);
    a === c ? (a === Jt.CW ? i = i.neighborCCW(s) : i = i.neighborCW(s), Lu(r, e, n, i, s)) : Nu(r, e, n, i, s);
  }
}
function Yy(r, e, n) {
  var i = r.edgeIndex(e, n);
  if (i !== -1) {
    r.markConstrainedEdgeByIndex(i);
    var s = r.getNeighbor(i);
    return s && s.markConstrainedEdgeByPoints(e, n), !0;
  }
  return !1;
}
function e_(r, e, n) {
  var i = new zt(e, n.point, n.next.point);
  i.markNeighbor(n.triangle), r.addToMap(i);
  var s = new Ou(e);
  return s.next = n.next, s.prev = n, n.next.prev = s, n.next = s, ki(r, i) || r.mapTriangleToNodes(i), s;
}
function vr(r, e) {
  var n = new zt(e.prev.point, e.point, e.next.point);
  n.markNeighbor(e.prev.triangle), n.markNeighbor(e.triangle), r.addToMap(n), e.prev.next = e.next, e.next.prev = e.prev, ki(r, n) || r.mapTriangleToNodes(n);
}
function n_(r, e) {
  for (var n = e.next; n.next && !Yd(n.point, n.next.point, n.prev.point); )
    vr(r, n), n = n.next;
  for (n = e.prev; n.prev && !Yd(n.point, n.next.point, n.prev.point); )
    vr(r, n), n = n.prev;
  e.next && e.next.next && i_(e) && r_(r, e);
}
function i_(r) {
  var e = r.point.x - r.next.next.point.x, n = r.point.y - r.next.next.point.y;
  return Ru(n >= 0, "unordered y"), e >= 0 || Math.abs(e) < n;
}
function ki(r, e) {
  for (var n = 0; n < 3; ++n)
    if (!e.delaunay_edge[n]) {
      var i = e.getNeighbor(n);
      if (i) {
        var s = e.getPoint(n), o = i.oppositePoint(e, s), a = i.index(o);
        if (i.constrained_edge[a] || i.delaunay_edge[a]) {
          e.constrained_edge[n] = i.constrained_edge[a];
          continue;
        }
        var h = s_(s, e.pointCCW(s), e.pointCW(s), o);
        if (h) {
          e.delaunay_edge[n] = !0, i.delaunay_edge[a] = !0, Hy(e, s, i, o);
          var c = !ki(r, e);
          return c && r.mapTriangleToNodes(e), c = !ki(r, i), c && r.mapTriangleToNodes(i), e.delaunay_edge[n] = !1, i.delaunay_edge[a] = !1, !0;
        }
      }
    }
  return !1;
}
function s_(r, e, n, i) {
  var s = r.x - i.x, o = r.y - i.y, a = e.x - i.x, h = e.y - i.y, c = s * h, l = a * o, u = c - l;
  if (u <= 0)
    return !1;
  var f = n.x - i.x, d = n.y - i.y, p = f * o, y = s * d, x = p - y;
  if (x <= 0)
    return !1;
  var m = a * d, g = f * h, w = s * s + o * o, M = a * a + h * h, S = f * f + d * d, E = w * (m - g) + M * x + S * u;
  return E > 0;
}
function Hy(r, e, n, i) {
  var s, o, a, h;
  s = r.neighborCCW(e), o = r.neighborCW(e), a = n.neighborCCW(i), h = n.neighborCW(i);
  var c, l, u, f;
  c = r.getConstrainedEdgeCCW(e), l = r.getConstrainedEdgeCW(e), u = n.getConstrainedEdgeCCW(i), f = n.getConstrainedEdgeCW(i);
  var d, p, y, x;
  d = r.getDelaunayEdgeCCW(e), p = r.getDelaunayEdgeCW(e), y = n.getDelaunayEdgeCCW(i), x = n.getDelaunayEdgeCW(i), r.legalize(e, i), n.legalize(i, e), n.setDelaunayEdgeCCW(e, d), r.setDelaunayEdgeCW(e, p), r.setDelaunayEdgeCCW(i, y), n.setDelaunayEdgeCW(i, x), n.setConstrainedEdgeCCW(e, c), r.setConstrainedEdgeCW(e, l), r.setConstrainedEdgeCCW(i, u), n.setConstrainedEdgeCW(i, f), r.clearNeighbors(), n.clearNeighbors(), s && n.markNeighbor(s), o && r.markNeighbor(o), a && r.markNeighbor(a), h && n.markNeighbor(h), r.markNeighbor(n);
}
function r_(r, e) {
  for (se(e.point, e.next.point, e.next.next.point) === Jt.CCW ? r.basin.left_node = e.next.next : r.basin.left_node = e.next, r.basin.bottom_node = r.basin.left_node; r.basin.bottom_node.next && r.basin.bottom_node.point.y >= r.basin.bottom_node.next.point.y; )
    r.basin.bottom_node = r.basin.bottom_node.next;
  if (r.basin.bottom_node !== r.basin.left_node) {
    for (r.basin.right_node = r.basin.bottom_node; r.basin.right_node.next && r.basin.right_node.point.y < r.basin.right_node.next.point.y; )
      r.basin.right_node = r.basin.right_node.next;
    r.basin.right_node !== r.basin.bottom_node && (r.basin.width = r.basin.right_node.point.x - r.basin.left_node.point.x, r.basin.left_highest = r.basin.left_node.point.y > r.basin.right_node.point.y, Xy(r, r.basin.bottom_node));
  }
}
function Xy(r, e) {
  if (!o_(r, e)) {
    vr(r, e);
    var n;
    if (!(e.prev === r.basin.left_node && e.next === r.basin.right_node)) {
      if (e.prev === r.basin.left_node) {
        if (n = se(e.point, e.next.point, e.next.next.point), n === Jt.CW)
          return;
        e = e.next;
      } else if (e.next === r.basin.right_node) {
        if (n = se(e.point, e.prev.point, e.prev.prev.point), n === Jt.CCW)
          return;
        e = e.prev;
      } else
        e.prev.point.y < e.next.point.y ? e = e.prev : e = e.next;
      Xy(r, e);
    }
  }
}
function o_(r, e) {
  var n;
  return r.basin.left_highest ? n = r.basin.left_node.point.y - e.point.y : n = r.basin.right_node.point.y - e.point.y, r.basin.width > n;
}
function a_(r, e, n) {
  r.edge_event.right ? h_(r, e, n) : c_(r, e, n);
}
function h_(r, e, n) {
  for (; n.next.point.x < e.p.x; )
    se(e.q, n.next.point, e.p) === Jt.CCW ? Zy(r, e, n) : n = n.next;
}
function Zy(r, e, n) {
  n.point.x < e.p.x && (se(n.point, n.next.point, n.next.next.point) === Jt.CCW ? Bu(r, e, n) : (Gy(r, e, n), Zy(r, e, n)));
}
function Bu(r, e, n) {
  vr(r, n.next), n.next.point !== e.p && se(e.q, n.next.point, e.p) === Jt.CCW && se(n.point, n.next.point, n.next.next.point) === Jt.CCW && Bu(r, e, n);
}
function Gy(r, e, n) {
  se(n.next.point, n.next.next.point, n.next.next.next.point) === Jt.CCW ? Bu(r, e, n.next) : se(e.q, n.next.next.point, e.p) === Jt.CCW && Gy(r, e, n.next);
}
function c_(r, e, n) {
  for (; n.prev.point.x > e.p.x; )
    se(e.q, n.prev.point, e.p) === Jt.CW ? Jy(r, e, n) : n = n.prev;
}
function Jy(r, e, n) {
  n.point.x > e.p.x && (se(n.point, n.prev.point, n.prev.prev.point) === Jt.CW ? Fu(r, e, n) : (Qy(r, e, n), Jy(r, e, n)));
}
function Qy(r, e, n) {
  se(n.prev.point, n.prev.prev.point, n.prev.prev.prev.point) === Jt.CW ? Fu(r, e, n.prev) : se(e.q, n.prev.prev.point, e.p) === Jt.CW && Qy(r, e, n.prev);
}
function Fu(r, e, n) {
  vr(r, n.prev), n.prev.point !== e.p && se(e.q, n.prev.point, e.p) === Jt.CW && se(n.point, n.prev.point, n.prev.prev.point) === Jt.CW && Fu(r, e, n);
}
function Nu(r, e, n, i, s) {
  var o = i.neighborAcross(s);
  Ru(o, "FLIP failed due to missing triangle!");
  var a = o.oppositePoint(i, s);
  if (i.getConstrainedEdgeAcross(s)) {
    var h = i.index(s);
    throw new fi(
      "poly2tri Intersecting Constraints",
      [s, a, i.getPoint((h + 1) % 3), i.getPoint((h + 2) % 3)]
    );
  }
  if (Wy(s, i.pointCCW(s), i.pointCW(s), a))
    if (Hy(i, s, o, a), r.mapTriangleToNodes(i), r.mapTriangleToNodes(o), s === n && a === e)
      n === r.edge_event.constrained_edge.q && e === r.edge_event.constrained_edge.p && (i.markConstrainedEdgeByPoints(e, n), o.markConstrainedEdgeByPoints(e, n), ki(r, i), ki(r, o));
    else {
      var c = se(n, a, e);
      i = l_(r, c, i, o, s, a), Nu(r, e, n, i, s);
    }
  else {
    var l = Ky(e, n, o, a);
    tx(r, e, n, i, o, l), Lu(r, e, n, i, s);
  }
}
function l_(r, e, n, i, s, o) {
  var a;
  return e === Jt.CCW ? (a = i.edgeIndex(s, o), i.delaunay_edge[a] = !0, ki(r, i), i.clearDelaunayEdges(), n) : (a = n.edgeIndex(s, o), n.delaunay_edge[a] = !0, ki(r, n), n.clearDelaunayEdges(), i);
}
function Ky(r, e, n, i) {
  var s = se(e, i, r);
  if (s === Jt.CW)
    return n.pointCCW(i);
  if (s === Jt.CCW)
    return n.pointCW(i);
  throw new fi("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [e, i, r]);
}
function tx(r, e, n, i, s, o) {
  var a = s.neighborAcross(o);
  Ru(a, "FLIP failed due to missing triangle");
  var h = a.oppositePoint(s, o);
  if (Wy(n, i.pointCCW(n), i.pointCW(n), h))
    Nu(r, n, h, a, h);
  else {
    var c = Ky(e, n, a, h);
    tx(r, e, n, i, a, c);
  }
}
const u_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  triangulate: jy
}, Symbol.toStringTag, { value: "Module" })), Ec = Ou;
var Hd = 0.3, f_ = function(r, e) {
  if (this.p = r, this.q = e, r.y > e.y)
    this.q = r, this.p = e;
  else if (r.y === e.y) {
    if (r.x > e.x)
      this.q = r, this.p = e;
    else if (r.x === e.x)
      throw new fi("poly2tri Invalid Edge constructor: repeated points!", [r]);
  }
  this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this);
}, ex = function() {
  this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;
};
ex.prototype.clear = function() {
  this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;
};
var d_ = function() {
  this.constrained_edge = null, this.right = !1;
}, Ot = function(r, e) {
  e = e || {}, this.triangles_ = [], this.map_ = [], this.points_ = e.cloneArrays ? r.slice(0) : r, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new ex(), this.edge_event = new d_(), this.initEdges(this.points_);
};
Ot.prototype.addHole = function(r) {
  this.initEdges(r);
  var e, n = r.length;
  for (e = 0; e < n; e++)
    this.points_.push(r[e]);
  return this;
};
Ot.prototype.AddHole = Ot.prototype.addHole;
Ot.prototype.addHoles = function(r) {
  var e, n = r.length;
  for (e = 0; e < n; e++)
    this.initEdges(r[e]);
  return this.points_ = this.points_.concat.apply(this.points_, r), this;
};
Ot.prototype.addPoint = function(r) {
  return this.points_.push(r), this;
};
Ot.prototype.AddPoint = Ot.prototype.addPoint;
Ot.prototype.addPoints = function(r) {
  return this.points_ = this.points_.concat(r), this;
};
Ot.prototype.triangulate = function() {
  return jy(this), this;
};
Ot.prototype.getBoundingBox = function() {
  return { min: this.pmin_, max: this.pmax_ };
};
Ot.prototype.getTriangles = function() {
  return this.triangles_;
};
Ot.prototype.GetTriangles = Ot.prototype.getTriangles;
Ot.prototype.front = function() {
  return this.front_;
};
Ot.prototype.pointCount = function() {
  return this.points_.length;
};
Ot.prototype.head = function() {
  return this.head_;
};
Ot.prototype.setHead = function(r) {
  this.head_ = r;
};
Ot.prototype.tail = function() {
  return this.tail_;
};
Ot.prototype.setTail = function(r) {
  this.tail_ = r;
};
Ot.prototype.getMap = function() {
  return this.map_;
};
Ot.prototype.initTriangulation = function() {
  var r = this.points_[0].x, e = this.points_[0].x, n = this.points_[0].y, i = this.points_[0].y, s, o = this.points_.length;
  for (s = 1; s < o; s++) {
    var a = this.points_[s];
    a.x > r && (r = a.x), a.x < e && (e = a.x), a.y > n && (n = a.y), a.y < i && (i = a.y);
  }
  this.pmin_ = new It(e, i), this.pmax_ = new It(r, n);
  var h = Hd * (r - e), c = Hd * (n - i);
  this.head_ = new It(r + h, i - c), this.tail_ = new It(e - h, i - c), this.points_.sort(It.compare);
};
Ot.prototype.initEdges = function(r) {
  var e, n = r.length;
  for (e = 0; e < n; ++e)
    this.edge_list.push(new f_(r[e], r[(e + 1) % n]));
};
Ot.prototype.getPoint = function(r) {
  return this.points_[r];
};
Ot.prototype.addToMap = function(r) {
  this.map_.push(r);
};
Ot.prototype.locateNode = function(r) {
  return this.front_.locateNode(r.x);
};
Ot.prototype.createAdvancingFront = function() {
  var r, e, n, i = new zt(this.points_[0], this.tail_, this.head_);
  this.map_.push(i), r = new Ec(i.getPoint(1), i), e = new Ec(i.getPoint(0), i), n = new Ec(i.getPoint(2)), this.front_ = new YM(r, n), r.next = e, e.next = n, e.prev = r, n.prev = e;
};
Ot.prototype.removeNode = function(r) {
};
Ot.prototype.mapTriangleToNodes = function(r) {
  for (var e = 0; e < 3; ++e)
    if (!r.getNeighbor(e)) {
      var n = this.front_.locatePoint(r.pointCW(r.getPoint(e)));
      n && (n.triangle = r);
    }
};
Ot.prototype.removeFromMap = function(r) {
  var e, n = this.map_, i = n.length;
  for (e = 0; e < i; e++)
    if (n[e] === r) {
      n.splice(e, 1);
      break;
    }
};
Ot.prototype.meshClean = function(r) {
  for (var e = [r], n, i; n = e.pop(); )
    if (!n.isInterior())
      for (n.setInterior(!0), this.triangles_.push(n), i = 0; i < 3; i++)
        n.constrained_edge[i] || e.push(n.getNeighbor(i));
};
var p_ = window.poly2tri;
const y_ = function() {
  return global.poly2tri = p_, exports;
}, x_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Point: It,
  PointError: fi,
  SweepContext: Ot,
  Triangle: zt,
  noConflict: y_,
  sweep: u_
}, Symbol.toStringTag, { value: "Module" })), Xd = Ms.default();
let m_ = class nx {
  constructor(e, n, i) {
    this.cx = e, this.cy = n, this.radius = i;
  }
  clone() {
    return new nx(this.cx, this.cy, this.radius);
  }
  copy(e) {
    return this.cx = e.cx, this.cy = e.cy, this.radius = e.radius, this;
  }
  setRadius(e) {
    return this.radius = e, this;
  }
  setCenter(e, n) {
    return this.cx = e, this.cy = n, this;
  }
  /**
   * 计算圆的面积
   *
   * @returns 返回圆的面积
   */
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  /**
   * 计算圆的周长
   *
   * @returns 返回圆的周长
   */
  getCircumference() {
    return 2 * Math.PI * this.radius;
  }
  distanceTo(e, n) {
    return Math.sqrt((e - this.cx) ** 2 + (n - this.cy) ** 2);
  }
  contains(e, n) {
    return this.distanceTo(e, n) <= this.radius;
  }
  containsStroke(e, n, i, s = 0.5) {
    const o = this.distanceTo(e, n), a = i * 0.5, h = (s - 0.5) * 2 * a, c = this.radius + h;
    return Math.abs(o - c) <= a;
  }
  containsBoundingRect(e, n) {
    return Xd.fromCircle(this.cx, this.cy, this.radius), Xd.containsXY(e, n);
  }
  getBoundingBox(e) {
    return e.fromCircle(this.cx, this.cy, this.radius), e;
  }
}, g_ = class ix {
  start = O.default();
  end = O.default();
  constructor(e = O.default(), n = O.default()) {
    this.start.copy(e), this.end.copy(n);
  }
  get length() {
    return this.end.distance(this.start);
  }
  get lengthSquared() {
    return this.end.distanceSquared(this.start);
  }
  clone() {
    return new ix(this.start, this.end);
  }
  copy(e) {
    this.start.copy(e.start), this.end.copy(e.end);
  }
  offset(e) {
    const n = this.end.clone().sub(this.start).normalize().perp();
    return this.start.add(n.clone().multiplyScalar(e)), this.end.add(n.clone().multiplyScalar(e)), this;
  }
  getDelta(e = O.default()) {
    return e.subVectors(this.end, this.start);
  }
  getCenter(e = O.default()) {
    return O.lerp(e, this.start, this.end, 0.5);
  }
  distanceTo(e, n) {
    const i = O.create(e, n), s = this.end.clone().sub(this.start), o = i.clone().sub(this.start);
    let a = o.dot(s) / s.dot(s);
    return a = Ce(a, 0, 1), o.distance(s.multiplyScalar(a));
  }
  /** 
       * 直线参数方程(x,y)=(x0+at, y0+bt) (a,b)是单位向量
       * 线段上的点参数方程:(x,y)=(x0+(x1-x0)t, y0+(y1-y0)t)
       * 直线一般式 Ax+By+C=0
        参数方程转一般式：
        x=x0+(x1-x0)t  t=(x-x0)/(x1-x0)
        y=y0+(y1-y0)t  t=(y-y0)/(y1-y0)
        (x-x0)/(x1-x0)=(y-y0)/(y1-y0)=(x-x0)(y1-y0)=(y-y0)(x1-x0)=(x-x0)dy=(y-y0)dx
        dx=bx-ax dy=by-ay
        (x-x0)dy-(y-y0)dx=0 =dx*x-x0dy-dx*y+y0dx=0
  
        Ax=dy,By=-dx,C=y0dx-x0dy
  
  
       * 线段与线段相交点
       * 法向式:
       * (x-x0)dy=(y-y0)dx
       * Ax+By+C=0
       * Cx+Dy+E=0
       * 克莱姆法则求解：
       * Ax+By=-C
       * Cx+Dy=-E
         d=AD-BC
         u=(BE-DC)/d
         v=(AE-CD)/d
      */
  intersectionFromLine(e, n = O.default()) {
    const i = this.getDelta(), s = e.getDelta(), o = i.cross(s);
    if (o === 0)
      return null;
    const a = e.start.clone().sub(this.start), h = a.cross(s) / o, c = a.cross(i) / o;
    return h < 0 || h > 1 || c < 0 || c > 1 ? null : (n.copy(i).multiplyScalar(h).add(this.start), n);
  }
  /**
   * y=xk+b b=y-xk
   * 适用所有直线
   * 计算截距:Ax+By+C=0
   * (x-x0)dy-(y-y0)dx=
   * 横截距 a=-C/A 
   * 纵截距 b=-C/B 
  */
  intercept() {
    const e = this.getDelta(), n = e.y, i = -e.x, s = e.cross(this.start);
    return {
      x: -s / n,
      y: -s / i
    };
  }
  contains(e, n) {
    return this.distanceTo(e, n) < 1e-6;
  }
  containsStroke(e, n, i, s = 0.5) {
    const o = i * 0.5, a = (s - 0.5) * 2 * o;
    return this.clone().offset(a).distanceTo(e, n) <= o;
  }
  getBoundingBox(e) {
    let n = Math.min(this.start.x, this.end.x), i = Math.min(this.start.y, this.end.y), s = Math.abs(this.start.x - this.end.x), o = Math.abs(this.start.y - this.end.y);
    return e.fromRect(n, i, s, o), e;
  }
};
function w_(r, e, n, i, s, o) {
  let a = s - n, h = o - i, c = r - n, l = e - i;
  if (a !== 0 || h !== 0) {
    let u = (c * a + l * h) / (a * a + h * h);
    return u = Ce(u, 0, 1), Math.hypot(c - a * u, c - h * u);
  }
  return Number.POSITIVE_INFINITY;
}
let b_ = class {
  vertices;
  constructor(e) {
    this.vertices = e;
  }
  getVectors() {
    return this.vertices.map((e) => O.create(e.x, e.y));
  }
  getArea() {
    let e = 0;
    for (let n = 0; n < this.vertices.length; n++) {
      const i = this.vertices[n], s = this.vertices[(n + 1) % this.vertices.length];
      e += i.x * s.y - i.y * s.x;
    }
    return Math.abs(e / 2);
  }
  getBoundingBox(e) {
    return e.setFromPoints(this.vertices), e;
  }
  contains(e, n, i) {
    let s = 0;
    for (let o = 0; o < this.vertices.length; o++) {
      let a = this.vertices[o], h = this.vertices[(o + 1) % this.vertices.length], c = a.x, l = a.y, u = h.x, f = h.y;
      n > l != n > f && e < (u - c) * (n - l) / (f - l) + c && (i === "nonzero" ? s += l < f ? 1 : -1 : i === "evenodd" && s++);
    }
    return s % 2 !== 0;
  }
  containsStroke(e, n, i, s = 0.5) {
    const o = i * 0.5, a = (s - 0.5) * 2 * o;
    for (let h = 0; h < this.vertices.length; h++) {
      let { x: c, y: l } = this.vertices[h], { x: u, y: f } = this.vertices[(h + 1) % this.vertices.length];
      const d = Math.hypot(u - c, f - l), p = (u - c) / d, y = (f - l) / d;
      c = c - y * a, l = l + p * a, u = u - y * a, f = f + p * a;
      const x = w_(e, n, c, l, u, f);
      if (Math.abs(x) <= o)
        return !0;
    }
    return !1;
  }
}, v_ = class {
  constructor(e, n, i, s) {
    this.x = e, this.y = n, this.width = i, this.height = s;
  }
  getCenter() {
    return O.create(this.x + this.width / 2, this.y + this.height / 2);
  }
  /**
   * 计算矩形的面积
   * @returns 矩形的面积
   */
  getArea() {
    return this.width * this.height;
  }
  /**
   * 计算矩形的周长
   * @returns 矩形的周长
   */
  getPerimeter() {
    return 2 * (this.width + this.height);
  }
  distanceTo(e, n) {
    const i = this.getCenter(), s = this.width / 2, o = this.height / 2, a = Math.abs(e - i.x) - s, h = Math.abs(n - i.y) - o, c = Math.max(0, a), l = Math.max(0, h);
    return c > 0 || l > 0 ? Math.sqrt(c * c + l * l) : Math.min(0, Math.max(a, h));
  }
  /**
   * 判断一个点是否在矩形内
   * @param x 点的 x 坐标
   * @param y 点的 y 坐标
   * @returns 如果点在矩形内返回 true，否则返回 false
   */
  containsPoint(e, n) {
    return !(e < this.x || e > this.x + this.width || n < this.y || n > this.y + this.height);
  }
  containsStroke(e, n, i, s = 0.5) {
    const o = this.distanceTo(e, n), a = i * 0.5, h = (s - 0.5) * 2 * a;
    return Math.abs(o - h) <= a;
  }
};
class M_ {
  constructor(e, n) {
    this.m = e, this.x0 = n;
  }
  static from(e, n) {
    return new this(e, n.x - e * n.y);
  }
  static fromPoint(e, n) {
    return this.from((n.x - e.x) / (n.y - e.y), e);
  }
  static fromFloat(e) {
    return new this(0, e);
  }
  getX(e) {
    return this.m * e + this.x0;
  }
}
class __ {
  static fromLine(e, n, i, s) {
    return new this(e, n, i.getX(e), i.getX(n), s.getX(e), s.getX(n));
  }
  //    y1    --------
  //         /       /
  //        /       /
  //       /       /
  //    y0 --------
  //      x0 x1   x2 x3
  y0 = 0;
  y1 = 0;
  x0 = 0;
  x1 = 0;
  x2 = 0;
  x3 = 0;
  constructor(e, n, i, s, o, a) {
    this.y0 = e, this.y1 = n, this.x0 = i, this.x1 = s, this.x2 = o, this.x3 = a;
  }
  getArea() {
    const { y0: e, y1: n, x2: i, x3: s, x0: o, x1: a } = this;
    return (n - e) * (i + s - o - a) * 0.5;
  }
}
let S_ = class os {
  constructor(e, n, i, s, o, a) {
    this.x1 = e, this.y1 = n, this.x2 = i, this.y2 = s, this.x3 = o, this.y3 = a;
  }
  /**
   * 计算三角形的面积（使用向量叉积法）
   * @returns 三角形的面积
   */
  getArea() {
    return Math.abs(
      0.5 * (this.x1 * (this.y2 - this.y3) + this.x2 * (this.y3 - this.y1) + this.x3 * (this.y1 - this.y2))
    );
  }
  /**
   * 判断一个点是否在三角形内（使用面积法）
   * @param px 点的 x 坐标
   * @param py 点的 y 坐标
   * @returns 如果点在三角形内返回 true，否则返回 false
   */
  containsPoint(e, n) {
    const i = this.getArea(), s = new os(e, n, this.x1, this.y1, this.x2, this.y2).getArea(), o = new os(e, n, this.x2, this.y2, this.x3, this.y3).getArea(), a = new os(e, n, this.x3, this.y3, this.x1, this.y1).getArea();
    return Math.abs(i - (s + o + a)) < 1e-9;
  }
  /**
   * 计算给定点相对于当前三角形的重心坐标
   * @param px 点的 x 坐标
   * @param py 点的 y 坐标
   * @returns 包含重心坐标 (u, v, w) 的对象，如果点不在三角形内，返回 null
   */
  getBarycentricCoordinates(e, n) {
    const i = this.getArea(), s = new os(e, n, this.x2, this.y2, this.x3, this.y3).getArea(), o = new os(e, n, this.x3, this.y3, this.x1, this.y1).getArea(), a = new os(e, n, this.x1, this.y1, this.x2, this.y2).getArea(), h = s / i, c = o / i, l = a / i;
    return { u: h, v: c, w: l };
  }
  // barycentric(x:number,y:number) {
  //     const cross = (a, b) => {
  //         return a[0] * b[1] - a[1] * b[0]
  //     }
  //     // 一般要保证叉乘的顺序，保证p如果在三角形内是正数
  //     let bc = vec2.sub([], b, c)
  //     let ca = vec2.sub([], c, a)
  //     let pc = vec2.sub([], p, c)
  //     let area = cross(bc, ca)
  //     // 如果在右边，叉乘的结果是正数
  //     let alpha = cross(pc, bc) / area 
  //     let beta = cross(pc, ca) / area
  //     let gamma = 1 - alpha - beta
  //     return [alpha, beta, gamma]
  //     //  return barycentric4(a,b,c,p)
  // }
};
const T_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: m_,
  Line: g_,
  Polygon: b_,
  RasterizeLine: M_,
  Rectangle: v_,
  Trapezoid: __,
  Triangle: S_
}, Symbol.toStringTag, { value: "Module" }));
function Dh(r, e, n) {
  let i = 0, s = 1;
  const o = e.x - r.x, a = e.y - r.y, h = (c, l) => {
    if (c == 0 && l < 0) return !1;
    const u = l / c;
    if (c < 0) {
      if (u > s) return !1;
      u > i && (i = u);
    } else if (c > 0) {
      if (u < i) return !1;
      u < s && (s = u);
    }
    return !0;
  };
  return !h(-o, r.x - n.xmin) || !h(o, n.xmax - r.x) || !h(-a, r.y - n.ymin) || !h(a, n.ymax - r.y) ? null : [
    { x: r.x + i * o, y: r.y + i * a },
    { x: r.x + s * o, y: r.y + s * a }
  ];
}
function E_(r, e, n) {
  return Dh(r, e, n);
}
const z_ = 0, sx = 1, rx = 2, ox = 4, ax = 8;
function cr(r, e) {
  let n = z_;
  return r.x < e.xmin ? n |= sx : r.x > e.xmax && (n |= rx), r.y < e.ymin ? n |= ox : r.y > e.ymax && (n |= ax), n;
}
function A_(r, e, n) {
  let i = cr(r, n), s = cr(e, n);
  for (; ; ) {
    if (!(i | s)) return [r, e];
    if (i & s) return null;
    let o = 0, a = 0;
    const h = i || s;
    h & ax ? (o = r.x + (e.x - r.x) * (n.ymax - r.y) / (e.y - r.y), a = n.ymax) : h & ox ? (o = r.x + (e.x - r.x) * (n.ymin - r.y) / (e.y - r.y), a = n.ymin) : h & rx ? (a = r.y + (e.y - r.y) * (n.xmax - r.x) / (e.x - r.x), o = n.xmax) : h & sx && (a = r.y + (e.y - r.y) * (n.xmin - r.x) / (e.x - r.x), o = n.xmin), h === i ? (r = { x: o, y: a }, i = cr(r, n)) : (e = { x: o, y: a }, s = cr(e, n));
  }
}
function ql(r, e, n) {
  let i = cr(r, n), s = cr(e, n);
  if (!(i | s)) return [r, e];
  if (i & s || Math.abs(e.x - r.x) < 1e-6 && Math.abs(e.y - r.y) < 1e-6) return null;
  const o = { x: (r.x + e.x) / 2, y: (r.y + e.y) / 2 };
  return [...ql(r, o, n) || [], ...ql(o, e, n) || []];
}
function C_(r, e, n) {
  return Dh(r, e, n);
}
function P_(r, e, n) {
  return Dh(r, e, n);
}
const I_ = (r, e) => {
  const n = (h) => {
    let c = 0;
    return h.x < e.left && (c |= 1), h.x > e.right && (c |= 2), h.y < e.bottom && (c |= 4), h.y > e.top && (c |= 8), c;
  };
  let [i, s] = r, o = n(i), a = n(s);
  for (; ; ) {
    if ((o | a) === 0) return [i, s];
    if ((o & a) !== 0) return null;
    const h = o !== 0 ? o : a;
    let c = { x: 0, y: 0 };
    h & 8 ? (c.x = i.x + (s.x - i.x) * (e.top - i.y) / (s.y - i.y), c.y = e.top) : h & 4 ? (c.x = i.x + (s.x - i.x) * (e.bottom - i.y) / (s.y - i.y), c.y = e.bottom) : h & 2 ? (c.y = i.y + (s.y - i.y) * (e.right - i.x) / (s.x - i.x), c.x = e.right) : h & 1 && (c.y = i.y + (s.y - i.y) * (e.left - i.x) / (s.x - i.x), c.x = e.left), h === o ? (i = c, o = n(i)) : (s = c, a = n(s));
  }
}, k_ = (r, e) => {
  let n = [r[0], r[1]];
  for (const i of e) {
    const s = [];
    for (let o = 0; o < n.length; o++) {
      const a = n[o], h = n[(o + 1) % n.length], c = i.normal[0] * (a.x - i.point.x) + i.normal[1] * (a.y - i.point.y), l = i.normal[0] * (h.x - i.point.x) + i.normal[1] * (h.y - i.point.y);
      if (c <= 0 && s.push(a), c < 0 && l > 0 || c > 0 && l < 0) {
        const u = -c / (l - c);
        s.push({
          x: a.x + u * (h.x - a.x),
          y: a.y + u * (h.y - a.y)
        });
      }
    }
    n = s;
  }
  return n;
}, R_ = (r, e, n = 1) => {
  const i = (a, h) => {
    let c = a, l = h;
    for (; Math.hypot(l.x - c.x, l.y - c.y) > n; ) {
      const u = {
        x: (c.x + l.x) / 2,
        y: (c.y + l.y) / 2
      };
      u.x < e.left || u.x > e.right || u.y < e.bottom || u.y > e.top ? l = u : c = u;
    }
    return c;
  }, s = i(r[0], r[1]), o = i(r[1], r[0]);
  return Math.abs(s.x - o.x) > n || Math.abs(s.y - o.y) > n ? [s, o] : null;
};
function O_(r, e) {
  let n = r;
  for (let i = 0; i < e.length; i++) {
    const s = e[i], o = e[(i + 1) % e.length], a = n;
    if (n = [], a.length === 0) break;
    let h = a[a.length - 1];
    for (const c of a) {
      const l = Zd(h, s, o);
      if (Zd(c, s, o)) {
        if (!l) {
          const f = Gd(
            h,
            c,
            s,
            o
          );
          f && n.push(f);
        }
        n.push(c);
      } else if (l) {
        const f = Gd(
          h,
          c,
          s,
          o
        );
        f && n.push(f);
      }
      h = c;
    }
  }
  return n;
}
function Zd(r, e, n) {
  return (n.x - e.x) * (r.y - e.y) > (n.y - e.y) * (r.x - e.x);
}
function Gd(r, e, n, i) {
  const s = e.x - r.x, o = e.y - r.y, a = i.x - n.x, h = i.y - n.y, c = s * h - o * a;
  if (c === 0) return null;
  const l = n.x - r.x, u = n.y - r.y, f = (l * h - u * a) / c;
  return {
    x: r.x + f * (e.x - r.x),
    y: r.y + f * (e.y - r.y)
  };
}
const L_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CohenSutherlandClip: I_,
  MidpointClip: R_,
  SutherlandHodgmanClip: k_,
  cohenSutherland: A_,
  cyrusBeck: P_,
  equationBasedClipping: C_,
  liangBarsky: Dh,
  midpointSubdivision: ql,
  nichollLeeNicholl: E_,
  sutherlandHodgmanClip: O_
}, Symbol.toStringTag, { value: "Module" }));
var Pe = /* @__PURE__ */ ((r) => (r[r.ODD = 0] = "ODD", r[r.NONZERO = 1] = "NONZERO", r[r.POSITIVE = 2] = "POSITIVE", r[r.NEGATIVE = 3] = "NEGATIVE", r[r.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO", r))(Pe || {}), bn = /* @__PURE__ */ ((r) => (r[r.POLYGONS = 0] = "POLYGONS", r[r.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", r[r.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS", r))(bn || {});
function dt(r, e = void 0) {
  if (!r)
    throw e || "Assertion Failed!";
}
class tt {
  static vertEq(e, n) {
    return e.s === n.s && e.t === n.t;
  }
  /* Returns TRUE if u is lexicographically <= v. */
  static vertLeq(e, n) {
    return e.s < n.s || e.s === n.s && e.t <= n.t;
  }
  /* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */
  static transLeq(e, n) {
    return e.t < n.t || e.t === n.t && e.s <= n.s;
  }
  static edgeGoesLeft(e) {
    return tt.vertLeq(e.Dst, e.Org);
  }
  static edgeGoesRight(e) {
    return tt.vertLeq(e.Org, e.Dst);
  }
  static vertL1dist(e, n) {
    return Math.abs(e.s - n.s) + Math.abs(e.t - n.t);
  }
  //TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static edgeEval(e, n, i) {
    dt(tt.vertLeq(e, n) && tt.vertLeq(n, i));
    var s = n.s - e.s, o = i.s - n.s;
    return s + o > 0 ? s < o ? n.t - e.t + (e.t - i.t) * (s / (s + o)) : n.t - i.t + (i.t - e.t) * (o / (s + o)) : 0;
  }
  //TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static edgeSign(e, n, i) {
    dt(tt.vertLeq(e, n) && tt.vertLeq(n, i));
    var s = n.s - e.s, o = i.s - n.s;
    return s + o > 0 ? (n.t - i.t) * s + (n.t - e.t) * o : 0;
  }
  /***********************************************************************
   * Define versions of EdgeSign, EdgeEval with s and t transposed.
   */
  //TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static transEval(e, n, i) {
    dt(tt.transLeq(e, n) && tt.transLeq(n, i));
    var s = n.t - e.t, o = i.t - n.t;
    return s + o > 0 ? s < o ? n.s - e.s + (e.s - i.s) * (s / (s + o)) : n.s - i.s + (i.s - e.s) * (o / (s + o)) : 0;
  }
  //TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static transSign(e, n, i) {
    dt(tt.transLeq(e, n) && tt.transLeq(n, i));
    var s = n.t - e.t, o = i.t - n.t;
    return s + o > 0 ? (n.s - i.s) * s + (n.s - e.s) * o : 0;
  }
  //int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static vertCCW(e, n, i) {
    return e.s * (n.t - i.t) + n.s * (i.t - e.t) + i.s * (e.t - n.t) >= 0;
  }
  /* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
   * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
   * this in the rare case that one argument is slightly negative.
   * The implementation is extremely stable numerically.
   * In particular it guarantees that the result r satisfies
   * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
   * even when a and b differ greatly in magnitude.
   */
  static interpolate(e, n, i, s) {
    return e = e < 0 ? 0 : e, i = i < 0 ? 0 : i, e <= i ? i === 0 ? (n + s) / 2 : n + (s - n) * (e / (e + i)) : s + (n - s) * (i / (e + i));
  }
  /*
  	#ifndef FOR_TRITE_TEST_PROGRAM
  	#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
  	#else
  
  	// Claim: the ONLY property the sweep algorithm relies on is that
  	// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
  	#include <stdlib.h>
  	extern int RandomInterpolate;
  
  	double Interpolate( double a, double x, double b, double y)
  	{
  		printf("*********************%d\n",RandomInterpolate);
  		if( RandomInterpolate ) {
  			a = 1.2 * drand48() - 0.1;
  			a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
  			b = 1.0 - a;
  		}
  		return RealInterpolate(a,x,b,y);
  	}
  	#endif*/
  static intersect(e, n, i, s, o) {
    var a, h, c;
    tt.vertLeq(e, n) || (c = e, e = n, n = c), tt.vertLeq(i, s) || (c = i, i = s, s = c), tt.vertLeq(e, i) || (c = e, e = i, i = c, c = n, n = s, s = c), tt.vertLeq(i, n) ? tt.vertLeq(n, s) ? (a = tt.edgeEval(e, i, n), h = tt.edgeEval(i, n, s), a + h < 0 && (a = -a, h = -h), o.s = tt.interpolate(a, i.s, h, n.s)) : (a = tt.edgeSign(e, i, n), h = -tt.edgeSign(e, s, n), a + h < 0 && (a = -a, h = -h), o.s = tt.interpolate(a, i.s, h, s.s)) : o.s = (i.s + n.s) / 2, tt.transLeq(e, n) || (c = e, e = n, n = c), tt.transLeq(i, s) || (c = i, i = s, s = c), tt.transLeq(e, i) || (c = e, e = i, i = c, c = n, n = s, s = c), tt.transLeq(i, n) ? tt.transLeq(n, s) ? (a = tt.transEval(e, i, n), h = tt.transEval(i, n, s), a + h < 0 && (a = -a, h = -h), o.t = tt.interpolate(a, i.t, h, n.t)) : (a = tt.transSign(e, i, n), h = -tt.transSign(e, s, n), a + h < 0 && (a = -a, h = -h), o.t = tt.interpolate(a, i.t, h, s.t)) : o.t = (i.t + n.t) / 2;
  }
}
class $r {
  next = null;
  /* next face (never NULL) */
  prev = null;
  /* previous face (never NULL) */
  anEdge = null;
  /* a half edge with this left face */
  /* Internal data (keep hidden) */
  trail = null;
  /* "stack" for conversion to strips */
  n = 0;
  /* to allow identiy unique faces */
  marked = !1;
  /* flag for conversion to strips */
  inside = !1;
  /* this face is in the polygon interior */
}
class da {
  /* change in winding number when crossing from the right face to the left face */
  constructor(e) {
    this.side = e;
  }
  next = null;
  /* doubly-linked list (prev==Sym->next) */
  Org = null;
  /* origin vertex (Overtex too long) */
  Sym = null;
  /* same edge, opposite direction */
  Onext = null;
  /* next edge CCW around origin */
  Lnext = null;
  /* next edge CCW around left face */
  Lface = null;
  /* left face */
  /* Internal data (keep hidden) */
  activeRegion = null;
  /* a region with this upper edge (sweep.c) */
  winding = 0;
  get Rface() {
    return this.Sym.Lface;
  }
  set Rface(e) {
    this.Sym.Lface = e;
  }
  get Dst() {
    return this.Sym.Org;
  }
  set Dst(e) {
    this.Sym.Org = e;
  }
  get Oprev() {
    return this.Sym.Lnext;
  }
  set Oprev(e) {
    this.Sym.Lnext = e;
  }
  get Lprev() {
    return this.Onext.Sym;
  }
  set Lprev(e) {
    this.Onext.Sym = e;
  }
  get Dprev() {
    return this.Lnext.Sym;
  }
  set Dprev(e) {
    this.Lnext.Sym = e;
  }
  get Rprev() {
    return this.Sym.Onext;
  }
  set Rprev(e) {
    this.Sym.Onext = e;
  }
  get Dnext() {
    return this.Sym.Onext.Sym;
  }
  set Dnext(e) {
    this.Sym.Onext.Sym = e;
  }
  get Rnext() {
    return this.Sym.Lnext.Sym;
  }
  set Rnext(e) {
    this.Sym.Lnext.Sym = e;
  }
}
class ir {
  next = null;
  /* next vertex (never NULL) */
  prev = null;
  /* previous vertex (never NULL) */
  anEdge = null;
  /* a half-edge with this origin */
  /* Internal data (keep hidden) */
  coords = [0, 0, 0];
  /* vertex location in 3D */
  s = 0;
  t = 0;
  /* projection onto the sweep plane */
  pqHandle = 0;
  /* to allow deletion from priority queue */
  n = 0;
  /* to allow identify unique vertices */
  idx = 0;
  /* to allow map result to original verts */
}
class Jd {
  vHead;
  /* dummy header for vertex list */
  fHead;
  /* dummy header for face list */
  eHead;
  /* dummy header for edge list */
  eHeadSym;
  /* and its symmetric counterpart */
  constructor() {
    const e = new ir(), n = new $r(), i = new da(0), s = new da(1);
    e.next = e.prev = e, e.anEdge = null, n.next = n.prev = n, i.next = i, i.Sym = s, s.next = s, s.Sym = i, this.vHead = e, this.fHead = n, this.eHead = i, this.eHeadSym = s;
  }
  /* MakeEdge creates a new pair of half-edges which form their own loop.
   * No vertex or face structures are allocated, but these must be assigned
   * before the current edge operation is completed.
   */
  //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
  makeEdge_(e) {
    var n = new da(0), i = new da(1);
    e.Sym.side < e.side && (e = e.Sym);
    var s = e.Sym.next;
    return i.next = s, s.Sym.next = n, n.next = e, e.Sym.next = i, n.Sym = i, n.Onext = n, n.Lnext = i, n.Org = null, n.Lface = null, n.winding = 0, n.activeRegion = null, i.Sym = n, i.Onext = i, i.Lnext = n, i.Org = null, i.Lface = null, i.winding = 0, i.activeRegion = null, n;
  }
  /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
   * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
   * a->Onext and b->Onext are exchanged.  This can have various effects
   * depending on whether a and b belong to different face or vertex rings.
   * For more explanation see tessMeshSplice() below.
   */
  // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
  splice_(e, n) {
    var i = e.Onext, s = n.Onext;
    i.Sym.Lnext = n, s.Sym.Lnext = e, e.Onext = s, n.Onext = i;
  }
  /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
   * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
   * a place to insert the new vertex in the global vertex list.  We insert
   * the new vertex *before* vNext so that algorithms which walk the vertex
   * list will not see the newly created vertices.
   */
  //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
  makeVertex_(e, n, i) {
    var s = e;
    dt(s, "Vertex can't be null!");
    var o = i.prev;
    s.prev = o, o.next = s, s.next = i, i.prev = s, s.anEdge = n;
    var a = n;
    do
      a.Org = s, a = a.Onext;
    while (a !== n);
  }
  /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
   * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
   * a place to insert the new face in the global face list.  We insert
   * the new face *before* fNext so that algorithms which walk the face
   * list will not see the newly created faces.
   */
  // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
  makeFace_(e, n, i) {
    var s = e;
    dt(s, "Face can't be null");
    var o = i.prev;
    s.prev = o, o.next = s, s.next = i, i.prev = s, s.anEdge = n, s.trail = null, s.marked = !1, s.inside = i.inside;
    var a = n;
    do
      a.Lface = s, a = a.Lnext;
    while (a !== n);
  }
  /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
   * and removes from the global edge list.
   */
  //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
  killEdge_(e) {
    e.Sym.side < e.side && (e = e.Sym);
    var n = e.next, i = e.Sym.next;
    n.Sym.next = i, i.Sym.next = n;
  }
  /* KillVertex( vDel ) destroys a vertex and removes it from the global
   * vertex list.  It updates the vertex loop to point to a given new vertex.
   */
  //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
  killVertex_(e, n) {
    var i = e.anEdge, s = i;
    do
      s.Org = n, s = s.Onext;
    while (s !== i);
    var o = e.prev, a = e.next;
    a.prev = o, o.next = a;
  }
  /* KillFace( fDel ) destroys a face and removes it from the global face
   * list.  It updates the face loop to point to a given new face.
   */
  //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
  killFace_(e, n) {
    var i = e.anEdge, s = i;
    do
      s.Lface = n, s = s.Lnext;
    while (s !== i);
    var o = e.prev, a = e.next;
    a.prev = o, o.next = a;
  }
  /****************** Basic Edge Operations **********************/
  /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
   * The loop consists of the two new half-edges.
   */
  //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
  makeEdge() {
    var e = new ir(), n = new ir(), i = new $r(), s = this.makeEdge_(this.eHead);
    return this.makeVertex_(e, s, this.vHead), this.makeVertex_(n, s.Sym, this.vHead), this.makeFace_(i, s, this.fHead), s;
  }
  /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
   * mesh connectivity and topology.  It changes the mesh so that
   *	eOrg->Onext <- OLD( eDst->Onext )
   *	eDst->Onext <- OLD( eOrg->Onext )
   * where OLD(...) means the value before the meshSplice operation.
   *
   * This can have two effects on the vertex structure:
   *  - if eOrg->Org != eDst->Org, the two vertices are merged together
   *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
   * In both cases, eDst->Org is changed and eOrg->Org is untouched.
   *
   * Similarly (and independently) for the face structure,
   *  - if eOrg->Lface == eDst->Lface, one loop is split into two
   *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
   * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
   *
   * Some special cases:
   * If eDst == eOrg, the operation has no effect.
   * If eDst == eOrg->Lnext, the new face will have a single edge.
   * If eDst == eOrg->Lprev, the old face will have a single edge.
   * If eDst == eOrg->Onext, the new vertex will have a single edge.
   * If eDst == eOrg->Oprev, the old vertex will have a single edge.
   */
  //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
  splice(e, n) {
    var i = !1, s = !1;
    if (e !== n) {
      if (n.Org !== e.Org && (s = !0, this.killVertex_(n.Org, e.Org)), n.Lface !== e.Lface && (i = !0, this.killFace_(n.Lface, e.Lface)), this.splice_(n, e), !s) {
        var o = new ir();
        this.makeVertex_(o, n, e.Org), e.Org.anEdge = e;
      }
      if (!i) {
        var a = new $r();
        this.makeFace_(a, n, e.Lface), e.Lface.anEdge = e;
      }
    }
  }
  /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
   * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
   * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
   * the newly created loop will contain eDel->Dst.  If the deletion of eDel
   * would create isolated vertices, those are deleted as well.
   *
   * This function could be implemented as two calls to tessMeshSplice
   * plus a few calls to memFree, but this would allocate and delete
   * unnecessary vertices and faces.
   */
  //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
  delete(e) {
    var n = e.Sym, i = !1;
    if (e.Lface !== e.Rface && (i = !0, this.killFace_(e.Lface, e.Rface)), e.Onext === e)
      this.killVertex_(e.Org, null);
    else if (e.Rface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev), !i) {
      var s = new $r();
      this.makeFace_(s, e, e.Lface);
    }
    n.Onext === n ? (this.killVertex_(n.Org, null), this.killFace_(n.Lface, null)) : (e.Lface.anEdge = n.Oprev, n.Org.anEdge = n.Onext, this.splice_(n, n.Oprev)), this.killEdge_(e);
  }
  /******************** Other Edge Operations **********************/
  /* All these routines can be implemented with the basic edge
   * operations above.  They are provided for convenience and efficiency.
   */
  /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
   * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
   * eOrg and eNew will have the same left face.
   */
  // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
  addEdgeVertex(e) {
    var n = this.makeEdge_(e), i = n.Sym;
    this.splice_(n, e.Lnext), n.Org = e.Dst;
    var s = new ir();
    return this.makeVertex_(s, i, n.Org), n.Lface = i.Lface = e.Lface, n;
  }
  /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
   * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
   * eOrg and eNew will have the same left face.
   */
  // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
  splitEdge(e) {
    var n = this.addEdgeVertex(e), i = n.Sym;
    return this.splice_(e.Sym, e.Sym.Oprev), this.splice_(e.Sym, i), e.Dst = i.Org, i.Dst.anEdge = i.Sym, i.Rface = e.Rface, i.winding = e.winding, i.Sym.winding = e.Sym.winding, i;
  }
  /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
   * to eDst->Org, and returns the corresponding half-edge eNew.
   * If eOrg->Lface == eDst->Lface, this splits one loop into two,
   * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
   * loops are merged into one, and the loop eDst->Lface is destroyed.
   *
   * If (eOrg == eDst), the new face will have only two edges.
   * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
   * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
   */
  // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
  connect(e, n) {
    var i = !1, s = this.makeEdge_(e), o = s.Sym;
    if (n.Lface !== e.Lface && (i = !0, this.killFace_(n.Lface, e.Lface)), this.splice_(s, e.Lnext), this.splice_(o, n), s.Org = e.Dst, o.Org = n.Org, s.Lface = o.Lface = e.Lface, e.Lface.anEdge = o, !i) {
      var a = new $r();
      this.makeFace_(a, s, e.Lface);
    }
    return s;
  }
  /* tessMeshZapFace( fZap ) destroys a face and removes it from the
   * global face list.  All edges of fZap will have a NULL pointer as their
   * left face.  Any edges which also have a NULL pointer as their right face
   * are deleted entirely (along with any isolated vertices this produces).
   * An entire mesh can be deleted by zapping its faces, one at a time,
   * in any order.  Zapped faces cannot be used in further mesh operations!
   */
  zapFace(e) {
    var n = e.anEdge, i, s, o, a, h;
    s = n.Lnext;
    do
      i = s, s = i.Lnext, i.Lface = null, i.Rface === null && (i.Onext === i ? this.killVertex_(i.Org, null) : (i.Org.anEdge = i.Onext, this.splice_(i, i.Oprev)), o = i.Sym, o.Onext === o ? this.killVertex_(o.Org, null) : (o.Org.anEdge = o.Onext, this.splice_(o, o.Oprev)), this.killEdge_(i));
    while (i != n);
    a = e.prev, h = e.next, h.prev = a, a.next = h;
  }
  countFaceVerts_(e) {
    var n = e.anEdge, i = 0;
    do
      i++, n = n.Lnext;
    while (n !== e.anEdge);
    return i;
  }
  //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
  mergeConvexFaces(e) {
    var n, i, s, o, a, h, c;
    for (n = this.fHead.next; n !== this.fHead; n = n.next)
      if (n.inside)
        for (i = n.anEdge, a = i.Org; s = i.Lnext, o = i.Sym, o && o.Lface && o.Lface.inside && (h = this.countFaceVerts_(n), c = this.countFaceVerts_(o.Lface), h + c - 2 <= e && tt.vertCCW(
          i.Lprev.Org,
          i.Org,
          o.Lnext.Lnext.Org
        ) && tt.vertCCW(
          o.Lprev.Org,
          o.Org,
          i.Lnext.Lnext.Org
        ) && (s = o.Lnext, this.delete(o), i = null, o = null)), !(i && i.Lnext.Org === a); )
          i = s;
    return !0;
  }
  /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
   */
  check() {
    var e = this.fHead, n = this.vHead, i = this.eHead, s, o, a, h, c, l;
    for (o = e, o = e; (s = o.next) !== e; o = s) {
      dt(s.prev === o), c = s.anEdge;
      do
        dt(c.Sym !== c), dt(c.Sym.Sym === c), dt(c.Lnext.Onext.Sym === c), dt(c.Onext.Sym.Lnext === c), dt(c.Lface === s), c = c.Lnext;
      while (c !== s.anEdge);
    }
    for (dt(s.prev === o && s.anEdge === null), h = n, h = n; (a = h.next) !== n; h = a) {
      dt(a.prev === h), c = a.anEdge;
      do
        dt(c.Sym !== c), dt(c.Sym.Sym === c), dt(c.Lnext.Onext.Sym === c), dt(c.Onext.Sym.Lnext === c), dt(c.Org === a), c = c.Onext;
      while (c !== a.anEdge);
    }
    for (dt(a.prev === h && a.anEdge === null), l = i, l = i; (c = l.next) !== i; l = c)
      dt(c.Sym.next === l.Sym), dt(c.Sym !== c), dt(c.Sym.Sym === c), dt(c.Org !== null), dt(c.Dst !== null), dt(c.Lnext.Onext.Sym === c), dt(c.Onext.Sym.Lnext === c);
    dt(
      c.Sym.next === l.Sym && c.Sym === this.eHeadSym && c.Sym.Sym === c && c.Org === null && c.Dst === null && c.Lface === null && c.Rface === null
    );
  }
}
class Qd {
  handle = null;
}
class Kd {
  key = null;
  node = 0;
}
class B_ {
  constructor(e, n) {
    this.leq = n, this.max = e, this.nodes = [], this.handles = [];
    for (let i = 0; i < e + 1; i++)
      this.nodes[i] = new Qd(), this.handles[i] = new Kd();
    this.initialized = !1, this.nodes[1].handle = 1, this.handles[1].key = null;
  }
  max = 0;
  nodes = [];
  handles = [];
  initialized = !1;
  freeList = 0;
  size = 0;
  floatDown_(e) {
    var n = this.nodes, i = this.handles, s, o, a;
    for (s = n[e].handle; ; ) {
      if (a = e << 1, a < this.size && this.leq(i[n[a + 1].handle].key, i[n[a].handle].key) && ++a, dt(a <= this.max), o = n[a].handle, a > this.size || this.leq(i[s].key, i[o].key)) {
        n[e].handle = s, i[s].node = e;
        break;
      }
      n[e].handle = o, i[o].node = e, e = a;
    }
  }
  floatUp_(e) {
    var n = this.nodes, i = this.handles, s, o, a;
    for (s = n[e].handle; ; ) {
      if (a = e >> 1, o = n[a].handle, a === 0 || this.leq(i[o].key, i[s].key)) {
        n[e].handle = s, i[s].node = e;
        break;
      }
      n[e].handle = o, i[o].node = e, e = a;
    }
  }
  init() {
    for (let e = this.size; e >= 1; --e)
      this.floatDown_(e);
    this.initialized = !0;
  }
  min() {
    return this.handles[this.nodes[1].handle].key;
  }
  /* really pqHeapInsert */
  /* returns INV_HANDLE iff out of memory */
  //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
  insert(e) {
    var n, i;
    if (n = ++this.size, n * 2 > this.max) {
      this.max *= 2;
      var s, o;
      for (o = this.nodes.length, this.nodes.length = this.max + 1, s = o; s < this.nodes.length; s++)
        this.nodes[s] = new Qd();
      for (o = this.handles.length, this.handles.length = this.max + 1, s = o; s < this.handles.length; s++)
        this.handles[s] = new Kd();
    }
    return this.freeList === 0 ? i = n : (i = this.freeList, this.freeList = this.handles[i].node), this.nodes[n].handle = i, this.handles[i].node = n, this.handles[i].key = e, this.initialized && this.floatUp_(n), i;
  }
  //PQkey pqHeapExtractMin( PriorityQHeap *pq )
  extractMin() {
    var e = this.nodes, n = this.handles, i = e[1].handle, s = n[i].key;
    return this.size > 0 && (e[1].handle = e[this.size].handle, n[e[1].handle].node = 1, n[i].key = null, n[i].node = this.freeList, this.freeList = i, --this.size, this.size > 0 && this.floatDown_(1)), s;
  }
  delete(e) {
    var n = this.nodes, i = this.handles, s;
    dt(e >= 1 && e <= this.max && i[e].key !== null), s = i[e].node, n[s].handle = n[this.size].handle, i[n[s].handle].node = s, --this.size, s <= this.size && (s <= 1 || this.leq(i[n[s >> 1].handle].key, i[n[s].handle].key) ? this.floatDown_(s) : this.floatUp_(s)), i[e].key = null, i[e].node = this.freeList, this.freeList = e;
  }
}
class zc {
  eUp = null;
  /* upper edge, directed right to left */
  nodeUp = null;
  /* dictionary node corresponding to eUp */
  windingNumber = 0;
  /* used to determine which regions are
   * inside the polygon */
  inside = !1;
  /* is this region inside the polygon? */
  sentinel = !1;
  /* marks fake edges at t = +/-infinity */
  dirty = !1;
  /* marks regions where the upper or lower
   * edge has changed, but we haven't checked
   * whether they intersect yet */
  fixUpperEdge = !1;
  /* marks temporary edges introduced when
   * we process a "right vertex" (one without
   * any edges leaving to the right) */
}
class tp {
  key = null;
  next = null;
  prev = null;
}
class F_ {
  constructor(e, n) {
    this.frame = e, this.leq = n, this.head.next = this.head, this.head.prev = this.head;
  }
  head = new tp();
  min() {
    return this.head.next;
  }
  max() {
    return this.head.prev;
  }
  insert(e) {
    return this.insertBefore(this.head, e);
  }
  search(e) {
    let n = this.head;
    do
      n = n.next;
    while (n.key !== null && !this.leq(this.frame, e, n.key));
    return n;
  }
  insertBefore(e, n) {
    do
      e = e.prev;
    while (e.key !== null && !this.leq(this.frame, e.key, n));
    const i = new tp();
    return i.key = n, i.next = e.next, e.next.prev = i, i.prev = e, e.next = i, i;
  }
  delete(e) {
    e.next.prev = e.prev, e.prev.next = e.next;
  }
}
class H {
  static regionBelow(e) {
    return e.nodeUp.prev.key;
  }
  static regionAbove(e) {
    return e.nodeUp.next.key;
  }
  static debugEvent(e) {
  }
  /*
   * Invariants for the Edge Dictionary.
   * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
   *   at any valid location of the sweep event
   * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
   *   share a common endpoint
   * - for each e, e->Dst has been processed, but not e->Org
   * - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
   *   where "event" is the current sweep line event.
   * - no edge e has zero length
   *
   * Invariants for the Mesh (the processed portion).
   * - the portion of the mesh left of the sweep line is a planar graph,
   *   ie. there is *some* way to embed it in the plane
   * - no processed edge has zero length
   * - no two processed vertices have identical coordinates
   * - each "inside" region is monotone, ie. can be broken into two chains
   *   of monotonically increasing vertices according to VertLeq(v1,v2)
   *   - a non-invariant: these chains may intersect (very slightly)
   *
   * Invariants for the Sweep.
   * - if none of the edges incident to the event vertex have an activeRegion
   *   (ie. none of these edges are in the edge dictionary), then the vertex
   *   has only right-going edges.
   * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
   *   by ConnectRightVertex), then it is the only right-going edge from
   *   its associated vertex.  (This says that these edges exist only
   *   when it is necessary.)
   */
  /* When we merge two edges into one, we need to compute the combined
   * winding of the new edge.
   */
  static addWinding(e, n) {
    e.winding += n.winding, e.Sym.winding += n.Sym.winding;
  }
  //static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )
  static edgeLeq(e, n, i) {
    var s = e.event, o = n.eUp, a = i.eUp;
    if (o.Dst === s)
      return a.Dst === s ? tt.vertLeq(o.Org, a.Org) ? tt.edgeSign(a.Dst, o.Org, a.Org) <= 0 : tt.edgeSign(o.Dst, a.Org, o.Org) >= 0 : tt.edgeSign(a.Dst, s, a.Org) <= 0;
    if (a.Dst === s)
      return tt.edgeSign(o.Dst, s, o.Org) >= 0;
    const h = tt.edgeEval(o.Dst, s, o.Org), c = tt.edgeEval(a.Dst, s, a.Org);
    return h >= c;
  }
  //static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )
  static deleteRegion(e, n) {
    n.fixUpperEdge && dt(n.eUp.winding === 0), n.eUp.activeRegion = null, e.dict.delete(n.nodeUp);
  }
  //static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )
  static fixUpperEdge(e, n, i) {
    dt(n.fixUpperEdge), e.mesh.delete(n.eUp), n.fixUpperEdge = !1, n.eUp = i, i.activeRegion = n;
  }
  //static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )
  static topLeftRegion(e, n) {
    var i = n.eUp.Org, s;
    do
      n = H.regionAbove(n);
    while (n.eUp.Org === i);
    if (n.fixUpperEdge) {
      if (s = e.mesh.connect(
        H.regionBelow(n).eUp.Sym,
        n.eUp.Lnext
      ), s === null) return null;
      H.fixUpperEdge(e, n, s), n = H.regionAbove(n);
    }
    return n;
  }
  //static ActiveRegion *TopRightRegion( ActiveRegion *reg )
  static topRightRegion(e) {
    var n = e.eUp.Dst;
    do
      e = H.regionAbove(e);
    while (e.eUp.Dst === n);
    return e;
  }
  //static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )
  static addRegionBelow(e, n, i) {
    var s = new zc();
    return s.eUp = i, s.nodeUp = e.dict.insertBefore(n.nodeUp, s), s.fixUpperEdge = !1, s.sentinel = !1, s.dirty = !1, i.activeRegion = s, s;
  }
  //static int IsWindingInside( TESStesselator *tess, int n )
  static isWindingInside(e, n) {
    switch (e.windingRule) {
      case Pe.ODD:
        return (n & 1) !== 0;
      case Pe.NONZERO:
        return n !== 0;
      case Pe.POSITIVE:
        return n > 0;
      case Pe.NEGATIVE:
        return n < 0;
      case Pe.ABS_GEQ_TWO:
        return n >= 2 || n <= -2;
    }
    throw new Error("Invalid winding rulle");
  }
  //static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )
  static computeWinding(e, n) {
    n.windingNumber = H.regionAbove(n).windingNumber + n.eUp.winding, n.inside = H.isWindingInside(e, n.windingNumber);
  }
  //static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )
  static finishRegion(e, n) {
    var i = n.eUp, s = i.Lface;
    s.inside = n.inside, s.anEdge = i, H.deleteRegion(e, n);
  }
  //static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )
  static finishLeftRegions(e, n, i) {
    for (var s, o = null, a = n, h = n.eUp; a !== i; ) {
      if (a.fixUpperEdge = !1, o = H.regionBelow(a), s = o.eUp, s.Org != h.Org) {
        if (!o.fixUpperEdge) {
          H.finishRegion(e, a);
          break;
        }
        s = e.mesh.connect(h.Lprev, s.Sym), H.fixUpperEdge(e, o, s);
      }
      h.Onext !== s && (e.mesh.splice(s.Oprev, s), e.mesh.splice(h, s)), H.finishRegion(e, a), h = o.eUp, a = o;
    }
    return h;
  }
  //static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )
  static addRightEdges(e, n, i, s, o, a) {
    var h, c, l, u, f = !0;
    l = i;
    do
      dt(tt.vertLeq(l.Org, l.Dst)), H.addRegionBelow(e, n, l.Sym), l = l.Onext;
    while (l !== s);
    for (o === null && (o = H.regionBelow(n).eUp.Rprev), c = n, u = o; h = H.regionBelow(c), l = h.eUp.Sym, l.Org === u.Org; )
      l.Onext !== u && (e.mesh.splice(l.Oprev, l), e.mesh.splice(u.Oprev, l)), h.windingNumber = c.windingNumber - l.winding, h.inside = H.isWindingInside(e, h.windingNumber), c.dirty = !0, !f && H.checkForRightSplice(e, c) && (H.addWinding(l, u), H.deleteRegion(e, c), e.mesh.delete(u)), f = !1, c = h, u = l;
    c.dirty = !0, dt(c.windingNumber - l.winding === h.windingNumber), a && H.walkDirtyRegions(e, c);
  }
  //static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )
  static spliceMergeVertices(e, n, i) {
    e.mesh.splice(n, i);
  }
  //static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )
  static vertexWeights(e, n, i) {
    var s = tt.vertL1dist(n, e), o = tt.vertL1dist(i, e), a = 0.5 * o / (s + o), h = 0.5 * s / (s + o);
    e.coords[0] += a * n.coords[0] + h * i.coords[0], e.coords[1] += a * n.coords[1] + h * i.coords[1], e.coords[2] += a * n.coords[2] + h * i.coords[2];
  }
  //static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )
  static getIntersectData(e, n, i, s, o, a) {
    n.coords[0] = n.coords[1] = n.coords[2] = 0, n.idx = -1, H.vertexWeights(n, i, s), H.vertexWeights(n, o, a);
  }
  //static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )
  static checkForRightSplice(e, n) {
    var i = H.regionBelow(n), s = n.eUp, o = i.eUp;
    if (tt.vertLeq(s.Org, o.Org)) {
      if (tt.edgeSign(o.Dst, s.Org, o.Org) > 0) return !1;
      tt.vertEq(s.Org, o.Org) ? s.Org !== o.Org && (e.pq.delete(s.Org.pqHandle), H.spliceMergeVertices(e, o.Oprev, s)) : (e.mesh.splitEdge(o.Sym), e.mesh.splice(s, o.Oprev), n.dirty = i.dirty = !0);
    } else {
      if (tt.edgeSign(s.Dst, o.Org, s.Org) < 0) return !1;
      H.regionAbove(n).dirty = n.dirty = !0, e.mesh.splitEdge(s.Sym), e.mesh.splice(o.Oprev, s);
    }
    return !0;
  }
  //static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )
  static checkForLeftSplice(e, n) {
    var i = H.regionBelow(n), s = n.eUp, o = i.eUp, a;
    if (dt(!tt.vertEq(s.Dst, o.Dst)), tt.vertLeq(s.Dst, o.Dst)) {
      if (tt.edgeSign(s.Dst, o.Dst, s.Org) < 0) return !1;
      H.regionAbove(n).dirty = n.dirty = !0, a = e.mesh.splitEdge(s), e.mesh.splice(o.Sym, a), a.Lface.inside = n.inside;
    } else {
      if (tt.edgeSign(o.Dst, s.Dst, o.Org) > 0) return !1;
      n.dirty = i.dirty = !0, a = e.mesh.splitEdge(o), e.mesh.splice(s.Lnext, o.Sym), a.Rface.inside = n.inside;
    }
    return !0;
  }
  //static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )
  static checkForIntersect(e, n) {
    var i = H.regionBelow(n), s = n.eUp, o = i.eUp, a = s.Org, h = o.Org, c = s.Dst, l = o.Dst, u, f, d = new ir(), p, y;
    if (dt(!tt.vertEq(l, c)), dt(tt.edgeSign(c, e.event, a) <= 0), dt(tt.edgeSign(l, e.event, h) >= 0), dt(a !== e.event && h !== e.event), dt(!n.fixUpperEdge && !i.fixUpperEdge), a === h || (u = Math.min(a.t, c.t), f = Math.max(h.t, l.t), u > f)) return !1;
    if (tt.vertLeq(a, h)) {
      if (tt.edgeSign(l, a, h) > 0) return !1;
    } else if (tt.edgeSign(c, h, a) < 0) return !1;
    return tt.intersect(c, a, l, h, d), dt(Math.min(a.t, c.t) <= d.t), dt(d.t <= Math.max(h.t, l.t)), dt(Math.min(l.s, c.s) <= d.s), dt(d.s <= Math.max(h.s, a.s)), tt.vertLeq(d, e.event) && (d.s = e.event.s, d.t = e.event.t), p = tt.vertLeq(a, h) ? a : h, tt.vertLeq(p, d) && (d.s = p.s, d.t = p.t), tt.vertEq(d, a) || tt.vertEq(d, h) ? (H.checkForRightSplice(e, n), !1) : !tt.vertEq(c, e.event) && tt.edgeSign(c, e.event, d) >= 0 || !tt.vertEq(l, e.event) && tt.edgeSign(l, e.event, d) <= 0 ? l === e.event ? (e.mesh.splitEdge(s.Sym), e.mesh.splice(o.Sym, s), n = H.topLeftRegion(e, n), s = H.regionBelow(n).eUp, H.finishLeftRegions(e, H.regionBelow(n), i), H.addRightEdges(e, n, s.Oprev, s, s, !0), !0) : c === e.event ? (e.mesh.splitEdge(o.Sym), e.mesh.splice(s.Lnext, o.Oprev), i = n, n = H.topRightRegion(n), y = H.regionBelow(n).eUp.Rprev, i.eUp = o.Oprev, o = H.finishLeftRegions(e, i, null), H.addRightEdges(e, n, o.Onext, s.Rprev, y, !0), !0) : (tt.edgeSign(c, e.event, d) >= 0 && (H.regionAbove(n).dirty = n.dirty = !0, e.mesh.splitEdge(s.Sym), s.Org.s = e.event.s, s.Org.t = e.event.t), tt.edgeSign(l, e.event, d) <= 0 && (n.dirty = i.dirty = !0, e.mesh.splitEdge(o.Sym), o.Org.s = e.event.s, o.Org.t = e.event.t), !1) : (e.mesh.splitEdge(s.Sym), e.mesh.splitEdge(o.Sym), e.mesh.splice(o.Oprev, s), s.Org.s = d.s, s.Org.t = d.t, s.Org.pqHandle = e.pq.insert(s.Org), H.getIntersectData(e, s.Org, a, c, h, l), H.regionAbove(n).dirty = n.dirty = i.dirty = !0, !1);
  }
  //static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )
  static walkDirtyRegions(e, n) {
    for (var i = H.regionBelow(n), s, o; ; ) {
      for (; i.dirty; )
        n = i, i = H.regionBelow(i);
      if (!n.dirty && (i = n, n = H.regionAbove(n), n === null || !n.dirty))
        return;
      if (n.dirty = !1, s = n.eUp, o = i.eUp, s.Dst !== o.Dst && H.checkForLeftSplice(e, n) && (i.fixUpperEdge ? (H.deleteRegion(e, i), e.mesh.delete(o), i = H.regionBelow(n), o = i.eUp) : n.fixUpperEdge && (H.deleteRegion(e, n), e.mesh.delete(s), n = H.regionAbove(i), s = n.eUp)), s.Org !== o.Org)
        if (s.Dst !== o.Dst && !n.fixUpperEdge && !i.fixUpperEdge && (s.Dst === e.event || o.Dst === e.event)) {
          if (H.checkForIntersect(e, n))
            return;
        } else
          H.checkForRightSplice(e, n);
      s.Org === o.Org && s.Dst === o.Dst && (H.addWinding(o, s), H.deleteRegion(e, n), e.mesh.delete(s), n = H.regionAbove(i));
    }
  }
  //static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )
  static connectRightVertex(e, n, i) {
    var s, o = i.Onext, a = H.regionBelow(n), h = n.eUp, c = a.eUp, l = !1;
    if (h.Dst !== c.Dst && H.checkForIntersect(e, n), tt.vertEq(h.Org, e.event) && (e.mesh.splice(o.Oprev, h), n = H.topLeftRegion(e, n), o = H.regionBelow(n).eUp, H.finishLeftRegions(e, H.regionBelow(n), a), l = !0), tt.vertEq(c.Org, e.event) && (e.mesh.splice(i, c.Oprev), i = H.finishLeftRegions(e, a, null), l = !0), l) {
      H.addRightEdges(
        e,
        n,
        i.Onext,
        o,
        o,
        !0
      );
      return;
    }
    tt.vertLeq(c.Org, h.Org) ? s = c.Oprev : s = h, s = e.mesh.connect(i.Lprev, s), H.addRightEdges(e, n, s, s.Onext, s.Onext, !1), s.Sym.activeRegion.fixUpperEdge = !0, H.walkDirtyRegions(e, n);
  }
  /* Because vertices at exactly the same location are merged together
   * before we process the sweep event, some degenerate cases can't occur.
   * However if someone eventually makes the modifications required to
   * merge features which are close together, the cases below marked
   * TOLERANCE_NONZERO will be useful.  They were debugged before the
   * code to merge identical vertices in the main loop was added.
   */
  //#define TOLERANCE_NONZERO	FALSE
  //static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )
  static connectLeftDegenerate(e, n, i) {
    var s, o, a, h, c;
    if (s = n.eUp, tt.vertEq(s.Org, i)) {
      dt(
        !1
        /*TOLERANCE_NONZERO*/
      ), H.spliceMergeVertices(e, s, i.anEdge);
      return;
    }
    if (!tt.vertEq(s.Dst, i)) {
      e.mesh.splitEdge(s.Sym), n.fixUpperEdge && (e.mesh.delete(s.Onext), n.fixUpperEdge = !1), e.mesh.splice(i.anEdge, s), H.sweepEvent(e, i);
      return;
    }
    dt(
      !1
      /*TOLERANCE_NONZERO*/
    ), n = H.topRightRegion(n), c = H.regionBelow(n), a = c.eUp.Sym, o = h = a.Onext, c.fixUpperEdge && (dt(o !== a), H.deleteRegion(e, c), e.mesh.delete(a), a = o.Oprev), e.mesh.splice(i.anEdge, a), tt.edgeGoesLeft(o) || (o = null), H.addRightEdges(
      e,
      n,
      a.Onext,
      h,
      o,
      !0
    );
  }
  //static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )
  static connectLeftVertex(e, n) {
    var i, s, o, a, h, c, l = new zc();
    if (l.eUp = n.anEdge.Sym, i = e.dict.search(l).key, s = H.regionBelow(i), !!s) {
      if (a = i.eUp, h = s.eUp, tt.edgeSign(a.Dst, n, a.Org) === 0) {
        H.connectLeftDegenerate(e, i, n);
        return;
      }
      if (o = tt.vertLeq(h.Dst, a.Dst) ? i : s, i.inside || o.fixUpperEdge) {
        if (o === i)
          c = e.mesh.connect(n.anEdge.Sym, a.Lnext);
        else {
          var u = e.mesh.connect(h.Dnext, n.anEdge);
          c = u.Sym;
        }
        o.fixUpperEdge ? H.fixUpperEdge(e, o, c) : H.computeWinding(
          e,
          H.addRegionBelow(e, i, c)
        ), H.sweepEvent(e, n);
      } else
        H.addRightEdges(
          e,
          i,
          n.anEdge,
          n.anEdge,
          null,
          !0
        );
    }
  }
  //static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )
  static sweepEvent(e, n) {
    e.event = n;
    for (var i = n.anEdge; i.activeRegion === null; )
      if (i = i.Onext, i === n.anEdge) {
        H.connectLeftVertex(e, n);
        return;
      }
    var s = H.topLeftRegion(e, i.activeRegion);
    dt(s !== null);
    var o = H.regionBelow(s), a = o.eUp, h = H.finishLeftRegions(e, o, null);
    h.Onext === a ? H.connectRightVertex(e, s, h) : H.addRightEdges(
      e,
      s,
      h.Onext,
      a,
      a,
      !0
    );
  }
  /* Make the sentinel coordinates big enough that they will never be
   * merged with real input features.
   */
  //static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )
  static addSentinel(e, n, i, s) {
    var o = new zc(), a = e.mesh.makeEdge();
    a.Org.s = i, a.Org.t = s, a.Dst.s = n, a.Dst.t = s, e.event = a.Dst, o.eUp = a, o.windingNumber = 0, o.inside = !1, o.fixUpperEdge = !1, o.sentinel = !0, o.dirty = !1, o.nodeUp = e.dict.insert(o);
  }
  //static void InitEdgeDict( TESStesselator *tess )
  static initEdgeDict(e) {
    e.dict = new F_(e, H.edgeLeq);
    var n = e.bmax[0] - e.bmin[0], i = e.bmax[1] - e.bmin[1], s = e.bmin[0] - n, o = e.bmax[0] + n, a = e.bmin[1] - i, h = e.bmax[1] + i;
    H.addSentinel(e, s, o, a), H.addSentinel(e, s, o, h);
  }
  static doneEdgeDict(e) {
    for (var n, i = 0; (n = e.dict.min().key) !== null; )
      n.sentinel || (dt(n.fixUpperEdge), dt(++i === 1)), dt(n.windingNumber === 0), H.deleteRegion(e, n);
  }
  static removeDegenerateEdges(e) {
    var n, i, s, o = e.mesh.eHead;
    for (n = o.next; n !== o; n = i)
      i = n.next, s = n.Lnext, tt.vertEq(n.Org, n.Dst) && n.Lnext.Lnext !== n && (H.spliceMergeVertices(e, s, n), e.mesh.delete(n), n = s, s = n.Lnext), s.Lnext === n && (s !== n && ((s === i || s === i.Sym) && (i = i.next), e.mesh.delete(s)), (n === i || n === i.Sym) && (i = i.next), e.mesh.delete(n));
  }
  static initPriorityQ(e) {
    var n, i, s, o = 0;
    for (s = e.mesh.vHead, i = s.next; i !== s; i = i.next)
      o++;
    for (o += 8, n = e.pq = new B_(o, tt.vertLeq), s = e.mesh.vHead, i = s.next; i !== s; i = i.next)
      i.pqHandle = n.insert(i);
    return i !== s ? !1 : (n.init(), !0);
  }
  static donePriorityQ(e) {
    e.pq = null;
  }
  static removeDegenerateFaces(e, n) {
    var i, s, o;
    for (i = n.fHead.next; i !== n.fHead; i = s)
      s = i.next, o = i.anEdge, dt(o.Lnext !== o), o.Lnext.Lnext === o && (H.addWinding(o.Onext, o), e.mesh.delete(o));
    return !0;
  }
  static computeInterior(e, n = !0) {
    var i, s;
    if (H.removeDegenerateEdges(e), !H.initPriorityQ(e))
      return !1;
    for (H.initEdgeDict(e); (i = e.pq.extractMin()) !== null; ) {
      for (; s = e.pq.min(), !(s === null || !tt.vertEq(s, i)); )
        s = e.pq.extractMin(), H.spliceMergeVertices(e, i.anEdge, s.anEdge);
      H.sweepEvent(e, i);
    }
    return e.event = e.dict.min().key.eUp.Org, H.doneEdgeDict(e), H.donePriorityQ(e), H.removeDegenerateFaces(e, e.mesh), n && e.mesh.check(), !0;
  }
}
class hx {
  /*** state needed for collecting the input data ***/
  /* stores the input contours, and eventually the tessellation itself */
  mesh = new Jd();
  /*** state needed for projecting onto the sweep plane ***/
  normal = [0, 0, 0];
  /* user-specified normal (if provided) */
  sUnit = [0, 0, 0];
  /* unit vector in s-direction (debugging) */
  tUnit = [0, 0, 0];
  /* unit vector in t-direction (debugging) */
  bmin = [0, 0];
  bmax = [0, 0];
  /*** state needed for the line sweep ***/
  /* rule for determining polygon interior */
  windingRule = Pe.ODD;
  dict = null;
  /* edge dictionary for sweep line */
  pq = null;
  /* priority queue of vertex events */
  event = null;
  /* current sweep event being processed */
  vertexIndexCounter = 0;
  vertices = [];
  vertexIndices = [];
  vertexCount = 0;
  elements = [];
  elementCount = 0;
  dot_(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2];
  }
  normalize_(e) {
    let n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2];
    if (!n)
      throw "Zero-size vector!";
    n = Math.sqrt(n), e[0] /= n, e[1] /= n, e[2] /= n;
  }
  longAxis_(e) {
    let n = 0;
    return Math.abs(e[1]) > Math.abs(e[0]) && (n = 1), Math.abs(e[2]) > Math.abs(e[n]) && (n = 2), n;
  }
  computeNormal_(e) {
    let n, i, s, o, a, h, c = [0, 0, 0], l = [0, 0, 0], u = [0, 0, 0], f = [0, 0, 0], d = [0, 0, 0];
    const p = [null, null, null], y = [null, null, null], x = this.mesh.vHead;
    n = x.next;
    for (let g = 0; g < 3; ++g)
      o = n.coords[g], l[g] = o, y[g] = n, c[g] = o, p[g] = n;
    for (n = x.next; n !== x; n = n.next)
      for (let g = 0; g < 3; ++g)
        o = n.coords[g], o < l[g] && (l[g] = o, y[g] = n), o > c[g] && (c[g] = o, p[g] = n);
    let m = 0;
    if (c[1] - l[1] > c[0] - l[0] && (m = 1), c[2] - l[2] > c[m] - l[m] && (m = 2), l[m] >= c[m]) {
      e[0] = 0, e[1] = 0, e[2] = 1;
      return;
    }
    for (h = 0, i = y[m], s = p[m], u[0] = i.coords[0] - s.coords[0], u[1] = i.coords[1] - s.coords[1], u[2] = i.coords[2] - s.coords[2], n = x.next; n !== x; n = n.next)
      f[0] = n.coords[0] - s.coords[0], f[1] = n.coords[1] - s.coords[1], f[2] = n.coords[2] - s.coords[2], d[0] = u[1] * f[2] - u[2] * f[1], d[1] = u[2] * f[0] - u[0] * f[2], d[2] = u[0] * f[1] - u[1] * f[0], a = d[0] * d[0] + d[1] * d[1] + d[2] * d[2], a > h && (h = a, e[0] = d[0], e[1] = d[1], e[2] = d[2]);
    h <= 0 && (e[0] = e[1] = e[2] = 0, e[this.longAxis_(u)] = 1);
  }
  checkOrientation_() {
    var e = this.mesh.fHead, n, i = this.mesh.vHead, s;
    let o = 0;
    for (let a = e.next; a !== e; a = a.next)
      if (s = a.anEdge, !(s.winding <= 0))
        do
          o += (s.Org.s - s.Dst.s) * (s.Org.t + s.Dst.t), s = s.Lnext;
        while (s !== a.anEdge);
    if (o < 0) {
      for (n = i.next; n !== i; n = n.next)
        n.t = -n.t;
      this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
    }
  }
  /*	#ifdef FOR_TRITE_TEST_PROGRAM
  	#include <stdlib.h>
  	extern int RandomSweep;
  	#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
  	#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
  	#else
  	#if defined(SLANTED_SWEEP) */
  /* The "feature merging" is not intended to be complete.  There are
   * special cases where edges are nearly parallel to the sweep line
   * which are not implemented.  The algorithm should still behave
   * robustly (ie. produce a reasonable tesselation) in the presence
   * of such edges, however it may miss features which could have been
   * merged.  We could minimize this effect by choosing the sweep line
   * direction to be something unusual (ie. not parallel to one of the
   * coordinate axes).
   */
  /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
  	#define S_UNIT_Y	(TESSreal)0.86052074622010633
  	#else
  	#define S_UNIT_X	(TESSreal)1.0
  	#define S_UNIT_Y	(TESSreal)0.0
  	#endif
  	#endif*/
  /* Determine the polygon normal and project vertices onto the plane
   * of the polygon.
   */
  projectPolygon_() {
    let e = this.mesh.vHead, n = [0, 0, 0], i, s, o = !1;
    n[0] = this.normal[0], n[1] = this.normal[1], n[2] = this.normal[2], !n[0] && !n[1] && !n[2] && (this.computeNormal_(n), o = !0), i = this.sUnit, s = this.tUnit;
    let a = this.longAxis_(n);
    i[a] = 0, i[(a + 1) % 3] = 1, i[(a + 2) % 3] = 0, s[a] = 0, s[(a + 1) % 3] = 0, s[(a + 2) % 3] = n[a] > 0 ? 1 : -1;
    for (let c = e.next; c !== e; c = c.next)
      c.s = this.dot_(c.coords, i), c.t = this.dot_(c.coords, s);
    o && this.checkOrientation_();
    let h = !0;
    for (let c = e.next; c !== e; c = c.next)
      h ? (this.bmin[0] = this.bmax[0] = c.s, this.bmin[1] = this.bmax[1] = c.t, h = !1) : (c.s < this.bmin[0] && (this.bmin[0] = c.s), c.s > this.bmax[0] && (this.bmax[0] = c.s), c.t < this.bmin[1] && (this.bmin[1] = c.t), c.t > this.bmax[1] && (this.bmax[1] = c.t));
  }
  addWinding_(e, n) {
    e.winding += n.winding, e.Sym.winding += n.Sym.winding;
  }
  /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
   * (what else would it do??)  The region must consist of a single
   * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
   * case means that any vertical line intersects the interior of the
   * region in a single interval.
   *
   * Tessellation consists of adding interior edges (actually pairs of
   * half-edges), to split the region into non-overlapping triangles.
   *
   * The basic idea is explained in Preparata and Shamos (which I don''t
   * have handy right now), although their implementation is more
   * complicated than this one.  The are two edge chains, an upper chain
   * and a lower chain.  We process all vertices from both chains in order,
   * from right to left.
   *
   * The algorithm ensures that the following invariant holds after each
   * vertex is processed: the untessellated region consists of two
   * chains, where one chain (say the upper) is a single edge, and
   * the other chain is concave.  The left vertex of the single edge
   * is always to the left of all vertices in the concave chain.
   *
   * Each step consists of adding the rightmost unprocessed vertex to one
   * of the two chains, and forming a fan of triangles from the rightmost
   * of two chain endpoints.  Determining whether we can add each triangle
   * to the fan is a simple orientation test.  By making the fan as large
   * as possible, we restore the invariant (check it yourself).
   */
  //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
  tessellateMonoRegion_(e, n) {
    let i, s;
    if (i = n.anEdge, !(i.Lnext !== i && i.Lnext.Lnext !== i))
      throw "Mono region invalid";
    for (; tt.vertLeq(i.Dst, i.Org); i = i.Lprev) ;
    for (; tt.vertLeq(i.Org, i.Dst); i = i.Lnext) ;
    s = i.Lprev;
    let o;
    for (; i.Lnext !== s; )
      if (tt.vertLeq(i.Dst, s.Org)) {
        for (; s.Lnext !== i && (tt.edgeGoesLeft(s.Lnext) || tt.edgeSign(s.Org, s.Dst, s.Lnext.Dst) <= 0); )
          o = e.connect(s.Lnext, s), s = o.Sym;
        s = s.Lprev;
      } else {
        for (; s.Lnext !== i && (tt.edgeGoesRight(i.Lprev) || tt.edgeSign(i.Dst, i.Org, i.Lprev.Org) >= 0); )
          o = e.connect(i, i.Lprev), i = o.Sym;
        i = i.Lnext;
      }
    if (s.Lnext === i)
      throw "Mono region invalid";
    for (; s.Lnext.Lnext !== i; )
      o = e.connect(s.Lnext, s), s = o.Sym;
    return !0;
  }
  /* tessMeshTessellateInterior( mesh ) tessellates each region of
   * the mesh which is marked "inside" the polygon.  Each such region
   * must be monotone.
   */
  //int tessMeshTessellateInterior( TESSmesh *mesh )
  tessellateInterior_(e) {
    let n;
    for (let i = e.fHead.next; i !== e.fHead; i = n)
      if (n = i.next, i.inside && !this.tessellateMonoRegion_(e, i))
        return !1;
    return !0;
  }
  /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
   * which are not marked "inside" the polygon.  Since further mesh operations
   * on NULL faces are not allowed, the main purpose is to clean up the
   * mesh so that exterior loops are not represented in the data structure.
   */
  //void tessMeshDiscardExterior( TESSmesh *mesh )
  discardExterior_(e) {
    let n;
    for (let i = e.fHead.next; i !== e.fHead; i = n)
      n = i.next, i.inside || e.zapFace(i);
  }
  /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
   * winding numbers on all edges so that regions marked "inside" the
   * polygon have a winding number of "value", and regions outside
   * have a winding number of 0.
   *
   * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
   * separate an interior region from an exterior one.
   */
  //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
  setWindingNumber_(e, n, i) {
    let s;
    for (let o = e.eHead.next; o !== e.eHead; o = s)
      s = o.next, o.Rface.inside !== o.Lface.inside ? o.winding = o.Lface.inside ? n : -n : i ? e.delete(o) : o.winding = 0;
  }
  getNeighbourFace_(e) {
    return !e.Rface || !e.Rface.inside ? -1 : e.Rface.n;
  }
  outputPolymesh_(e, n, i, s) {
    let o, a = 0, h = 0, c;
    i > 3 && e.mergeConvexFaces(i);
    for (let f = e.vHead.next; f !== e.vHead; f = f.next)
      f.n = -1;
    for (let f = e.fHead.next; f !== e.fHead; f = f.next)
      if (f.n = -1, !!f.inside) {
        o = f.anEdge, c = 0;
        do {
          let d = o.Org;
          d.n === -1 && (d.n = h, h++), c++, o = o.Lnext;
        } while (o !== f.anEdge);
        if (c > i)
          throw "Face vertex greater that support polygon";
        f.n = a, ++a;
      }
    this.elementCount = a, n === bn.CONNECTED_POLYGONS && (a *= 2), this.elements = [], this.elements.length = a * i, this.vertexCount = h, this.vertices = [], this.vertices.length = h * s, this.vertexIndices = [], this.vertexIndices.length = h;
    for (let f = e.vHead.next; f !== e.vHead; f = f.next)
      if (f.n !== -1) {
        var l = f.n * s;
        this.vertices[l + 0] = f.coords[0], this.vertices[l + 1] = f.coords[1], s > 2 && (this.vertices[l + 2] = f.coords[2]), this.vertexIndices[f.n] = f.idx;
      }
    let u = 0;
    for (let f = e.fHead.next; f !== e.fHead; f = f.next)
      if (f.inside) {
        o = f.anEdge, c = 0;
        do {
          let d = o.Org;
          this.elements[u++] = d.n, c++, o = o.Lnext;
        } while (o !== f.anEdge);
        for (let d = c; d < i; ++d)
          this.elements[u++] = -1;
        if (n === bn.CONNECTED_POLYGONS) {
          o = f.anEdge;
          do
            this.elements[u++] = this.getNeighbourFace_(o), o = o.Lnext;
          while (o !== f.anEdge);
          for (let d = c; d < i; ++d)
            this.elements[u++] = -1;
        }
      }
  }
  //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
  outputContours_(e, n) {
    let i, s, o = 0, a = 0;
    this.vertexCount = 0, this.elementCount = 0;
    for (let u = e.fHead.next; u !== e.fHead; u = u.next)
      if (u.inside) {
        s = i = u.anEdge;
        do
          this.vertexCount++, i = i.Lnext;
        while (i !== s);
        this.elementCount++;
      }
    this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * n, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
    let h = 0, c = 0, l = 0;
    o = 0;
    for (let u = e.fHead.next; u !== e.fHead; u = u.next)
      if (u.inside) {
        a = 0, s = i = u.anEdge;
        do
          this.vertices[h++] = i.Org.coords[0], this.vertices[h++] = i.Org.coords[1], n > 2 && (this.vertices[h++] = i.Org.coords[2]), this.vertexIndices[c++] = i.Org.idx, a++, i = i.Lnext;
        while (i !== s);
        this.elements[l++] = o, this.elements[l++] = a, o += a;
      }
  }
  addContour(e, n) {
    this.mesh === null && (this.mesh = new Jd()), e < 2 && (e = 2), e > 3 && (e = 3);
    let i = null;
    for (let s = 0; s < n.length; s += e)
      i === null ? (i = this.mesh.makeEdge(), this.mesh.splice(i, i.Sym)) : (this.mesh.splitEdge(i), i = i.Lnext), i.Org.coords[0] = n[s + 0], i.Org.coords[1] = n[s + 1], e > 2 ? i.Org.coords[2] = n[s + 2] : i.Org.coords[2] = 0, i.Org.idx = this.vertexIndexCounter++, i.winding = 1, i.Sym.winding = -1;
  }
  //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
  /**
   * Run tesselation
   * @param windingRule 
   * @param elementType 
   * @param polySize 
   * @param vertexSize 
   * @param normal 
   * @param validate UNSAFE! Skip mesh validation pass, may throw any error.
   */
  tesselate(e = Pe.ODD, n = bn.POLYGONS, i, s, o, a = !0) {
    if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, o && (this.normal[0] = o[0], this.normal[1] = o[1], this.normal[2] = o[2]), this.windingRule = e, s < 2 && (s = 2), s > 3 && (s = 3), !this.mesh)
      return !1;
    this.projectPolygon_(), H.computeInterior(this, a);
    var h = this.mesh;
    return n === bn.BOUNDARY_CONTOURS ? this.setWindingNumber_(h, 1, !0) : this.tessellateInterior_(h), a && h.check(), n === bn.BOUNDARY_CONTOURS ? this.outputContours_(h, s) : this.outputPolymesh_(
      h,
      n,
      i,
      s
    ), !0;
  }
}
function N_({
  windingRule: r = Pe.ODD,
  elementType: e = bn.POLYGONS,
  polySize: n = 3,
  vertexSize: i = 2,
  normal: s = [0, 0, 1],
  contours: o = [],
  strict: a = !0,
  debug: h = !1
}) {
  if (!o && a)
    throw new Error("Contours can't be empty");
  if (!o)
    return;
  const c = new hx();
  for (let l = 0; l < o.length; l++)
    c.addContour(i || 2, o[l]);
  return c.tesselate(
    r,
    e,
    n,
    i,
    s,
    a
  ), {
    vertices: c.vertices,
    vertexIndices: c.vertexIndices,
    vertexCount: c.vertexCount,
    elements: c.elements,
    elementCount: c.elementCount,
    mesh: h ? c.mesh : void 0
  };
}
const q_ = Pe.ODD, D_ = Pe.NONZERO, $_ = Pe.POSITIVE, V_ = Pe.NEGATIVE, U_ = Pe.ABS_GEQ_TWO, W_ = bn.POLYGONS, j_ = bn.CONNECTED_POLYGONS, Y_ = bn.BOUNDARY_CONTOURS, H_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOUNDARY_CONTOURS: Y_,
  CONNECTED_POLYGONS: j_,
  ELEMENT: bn,
  POLYGONS: W_,
  Tesselator: hx,
  WINDING: Pe,
  WINDING_ABS_GEQ_TWO: U_,
  WINDING_NEGATIVE: V_,
  WINDING_NONZERO: D_,
  WINDING_ODD: q_,
  WINDING_POSITIVE: $_,
  tesselate: N_
}, Symbol.toStringTag, { value: "Module" }));
function cx(r = 10) {
  return Math.random().toString(36).substr(2, r);
}
function X_(r, ...e) {
  return r instanceof Function ? r(...e) : r;
}
function go(r, ...e) {
  return e.includes(r);
}
const Z_ = (r, e) => r.concat(e);
function lx(r, e, n = Z_) {
  for (const i of Object.keys(e))
    i in r && Array.isArray(r[i]) && Array.isArray(e[i]) ? r[i] = n(r[i], e[i]) : i in r && r[i] instanceof Object && e[i] instanceof Object ? lx(r[i], e[i]) : r[i] = e[i];
}
function G_(r, e = 0) {
  return e ? +setTimeout(r, e) : (r(), 0);
}
function J_(r) {
  return new Promise((e) => setTimeout(e, r));
}
function Q_() {
  let r = () => {
  }, e = () => {
  };
  const n = new Promise((i, s) => {
    r = i, e = s;
  });
  return n.catch((i) => i), { promise: n, resolve: r, reject: e };
}
class ep extends Error {
  constructor(e) {
    super("[Cache Error]"), this.data = e;
  }
}
function K_(r) {
  const e = /* @__PURE__ */ new Map();
  return function(...n) {
    const i = n.join("--");
    if (!e.has(i))
      try {
        e.set(i, r(...n));
      } catch (o) {
        e.set(i, new ep(o));
      }
    const s = e.get(i);
    if (s instanceof ep) throw s.data;
    return s;
  };
}
function t3(r, e = 0, n = !1) {
  let i = !1, s = !1;
  return (...o) => {
    i ? s = !0 : (n ? s = !0 : r(...o), i = !0, setTimeout(() => {
      s && r(...o), i = s = !1;
    }, e));
  };
}
function e3(r) {
  return function(e, n) {
    if (!e || Array.isArray(this) || r.includes(e)) return n;
  };
}
function n3(r, e, n) {
  if (!r) return e;
  try {
    return JSON.parse(r, n ? e3(n) : void 0) || e;
  } catch {
    return e;
  }
}
function qu(r, e) {
  return new Array(e).fill(r);
}
function Du(r, e, n) {
  const i = [];
  for (let s = 0; s < e; ++s)
    i.push(qu(r, n));
  return i;
}
function wh(r, e) {
  const n = [];
  for (let i = 0; i < e; ++i)
    n.push(r(i));
  return n;
}
function ux(r, e, n) {
  const i = [];
  for (let s = 0; s < e; ++s) {
    const o = [];
    for (let a = 0; a < n; ++a)
      o.push(r(s, a));
    i.push(o);
  }
  return i;
}
function fx(r, e, n = 1) {
  const i = [];
  if (e === void 0 && r >= 0)
    for (let s = 0; s < r; s += n) i.push(s);
  else if (e === void 0)
    for (let s = 0; s > r; s -= n) i.push(s);
  else if (r <= e)
    for (let s = r; s <= e; s += n) i.push(s);
  else
    for (let s = r; s >= e; s -= n) i.push(s);
  return i;
}
function $u(r, e = 0) {
  return r[r.length - 1 - e];
}
function be(r) {
  return r.reduce((e, n) => e + n, 0);
}
function dx(r, e, n = !1) {
  return r.slice(0).sort((i, s) => {
    const o = e(i), a = e(s);
    return o < a ? n ? 1 : -1 : o > a ? n ? -1 : 1 : 0;
  });
}
function i3(r) {
  let e = 0;
  return () => r[e++ % r.length];
}
function px(r) {
  return r.filter((e, n) => r.indexOf(e) === n);
}
function Vu(r) {
  return r.reduce((e, n) => e.concat(Array.isArray(n) ? Vu(n) : n), []);
}
function s3(r) {
  let e = 0;
  return r.map((n) => e += n);
}
function r3(r, e) {
  const n = [];
  for (let i = 0; i < r.length; i += e)
    n.push(r.slice(i, i + e));
  return n;
}
function o3(r, e = 1) {
  const n = r.length;
  e = (e % n + n) % n;
  const i = r.slice(0, e);
  return r.slice(e).concat(i);
}
function a3(r, e) {
  return r.filter((n) => e.includes(n));
}
function h3(r, e) {
  const n = e.filter((s) => !r.includes(s)), i = r.filter((s) => !e.includes(s));
  return [...n, ...i];
}
function c3(...r) {
  return r.reduce((e, n) => e.concat(n), []);
}
function l3(r) {
  return r.map((e) => e.map((n) => {
    let i = n ? `${n}` : "";
    return i.match(/[,\n"']/) && (i = `"${i.replace(/"/g, '""')}"`), i;
  }).join(",")).join(`
`);
}
class u3 {
  root;
  constructor(e) {
    const n = e.length, i = e.map((s) => ({ val: s }));
    for (const [s, o] of i.entries())
      o.next = i[(s + 1) % n], o.prev = i[(s - 1 + n) % n];
    this.root = i[0];
  }
  *traverse() {
    let e = this.root;
    for (; e; )
      if (yield e, e = e.next, e === this.root) return;
  }
  get array() {
    return Array.from(this.traverse());
  }
  delete(e) {
    if (e === this.root) {
      if (e.next === e) return this.root = void 0;
      this.root = e.next;
    }
    e.prev.next = e.next, e.next.prev = e.prev;
  }
}
var yx = /* @__PURE__ */ ((r) => (r[r.first = 0] = "first", r[r.firstGreater = 1] = "firstGreater", r))(yx || {});
function xx(r, e, n) {
  let i = 0, s = r.length - 1, o = -1;
  for (; i <= s; ) {
    const a = Math.floor((i + s) / 2), h = r[a].val;
    h < e ? i = a + 1 : h > e ? (n === 1 && (o = a), s = a - 1) : n === 0 ? (o = a, s = a - 1) : n === 1 && (i = a + 1);
  }
  return o;
}
function f3(r, e, n) {
  let i = xx(
    r,
    n,
    0
    /* first */
  );
  if (i < 0) return -1;
  for (; r[i].val === n; ) {
    if (r[i].item === e) return i;
    i += 1;
  }
  return -1;
}
function Ja(r, e = /\s+/) {
  return r ? r.trim().split(e) : [];
}
function d3(r) {
  return r.replace(/\S+/g, (e) => e.charAt(0).toUpperCase() + e.slice(1));
}
function p3(r) {
  return r.toLowerCase().replace(/^-/, "").replace(/-(.)/g, (e, n) => n.toUpperCase());
}
function y3(r) {
  return r === r.split("").reverse().join("");
}
function mx(r, e, n = !1) {
  const i = Du(0, r.length + 1, e.length + 1);
  for (let s = 0; s <= r.length; s++) i[s][0] = s;
  for (let s = 0; s <= e.length; s++) i[0][s] = s;
  for (let s = 1; s <= r.length; s++)
    for (let o = 1; o <= e.length; o++)
      i[s][o] = Math.min(
        i[s - 1][o - 1] + (r.charAt(s - 1) === e.charAt(o - 1) ? 0 : 1),
        i[s - 1][o] + 1,
        i[s][o - 1] + 1
      );
  return n ? Math.min(...i[r.length]) : i[r.length][e.length];
}
function x3(r, e) {
  const n = r.length / 2, i = e.map((o) => ({ w: o, d: mx(r, o) })).filter(({ d: o }) => o < n), s = dx(i, (o) => o.d)[0];
  return s ? s.w : void 0;
}
class m3 {
  events = /* @__PURE__ */ new Map();
  /** Adds an event listener for one or more events. */
  on(e, n) {
    for (const i of Ja(e))
      this.events.has(i) || this.events.set(i, []), this.events.get(i).push(n);
  }
  /** Adds a one-time event listener to one or more events. */
  one(e, n) {
    const i = (s) => {
      this.off(e, i), n(s);
    };
    this.on(e, i);
  }
  /** Removes an event listener from one or more events. */
  off(e, n) {
    for (const i of Ja(e))
      this.events.has(i) && this.events.set(i, this.events.get(i).filter((s) => s !== n));
  }
  /** Triggers one or more events, and executes all bound event listeners. */
  trigger(e, n) {
    for (const i of Ja(e))
      if (this.events.has(i))
        for (const s of this.events.get(i))
          s(n);
  }
}
const g3 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, w3 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, b3 = /rgba?\(([0-9.]+), ?([0-9.]+), ?([0-9.]+)(, ?([0-9.]+))?\)/, v3 = [
  "#22ab24",
  "#009ea6",
  "#0f82f2",
  "#6d3bbf",
  "#cd0e66",
  "#eb4726",
  "#fd8c00"
];
function np(r) {
  return r.length === 1 ? `0${r}` : r;
}
function ip(r, e) {
  if (e <= 0) return Qa.from(r[0]);
  if (e >= 1) return Qa.from($u(r));
  const n = Math.floor(e * (r.length - 1)), i = e * (r.length - 1) - n;
  return Qa.mix(r[n + 1], r[n], i);
}
function Ac(r, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? r + (e - r) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? r + (e - r) * (2 / 3 - n) * 6 : r;
}
let Qa = class pe {
  constructor(e, n, i, s = 1) {
    this.r = e, this.g = n, this.b = i, this.a = s;
  }
  /** Converts this color to a hex string. */
  get hex() {
    const e = [this.r, this.g, this.b].map((i) => np(Math.round(i).toString(16))), n = this.a >= 1 ? "" : np(Math.round(this.a * 255).toString(16));
    return `#${e.join("")}${n}`;
  }
  /** Converts this color to an rgba string. */
  get rgb() {
    return `rgba(${[this.r, this.g, this.b].map((n) => Math.round(n)).join(",")},${this.a})`;
  }
  /** Get the brightness of this color. */
  get brightness() {
    return (this.r * 299 + this.g * 587 + this.g * 114) / 1e3;
  }
  /** Converts this color to an HSL array. */
  get hsl() {
    const e = this.r / 255, n = this.g / 255, i = this.b / 255, s = Math.max(e, n, i), o = Math.min(e, n, i), a = (o + s) / 2, h = s - o;
    if (s === o) return [0, 0, Math.round(a * 100)];
    let c = e === s ? (n - i) / h : n === s ? 2 + (i - e) / h : 4 + (e - n) / h;
    c = Math.min(c * 60, 360), c < 0 && (c += 360);
    const l = a <= 0.5 ? h / (s + o) : h / (2 - s - o);
    return [Math.round(c), Math.round(l * 100), Math.round(a * 100)];
  }
  get chroma() {
    return Math.max(this.r, this.g, this.b) - Math.min(this.r, this.g, this.b);
  }
  toString() {
    return this.rgb;
  }
  /** Creates a copy of this color. */
  copy() {
    return new pe(this.r, this.g, this.b, this.a);
  }
  // ---------------------------------------------------------------------------
  static from(e) {
    return typeof e != "string" ? e : e.startsWith("#") ? pe.fromHex(e) : pe.fromRgb(e);
  }
  static fromRgb(e) {
    const n = e.match(b3);
    if (!n) return new pe(0, 0, 0);
    const i = n[4] ? +n[5] || 0 : 1;
    return new pe(+n[1], +n[2], +n[3], i);
  }
  /** Creates a Color instance from a hex string. */
  static fromHex(e) {
    e = e.replace(g3, (i, s, o, a) => s + s + o + o + a + a);
    const n = w3.exec(e);
    return n ? new pe(
      parseInt(n[1], 16),
      parseInt(n[2], 16),
      parseInt(n[3], 16),
      n[4] ? parseInt(n[4], 16) / 255 : 1
    ) : new pe(0, 0, 0);
  }
  static fromHsl(e, n, i) {
    if (e /= 360, n /= 100, i /= 100, n === 0) {
      const l = Math.round(i * 255);
      return new pe(l, l, l);
    }
    const s = i < 0.5 ? i * (1 + n) : i + n - i * n, o = 2 * i - s, a = Ac(o, s, e + 1 / 3), h = Ac(o, s, e), c = Ac(o, s, e - 1 / 3);
    return new pe(Math.round(a * 255), Math.round(h * 255), Math.round(c * 255));
  }
  /** Generates a rainbow gradient with a given number of steps. */
  static rainbow(e) {
    return wh((n) => ip(v3, n / (e - 1)), e);
  }
  /** Generates a rainbow gradient with a given number of steps. */
  static gradient(e, n) {
    return wh((i) => ip(e, i / (n - 1)), n);
  }
  static shades(e, n, i = 0.5) {
    const s = pe.mix("#fff", e, i), o = pe.mix("#000", e, i);
    return pe.gradient([s, e, o], n);
  }
  /** Linearly interpolates two colors or hex strings. */
  static mix(e, n, i = 0.5) {
    return e = pe.from(e), n = pe.from(n), new pe(
      i * e.r + (1 - i) * n.r,
      i * e.g + (1 - i) * n.g,
      i * e.b + (1 - i) * n.b,
      i * e.a + (1 - i) * n.a
    );
  }
  static mixMany(e, n) {
    n || (n = e.map(() => 1));
    const i = be(n), s = e.map((m) => m.hsl), o = s.map((m) => m[0]), a = o.map((m) => m < 180 ? m + 360 : m), h = n.map((m, g) => m * Math.sqrt(e[g].chroma)), c = be(h), l = be(o.map((m, g) => m * h[g])) / c, u = be(a.map((m, g) => m * h[g])) / c, f = be(o.map((m, g) => Math.abs(m - l) * h[g])), d = be(a.map((m, g) => Math.abs(m - u) * h[g])), p = f <= d ? l : u % 360, y = be(s.map((m, g) => n[g] * m[1])) / i, x = be(s.map((m, g) => n[g] * m[2])) / i;
    return pe.fromHsl(p, y, x);
  }
};
class M3 {
  constructor(e) {
    this.maxSize = e;
  }
  store = /* @__PURE__ */ new Map();
  list = [];
  has(e) {
    return this.store.has(e);
  }
  get(e) {
    const n = this.store.get(e);
    return n && this.touch(e, n), n ? n.val : void 0;
  }
  set(e, n) {
    const i = this.store.get(e);
    if (i) {
      i.val = n, this.touch(e, i);
      return;
    }
    if (this.list.push(e), this.store.set(e, { val: n, i: this.list.length }), this.list.length > this.maxSize) {
      const s = this.list.shift();
      this.store.delete(s);
    }
  }
  getOrSet(e, n) {
    const i = this.get(e);
    if (i) return i;
    const s = n(e);
    return this.set(e, s), s;
  }
  touch(e, n) {
    this.list.splice(n.i, 1).push(e), n.i = this.list.length;
  }
}
function _3(r) {
  return r[Symbol.iterator]().next().value;
}
function* S3(...r) {
  for (const e of r) yield* e;
}
function T3(r, e) {
  for (const n of r)
    if (!e(n)) return !1;
  return !0;
}
function E3(r, e) {
  for (const n of r)
    if (e(n)) return !0;
  return !1;
}
function* z3(r, e) {
  let n = 0;
  for (const i of r)
    e(i, n) && (yield i), n += 1;
}
function* A3(r, e) {
  let n = 0;
  for (const i of r)
    yield e(i, n), n += 1;
}
function* C3(r, e) {
  for (const n of r)
    for (const i of e(n))
      yield i;
}
function* P3(r, e) {
  for (const n of r)
    for (const i of e)
      yield [n, i];
}
function* I3(r) {
  const e = r.length;
  for (let n = 0; n < e; ++n)
    for (let i = n + 1; i < e; ++i)
      yield [r[n], r[i]];
}
function k3(r, e, n = 1 / 0, i) {
  let s, o = n;
  for (const a of r) {
    const h = e(a);
    if (h < o && (s = a, o = h, i !== void 0 && o < i))
      return s;
  }
  return s;
}
const R3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BinarySearchType: yx,
  Cache: M3,
  Color: Qa,
  EventTarget: m3,
  LinkedList: u3,
  autoCorrect: x3,
  binaryIndexOf: f3,
  binarySearch: xx,
  cache: K_,
  chunk: r3,
  concat: S3,
  cumulative: s3,
  deepExtend: lx,
  defer: Q_,
  delay: G_,
  difference: h3,
  every: T3,
  filter: z3,
  findMin: k3,
  first: _3,
  flatMap: C3,
  flatten: Vu,
  intersect: a3,
  isOneOf: go,
  isPalindrome: y3,
  join: c3,
  last: $u,
  list: fx,
  listPairs: I3,
  loop: i3,
  map: A3,
  pairs: P3,
  repeat: qu,
  repeat2D: Du,
  rotate: o3,
  run: X_,
  safeToJSON: n3,
  some: E3,
  sortBy: dx,
  stringDistance: mx,
  tabulate: wh,
  tabulate2D: ux,
  throttle: t3,
  toCSV: l3,
  toCamelCase: p3,
  toTitleCase: d3,
  total: be,
  uid: cx,
  unique: px,
  wait: J_,
  words: Ja
}, Symbol.toStringTag, { value: "Module" })), $h = 1e-6;
function bt(r, e, n = $h) {
  return isNaN(r) || isNaN(e) ? !1 : Math.abs(r - e) < n;
}
function ti(r, e = $h) {
  return bt(r, Math.round(r), e);
}
function En(r, e, n, i = $h) {
  return e > n && ([e, n] = [n, e]), r > e + i && r < n - i;
}
function gx(r, e = $h) {
  return bt(r, 0, e) ? 0 : r > 0 ? 1 : -1;
}
const sp = /(\d+)(\d{3})/, O3 = ["", "k", "m", "b", "t", "q"];
function L3(r) {
  let [e, n] = r.split(".");
  for (; sp.test(e); )
    e = e.replace(sp, "$1,$2");
  return e + (n ? `.${n}` : "");
}
function B3(r, e = 6) {
  if (!e) return `${r}`;
  const n = `${Math.abs(Math.floor(r))}`.length, i = n + (r < 0 ? 1 : 0);
  if (i <= e) return `${wo(r, e - i)}`;
  const s = Math.floor(Math.log10(Math.abs(r)) / 3), o = O3[s], a = e - (n % 3 || 3) - (o ? 1 : 0) - (r < 0 ? 1 : 0);
  return wo(r / Math.pow(10, 3 * s), a) + o;
}
function co(r, e = 0, n = !0) {
  const i = B3(r, e).replace("-", "–");
  return n ? L3(i) : i;
}
function F3(r, e = 6) {
  const n = Math.abs(r);
  if (En(n, Math.pow(10, -e), Math.pow(10, e)))
    return co(r, e);
  if (n > Number.MAX_VALUE) return `${Math.sign(r) < 0 ? "–" : ""}∞`;
  if (n < Number.MIN_VALUE) return "0";
  const [i, s] = r.toExponential().split("e"), o = s.replace("+", "").replace("-", "–"), a = o.startsWith("–");
  return `${i.slice(0, 5)} × 10^${(a ? "(" : "") + o + (a ? ")" : "")}`;
}
const N3 = /^-?0,[0-9]+$/, q3 = /^-?([0-9]+(,[0-9]{3})*)?\.?[0-9]*$/, D3 = /^-?[0-9]+(\.[0-9]{3})*,?[0-9]*$/;
function $3(r) {
  return r = r.replace(/^–/, "-").trim(), !r || r.match(/[^0-9.,-]/) ? NaN : N3.test(r) ? parseFloat(r.replace(/,/, ".")) : q3.test(r) ? parseFloat(r.replace(/,/g, "")) : D3.test(r) ? parseFloat(r.replace(/\./g, "").replace(/,/, ".")) : NaN;
}
function V3(r) {
  if (Math.abs(r) % 100 >= 11 && Math.abs(r) % 100 <= 13)
    return `${r}th`;
  switch (r % 10) {
    case 1:
      return `${r}st`;
    case 2:
      return `${r}nd`;
    case 3:
      return `${r}rd`;
    default:
      return `${r}th`;
  }
}
const Cc = [
  "",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen"
], rp = [
  "",
  "",
  "twenty",
  "thirty",
  "forty",
  "fifty",
  "sixty",
  "seventy",
  "eighty",
  "ninety"
], U3 = [
  "",
  " thousand",
  " million",
  " billion",
  " trillion",
  " quadrillion",
  " quintillion",
  " sextillion"
];
function W3(r) {
  const [e, n, i] = r.split(""), s = e === "0" ? "" : ` ${Cc[+e]} hundred`;
  return n + i === "00" ? s : +n < 2 ? `${s} ${Cc[+(n + i)]}` : i === "0" ? `${s} ${rp[+n]}` : `${s} ${rp[+n]}-${Cc[+i]}`;
}
function j3(r) {
  if (r === 0) return "zero";
  const e = Math.round(Math.abs(r)).toString(), n = Math.ceil(e.length / 3), i = e.padStart(3 * n, "0");
  let s = "";
  for (let o = 0; o < n; o += 1) {
    const a = i.substr(o * 3, 3);
    a !== "000" && (s += W3(a) + U3[n - 1 - o]);
  }
  return s.trim();
}
function Y3(r) {
  return `${Math.abs(r)}`.split("").reverse().map((n) => +n);
}
function wo(r, e = 0) {
  const n = Math.pow(10, e);
  return Math.round(r * n) / n;
}
function Dl(r, e = 1) {
  return Math.round(r / e) * e;
}
function _n(r, e = -1 / 0, n = 1 / 0) {
  return Math.min(n, Math.max(e, r));
}
function bh(r, e, n = 0.5) {
  return r + (e - r) * n;
}
function an(r) {
  return r * r;
}
function H3(r) {
  return r * r * r;
}
function wx(r, e) {
  return (r % e + e) % e;
}
function X3(r, e) {
  return e === void 0 ? Math.log(r) : Math.log(r) / Math.log(e);
}
function bx(r, e, n) {
  if (bt(r, 0) && bt(e, 0)) return [];
  if (bt(r, 0)) return [-n / e];
  const i = -e / 2 / r, s = Math.sqrt(e * e - 4 * r * n) / 2 / r;
  return [i + s, i - s];
}
function Z3(r, e) {
  let n = 0, i = 1;
  for (const s of e)
    n += i * s, i *= r;
  return n;
}
function G3(r) {
  if (r === 0) return 1;
  if (r < 0) return NaN;
  let e = 1;
  for (let n = 2; n <= r; ++n) e *= n;
  return e;
}
function vx(r, e) {
  if (e < 0 || e > r) return 0;
  if (e === 0) return 1;
  if (2 * e > r) return vx(r, r - e);
  let n = 1;
  for (let i = 1; i <= e; ++i) n *= (r - i + 1) / i;
  return Math.round(n);
}
function J3(r) {
  const e = [];
  return Mx(r, e, []), e;
}
function Mx(r, e, n) {
  for (let i = 0; i < r.length; i++) {
    const s = r.splice(i, 1)[0];
    n.push(s), r.length === 0 && e.push(n.slice()), Mx(r, e, n), r.splice(i, 0, s), n.pop();
  }
}
function _x(r, e = 0) {
  const n = r.slice(0), i = Sx(n);
  return e ? i.filter((s) => s.length === e) : i;
}
function Sx(r) {
  if (r.length === 1) return [[], r];
  const e = r.pop(), n = Sx(r), i = [];
  for (const s of n)
    i.push(s, [...s, e]);
  return i;
}
const pa = (r, e) => {
  const n = r < 0 ? "–" : "";
  return Math.abs(r) === 1 && e ? n + e : n + Math.abs(r) + (e || "");
};
class Yt {
  constructor(e = 0, n = 0) {
    this.re = e, this.im = n;
  }
  get modulus() {
    return Math.sqrt(this.re * this.re + this.im * this.im);
  }
  get argument() {
    return Math.atan2(this.im, this.re);
  }
  get conjugate() {
    return new Yt(this.re, -this.im);
  }
  /** Returns the ith nth-root of this complex number. */
  root(e, n = 0) {
    const i = Math.pow(this.modulus, 1 / e), s = (this.argument + n * 2 * Math.PI) / e;
    return new Yt(i * Math.cos(s), i * Math.sin(s));
  }
  toString(e = 2) {
    const n = wo(this.re, e), i = wo(this.im, e);
    return i === 0 ? pa(n) : n === 0 ? pa(i, "i") : [pa(n), i < 0 ? "–" : "+", pa(Math.abs(i), "i")].join(" ");
  }
  // ---------------------------------------------------------------------------
  add(e) {
    return Yt.sum(this, e);
  }
  subtract(e) {
    return Yt.difference(this, e);
  }
  multiply(e) {
    return Yt.product(this, e);
  }
  divide(e) {
    return Yt.quotient(this, e);
  }
  /** Calculates the sum of two complex numbers c1 and c2. */
  static sum(e, n) {
    return typeof e == "number" && (e = new Yt(e, 0)), typeof n == "number" && (n = new Yt(n, 0)), new Yt(e.re + n.re, e.im + n.im);
  }
  /** Calculates the difference of two complex numbers c1 and c2. */
  static difference(e, n) {
    return typeof e == "number" && (e = new Yt(e, 0)), typeof n == "number" && (n = new Yt(n, 0)), new Yt(e.re - n.re, e.im - n.im);
  }
  /** Calculates the product of two complex numbers c1 and c2. */
  static product(e, n) {
    typeof e == "number" && (e = new Yt(e, 0)), typeof n == "number" && (n = new Yt(n, 0));
    const i = e.re * n.re - e.im * n.im, s = e.im * n.re + e.re * n.im;
    return new Yt(i, s);
  }
  /** Calculates the quotient of two complex numbers c1 and c2. */
  static quotient(e, n) {
    if (typeof e == "number" && (e = new Yt(e, 0)), typeof n == "number" && (n = new Yt(n, 0)), Math.abs(n.re) < Number.EPSILON || Math.abs(n.im) < Number.EPSILON)
      return new Yt(1 / 0, 1 / 0);
    const i = n.re * n.re + n.im * n.im, s = (e.re * n.re + e.im * n.im) / i, o = (e.im * n.re - e.re * n.im) / i;
    return new Yt(s, o);
  }
  /** Calculates e^c for a complex number c. */
  static exp(e) {
    typeof e == "number" && (e = new Yt(e, 0));
    const n = Math.exp(e.re);
    return new Yt(n * Math.cos(e.im), n * Math.sin(e.im));
  }
}
function bo(...r) {
  const [e, ...n] = r;
  if (n.length > 1) return bo(e, bo(...n));
  let i = Math.abs(e), s = Math.abs(n[0]);
  for (; s; ) [i, s] = [s, i % s];
  return i;
}
function vh(...r) {
  const [e, ...n] = r;
  return n.length > 1 ? vh(e, vh(...n)) : Math.abs(e * n[0]) / bo(e, n[0]);
}
function vo(r) {
  if (r % 1 !== 0 || r < 2) return !1;
  if (r % 2 === 0) return r === 2;
  if (r % 3 === 0) return r === 3;
  const e = Math.sqrt(r);
  for (let n = 5; n <= e; n += 6)
    if (r % n === 0 || r % (n + 2) === 0) return !1;
  return !0;
}
function Mh(r) {
  if (r === 1) return [];
  if (vo(r)) return [r];
  const e = Math.sqrt(r);
  for (let n = 2; n <= e; ++n)
    if (r % n === 0)
      return Mh(n).concat(Mh(r / n));
  return [];
}
function Tx(r) {
  return px(Mh(r));
}
function Q3(r = 100) {
  if (r < 2) return [];
  const e = [2];
  for (let n = 3; n <= r; n++) {
    let i = !1;
    for (const s of e)
      i = i || n % s === 0;
    i || e.push(n);
  }
  return e;
}
function K3(r) {
  if (r < 2 || r > 16) throw new Error("Invalid number of digits.");
  const e = [1, 3, 7, 9], n = Math.pow(10, r - 2);
  for (; ; ) {
    const s = 10 * (Math.floor(Math.random() * 9 * n) + n) + e[Math.floor(4 * Math.random())];
    if (vo(s)) return s;
  }
}
function tS(r) {
  if (r === 4) return [2, 2];
  let e = r / 2, n = r / 2;
  for (e % 2 === 0 && (e--, n++); e >= 3; ) {
    if (vo(e) && vo(n)) return [e, n];
    e -= 2, n += 2;
  }
  return [-1, -1];
}
function eS(r) {
  if (r <= 0) throw Error("Number should be greater than zero");
  let e = r;
  for (const n of Tx(r)) e *= (n - 1) / n;
  return e;
}
const nS = /^([0-9\-.]*)([%πkmbtq]?)(\/([0-9\-.]+))?([%π]?)$/, op = (r) => r >= Number.MAX_SAFE_INTEGER;
class Rt {
  /** Only used for fractions and always ≥ 0. */
  constructor(e, n, i) {
    this.unit = i, this.num = n !== void 0 && n < 0 ? -e : e, n !== void 0 && Math.abs(n) !== 1 && e !== 0 && (this.den = Math.abs(n));
  }
  num;
  /** Used for all number types (decimals, fractions, units, ...). */
  den;
  valueOf() {
    return this.value;
  }
  toMixed() {
    if (!this.den || this.unit) return this.toString();
    const e = Math.abs(this.num) % this.den, n = Math.abs(Math.trunc(this.value));
    return n ? `${this.sign < 0 ? "–" : ""}${n} ${e}/${this.den}` : this.toString();
  }
  toExpr(e, n = 4) {
    const i = this.value;
    if (Math.abs(i) >= Number.MAX_VALUE) return "∞";
    if ((op(this.num) || this.den && op(this.den)) && (e = "decimal"), e === "scientific" || Math.abs(i) >= Number.MAX_SAFE_INTEGER) {
      const [s, o] = this.value.toExponential(n - 1).split("e");
      if (Math.abs(+o) >= n) {
        const a = o.startsWith("-"), h = `${a ? "(" : ""}${a ? o : o.slice(1)}${a ? ")" : ""}`;
        return `${s.replace(/\.?0+$/, "")} × 10^${h}${this.unit || ""}`;
      }
    }
    if (!this.unit && !this.den || e === "decimal" || e === "scientific") {
      const s = co(this.value, n);
      return s.match(/^[\d.]+$/g) ? s : `"${s}"`;
    } else
      return e === "mixed" ? this.toMixed() : this.toString();
  }
  toString(e = 4) {
    const n = !this.den && !this.unit;
    let i = co(this.num, this.den ? 0 : e, n), s = this.unit || "";
    const o = this.den ? `/${co(this.den, 0, n)}` : "";
    return i === "0" && (s = ""), s === "π" && !this.den && (i === "1" || i === "–1") && (i = i.replace("1", "")), `${i}${o}${s}`;
  }
  toMathML() {
    let e = `<mn>${this.num}</mn>`;
    return this.den !== void 0 && (e = `<mfrac>${e}<mn>${this.den}</mn></mfrac>`), this.unit && (e += this.unit === "π" ? "<mi>π</mi>" : "<mo>%</mo>"), e;
  }
  // ---------------------------------------------------------------------------
  /**
   * Returns the value of this number as a decimal. For example, 2/5 and 40%
   * would both return 0.4.
   */
  get value() {
    const e = this.unit === "%" ? 0.01 : this.unit === "π" ? Math.PI : 1;
    return this.num * e / (this.den || 1);
  }
  get sign() {
    return Math.sign(this.num);
  }
  /** Simplifies fractions, e.g. 4/8 would become 1/2. */
  get simplified() {
    if (!this.den) return this;
    const e = bo(Math.abs(this.num), this.den);
    return new Rt(this.num / e, this.den / e, this.unit);
  }
  /** Returns 1/x of this number. */
  get inverse() {
    return this.den ? new Rt(1 / this.num, void 0, this.unit) : new Rt(this.den, this.num);
  }
  /** Returns -x of this number. */
  get negative() {
    return new Rt(-this.num, this.den, this.unit);
  }
  get fraction() {
    if (!(this.unit || !ti(this.num)))
      return [this.num, this.den || 1];
  }
  // ---------------------------------------------------------------------------
  /** Parses a number string, e.g. '1/2' or '20.7%'. */
  static fromString(e) {
    e = e.toLowerCase().replace(/[\s,"]/g, "").replace("–", "-").replace("pi", "π");
    const n = e.match(nS);
    if (!n) return;
    let i = n[2] || n[5] || void 0, s = n[1] ? +n[1] : void 0;
    const o = n[4] ? +n[4] : void 0;
    if (i === "π" && (!n[1] || n[1] === "-") && (s = n[1] ? -1 : 1), s === void 0 || isNaN(s)) return;
    const a = i ? "kmbtq".indexOf(i) : -1;
    if (a >= 0 && (s *= 1e3 ** (a + 1), i = void 0), o === void 0) return new Rt(s, void 0, i);
    if (!(isNaN(o) || bt(o, 0)))
      return !ti(s) || !ti(o) ? new Rt(s / o, void 0, i) : new Rt(s, o, i);
  }
  /** Converts a decimal into the closest fraction with a given maximum denominator. */
  static fractionFromDecimal(e, n = 1e3, i = 1e-12) {
    let s = [1, 0], o = [0, 1];
    const a = Math.abs(e);
    let h = a;
    for (; Math.abs(s[0] / o[0] - a) > i; ) {
      const c = Math.floor(h);
      if (s = [c * s[0] + s[1], s[0]], o = [c * o[0] + o[1], o[0]], o[0] > n) return new Rt(e);
      h = 1 / (h - c);
    }
    return bt(s[0] / o[0], a, i) ? new Rt(gx(e) * s[0], o[0] === 1 ? void 0 : o[0]) : new Rt(e);
  }
  // ---------------------------------------------------------------------------
  clamp(e, n) {
    const i = this.value;
    return e !== void 0 && i < e ? new Rt(e) : n !== void 0 && i > n ? new Rt(n) : this;
  }
  add(e) {
    return Rt.sum(this, e);
  }
  subtract(e) {
    return Rt.difference(this, e);
  }
  multiply(e) {
    return Rt.product(this, e);
  }
  divide(e) {
    return Rt.quotient(this, e);
  }
  /** Calculates the sum of two fractions a and b. */
  static sum(e, n) {
    if (typeof n == "number" && (n = new Rt(n)), e.num === 0) return n;
    if (e.unit !== n.unit) return new Rt(e.value + n.value);
    if (!e.den && !n.den) return new Rt(e.num + n.num, void 0, e.unit);
    if (e.den || ([e, n] = [n, e]), !ti(n.num)) return new Rt(e.value + n.value, void 0, e.unit);
    const i = vh(e.den, n.den || 1), s = i / e.den, o = i / (n.den || 1);
    return new Rt(e.num * s + n.num * o, i, e.unit);
  }
  /** Calculates the difference of two numbers a and b. */
  static difference(e, n) {
    return typeof n == "number" && (n = new Rt(n)), Rt.sum(e, n.negative);
  }
  /** Calculates the product of two numbers a and b. */
  static product(e, n) {
    if (typeof n == "number" && (n = new Rt(n)), !e.unit && !e.den && ti(e.num)) return new Rt(e.num * n.num, n.den, n.unit);
    if (!n.unit && !n.den && ti(n.num)) return new Rt(e.num * n.num, e.den, e.unit);
    if (e.unit === "π" || n.unit === "π" || !ti(e.num) || !ti(n.num)) return new Rt(e.value * n.value);
    const i = (e.unit === "%" ? 100 : 1) * (n.unit === "%" ? 100 : 1);
    return new Rt(e.num * n.num, (e.den || 1) * (n.den || 1) * i);
  }
  /** Calculates the quotient of two fractions a and b. */
  static quotient(e, n) {
    return typeof n == "number" && (n = new Rt(n)), Rt.product(e, n.inverse);
  }
}
function Ex(r, e, n) {
  return Du(r, e, n);
}
function zx(r = 2) {
  const e = Ex(0, r, r);
  for (let n = 0; n < r; ++n) e[n][n] = 1;
  return e;
}
function iS(r) {
  const e = Math.sin(r), n = Math.cos(r);
  return [[n, -e], [e, n]];
}
function sS(r) {
  return [[1, r], [0, 1]];
}
function rS(r) {
  const e = Math.sin(2 * r), n = Math.cos(2 * r);
  return [[n, e], [e, -n]];
}
function Ax(...r) {
  const [e, ...n] = r, i = n.length > 1 ? Ax(...n) : n[0];
  if (e.length !== i.length || e[0].length !== i[0].length)
    throw new Error("Matrix sizes don’t match");
  const s = [];
  for (let o = 0; o < e.length; ++o) {
    const a = [];
    for (let h = 0; h < e[o].length; ++h)
      a.push(e[o][h] + i[o][h]);
    s.push(a);
  }
  return s;
}
function oS(r, e) {
  return r.map((n) => n.map((i) => i * e));
}
function _h(...r) {
  const [e, ...n] = r, i = n.length > 1 ? _h(...n) : n[0];
  if (e[0].length !== i.length)
    throw new Error("Matrix sizes don’t match.");
  const s = [];
  for (let o = 0; o < e.length; ++o) {
    const a = [];
    for (let h = 0; h < i[0].length; ++h) {
      let c = 0;
      for (let l = 0; l < i.length; ++l)
        c += e[o][l] * i[l][h];
      a.push(c);
    }
    s.push(a);
  }
  return s;
}
function Cx(r) {
  const e = [];
  for (let n = 0; n < r[0].length; ++n) {
    const i = [];
    for (let s = 0; s < r.length; ++s)
      i.push(r[s][n]);
    e.push(i);
  }
  return e;
}
function aS(r) {
  if (r.length !== r[0].length) throw new Error("Not a square matrix.");
  const e = r.length;
  if (e === 1) return r[0][0];
  if (e === 2) return r[0][0] * r[1][1] - r[0][1] * r[1][0];
  let n = 0;
  for (let i = 0; i < e; ++i) {
    let s = r[0][i], o = r[0][i];
    for (let a = 1; a < e; ++a)
      o *= r[a][(i + a) % e], s *= r[a][(i - a + e) % e];
    n += o - s;
  }
  return n;
}
function Px(r) {
  const e = r.length;
  if (e !== r[0].length) throw new Error("Not a square matrix.");
  const n = zx(e), i = ux((s, o) => r[s][o], e, e);
  for (let s = 0; s < e; ++s) {
    let o = i[s][s];
    if (bt(o, 0)) {
      for (let a = s + 1; a < e; ++a)
        if (i[a][s] !== 0) {
          for (let h = 0; h < e; ++h)
            [i[a][h], i[s][h]] = [i[s][h], i[a][h]], [n[a][h], n[s][h]] = [n[s][h], n[a][h]];
          break;
        }
      if (o = i[s][s], bt(o, 0)) throw new Error("Matrix not invertible.");
    }
    for (let a = 0; a < e; ++a)
      i[s][a] = i[s][a] / o, n[s][a] = n[s][a] / o;
    for (let a = 0; a < e; ++a) {
      if (a === s) continue;
      const h = i[a][s];
      for (let c = 0; c < e; ++c)
        i[a][c] -= h * i[s][c], n[a][c] -= h * n[s][c];
    }
  }
  return n;
}
const hS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  determinant: aS,
  fill: Ex,
  identity: zx,
  inverse: Px,
  product: _h,
  reflection: rS,
  rotation: iS,
  scalarProduct: oS,
  shear: sS,
  sum: Ax,
  transpose: Cx
}, Symbol.toStringTag, { value: "Module" }));
function cS(r) {
  r = r.slice(0);
  for (let e = r.length - 1; e > 0; --e) {
    const n = Math.floor(Math.random() * (e + 1));
    [r[e], r[n]] = [r[n], r[e]];
  }
  return r;
}
function lS(r, e) {
  const n = e === void 0 ? 0 : r, i = e === void 0 ? r : e - r + 1;
  return n + Math.floor(i * Math.random());
}
function Ix(r) {
  const e = Math.random() * be(r);
  let n = 0;
  return r.findIndex((i) => (n += i) >= e);
}
function uS(r) {
  return r[Math.floor(r.length * Math.random())];
}
const ya = /* @__PURE__ */ new Map();
function fS(r, e) {
  e || (e = cx()), ya.has(e) || ya.set(e, qu(1, r));
  const n = ya.get(e), i = Ix(n.map((s) => s * s));
  return n[i] -= 1, n[i] <= 0 && ya.set(e, n.map((s) => s + 1)), i;
}
function kx(r = 0.5) {
  return Math.random() < r ? 1 : 0;
}
function dS(r = 1, e = 0.5) {
  let n = 0;
  for (let i = 0; i < r; ++i) n += kx(e);
  return n;
}
function pS(r = 1) {
  if (r <= 0) return 0;
  const e = Math.exp(-r);
  let n = 1, i = 0;
  for (; n > e; ++i) n *= Math.random();
  return i - 1;
}
function $l(r = 0, e = 1) {
  return r + (e - r) * Math.random();
}
function yS(r = 0, e = 1) {
  const n = Math.random(), i = Math.random();
  return Math.sqrt(-2 * Math.log(n)) * Math.cos(2 * Math.PI * i) * Math.sqrt(e) + r;
}
function xS(r = 1) {
  return r <= 0 ? 0 : -Math.log(Math.random()) / r;
}
function mS(r = 0.5) {
  if (!(r <= 0 || r > 1))
    return Math.floor(Math.log(Math.random()) / Math.log(1 - r));
}
function gS() {
  let r, e, n;
  do
    e = 2 * Math.random() - 1, n = 2 * Math.random() - 1, r = e * e + n * n;
  while (r >= 1);
  return e / n;
}
function wS(r, e = 1, n = 0) {
  return Math.exp(-((r - e) ** 2) / (2 * n)) / Math.sqrt(2 * Math.PI * n);
}
const ap = 7, hp = [
  0.9999999999998099,
  676.5203681218851,
  -1259.1392167224028,
  771.3234287776531,
  -176.6150291621406,
  12.507343278686905,
  -0.13857109526572012,
  9984369578019572e-21,
  15056327351493116e-23
];
function Rx(r) {
  if (r < 0.5) return Math.PI / (Math.sin(Math.PI * r) * Rx(1 - r));
  r -= 1;
  let e = hp[0];
  for (let i = 1; i < ap + 2; i++) e += hp[i] / (r + i);
  const n = r + ap + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(n, r + 0.5) * Math.exp(-n) * e;
}
function Ox(r, e, n, i = 1) {
  let s = 0;
  for (let o = e; o < n; o += i)
    s += r(o) * i || 0;
  return s;
}
function bS(r, e) {
  return 1 - Ox((i) => Math.pow(i, (e - 2) / 2) * Math.exp(-i / 2), 0, r) / Math.pow(2, e / 2) / Rx(e / 2);
}
const vS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bernoulli: kx,
  binomial: dS,
  cauchy: gS,
  chiCDF: bS,
  exponential: xS,
  find: uS,
  geometric: mS,
  integer: lS,
  integrate: Ox,
  normal: yS,
  normalPDF: wS,
  poisson: pS,
  shuffle: cS,
  smart: fS,
  uniform: $l,
  weighted: Ix
}, Symbol.toStringTag, { value: "Module" }));
function MS(r, e) {
  let n = 1, i = r[0];
  for (let s = 1; s < r.length; ++s)
    n *= e, i += n * r[s];
  return i;
}
function _S(r, e = !1) {
  let n = 0, i = 0, s = 0, o = 0;
  const a = r.length;
  for (let l = 0; l < a; l++)
    n += r[l][0], i += r[l][1], s += r[l][0] * r[l][0], o += r[l][0] * r[l][1];
  if (e)
    return [0, o / s];
  const h = (a * o - n * i) / (a * s - n * n);
  return [i / a - h * n / a, h];
}
function SS(r) {
  const e = [0, 0, 0, 0, 0, 0];
  for (const o of r)
    e[0] += o[0], e[1] += o[1], e[2] += o[0] * o[0] * o[1], e[3] += o[1] * Math.log(o[1]), e[4] += o[0] * o[1] * Math.log(o[1]), e[5] += o[0] * o[1];
  const n = e[1] * e[2] - e[5] * e[5], i = Math.exp((e[2] * e[3] - e[5] * e[4]) / n), s = (e[1] * e[4] - e[5] * e[3]) / n;
  return [i, s];
}
function TS(r) {
  const e = [0, 0, 0, 0], n = r.length;
  for (const o of r)
    e[0] += Math.log(o[0]), e[1] += o[1] * Math.log(o[0]), e[2] += o[1], e[3] += Math.pow(Math.log(o[0]), 2);
  const i = (n * e[1] - e[2] * e[0]) / (n * e[3] - e[0] * e[0]);
  return [(e[2] - i * e[0]) / n, i];
}
function ES(r) {
  const e = [0, 0, 0, 0], n = r.length;
  for (const o of r)
    e[0] += Math.log(o[0]), e[1] += Math.log(o[1]) * Math.log(o[0]), e[2] += Math.log(o[1]), e[3] += Math.pow(Math.log(o[0]), 2);
  const i = (n * e[1] - e[2] * e[0]) / (n * e[3] - e[0] * e[0]);
  return [Math.exp((e[2] - i * e[0]) / n), i];
}
function Lx(r, e = 2) {
  const n = r.map((c) => fx(e + 1).map((l) => Math.pow(c[0], l))), i = Cx(n), s = r.map((c) => [c[1]]), o = _h(i, n), a = Px(o);
  return _h(a, i, s).map((c) => c[0]);
}
function Bx(r, e) {
  const i = r.reduce((a, h) => a + h[1], 0) / r.length, s = r.reduce((a, h) => a + (h[1] - i) ** 2, 0);
  return 1 - r.reduce((a, h) => a + (h[1] - e(h[0])) ** 2, 0) / s;
}
function zS(r, e = 0.85, n = 8) {
  if (!(r.length <= 1))
    for (let i = 1; i < n; ++i) {
      const s = Lx(r, i), o = (h) => MS(s, h);
      if (Bx(r, o) >= e) return { order: i, coefficients: s, fn: o };
    }
}
const AS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bestPolynomial: zS,
  coefficient: Bx,
  exponential: SS,
  linear: _S,
  logarithmic: TS,
  polynomial: Lx,
  power: ES
}, Symbol.toStringTag, { value: "Module" }));
function Fx(r) {
  return r.length ? be(r) / r.length : 0;
}
function Nx(r, e, n = 1) {
  const i = r.length;
  if (!i) return 0;
  const s = r.slice(0).sort((h, c) => h - c);
  if (e === 0) return s[0];
  if (e === 1) return s[i - 1];
  if (![1, 2, 3].includes(n)) throw new RangeError("Invalid quantile method.");
  const o = n === 1 ? i * e - 0.5 : (
    // Matlab, Mathematica
    n === 2 ? (i - 1) * e : (
      // Excel, NumPy, Google Docs, R, Python (option)
      (i + 1) * e - 1
    )
  );
  if (Number.isInteger(o)) return s[o];
  const a = Math.floor(o);
  return bh(s[a], s[a + 1], o - a);
}
function CS(r, e = 1) {
  return Nx(r, 0.5, e);
}
function PS(r) {
  const e = /* @__PURE__ */ new Map();
  let n = -1, i;
  for (const s of r) {
    e.has(s) || e.set(s, 0);
    const o = e.get(s) + 1;
    e.set(s, o), o === n ? i = void 0 : o > n && (n = o, i = s);
  }
  return i;
}
function qx(r) {
  if (!r.length) return;
  const e = Fx(r);
  return r.reduce((i, s) => i + (s - e) ** 2, 0) / (r.length - 1);
}
function Vl(r) {
  const e = qx(r);
  return e ? Math.sqrt(e) : 0;
}
function Dx(r, e) {
  if (r.length !== e.length) throw new Error("Array length mismatch.");
  return (r.reduce((i, s, o) => i + s * e[o], 0) - be(r) * be(e) / r.length) / r.length;
}
function IS(r, e) {
  if (r.length !== e.length) throw new Error("Array length mismatch.");
  const n = Dx(r, e), i = Vl(r), s = Vl(e);
  return n / (i * s);
}
class Sh extends Array {
  constructor(...e) {
    super();
    for (const n of e) this.push(n);
  }
  /** Returns the magnitude of the Vector */
  get magnitude() {
    let e = 0;
    for (let n = 0; n < this.length; ++n) e += this[n] ** 2;
    return Math.sqrt(e);
  }
  /** Returns the unitVector of the Vector */
  get unitVector() {
    return this.scale(1 / this.magnitude);
  }
  /** Scales this vector by a factor q. */
  scale(e) {
    return this.map((n) => e * n);
  }
  // -------------------------------------------------------------------------
  /** Calculates the sum of two vectors v1 and v2. */
  static sum(e, n) {
    if (e.length !== n.length) throw new Error("Mismatched vector sizes.");
    return e.map((i, s) => i + n[s]);
  }
  /** Calculates the difference of two vectors v1 and v2. */
  static difference(e, n) {
    if (e.length !== n.length) throw new Error("Mismatched vector sizes.");
    return e.map((i, s) => i - n[s]);
  }
  /** Calculates the element-wise product of two vectors v1 and v2. */
  static product(e, n) {
    if (e.length !== n.length) throw new Error("Mismatched vector sizes.");
    return e.map((i, s) => i * n[s]);
  }
  /** Calculates the dot product of two vectors v1 and v2. */
  static dot(e, n) {
    return be(Sh.product(e, n));
  }
  /** Finds the cross product of two 3-dimensional vectors v1 and v2. */
  static cross(e, n) {
    if (e.length !== 3 || n.length !== 3)
      throw new Error("Cross product requires vectors of size 3.");
    return new Sh(
      e[1] * n[2] - e[2] * n[1],
      e[2] * n[0] - e[0] * n[2],
      e[0] * n[1] - e[1] * n[0]
    );
  }
  /** Checks if two vectors are equal. */
  static equals(e, n) {
    const i = e.length;
    if (i !== n.length) return !1;
    for (let s = 0; s < i; ++s) if (!bt(e[s], n[s])) return !1;
    return !0;
  }
}
const kS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Complex: Yt,
  Matrix: hS,
  Random: vS,
  Regression: AS,
  Vector: Sh,
  XNumber: Rt,
  binomial: vx,
  clamp: _n,
  correlation: IS,
  covariance: Dx,
  cube: H3,
  digits: Y3,
  eulerPhi: eS,
  factorial: G3,
  gcd: bo,
  generatePrime: K3,
  goldbach: tS,
  isBetween: En,
  isInteger: ti,
  isPrime: vo,
  lcm: vh,
  lerp: bh,
  listPrimes: Q3,
  log: X3,
  mean: Fx,
  median: CS,
  mod: wx,
  mode: PS,
  nearlyEquals: bt,
  numberFormat: co,
  parseNumber: $3,
  permutations: J3,
  polynomial: Z3,
  primeFactorisation: Mh,
  primeFactors: Tx,
  quadratic: bx,
  quantile: Nx,
  round: wo,
  roundTo: Dl,
  scientificFormat: F3,
  sign: gx,
  square: an,
  stdDev: Vl,
  subsets: _x,
  toOrdinal: V3,
  toWord: j3,
  variance: qx
}, Symbol.toStringTag, { value: "Module" })), ye = 2 * Math.PI;
function Mr(r, e) {
  const n = Math.atan2(r.y - (e ? e.y : 0), r.x - (e ? e.x : 0));
  return wx(n, ye);
}
function cp(r, e) {
  let n, i = 1 / 0, s = -1;
  for (const [o, a] of e.entries()) {
    const h = a.project(r), c = rt.distance(r, h);
    c < i && (n = h, i = c, s = o);
  }
  return n ? [n, s] : void 0;
}
let rt = class qt {
  constructor(e = 0, n = 0) {
    this.x = e, this.y = n;
  }
  type = "point";
  get unitVector() {
    return bt(this.length, 0) ? new qt(1, 0) : this.scale(1 / this.length);
  }
  get length() {
    return Math.sqrt(this.x ** 2 + this.y ** 2);
  }
  get inverse() {
    return new qt(-this.x, -this.y);
  }
  get flip() {
    return new qt(this.y, this.x);
  }
  get perpendicular() {
    return new qt(-this.y, this.x);
  }
  get array() {
    return [this.x, this.y];
  }
  /** Finds the perpendicular distance between this point and a line. */
  distanceFromLine(e) {
    return qt.distance(this, e.project(this));
  }
  /** Clamps this point to specific bounds. */
  clamp(e, n = 0) {
    const i = _n(this.x, e.xMin + n, e.xMax - n), s = _n(this.y, e.yMin + n, e.yMax - n);
    return new qt(i, s);
  }
  changeCoordinates(e, n) {
    const i = n.xMin + (this.x - e.xMin) / e.dx * n.dx, s = n.yMin + (this.y - e.yMin) / e.dy * n.dy;
    return new qt(i, s);
  }
  add(e) {
    return qt.sum(this, e);
  }
  subtract(e) {
    return qt.difference(this, e);
  }
  round(e = 1) {
    return new qt(Dl(this.x, e), Dl(this.y, e));
  }
  floor() {
    return new qt(Math.floor(this.x), Math.floor(this.y));
  }
  mod(e, n = e) {
    return new qt(this.x % e, this.y % n);
  }
  angle(e = Xe) {
    return Mr(this, e);
  }
  // Snap to the x or y values of another point
  snap(e, n = 5) {
    return bt(this.x, e.x, n) ? new qt(e.x, this.y) : bt(this.y, e.y, n) ? new qt(this.x, e.y) : this;
  }
  /** Calculates the average of multiple points. */
  static average(...e) {
    const n = be(e.map((s) => s.x)) / e.length, i = be(e.map((s) => s.y)) / e.length;
    return new qt(n, i);
  }
  /** Calculates the dot product of two points p1 and p2. */
  static dot(e, n) {
    return e.x * n.x + e.y * n.y;
  }
  static sum(e, n) {
    return new qt(e.x + n.x, e.y + n.y);
  }
  static difference(e, n) {
    return new qt(e.x - n.x, e.y - n.y);
  }
  /** Returns the Euclidean distance between two points p1 and p2. */
  static distance(e, n) {
    return Math.sqrt(an(e.x - n.x) + an(e.y - n.y));
  }
  /** Returns the Manhattan distance between two points p1 and p2. */
  static manhattan(e, n) {
    return Math.abs(e.x - n.x) + Math.abs(e.y - n.y);
  }
  /** Interpolates two points p1 and p2 by a factor of t. */
  static interpolate(e, n, i = 0.5) {
    return new qt(bh(e.x, n.x, i), bh(e.y, n.y, i));
  }
  /** Interpolates a list of multiple points. */
  static interpolateList(e, n = 0.5) {
    const i = e.length - 1, s = Math.floor(_n(n, 0, 1) * i);
    return qt.interpolate(e[s], e[s + 1], i * n - s);
  }
  /** Creates a point from polar coordinates. */
  static fromPolar(e, n = 1) {
    return new qt(n * Math.cos(e), n * Math.sin(e));
  }
  static random(e) {
    const n = $l(e.xMin, e.xMax), i = $l(e.yMin, e.yMax);
    return new qt(n, i);
  }
  static equals(e, n, i) {
    return bt(e.x, n.x, i) && bt(e.y, n.y, i);
  }
  /** Check if p1, p2 and p3 lie on a straight line. */
  static colinear(e, n, i, s) {
    const o = e.x - n.x, a = e.y - n.y, h = n.x - i.x, c = n.y - i.y;
    return bt(o * c, h * a, s);
  }
  // ---------------------------------------------------------------------------
  /** Transforms this point using a 2x3 matrix m. */
  transform(e) {
    const n = e[0][0] * this.x + e[0][1] * this.y + e[0][2], i = e[1][0] * this.x + e[1][1] * this.y + e[1][2];
    return new qt(n, i);
  }
  /** Rotates this point by a given angle (in radians) around point `c`. */
  rotate(e, n = Xe) {
    if (bt(e, 0)) return this;
    const i = this.x - n.x, s = this.y - n.y, o = Math.cos(e), a = Math.sin(e), h = i * o - s * a + n.x, c = i * a + s * o + n.y;
    return new qt(h, c);
  }
  /** Reflects this point across a line l. */
  reflect(e) {
    const n = e.p2.x - e.p1.x, i = e.p2.y - e.p1.y, s = this.x - e.p1.x, o = this.y - e.p1.y, a = (n * o - i * s) / (n * n + i * i), h = this.x + 2 * a * i, c = this.y - 2 * a * n;
    return new qt(h, c);
  }
  scale(e, n = e) {
    return new qt(this.x * e, this.y * n);
  }
  shift(e, n = e) {
    return new qt(this.x + e, this.y + n);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n) {
    return qt.equals(this, e, n);
  }
  toString() {
    return `point(${this.x},${this.y})`;
  }
};
const Xe = new rt(0, 0);
function Th(r) {
  return ["polygon", "polyline", "rectangle", "triangle"].includes(r.type);
}
function $x(r) {
  return ["polygon", "triangle"].includes(r.type);
}
function Uu(r) {
  return r.type === "polyline";
}
function Ul(r) {
  return r.type === "rectangle";
}
function xs(r) {
  return ["line", "ray", "segment"].includes(r.type);
}
function Vx(r) {
  return r.type === "line";
}
function qo(r) {
  return r.type === "ray";
}
function Do(r) {
  return r.type === "segment";
}
function ms(r) {
  return r.type === "circle";
}
function Wu(r) {
  return r.type === "ellipse";
}
function lo(r) {
  return r.type === "arc";
}
function Ux(r) {
  return r.type === "sector";
}
function Mo(r) {
  return r.type === "angle";
}
function RS(r) {
  return r.type === "point";
}
class fe {
  constructor(e, n) {
    this.p1 = e, this.p2 = n;
  }
  type = "line";
  flag;
  ["constructor"];
  /* The distance between the two points defining this line. */
  get length() {
    return rt.distance(this.p1, this.p2);
  }
  /* The squared distance between the two points defining this line. */
  get lengthSquared() {
    return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;
  }
  /** The midpoint of this line. */
  get midpoint() {
    return rt.average(this.p1, this.p2);
  }
  /** The slope of this line. */
  get slope() {
    return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
  }
  /** The y-axis intercept of this line. */
  get intercept() {
    return this.p1.y - this.slope * this.p1.x;
  }
  /** The angle formed between this line and the x-axis. */
  get angle() {
    return Mr(this.p2, this.p1);
  }
  /** The point representing a unit vector along this line. */
  get unitVector() {
    return this.p2.subtract(this.p1).unitVector;
  }
  /** The point representing the perpendicular vector of this line. */
  get perpendicularVector() {
    return new rt(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;
  }
  /** Finds the line parallel to this one, going through point p. */
  parallel(e) {
    return new fe(e, e.add(this.p2).subtract(this.p1));
  }
  /** Finds the line perpendicular to this one, going through point p. */
  perpendicular(e) {
    const n = this.line.project(e);
    return rt.equals(e, n) ? new fe(n, n.add(this.perpendicularVector.scale(this.length / 2))) : new fe(n, e);
  }
  /** The perpendicular bisector of this line. */
  get perpendicularBisector() {
    return this.perpendicular(this.midpoint);
  }
  /** Squared distance between a point and a line. */
  distanceSquared(e) {
    const n = this.project(e);
    return (e.x - n.x) ** 2 + (e.y - n.y) ** 2;
  }
  get line() {
    return this.type === "line" ? this : new fe(this.p1, this.p2);
  }
  get ray() {
    return qo(this) ? this : new Wx(this.p1, this.p2);
  }
  get segment() {
    return Do(this) ? this : new Is(this.p1, this.p2);
  }
  // ---------------------------------------------------------------------------
  /** Signed distance along the line (opposite of .at()). */
  offset(e) {
    const n = rt.difference(this.p2, this.p1), i = rt.difference(e, this.p1);
    return rt.dot(n, i) / this.lengthSquared;
  }
  /** Projects a point `p` onto this line. */
  project(e) {
    return this.at(this.offset(e));
  }
  /** Returns which side of this line a point p is on (or 0 on the line). */
  side(e, n) {
    const i = rt.difference(this.p2, this.p1), s = rt.difference(e, this.p1), o = s.x * i.y - s.y * i.x;
    return bt(o, 0, n) ? 0 : Math.sign(o);
  }
  /** Checks if a point p lies on this line. */
  contains(e, n) {
    return this.side(e, n) === 0;
  }
  /** Gets the point at a specific offset along the line (opposite of .offset()). */
  at(e) {
    return rt.interpolate(this.p1, this.p2, e);
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new this.constructor(this.p1.transform(e), this.p2.transform(e));
  }
  /** Rotates this line by a given angle (in radians), optionally around point `c`. */
  rotate(e, n = Xe) {
    return bt(e, 0) ? this : new this.constructor(this.p1.rotate(e, n), this.p2.rotate(e, n));
  }
  reflect(e) {
    return new this.constructor(this.p1.reflect(e), this.p2.reflect(e));
  }
  scale(e, n = e) {
    return new this.constructor(this.p1.scale(e, n), this.p2.scale(e, n));
  }
  shift(e, n = e) {
    return new this.constructor(this.p1.shift(e, n), this.p2.shift(e, n));
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n) {
    return this.contains(e.p1, n) && this.contains(e.p2, n);
  }
  toString() {
    return `line(${this.p1},${this.p2})`;
  }
}
let Wx = class extends fe {
  type = "ray";
  equals(e, n) {
    return e.type !== "ray" || !this.p1.equals(e.p1, n) ? !1 : this.p2.equals(e.p2, n) ? !0 : e.contains(this.p2, n) || this.contains(e.p2, n);
  }
  contains(e, n) {
    if (!super.contains(e, n)) return !1;
    const i = this.offset(e);
    return bt(i, 0, n) || i > 0;
  }
  toString() {
    return `ray(${this.p1},${this.p2})`;
  }
};
class Is extends fe {
  type = "segment";
  contains(e, n) {
    return super.contains(e, n) ? this.p1.equals(e, n) || this.p2.equals(e, n) ? !0 : bt(this.p1.x, this.p2.x, n) ? En(e.y, this.p1.y, this.p2.y) : En(e.x, this.p1.x, this.p2.x) : !1;
  }
  project(e) {
    const n = rt.difference(this.p2, this.p1), i = rt.difference(e, this.p1), s = _n(rt.dot(n, i) / this.lengthSquared, 0, 1);
    return this.p1.add(n.scale(s));
  }
  /** Contracts (or expands) a line by a specific ratio. */
  contract(e) {
    return new Is(this.at(e), this.at(1 - e));
  }
  equals(e, n, i = !1) {
    return e.type !== "segment" ? !1 : this.p1.equals(e.p1, n) && this.p2.equals(e.p2, n) || !i && this.p1.equals(e.p2, n) && this.p2.equals(e.p1, n);
  }
  toString() {
    return `segment(${this.p1},${this.p2})`;
  }
}
let Eh = class sr {
  constructor(e = Xe, n = 1) {
    this.c = e, this.r = n;
  }
  type = "circle";
  /** The length of the circumference of this circle. */
  get circumference() {
    return ye * this.r;
  }
  /** The area of this circle. */
  get area() {
    return Math.PI * this.r ** 2;
  }
  get arc() {
    const e = this.c.shift(this.r, 0);
    return new _o(this.c, e, ye);
  }
  tangentAt(e) {
    const n = this.at(e), i = this.c.rotate(Math.PI / 2, n);
    return new fe(n, i);
  }
  collision(e) {
    const n = this.c.x < e.p.x ? e.p.x : this.c.x > e.p.x + e.w ? e.p.x + e.w : this.c.x, i = this.c.y < e.p.y ? e.p.y : this.c.y > e.p.y + e.h ? e.p.y + e.h : this.c.y;
    return rt.distance(this.c, new rt(n, i)) <= this.r;
  }
  // ---------------------------------------------------------------------------
  project(e) {
    const n = e.subtract(this.c).unitVector.scale(this.r);
    return rt.sum(this.c, n);
  }
  at(e) {
    const n = ye * e;
    return this.c.shift(this.r * Math.cos(n), this.r * Math.sin(n));
  }
  offset(e) {
    return Mr(e, this.c) / ye;
  }
  contains(e) {
    return rt.distance(e, this.c) <= this.r;
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    const n = Math.abs(e[0][0]) + Math.abs(e[1][1]);
    return new sr(this.c.transform(e), this.r * n / 2);
  }
  rotate(e, n = Xe) {
    return bt(e, 0) ? this : new sr(this.c.rotate(e, n), this.r);
  }
  reflect(e) {
    return new sr(this.c.reflect(e), this.r);
  }
  scale(e, n = e) {
    return new sr(this.c.scale(e, n), this.r * (e + n) / 2);
  }
  shift(e, n = e) {
    return new sr(this.c.shift(e, n), this.r);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n) {
    return bt(this.r, e.r, n) && this.c.equals(e.c, n);
  }
  toString() {
    return `circle(${this.c},${this.r})`;
  }
};
class _o {
  constructor(e, n, i) {
    this.c = e, this.start = n, this.angle = i;
  }
  type = "arc";
  ["constructor"];
  get circle() {
    return new Eh(this.c, this.radius);
  }
  get radius() {
    return rt.distance(this.c, this.start);
  }
  get end() {
    return this.start.rotate(this.angle, this.c);
  }
  get startAngle() {
    return Mr(this.start, this.c);
  }
  contract(e) {
    return new this.constructor(this.c, this.at(e / 2), this.angle * (1 - e));
  }
  get minor() {
    return this.angle <= Math.PI ? this : new this.constructor(this.c, this.end, ye - this.angle);
  }
  get major() {
    return this.angle >= Math.PI ? this : new this.constructor(this.c, this.end, ye - this.angle);
  }
  get center() {
    return this.at(0.5);
  }
  // ---------------------------------------------------------------------------
  project(e) {
    const n = this.startAngle, i = n + this.angle;
    let s = Mr(e, this.c);
    return i > ye && s < i - ye && (s += ye), s = _n(s, n, i), this.c.shift(this.radius, 0).rotate(s, this.c);
  }
  at(e) {
    return this.start.rotate(this.angle * e, this.c);
  }
  offset(e) {
    return new Se(this.start, this.c, e).rad / this.angle;
  }
  contains(e) {
    return e.equals(this.project(e));
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new this.constructor(
      this.c.transform(e),
      this.start.transform(e),
      this.angle
    );
  }
  /** Rotates this arc by a given angle (in radians), optionally around point `c`. */
  rotate(e, n = Xe) {
    return bt(e, 0) ? this : new this.constructor(
      this.c.rotate(e, n),
      this.start.rotate(e, n),
      this.angle
    );
  }
  reflect(e) {
    return new this.constructor(
      this.c.reflect(e),
      this.start.reflect(e),
      this.angle
    );
  }
  scale(e, n = e) {
    return new this.constructor(
      this.c.scale(e, n),
      this.start.scale(e, n),
      this.angle
    );
  }
  shift(e, n = e) {
    return new this.constructor(
      this.c.shift(e, n),
      this.start.shift(e, n),
      this.angle
    );
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals() {
    return !1;
  }
  toString() {
    return `arc(${this.c},${this.start},${this.angle})`;
  }
}
class jx extends _o {
  type = "sector";
  contains(e) {
    return rt.distance(e, this.c) <= this.radius && new Se(this.start, this.c, e).rad <= this.angle;
  }
  toString() {
    return `sector(${this.c},${this.start},${this.angle})`;
  }
}
function OS(r, e) {
  return bt(r.p1.x, r.p2.x) ? En(e.y, r.p1.y, r.p2.y) : En(e.x, r.p1.x, r.p2.x);
}
function LS(r, e) {
  return bt(r.p1.x, r.p2.x) ? (e.y - r.p1.y) / (r.p2.y - r.p1.y) > 0 : (e.x - r.p1.x) / (r.p2.x - r.p1.x) > 0;
}
function BS(r, e) {
  return En(r.offset(e), 0, 1);
}
function FS(r, e) {
  const n = r.p1.x - r.p2.x, i = r.p1.y - r.p2.y, s = e.p1.x - e.p2.x, o = e.p1.y - e.p2.y, a = n * o - i * s;
  if (bt(a, 0)) return [];
  const h = r.p1.x * r.p2.y - r.p1.y * r.p2.x, c = e.p1.x * e.p2.y - e.p1.y * e.p2.x, l = h * s - n * c, u = h * o - i * c;
  return [new rt(l / a, u / a)];
}
function NS(r, e) {
  const n = rt.distance(r.c, e.c);
  if (n > r.r + e.r) return [];
  if (n < Math.abs(r.r - e.r)) return [];
  if (bt(n, 0) && bt(r.r, e.r)) return [];
  if (bt(n, r.r + e.r)) return [new fe(r.c, e.c).midpoint];
  const i = (an(r.r) - an(e.r) + an(n)) / (2 * n), s = Math.sqrt(an(r.r) - an(i)), o = (e.c.x - r.c.x) * i / n + (e.c.y - r.c.y) * s / n + r.c.x, a = (e.c.y - r.c.y) * i / n - (e.c.x - r.c.x) * s / n + r.c.y, h = (e.c.x - r.c.x) * i / n - (e.c.y - r.c.y) * s / n + r.c.x, c = (e.c.y - r.c.y) * i / n + (e.c.x - r.c.x) * s / n + r.c.y;
  return [new rt(o, a), new rt(h, c)];
}
function lp(r, e) {
  const n = r.p2.x - r.p1.x, i = r.p2.y - r.p1.y, s = an(n) + an(i), o = e.c.x, a = e.c.y, h = (r.p1.x - o) * (r.p2.y - a) - (r.p2.x - o) * (r.p1.y - a), c = an(e.r) * s - an(h);
  if (c < 0) return [];
  const l = h * i / s, u = -h * n / s;
  if (bt(c, 0)) return [e.c.shift(l, u)];
  const f = n * (i < 0 ? -1 : 1) * Math.sqrt(c) / s, d = Math.abs(i) * Math.sqrt(c) / s;
  return [e.c.shift(l + f, u + d), e.c.shift(l - f, u - d)];
}
function qS(r, e) {
  let n = [];
  const i = lo(r) ? r.circle : r, s = lo(e) ? e.circle : e;
  xs(r) && xs(e) ? n = FS(r, e) : xs(i) && ms(s) ? n = lp(i, s) : ms(i) && xs(s) ? n = lp(s, i) : ms(i) && ms(s) && (n = NS(i, s));
  for (const o of [r, e])
    Do(o) && (n = n.filter((a) => OS(o, a))), qo(o) && (n = n.filter((a) => LS(o, a))), lo(o) && (n = n.filter((a) => BS(o, a)));
  return n;
}
function Ri(...r) {
  if (r.length < 2) return [];
  if (r.length > 2)
    return Vu(_x(r, 2).map((i) => Ri(...i)));
  let [e, n] = r;
  if (Mo(e) && (e = e.shape(!0)), Mo(n) && (n = n.shape(!0)), Th(n) && ([e, n] = [n, e]), Th(e)) {
    const i = xs(n) ? e.points.filter((s) => n.contains(s)) : [];
    for (const s of e.edges) i.push(...Ri(s, n));
    return i;
  }
  return qS(e, n);
}
let _r = class Qr {
  type = "polygon";
  points;
  ["constructor"];
  constructor(...e) {
    this.points = e;
  }
  get circumference() {
    if (this.points.length <= 1) return 0;
    let e = rt.distance(this.points[0], $u(this.points));
    for (let n = 1; n < this.points.length; ++n)
      e += rt.distance(this.points[n - 1], this.points[n]);
    return e;
  }
  /**
   * The (signed) area of this polygon. The result is positive if the vertices
   * are ordered clockwise, and negative otherwise.
   */
  get signedArea() {
    const e = this.points, n = e.length;
    let i = e[n - 1].x * e[0].y - e[0].x * e[n - 1].y;
    for (let s = 1; s < n; ++s)
      i += e[s - 1].x * e[s].y - e[s].x * e[s - 1].y;
    return i / 2;
  }
  get area() {
    return Math.abs(this.signedArea);
  }
  get centroid() {
    const e = this.points, n = e.length;
    let i = 0;
    for (let o = 0; o < n; ++o) i += e[o].x;
    let s = 0;
    for (let o = 0; o < n; ++o) s += e[o].y;
    return new rt(i / n, s / n);
  }
  get edges() {
    const e = this.points.length, n = [];
    for (let i = 0; i < e; ++i)
      n.push(new Is(this.points[i], this.points[(i + 1) % e]));
    return n;
  }
  get radius() {
    const e = this.centroid, n = this.points.map((i) => rt.distance(i, e));
    return Math.max(...n);
  }
  /** The oriented version of this polygon (vertices in clockwise order). */
  get oriented() {
    if (this.signedArea >= 0) return this;
    const e = [...this.points].reverse();
    return new this.constructor(...e);
  }
  /** Checks if two polygons p1 and p2 collide. */
  static collision(e, n, i) {
    if (e.points.some((s) => n.contains(s)) || n.points.some((s) => e.contains(s))) return !0;
    for (const s of e.edges)
      for (const o of n.edges)
        if (Ri(s, o)[0]) return !0;
    return e.equals(n, i);
  }
  /** Creates a regular polygon. */
  static regular(e, n = 1) {
    const i = ye / e, s = Math.PI / 2 - i / 2, o = wh((a) => rt.fromPolar(s + i * a, n), e);
    return new Qr(...o);
  }
  /** Interpolates the points of two polygons */
  static interpolate(e, n, i = 0.5) {
    const s = e.points.map(
      (o, a) => rt.interpolate(o, n.points[a], i)
    );
    return new Qr(...s);
  }
  static convexHull(...e) {
    if (e.length <= 3) return new Qr(...e);
    const n = e.sort((a, h) => a.x !== h.x ? a.x - h.x : a.y - h.y), i = n.slice(0).reverse(), s = [], o = [];
    for (const [a, h] of [[n, s], [i, o]]) {
      for (const c of a) {
        for (; h.length >= 2; ) {
          const l = h[h.length - 1], u = h[h.length - 2];
          if ((l.x - u.x) * (c.y - u.y) >= (c.x - u.x) * (l.y - u.y))
            h.pop();
          else
            break;
        }
        h.push(c);
      }
      h.pop();
    }
    return new Qr(...s.concat(o));
  }
  // ---------------------------------------------------------------------------
  /**
   * Checks if a point p lies inside this polygon, by using a ray-casting
   * algorithm and calculating the number of intersections.
   */
  contains(e) {
    let n = !1;
    for (const i of this.edges) {
      if (i.p1.equals(e) || i.contains(e)) return !1;
      if (i.p1.y > e.y == i.p2.y > e.y) continue;
      const s = (i.p2.x - i.p1.x) / (i.p2.y - i.p1.y);
      e.x < s * (e.y - i.p1.y) + i.p1.x && (n = !n);
    }
    return n;
  }
  at(e) {
    e < 0 && (e += Math.floor(e));
    const n = e * this.circumference;
    let i = 0;
    for (const s of this.edges) {
      const o = s.length;
      if (i + o > n) return s.at((n - i) / o);
      i += o;
    }
    return this.points[0];
  }
  offset(e) {
    const n = this.edges, i = cp(e, this.edges) || [this.points[0], 0];
    let s = 0;
    for (let o = 0; o < i[1]; ++o) s += n[o].length;
    return s += n[i[1]].offset(e) * n[i[1]].length, s / this.circumference;
  }
  project(e) {
    const n = cp(e, this.edges);
    return n ? n[0] : this.points[0];
  }
  /** Center this polygon on a given point or the origin */
  centerAt(e = Xe) {
    return this.translate(e.subtract(this.centroid));
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new this.constructor(...this.points.map((n) => n.transform(e)));
  }
  /** Rotates this polygon by a given angle (in radians), optionally around point `center`. */
  rotate(e, n = Xe) {
    if (bt(e, 0)) return this;
    const i = this.points.map((s) => s.rotate(e, n));
    return new this.constructor(...i);
  }
  reflect(e) {
    const n = this.points.map((i) => i.reflect(e));
    return new this.constructor(...n);
  }
  scale(e, n = e) {
    const i = this.points.map((s) => s.scale(e, n));
    return new this.constructor(...i);
  }
  shift(e, n = e) {
    const i = this.points.map((s) => s.shift(e, n));
    return new this.constructor(...i);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n, i) {
    const s = this.points.length;
    if (s !== e.points.length) return !1;
    const o = i ? this : this.oriented, a = i ? e : e.oriented;
    for (let h = 0; h < s; ++h)
      if (o.points.every((c, l) => c.equals(a.points[(l + h) % s], n)))
        return !0;
    return !1;
  }
  toString() {
    return `polygon(${this.points.join(",")})`;
  }
};
class Yx extends _r {
  type = "polyline";
  get circumference() {
    return this.length;
  }
  get length() {
    let e = 0;
    for (let n = 1; n < this.points.length; ++n)
      e += rt.distance(this.points[n - 1], this.points[n]);
    return e;
  }
  /** @returns {Segment[]} */
  get edges() {
    const e = [];
    for (let n = 0; n < this.points.length - 1; ++n)
      e.push(new Is(this.points[n], this.points[n + 1]));
    return e;
  }
  toString() {
    return `polyline(${this.points.join(",")})`;
  }
}
let DS = class extends _r {
  type = "triangle";
  get circumcircle() {
    const [e, n, i] = this.points, s = 2 * (e.x * (n.y - i.y) + n.x * (i.y - e.y) + i.x * (e.y - n.y)), o = (e.x ** 2 + e.y ** 2) * (n.y - i.y) + (n.x ** 2 + n.y ** 2) * (i.y - e.y) + (i.x ** 2 + i.y ** 2) * (e.y - n.y), a = (e.x ** 2 + e.y ** 2) * (i.x - n.x) + (n.x ** 2 + n.y ** 2) * (e.x - i.x) + (i.x ** 2 + i.y ** 2) * (n.x - e.x), h = new rt(o / s, a / s), c = rt.distance(h, this.points[0]);
    if (!(isNaN(c) || c > Number.MAX_SAFE_INTEGER))
      return new Eh(h, c);
  }
  get incircle() {
    const e = this.edges, n = e.map((f) => f.length), i = n[0] + n[1] + n[2], [s, o, a] = this.points, h = n[1] * s.x + n[2] * o.x + n[0] * a.x, c = n[1] * s.y + n[2] * o.y + n[0] * a.y, l = new rt(h / i, c / i), u = l.distanceFromLine(e[0]);
    return isNaN(u) ? void 0 : new Eh(l, u);
  }
  get orthocenter() {
    const [e, n, i] = this.points, s = new fe(e, n).perpendicular(i), o = new fe(e, i).perpendicular(n);
    return Ri(s, o)[0];
  }
};
const $S = 180 / Math.PI, VS = Math.PI / 180;
function Hx(r) {
  return r * $S;
}
function US(r) {
  return r * VS;
}
class Se {
  constructor(e, n, i) {
    this.a = e, this.b = n, this.c = i;
  }
  type = "angle";
  static fromDegrees(e) {
    return Se.fromRadians(e * (Math.PI / 180));
  }
  static fromRadians(e) {
    const n = new rt(1, 0), i = n.rotate(e);
    return new Se(n, Xe, i);
  }
  /** Checks if `a` and `b` are roughly equivalent (by default, within one degree of eachother) */
  static equals(e, n, i = Math.PI / 360) {
    return bt(e.rad, n.rad, i);
  }
  /** The size, in radians, of this angle. */
  get rad() {
    const e = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
    let i = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x) - e;
    return i < 0 && (i += ye), i;
  }
  /** The size, in degrees, of this angle. */
  get deg() {
    return this.rad * 180 / Math.PI;
  }
  /** Checks if this angle is right-angled. */
  get isRight() {
    return bt(this.rad, Math.PI / 2, Math.PI / 360);
  }
  /** The bisector of this angle. */
  get bisector() {
    if (this.b.equals(this.a) || this.b.equals(this.c)) return;
    const e = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x), n = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
    let i = (e + n) / 2;
    e > n && (i += Math.PI);
    const s = Math.cos(i) + this.b.x, o = Math.sin(i) + this.b.y;
    return new fe(this.b, new rt(s, o));
  }
  /** Returns the smaller one of this and its supplementary angle. */
  get sup() {
    return this.rad < Math.PI ? this : new Se(this.c, this.b, this.a);
  }
  /** Returns the Arc element corresponding to this angle. */
  get arc() {
    return new _o(this.b, this.a, this.rad);
  }
  // ---------------------------------------------------------------------------
  /** Radius of the arc or sector representing this angle. */
  get radius() {
    return 24 + 20 * (1 - _n(this.rad, 0, Math.PI) / Math.PI);
  }
  /** Shape object that can be used to draw this angle. */
  shape(e = !0, n, i) {
    if (this.a.equals(this.b) || this.c.equals(this.b)) return new _r(Xe);
    const s = this.isRight && !i;
    n || (n = s ? 20 : this.radius);
    const o = new Is(this.b, this.a), a = o.at(n / o.length);
    if (s) {
      const h = rt.difference(this.c, this.b).unitVector.scale(n);
      return e ? new _r(this.b, a, a.add(h), this.b.add(h)) : new Yx(a, a.add(h), this.b.add(h));
    }
    return e ? new jx(this.b, a, this.rad) : new _o(this.b, a, this.rad);
  }
  // ---------------------------------------------------------------------------
  // These functions are just included for compatibility with GeoPath
  project(e) {
    return this.contains(e) ? e : this.shape(!0).project(e);
  }
  at() {
    return this.c;
  }
  offset() {
    return 0;
  }
  contains(e) {
    return this.shape(!0).contains(e);
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new Se(this.a.transform(e), this.b.transform(e), this.c.transform(e));
  }
  rotate(e, n) {
    return bt(e, 0) ? this : new Se(this.a.rotate(e, n), this.b.rotate(e, n), this.c.rotate(e, n));
  }
  reflect(e) {
    return new Se(this.a.reflect(e), this.b.reflect(e), this.c.reflect(e));
  }
  scale(e, n = e) {
    return new Se(this.a.scale(e, n), this.b.scale(e, n), this.c.scale(e, n));
  }
  shift(e, n = e) {
    return new Se(this.a.shift(e, n), this.b.shift(e, n), this.c.shift(e, n));
  }
  translate(e) {
    return new Se(this.a.translate(e), this.b.translate(e), this.c.translate(e));
  }
  equals(e, n) {
    return Se.equals(e, this, n);
  }
  toString() {
    return `angle(${this.a},${this.b},${this.c})`;
  }
}
let Xx = class rr {
  constructor(e, n = 1, i = n) {
    this.p = e, this.w = n, this.h = i;
  }
  type = "rectangle";
  /** Creates the smallest rectangle containing all given points. */
  static aroundPoints(e) {
    let n = 1 / 0, i = -1 / 0, s = 1 / 0, o = -1 / 0;
    for (const a of e)
      n = n < a.x ? n : a.x, i = i > a.x ? i : a.x, s = s < a.y ? s : a.y, o = o > a.y ? o : a.y;
    return new rr(new rt(n, s), i - n, o - s);
  }
  get center() {
    return new rt(this.p.x + this.w / 2, this.p.y + this.h / 2);
  }
  get centroid() {
    return this.center;
  }
  get circumference() {
    return 2 * Math.abs(this.w) + 2 * Math.abs(this.h);
  }
  get area() {
    return Math.abs(this.signedArea);
  }
  get signedArea() {
    return this.w * this.h;
  }
  /** @returns {Segment[]} */
  get edges() {
    return this.polygon.edges;
  }
  /** @returns {Point[]} */
  get points() {
    return this.polygon.points;
  }
  /** A polygon class representing this rectangle. */
  get polygon() {
    const e = new rt(this.p.x + this.w, this.p.y), n = new rt(this.p.x + this.w, this.p.y + this.h), i = new rt(this.p.x, this.p.y + this.h);
    return new _r(this.p, e, n, i);
  }
  get bounds() {
    return new yr(this.p.x, this.p.x + this.w, this.p.y, this.p.y + this.h);
  }
  collision(e) {
    return this.p.x < e.p.x + e.w && this.p.x + this.w > e.p.x && this.p.y < e.p.y + e.h && this.p.y + this.h > e.p.y || this.equals(e.polygon);
  }
  padding(e, n, i, s) {
    return new rr(this.p.shift(-s, -e), this.w + s + n, this.h + e + i);
  }
  get unsigned() {
    if (this.w > 0 && this.h > 0) return this;
    const e = this.p.shift(this.w < 0 ? this.w : 0, this.h < 0 ? this.h : 0);
    return new rr(e, Math.abs(this.w), Math.abs(this.h));
  }
  // ---------------------------------------------------------------------------
  contains(e, n) {
    return En(e.x, this.p.x, this.p.x + this.w, n) && En(e.y, this.p.y, this.p.y + this.h, n);
  }
  project(e) {
    let n;
    for (const i of this.edges) {
      const s = i.project(e);
      (!n || rt.distance(e, s) < rt.distance(e, n)) && (n = s);
    }
    return n;
  }
  at(e) {
    return this.polygon.at(e);
  }
  offset(e) {
    return this.polygon.offset(e);
  }
  get oriented() {
    return this.polygon.oriented;
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return this.polygon.transform(e);
  }
  /** Rotates this rectangle by a given angle (in radians), optionally around point `c`. */
  rotate(e, n = Xe) {
    return bt(e, 0) ? this : this.polygon.rotate(e, n);
  }
  reflect(e) {
    return this.polygon.reflect(e);
  }
  scale(e, n = e) {
    return new rr(this.p.scale(e, n), this.w * e, this.h * n);
  }
  shift(e, n = e) {
    return new rr(this.p.shift(e, n), this.w, this.h);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e) {
    return this.polygon.equals(e);
  }
  toString() {
    return `rectangle(${this.p},${this.w},${this.h})`;
  }
};
class yr {
  /**
   * Use the `errorHandling` option to decide how to deal with cases where the
   * min and max values are in the wrong order.
   */
  constructor(e, n, i, s, o) {
    this.xMin = e, this.xMax = n, this.yMin = i, this.yMax = s, o === "swap" ? (this.dx < 0 && ([this.xMin, this.xMax] = [n, e]), this.dy < 0 && ([this.yMin, this.yMax] = [s, i])) : o === "center" && (this.dx < 0 && (this.xMin = this.xMax = (e + n) / 2), this.dy < 0 && (this.yMin = this.yMax = (i + s) / 2));
  }
  contains(e) {
    return this.containsX(e) && this.containsY(e);
  }
  containsX(e) {
    return En(e.x, this.xMin, this.xMax);
  }
  containsY(e) {
    return En(e.y, this.yMin, this.yMax);
  }
  resize(e, n) {
    return new yr(this.xMin, this.xMax + e, this.yMin, this.yMax + n);
  }
  get dx() {
    return this.xMax - this.xMin;
  }
  get dy() {
    return this.yMax - this.yMin;
  }
  get xRange() {
    return [this.xMin, this.xMax];
  }
  get yRange() {
    return [this.yMin, this.yMax];
  }
  extend(e, n = e, i = e, s = n) {
    return new yr(this.xMin - s, this.xMax + n, this.yMin - e, this.yMax + i);
  }
  get rect() {
    return new Xx(new rt(this.xMin, this.yMin), this.dx, this.dy);
  }
  get center() {
    return new rt(this.xMin + this.dx / 2, this.yMin + this.dy / 2);
  }
  get flip() {
    return new yr(this.yMin, this.yMax, this.xMin, this.xMax);
  }
}
function Zx(r, e, n = {}) {
  if (Mo(e)) return Zx(r, e.shape(!!n.fill), n);
  if (n.fill && (r.fillStyle = n.fill), n.opacity && (r.globalAlpha = n.opacity), n.stroke && (r.strokeStyle = n.stroke, r.lineWidth = n.strokeWidth || 1, n.lineCap && (r.lineCap = n.lineCap), n.lineJoin && (r.lineJoin = n.lineJoin)), r.beginPath(), Do(e))
    r.moveTo(e.p1.x, e.p1.y), r.lineTo(e.p2.x, e.p2.y);
  else if (xs(e)) {
    if (!n.box) return;
    let [i, s] = Ri(e, n.box);
    if (qo(e) && (s = e.p1), !i || !s) return;
    r.moveTo(i.x, i.y), r.lineTo(s.x, s.y);
  } else if (ms(e))
    r.arc(e.c.x, e.c.y, e.r, 0, ye);
  else if (Th(e)) {
    const i = e.points;
    r.moveTo(i[0].x, i[0].y);
    for (const s of i.slice(1)) r.lineTo(s.x, s.y);
    r.closePath();
  } else if (Uu(e)) {
    r.moveTo(e.points[0].x, e.points[0].y);
    for (const i of e.points.slice(1)) r.lineTo(i.x, i.y);
  } else Wu(e) && r.ellipse(e.c.x, e.c.y, e.a, e.b, e.angle, 0, ye);
  n.fill && r.fill(), n.stroke && r.stroke();
}
const WS = 4 * (Math.sqrt(2) - 1) / 3;
function up(r, e, n) {
  const s = e.x * (n.y - r.y) + r.x * (e.y - n.y) + n.x * (r.y - e.y) > 0 ? 1 : 0, o = rt.distance(e, r);
  return [r.x, `${r.y}A${o}`, o, 0, s, 1, n.x, n.y].join(",");
}
function He(...r) {
  return `M${r.map((e) => `${e.x},${e.y}`).join("L")}`;
}
function Pc(r, e) {
  const n = r.perpendicularVector.scale(6), i = r.unitVector.scale(3), s = r.midpoint;
  switch (e) {
    case "bar":
      return He(s.add(n), s.add(n.inverse));
    case "bar2":
      return He(s.add(i).add(n), s.add(i).add(n.inverse)) + He(s.add(i.inverse).add(n), s.add(i.inverse).add(n.inverse));
    case "arrow":
      return He(
        s.add(i.inverse).add(n),
        s.add(i),
        s.add(i.inverse).add(n.inverse)
      );
    case "arrow2":
      return He(
        s.add(i.scale(-2)).add(n),
        s,
        s.add(i.scale(-2)).add(n.inverse)
      ) + He(s.add(n), s.add(i.scale(2)), s.add(n.inverse));
    default:
      return "";
  }
}
function zh(r, e) {
  if (!r || !e) return "";
  const n = e.perpendicular, i = r.add(e.scale(9)).add(n.scale(9)), s = r.add(e.scale(9)).add(n.scale(-9));
  return He(i, r, s);
}
function jS(r, e) {
  let n = "";
  return go(e, "start", "both") && (n += zh(r.p1, r.unitVector)), go(e, "end", "both") && (n += zh(r.p2, r.unitVector.inverse)), n;
}
function YS(r, e) {
  let n = "";
  if (go(e, "start", "both")) {
    const i = new fe(r.c, r.start).perpendicularVector.inverse;
    n += zh(r.start, i);
  }
  if (go(e, "end", "both")) {
    const i = new fe(r.c, r.end).perpendicularVector;
    n += zh(r.end, i);
  }
  return n;
}
function Wl(r, e) {
  const n = rt.distance(r[0], r[1]), i = rt.distance(r[1], r[2]), s = Math.max(0.1, n / 2), o = Math.max(0.1, i / 2), a = Math.min(e, s, o), h = a / n, c = a / i, l = 1 - WS, u = rt.interpolate(r[0], r[1], _n(1 - h, 0, 1)), f = rt.interpolate(r[0], r[1], _n(1 - h * l, 0, 1)), d = rt.interpolate(r[1], r[2], _n(c * l, 0, 1)), p = rt.interpolate(r[1], r[2], _n(c, 0, 1));
  return [u, f, d, p];
}
function fp(r, e, n = !1) {
  e < 0 && (e = 0);
  let i = "M";
  if (!n)
    i += `${r[0].x} ${r[0].y}`;
  else {
    const s = r[r.length - 1], o = r[0], a = r[1], h = Wl([s, o, a], e);
    i += `${h[3].x} ${h[3].y}`;
  }
  for (let s = 0; s < r.length; s++)
    if (s < r.length - 2 || n) {
      const o = r[s], a = r[(s + 1) % r.length], h = r[(s + 2) % r.length], c = Wl([o, a, h], e).map((l) => `${l.x} ${l.y}`);
      i += `L${c[0]}C${c[1]} ${c[2]} ${c[3]}`;
    } else s === r.length - 2 && !n && (i += `L${r[s + 1].x} ${r[s + 1].y}`);
  return i;
}
function HS(r, e, n = e, i = e, s = n) {
  const { p: o, w: a, h } = r;
  return `M${o.x} ${o.y + e}a${e} ${e} 0 0 1 ${e} ${-e}h${a - e - n}a${n} ${n} 0 0 1 ${n} ${n}v${h - n - i}a${i} ${i} 0 0 1 ${-i} ${i}h${-a + s + i}a${s} ${s} 0 0 1 ${-s} ${-s}Z`;
}
function Gx(r, e = {}) {
  if (Mo(r)) {
    const n = r.shape(!!e.fill, e.size, e.round);
    return Gx(n, e);
  }
  if (Do(r)) {
    if (r.p1.equals(r.p2)) return "";
    let n = He(r.p1, r.p2);
    return e.mark && (n += Pc(r, e.mark)), e.arrows && (n += jS(r, e.arrows)), n;
  }
  if (qo(r)) {
    if (!e.box) return "";
    const n = Ri(r, e.box)[0];
    if (!n) return "";
    let i = He(r.p1, n);
    return e.mark && (i += Pc(r, e.mark)), i;
  }
  if (Vx(r)) {
    if (!e.box) return "";
    const n = Ri(r, e.box);
    if (n.length < 2) return "";
    let i = He(n[0], n[1]);
    return e.mark && (i += Pc(r, e.mark)), i;
  }
  if (ms(r))
    return `M${r.c.x - r.r} ${r.c.y}a${r.r},${r.r} 0 1 0 ${2 * r.r} 0a${r.r} ${r.r} 0 1 0 ${-2 * r.r} 0Z`;
  if (Wu(r)) {
    const [n, i] = r.majorVertices, s = Hx(r.angle);
    return `M${n.x} ${n.y}A${r.a} ${r.b} ${s} 0 0 ${i.x} ${i.y}A${r.a} ${r.b} ${s} 0 0 ${n.x} ${n.y}Z`;
  }
  if (lo(r)) {
    let n = `M${up(r.start, r.c, r.end)}`;
    return e.arrows && (n += YS(r, e.arrows)), n;
  }
  return Ux(r) ? `M${r.c.x} ${r.c.y} L ${up(r.start, r.c, r.end)}Z` : Uu(r) ? e.cornerRadius ? fp(r.points, e.cornerRadius, !1) : He(...r.points) : $x(r) || Ul(r) && e.cornerRadius ? e.cornerRadius ? fp(r.points, e.cornerRadius, !0) : `${He(...r.points)}Z` : Ul(r) ? `${He(...r.polygon.points)}Z` : "";
}
let XS = class as {
  /**
   * @param c Center of the ellipse
   * @param a Major axis
   * @param b Minor axis
   * @param angle The rotation of the major axis of the ellipse.
   */
  constructor(e, n, i, s = 0) {
    this.c = e, n < i && ([n, i] = [i, n], s += Math.PI / 2), this.a = n, this.b = i, this.angle = s;
    const o = Math.sqrt(n ** 2 - i ** 2);
    this.f1 = this.c.add(new rt(-o, 0).rotate(s)), this.f2 = this.c.add(new rt(o, 0).rotate(s));
  }
  type = "ellipse";
  a;
  b;
  angle;
  f1;
  f2;
  get rx() {
    return bt(this.angle, 0) ? this.a : bt(this.angle, Math.PI / 2) ? this.b : void 0;
  }
  get ry() {
    return bt(this.angle, 0) ? this.b : bt(this.angle, Math.PI / 2) ? this.a : void 0;
  }
  normalAt(e) {
    return new Se(this.f1, e, this.f2).bisector;
  }
  /** Intersection between an ellipse and a line. */
  intersect(e) {
    e = e.rotate(-this.angle, this.c);
    const n = e.p1.x - e.p2.x, i = e.p1.y - e.p2.y, s = this.c.x - e.p1.x, o = this.c.y - e.p1.y, a = (n / this.a) ** 2 + (i / this.b) ** 2, h = 2 * s * n / this.a ** 2 + 2 * o * i / this.b ** 2, c = (s / this.a) ** 2 + (o / this.b) ** 2 - 1;
    return bx(a, h, c).map((u) => e.at(u).rotate(this.angle, this.c));
  }
  /**
   * Creates a new Ellipse. StringLength is the length of string from one foci
   * to a point on the circumference, to the other foci.
   */
  static fromFoci(e, n, i) {
    const s = rt.distance(e, n) / 2, o = i / 2, a = Math.sqrt(o ** 2 - s ** 2), h = new fe(e, n).angle;
    return new as(rt.interpolate(e, n), o, a, h);
  }
  // ---------------------------------------------------------------------------
  get majorVertices() {
    return [
      this.c.add(new rt(-this.a, 0).rotate(this.angle)),
      this.c.add(new rt(this.a, 0).rotate(this.angle))
    ];
  }
  get minorVertices() {
    return [
      this.c.add(new rt(0, -this.b).rotate(this.angle)),
      this.c.add(new rt(0, this.b).rotate(this.angle))
    ];
  }
  get extremes() {
    const { a: e, b: n, angle: i } = this, s = Math.cos(i), o = Math.sin(i), a = e ** 2 + n ** 2, h = (e ** 2 - n ** 2) * Math.cos(2 * i), c = Math.sqrt((a - h) / 2), l = c * a * o * s / (e ** 2 * o ** 2 + n ** 2 * s ** 2), u = Math.sqrt((a + h) / 2), f = u * a * o * s / (e ** 2 * s ** 2 + n ** 2 * o ** 2);
    return [
      new rt(l, c).add(this.c),
      new rt(l, c).inverse.add(this.c),
      new rt(u, f).add(this.c),
      new rt(u, f).inverse.add(this.c)
    ];
  }
  project(e) {
    e = e.rotate(-this.angle, this.c);
    const n = e.angle(this.c);
    return this.at(n / ye);
  }
  at(e) {
    const n = ye * e;
    return this.c.shift(this.a * Math.cos(n), this.b * Math.sin(n)).rotate(this.angle, this.c);
  }
  offset(e) {
    return 0.5;
  }
  contains(e) {
    const n = Math.cos(this.angle), i = Math.sin(this.angle), s = n ** 2 / this.a ** 2 + i ** 2 / this.b ** 2, o = 2 * n * i * (1 / this.a ** 2 - 1 / this.b ** 2), a = i ** 2 / this.a ** 2 + n ** 2 / this.b ** 2;
    return s * e.x ** 2 + o * e.x * e.y + a * e.y ** 2 <= 1;
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return this;
  }
  rotate(e, n = Xe) {
    const i = new fe(this.f1, this.f2).rotate(e, n);
    return as.fromFoci(i.p1, i.p2, this.a * 2);
  }
  reflect(e) {
    const n = new fe(this.f1, this.f2).reflect(e);
    return as.fromFoci(n.p1, n.p2, this.a * 2);
  }
  scale(e, n = e) {
    return new as(this.c.scale(e, n), this.a * e, this.b * n, this.angle);
  }
  shift(e, n = e) {
    return new as(this.c.shift(e, n), this.a, this.b, this.angle);
  }
  translate(e) {
    return new as(this.c.translate(e), this.a, this.b, this.angle);
  }
  equals(e, n) {
    return bt(this.a, e.a, n) && bt(this.b, e.b, n) && bt(this.angle, e.angle, n) && this.c.equals(e.c, n);
  }
  toString() {
    return `ellipse(${this.c},${this.a},${this.b},${this.angle})`;
  }
};
const ZS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Angle: Se,
  Arc: _o,
  Bounds: yr,
  Circle: Eh,
  Ellipse: XS,
  Line: fe,
  ORIGIN: Xe,
  Point: rt,
  Polygon: _r,
  Polyline: Yx,
  Ray: Wx,
  Rectangle: Xx,
  Sector: jx,
  Segment: Is,
  TWO_PI: ye,
  Triangle: DS,
  drawCanvas: Zx,
  drawRoundedRect: HS,
  drawSVG: Gx,
  getBezierPoints: Wl,
  intersections: Ri,
  isAngle: Mo,
  isArc: lo,
  isCircle: ms,
  isEllipse: Wu,
  isLine: Vx,
  isLineLike: xs,
  isPoint: RS,
  isPolygon: $x,
  isPolygonLike: Th,
  isPolyline: Uu,
  isRay: qo,
  isRectangle: Ul,
  isSector: Ux,
  isSegment: Do,
  rad: Mr,
  toDeg: Hx,
  toRad: US
}, Symbol.toStringTag, { value: "Module" })), GS = {
  core: R3,
  fermat: kS,
  euclid: ZS
}, JS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  mathigon: GS
}, Symbol.toStringTag, { value: "Module" }));
var QS = 20, KS = 1, Ts = 1e6, dp = 1e6, tT = -7, eT = 21, nT = !1, $o = "[big.js] ", ks = $o + "Invalid ", Vh = ks + "decimal places", iT = ks + "rounding mode", Jx = $o + "Division by zero", Ft = {}, Vn = void 0, sT = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function Qx() {
  function r(e) {
    var n = this;
    if (!(n instanceof r))
      return e === Vn && arguments.length === 0 ? Qx() : new r(e);
    if (e instanceof r)
      n.s = e.s, n.e = e.e, n.c = e.c.slice();
    else {
      if (typeof e != "string") {
        if (r.strict === !0 && typeof e != "bigint")
          throw TypeError(ks + "value");
        e = e === 0 && 1 / e < 0 ? "-0" : String(e);
      }
      rT(n, e);
    }
    n.constructor = r;
  }
  return r.prototype = Ft, r.DP = QS, r.RM = KS, r.NE = tT, r.PE = eT, r.strict = nT, r.roundDown = 0, r.roundHalfUp = 1, r.roundHalfEven = 2, r.roundUp = 3, r;
}
function rT(r, e) {
  var n, i, s;
  if (!sT.test(e))
    throw Error(ks + "number");
  for (r.s = e.charAt(0) == "-" ? (e = e.slice(1), -1) : 1, (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (i = e.search(/e/i)) > 0 ? (n < 0 && (n = i), n += +e.slice(i + 1), e = e.substring(0, i)) : n < 0 && (n = e.length), s = e.length, i = 0; i < s && e.charAt(i) == "0"; ) ++i;
  if (i == s)
    r.c = [r.e = 0];
  else {
    for (; s > 0 && e.charAt(--s) == "0"; ) ;
    for (r.e = n - i - 1, r.c = [], n = 0; i <= s; ) r.c[n++] = +e.charAt(i++);
  }
  return r;
}
function Rs(r, e, n, i) {
  var s = r.c;
  if (n === Vn && (n = r.constructor.RM), n !== 0 && n !== 1 && n !== 2 && n !== 3)
    throw Error(iT);
  if (e < 1)
    i = n === 3 && (i || !!s[0]) || e === 0 && (n === 1 && s[0] >= 5 || n === 2 && (s[0] > 5 || s[0] === 5 && (i || s[1] !== Vn))), s.length = 1, i ? (r.e = r.e - e + 1, s[0] = 1) : s[0] = r.e = 0;
  else if (e < s.length) {
    if (i = n === 1 && s[e] >= 5 || n === 2 && (s[e] > 5 || s[e] === 5 && (i || s[e + 1] !== Vn || s[e - 1] & 1)) || n === 3 && (i || !!s[0]), s.length = e, i) {
      for (; ++s[--e] > 9; )
        if (s[e] = 0, e === 0) {
          ++r.e, s.unshift(1);
          break;
        }
    }
    for (e = s.length; !s[--e]; ) s.pop();
  }
  return r;
}
function Os(r, e, n) {
  var i = r.e, s = r.c.join(""), o = s.length;
  if (e)
    s = s.charAt(0) + (o > 1 ? "." + s.slice(1) : "") + (i < 0 ? "e" : "e+") + i;
  else if (i < 0) {
    for (; ++i; ) s = "0" + s;
    s = "0." + s;
  } else if (i > 0)
    if (++i > o)
      for (i -= o; i--; ) s += "0";
    else i < o && (s = s.slice(0, i) + "." + s.slice(i));
  else o > 1 && (s = s.charAt(0) + "." + s.slice(1));
  return r.s < 0 && n ? "-" + s : s;
}
Ft.abs = function() {
  var r = new this.constructor(this);
  return r.s = 1, r;
};
Ft.cmp = function(r) {
  var e, n = this, i = n.c, s = (r = new n.constructor(r)).c, o = n.s, a = r.s, h = n.e, c = r.e;
  if (!i[0] || !s[0]) return i[0] ? o : s[0] ? -a : 0;
  if (o != a) return o;
  if (e = o < 0, h != c) return h > c ^ e ? 1 : -1;
  for (a = (h = i.length) < (c = s.length) ? h : c, o = -1; ++o < a; )
    if (i[o] != s[o]) return i[o] > s[o] ^ e ? 1 : -1;
  return h == c ? 0 : h > c ^ e ? 1 : -1;
};
Ft.div = function(r) {
  var e = this, n = e.constructor, i = e.c, s = (r = new n(r)).c, o = e.s == r.s ? 1 : -1, a = n.DP;
  if (a !== ~~a || a < 0 || a > Ts)
    throw Error(Vh);
  if (!s[0])
    throw Error(Jx);
  if (!i[0])
    return r.s = o, r.c = [r.e = 0], r;
  var h, c, l, u, f, d = s.slice(), p = h = s.length, y = i.length, x = i.slice(0, h), m = x.length, g = r, w = g.c = [], M = 0, S = a + (g.e = e.e - r.e) + 1;
  for (g.s = o, o = S < 0 ? 0 : S, d.unshift(0); m++ < h; ) x.push(0);
  do {
    for (l = 0; l < 10; l++) {
      if (h != (m = x.length))
        u = h > m ? 1 : -1;
      else
        for (f = -1, u = 0; ++f < h; )
          if (s[f] != x[f]) {
            u = s[f] > x[f] ? 1 : -1;
            break;
          }
      if (u < 0) {
        for (c = m == h ? s : d; m; ) {
          if (x[--m] < c[m]) {
            for (f = m; f && !x[--f]; ) x[f] = 9;
            --x[f], x[m] += 10;
          }
          x[m] -= c[m];
        }
        for (; !x[0]; ) x.shift();
      } else
        break;
    }
    w[M++] = u ? l : ++l, x[0] && u ? x[m] = i[p] || 0 : x = [i[p]];
  } while ((p++ < y || x[0] !== Vn) && o--);
  return !w[0] && M != 1 && (w.shift(), g.e--, S--), M > S && Rs(g, S, n.RM, x[0] !== Vn), g;
};
Ft.eq = function(r) {
  return this.cmp(r) === 0;
};
Ft.gt = function(r) {
  return this.cmp(r) > 0;
};
Ft.gte = function(r) {
  return this.cmp(r) > -1;
};
Ft.lt = function(r) {
  return this.cmp(r) < 0;
};
Ft.lte = function(r) {
  return this.cmp(r) < 1;
};
Ft.minus = Ft.sub = function(r) {
  var e, n, i, s, o = this, a = o.constructor, h = o.s, c = (r = new a(r)).s;
  if (h != c)
    return r.s = -c, o.plus(r);
  var l = o.c.slice(), u = o.e, f = r.c, d = r.e;
  if (!l[0] || !f[0])
    return f[0] ? r.s = -c : l[0] ? r = new a(o) : r.s = 1, r;
  if (h = u - d) {
    for ((s = h < 0) ? (h = -h, i = l) : (d = u, i = f), i.reverse(), c = h; c--; ) i.push(0);
    i.reverse();
  } else
    for (n = ((s = l.length < f.length) ? l : f).length, h = c = 0; c < n; c++)
      if (l[c] != f[c]) {
        s = l[c] < f[c];
        break;
      }
  if (s && (i = l, l = f, f = i, r.s = -r.s), (c = (n = f.length) - (e = l.length)) > 0) for (; c--; ) l[e++] = 0;
  for (c = e; n > h; ) {
    if (l[--n] < f[n]) {
      for (e = n; e && !l[--e]; ) l[e] = 9;
      --l[e], l[n] += 10;
    }
    l[n] -= f[n];
  }
  for (; l[--c] === 0; ) l.pop();
  for (; l[0] === 0; )
    l.shift(), --d;
  return l[0] || (r.s = 1, l = [d = 0]), r.c = l, r.e = d, r;
};
Ft.mod = function(r) {
  var e, n = this, i = n.constructor, s = n.s, o = (r = new i(r)).s;
  if (!r.c[0])
    throw Error(Jx);
  return n.s = r.s = 1, e = r.cmp(n) == 1, n.s = s, r.s = o, e ? new i(n) : (s = i.DP, o = i.RM, i.DP = i.RM = 0, n = n.div(r), i.DP = s, i.RM = o, this.minus(n.times(r)));
};
Ft.neg = function() {
  var r = new this.constructor(this);
  return r.s = -r.s, r;
};
Ft.plus = Ft.add = function(r) {
  var e, n, i, s = this, o = s.constructor;
  if (r = new o(r), s.s != r.s)
    return r.s = -r.s, s.minus(r);
  var a = s.e, h = s.c, c = r.e, l = r.c;
  if (!h[0] || !l[0])
    return l[0] || (h[0] ? r = new o(s) : r.s = s.s), r;
  if (h = h.slice(), e = a - c) {
    for (e > 0 ? (c = a, i = l) : (e = -e, i = h), i.reverse(); e--; ) i.push(0);
    i.reverse();
  }
  for (h.length - l.length < 0 && (i = l, l = h, h = i), e = l.length, n = 0; e; h[e] %= 10) n = (h[--e] = h[e] + l[e] + n) / 10 | 0;
  for (n && (h.unshift(n), ++c), e = h.length; h[--e] === 0; ) h.pop();
  return r.c = h, r.e = c, r;
};
Ft.pow = function(r) {
  var e = this, n = new e.constructor("1"), i = n, s = r < 0;
  if (r !== ~~r || r < -dp || r > dp)
    throw Error(ks + "exponent");
  for (s && (r = -r); r & 1 && (i = i.times(e)), r >>= 1, !!r; )
    e = e.times(e);
  return s ? n.div(i) : i;
};
Ft.prec = function(r, e) {
  if (r !== ~~r || r < 1 || r > Ts)
    throw Error(ks + "precision");
  return Rs(new this.constructor(this), r, e);
};
Ft.round = function(r, e) {
  if (r === Vn) r = 0;
  else if (r !== ~~r || r < -Ts || r > Ts)
    throw Error(Vh);
  return Rs(new this.constructor(this), r + this.e + 1, e);
};
Ft.sqrt = function() {
  var r, e, n, i = this, s = i.constructor, o = i.s, a = i.e, h = new s("0.5");
  if (!i.c[0]) return new s(i);
  if (o < 0)
    throw Error($o + "No square root");
  o = Math.sqrt(+Os(i, !0, !0)), o === 0 || o === 1 / 0 ? (e = i.c.join(""), e.length + a & 1 || (e += "0"), o = Math.sqrt(e), a = ((a + 1) / 2 | 0) - (a < 0 || a & 1), r = new s((o == 1 / 0 ? "5e" : (o = o.toExponential()).slice(0, o.indexOf("e") + 1)) + a)) : r = new s(o + ""), a = r.e + (s.DP += 4);
  do
    n = r, r = h.times(n.plus(i.div(n)));
  while (n.c.slice(0, a).join("") !== r.c.slice(0, a).join(""));
  return Rs(r, (s.DP -= 4) + r.e + 1, s.RM);
};
Ft.times = Ft.mul = function(r) {
  var e, n = this, i = n.constructor, s = n.c, o = (r = new i(r)).c, a = s.length, h = o.length, c = n.e, l = r.e;
  if (r.s = n.s == r.s ? 1 : -1, !s[0] || !o[0])
    return r.c = [r.e = 0], r;
  for (r.e = c + l, a < h && (e = s, s = o, o = e, l = a, a = h, h = l), e = new Array(l = a + h); l--; ) e[l] = 0;
  for (c = h; c--; ) {
    for (h = 0, l = a + c; l > c; )
      h = e[l] + o[c] * s[l - c - 1] + h, e[l--] = h % 10, h = h / 10 | 0;
    e[l] = h;
  }
  for (h ? ++r.e : e.shift(), c = e.length; !e[--c]; ) e.pop();
  return r.c = e, r;
};
Ft.toExponential = function(r, e) {
  var n = this, i = n.c[0];
  if (r !== Vn) {
    if (r !== ~~r || r < 0 || r > Ts)
      throw Error(Vh);
    for (n = Rs(new n.constructor(n), ++r, e); n.c.length < r; ) n.c.push(0);
  }
  return Os(n, !0, !!i);
};
Ft.toFixed = function(r, e) {
  var n = this, i = n.c[0];
  if (r !== Vn) {
    if (r !== ~~r || r < 0 || r > Ts)
      throw Error(Vh);
    for (n = Rs(new n.constructor(n), r + n.e + 1, e), r = r + n.e + 1; n.c.length < r; ) n.c.push(0);
  }
  return Os(n, !1, !!i);
};
Ft.toJSON = Ft.toString = function() {
  var r = this, e = r.constructor;
  return Os(r, r.e <= e.NE || r.e >= e.PE, !!r.c[0]);
};
typeof Symbol < "u" && (Ft[Symbol.for("nodejs.util.inspect.custom")] = Ft.toJSON);
Ft.toNumber = function() {
  var r = +Os(this, !0, !0);
  if (this.constructor.strict === !0 && !this.eq(r.toString()))
    throw Error($o + "Imprecise conversion");
  return r;
};
Ft.toPrecision = function(r, e) {
  var n = this, i = n.constructor, s = n.c[0];
  if (r !== Vn) {
    if (r !== ~~r || r < 1 || r > Ts)
      throw Error(ks + "precision");
    for (n = Rs(new i(n), r, e); n.c.length < r; ) n.c.push(0);
  }
  return Os(n, r <= n.e || n.e <= i.NE || n.e >= i.PE, !!s);
};
Ft.valueOf = function() {
  var r = this, e = r.constructor;
  if (e.strict === !0)
    throw Error($o + "valueOf disallowed");
  return Os(r, r.e <= e.NE || r.e >= e.PE, !0);
};
var oT = Qx(), he = function(r) {
  var e = 1e7, n = 7, i = 9007199254740992, s = d(i), o = "0123456789abcdefghijklmnopqrstuvwxyz", a = typeof BigInt == "function";
  function h(T, C, F, D) {
    return typeof T > "u" ? h[0] : typeof C < "u" ? +C == 10 && !F ? it(T) : Q(T, C, F, D) : it(T);
  }
  function c(T, C) {
    this.value = T, this.sign = C, this.isSmall = !1;
  }
  c.prototype = Object.create(h.prototype);
  function l(T) {
    this.value = T, this.sign = T < 0, this.isSmall = !0;
  }
  l.prototype = Object.create(h.prototype);
  function u(T) {
    this.value = T;
  }
  u.prototype = Object.create(h.prototype);
  function f(T) {
    return -i < T && T < i;
  }
  function d(T) {
    return T < 1e7 ? [T] : T < 1e14 ? [T % 1e7, Math.floor(T / 1e7)] : [T % 1e7, Math.floor(T / 1e7) % 1e7, Math.floor(T / 1e14)];
  }
  function p(T) {
    y(T);
    var C = T.length;
    if (C < 4 && q(T, s) < 0)
      switch (C) {
        case 0:
          return 0;
        case 1:
          return T[0];
        case 2:
          return T[0] + T[1] * e;
        default:
          return T[0] + (T[1] + T[2] * e) * e;
      }
    return T;
  }
  function y(T) {
    for (var C = T.length; T[--C] === 0; ) ;
    T.length = C + 1;
  }
  function x(T) {
    for (var C = new Array(T), F = -1; ++F < T; )
      C[F] = 0;
    return C;
  }
  function m(T) {
    return T > 0 ? Math.floor(T) : Math.ceil(T);
  }
  function g(T, C) {
    var F = T.length, D = C.length, W = new Array(F), V = 0, j = e, Y, Z;
    for (Z = 0; Z < D; Z++)
      Y = T[Z] + C[Z] + V, V = Y >= j ? 1 : 0, W[Z] = Y - V * j;
    for (; Z < F; )
      Y = T[Z] + V, V = Y === j ? 1 : 0, W[Z++] = Y - V * j;
    return V > 0 && W.push(V), W;
  }
  function w(T, C) {
    return T.length >= C.length ? g(T, C) : g(C, T);
  }
  function M(T, C) {
    var F = T.length, D = new Array(F), W = e, V, j;
    for (j = 0; j < F; j++)
      V = T[j] - W + C, C = Math.floor(V / W), D[j] = V - C * W, C += 1;
    for (; C > 0; )
      D[j++] = C % W, C = Math.floor(C / W);
    return D;
  }
  c.prototype.add = function(T) {
    var C = it(T);
    if (this.sign !== C.sign)
      return this.subtract(C.negate());
    var F = this.value, D = C.value;
    return C.isSmall ? new c(M(F, Math.abs(D)), this.sign) : new c(w(F, D), this.sign);
  }, c.prototype.plus = c.prototype.add, l.prototype.add = function(T) {
    var C = it(T), F = this.value;
    if (F < 0 !== C.sign)
      return this.subtract(C.negate());
    var D = C.value;
    if (C.isSmall) {
      if (f(F + D)) return new l(F + D);
      D = d(Math.abs(D));
    }
    return new c(M(D, Math.abs(F)), F < 0);
  }, l.prototype.plus = l.prototype.add, u.prototype.add = function(T) {
    return new u(this.value + it(T).value);
  }, u.prototype.plus = u.prototype.add;
  function S(T, C) {
    var F = T.length, D = C.length, W = new Array(F), V = 0, j = e, Y, Z;
    for (Y = 0; Y < D; Y++)
      Z = T[Y] - V - C[Y], Z < 0 ? (Z += j, V = 1) : V = 0, W[Y] = Z;
    for (Y = D; Y < F; Y++) {
      if (Z = T[Y] - V, Z < 0) Z += j;
      else {
        W[Y++] = Z;
        break;
      }
      W[Y] = Z;
    }
    for (; Y < F; Y++)
      W[Y] = T[Y];
    return y(W), W;
  }
  function E(T, C, F) {
    var D;
    return q(T, C) >= 0 ? D = S(T, C) : (D = S(C, T), F = !F), D = p(D), typeof D == "number" ? (F && (D = -D), new l(D)) : new c(D, F);
  }
  function A(T, C, F) {
    var D = T.length, W = new Array(D), V = -C, j = e, Y, Z;
    for (Y = 0; Y < D; Y++)
      Z = T[Y] + V, V = Math.floor(Z / j), Z %= j, W[Y] = Z < 0 ? Z + j : Z;
    return W = p(W), typeof W == "number" ? (F && (W = -W), new l(W)) : new c(W, F);
  }
  c.prototype.subtract = function(T) {
    var C = it(T);
    if (this.sign !== C.sign)
      return this.add(C.negate());
    var F = this.value, D = C.value;
    return C.isSmall ? A(F, Math.abs(D), this.sign) : E(F, D, this.sign);
  }, c.prototype.minus = c.prototype.subtract, l.prototype.subtract = function(T) {
    var C = it(T), F = this.value;
    if (F < 0 !== C.sign)
      return this.add(C.negate());
    var D = C.value;
    return C.isSmall ? new l(F - D) : A(D, Math.abs(F), F >= 0);
  }, l.prototype.minus = l.prototype.subtract, u.prototype.subtract = function(T) {
    return new u(this.value - it(T).value);
  }, u.prototype.minus = u.prototype.subtract, c.prototype.negate = function() {
    return new c(this.value, !this.sign);
  }, l.prototype.negate = function() {
    var T = this.sign, C = new l(-this.value);
    return C.sign = !T, C;
  }, u.prototype.negate = function() {
    return new u(-this.value);
  }, c.prototype.abs = function() {
    return new c(this.value, !1);
  }, l.prototype.abs = function() {
    return new l(Math.abs(this.value));
  }, u.prototype.abs = function() {
    return new u(this.value >= 0 ? this.value : -this.value);
  };
  function I(T, C) {
    var F = T.length, D = C.length, W = F + D, V = x(W), j = e, Y, Z, mt, Pt, St;
    for (mt = 0; mt < F; ++mt) {
      Pt = T[mt];
      for (var Lt = 0; Lt < D; ++Lt)
        St = C[Lt], Y = Pt * St + V[mt + Lt], Z = Math.floor(Y / j), V[mt + Lt] = Y - Z * j, V[mt + Lt + 1] += Z;
    }
    return y(V), V;
  }
  function b(T, C) {
    var F = T.length, D = new Array(F), W = e, V = 0, j, Y;
    for (Y = 0; Y < F; Y++)
      j = T[Y] * C + V, V = Math.floor(j / W), D[Y] = j - V * W;
    for (; V > 0; )
      D[Y++] = V % W, V = Math.floor(V / W);
    return D;
  }
  function v(T, C) {
    for (var F = []; C-- > 0; ) F.push(0);
    return F.concat(T);
  }
  function _(T, C) {
    var F = Math.max(T.length, C.length);
    if (F <= 30) return I(T, C);
    F = Math.ceil(F / 2);
    var D = T.slice(F), W = T.slice(0, F), V = C.slice(F), j = C.slice(0, F), Y = _(W, j), Z = _(D, V), mt = _(w(W, D), w(j, V)), Pt = w(w(Y, v(S(S(mt, Y), Z), F)), v(Z, 2 * F));
    return y(Pt), Pt;
  }
  function z(T, C) {
    return -0.012 * T - 0.012 * C + 15e-6 * T * C > 0;
  }
  c.prototype.multiply = function(T) {
    var C = it(T), F = this.value, D = C.value, W = this.sign !== C.sign, V;
    if (C.isSmall) {
      if (D === 0) return h[0];
      if (D === 1) return this;
      if (D === -1) return this.negate();
      if (V = Math.abs(D), V < e)
        return new c(b(F, V), W);
      D = d(V);
    }
    return z(F.length, D.length) ? new c(_(F, D), W) : new c(I(F, D), W);
  }, c.prototype.times = c.prototype.multiply;
  function P(T, C, F) {
    return T < e ? new c(b(C, T), F) : new c(I(C, d(T)), F);
  }
  l.prototype._multiplyBySmall = function(T) {
    return f(T.value * this.value) ? new l(T.value * this.value) : P(Math.abs(T.value), d(Math.abs(this.value)), this.sign !== T.sign);
  }, c.prototype._multiplyBySmall = function(T) {
    return T.value === 0 ? h[0] : T.value === 1 ? this : T.value === -1 ? this.negate() : P(Math.abs(T.value), this.value, this.sign !== T.sign);
  }, l.prototype.multiply = function(T) {
    return it(T)._multiplyBySmall(this);
  }, l.prototype.times = l.prototype.multiply, u.prototype.multiply = function(T) {
    return new u(this.value * it(T).value);
  }, u.prototype.times = u.prototype.multiply;
  function k(T) {
    var C = T.length, F = x(C + C), D = e, W, V, j, Y, Z;
    for (j = 0; j < C; j++) {
      Y = T[j], V = 0 - Y * Y;
      for (var mt = j; mt < C; mt++)
        Z = T[mt], W = 2 * (Y * Z) + F[j + mt] + V, V = Math.floor(W / D), F[j + mt] = W - V * D;
      F[j + C] = V;
    }
    return y(F), F;
  }
  c.prototype.square = function() {
    return new c(k(this.value), !1);
  }, l.prototype.square = function() {
    var T = this.value * this.value;
    return f(T) ? new l(T) : new c(k(d(Math.abs(this.value))), !1);
  }, u.prototype.square = function(T) {
    return new u(this.value * this.value);
  };
  function B(T, C) {
    var F = T.length, D = C.length, W = e, V = x(C.length), j = C[D - 1], Y = Math.ceil(W / (2 * j)), Z = b(T, Y), mt = b(C, Y), Pt, St, Lt, Ue, Le, Kh, tc;
    for (Z.length <= F && Z.push(0), mt.push(0), j = mt[D - 1], St = F - D; St >= 0; St--) {
      for (Pt = W - 1, Z[St + D] !== j && (Pt = Math.floor((Z[St + D] * W + Z[St + D - 1]) / j)), Lt = 0, Ue = 0, Kh = mt.length, Le = 0; Le < Kh; Le++)
        Lt += Pt * mt[Le], tc = Math.floor(Lt / W), Ue += Z[St + Le] - (Lt - tc * W), Lt = tc, Ue < 0 ? (Z[St + Le] = Ue + W, Ue = -1) : (Z[St + Le] = Ue, Ue = 0);
      for (; Ue !== 0; ) {
        for (Pt -= 1, Lt = 0, Le = 0; Le < Kh; Le++)
          Lt += Z[St + Le] - W + mt[Le], Lt < 0 ? (Z[St + Le] = Lt + W, Lt = 0) : (Z[St + Le] = Lt, Lt = 1);
        Ue += Lt;
      }
      V[St] = Pt;
    }
    return Z = L(Z, Y)[0], [p(V), p(Z)];
  }
  function R(T, C) {
    for (var F = T.length, D = C.length, W = [], V = [], j = e, Y, Z, mt, Pt, St; F; ) {
      if (V.unshift(T[--F]), y(V), q(V, C) < 0) {
        W.push(0);
        continue;
      }
      Z = V.length, mt = V[Z - 1] * j + V[Z - 2], Pt = C[D - 1] * j + C[D - 2], Z > D && (mt = (mt + 1) * j), Y = Math.ceil(mt / Pt);
      do {
        if (St = b(C, Y), q(St, V) <= 0) break;
        Y--;
      } while (Y);
      W.push(Y), V = S(V, St);
    }
    return W.reverse(), [p(W), p(V)];
  }
  function L(T, C) {
    var F = T.length, D = x(F), W = e, V, j, Y, Z;
    for (Y = 0, V = F - 1; V >= 0; --V)
      Z = Y * W + T[V], j = m(Z / C), Y = Z - j * C, D[V] = j | 0;
    return [D, Y | 0];
  }
  function N(T, C) {
    var F, D = it(C);
    if (a)
      return [new u(T.value / D.value), new u(T.value % D.value)];
    var W = T.value, V = D.value, j;
    if (V === 0) throw new Error("Cannot divide by zero");
    if (T.isSmall)
      return D.isSmall ? [new l(m(W / V)), new l(W % V)] : [h[0], T];
    if (D.isSmall) {
      if (V === 1) return [T, h[0]];
      if (V == -1) return [T.negate(), h[0]];
      var Y = Math.abs(V);
      if (Y < e) {
        F = L(W, Y), j = p(F[0]);
        var Z = F[1];
        return T.sign && (Z = -Z), typeof j == "number" ? (T.sign !== D.sign && (j = -j), [new l(j), new l(Z)]) : [new c(j, T.sign !== D.sign), new l(Z)];
      }
      V = d(Y);
    }
    var mt = q(W, V);
    if (mt === -1) return [h[0], T];
    if (mt === 0) return [h[T.sign === D.sign ? 1 : -1], h[0]];
    W.length + V.length <= 200 ? F = B(W, V) : F = R(W, V), j = F[0];
    var Pt = T.sign !== D.sign, St = F[1], Lt = T.sign;
    return typeof j == "number" ? (Pt && (j = -j), j = new l(j)) : j = new c(j, Pt), typeof St == "number" ? (Lt && (St = -St), St = new l(St)) : St = new c(St, Lt), [j, St];
  }
  c.prototype.divmod = function(T) {
    var C = N(this, T);
    return {
      quotient: C[0],
      remainder: C[1]
    };
  }, u.prototype.divmod = l.prototype.divmod = c.prototype.divmod, c.prototype.divide = function(T) {
    return N(this, T)[0];
  }, u.prototype.over = u.prototype.divide = function(T) {
    return new u(this.value / it(T).value);
  }, l.prototype.over = l.prototype.divide = c.prototype.over = c.prototype.divide, c.prototype.mod = function(T) {
    return N(this, T)[1];
  }, u.prototype.mod = u.prototype.remainder = function(T) {
    return new u(this.value % it(T).value);
  }, l.prototype.remainder = l.prototype.mod = c.prototype.remainder = c.prototype.mod, c.prototype.pow = function(T) {
    var C = it(T), F = this.value, D = C.value, W, V, j;
    if (D === 0) return h[1];
    if (F === 0) return h[0];
    if (F === 1) return h[1];
    if (F === -1) return C.isEven() ? h[1] : h[-1];
    if (C.sign)
      return h[0];
    if (!C.isSmall) throw new Error("The exponent " + C.toString() + " is too large.");
    if (this.isSmall && f(W = Math.pow(F, D)))
      return new l(m(W));
    for (V = this, j = h[1]; D & !0 && (j = j.times(V), --D), D !== 0; )
      D /= 2, V = V.square();
    return j;
  }, l.prototype.pow = c.prototype.pow, u.prototype.pow = function(T) {
    var C = it(T), F = this.value, D = C.value, W = BigInt(0), V = BigInt(1), j = BigInt(2);
    if (D === W) return h[1];
    if (F === W) return h[0];
    if (F === V) return h[1];
    if (F === BigInt(-1)) return C.isEven() ? h[1] : h[-1];
    if (C.isNegative()) return new u(W);
    for (var Y = this, Z = h[1]; (D & V) === V && (Z = Z.times(Y), --D), D !== W; )
      D /= j, Y = Y.square();
    return Z;
  }, c.prototype.modPow = function(T, C) {
    if (T = it(T), C = it(C), C.isZero()) throw new Error("Cannot take modPow with modulus 0");
    var F = h[1], D = this.mod(C);
    for (T.isNegative() && (T = T.multiply(h[-1]), D = D.modInv(C)); T.isPositive(); ) {
      if (D.isZero()) return h[0];
      T.isOdd() && (F = F.multiply(D).mod(C)), T = T.divide(2), D = D.square().mod(C);
    }
    return F;
  }, u.prototype.modPow = l.prototype.modPow = c.prototype.modPow;
  function q(T, C) {
    if (T.length !== C.length)
      return T.length > C.length ? 1 : -1;
    for (var F = T.length - 1; F >= 0; F--)
      if (T[F] !== C[F]) return T[F] > C[F] ? 1 : -1;
    return 0;
  }
  c.prototype.compareAbs = function(T) {
    var C = it(T), F = this.value, D = C.value;
    return C.isSmall ? 1 : q(F, D);
  }, l.prototype.compareAbs = function(T) {
    var C = it(T), F = Math.abs(this.value), D = C.value;
    return C.isSmall ? (D = Math.abs(D), F === D ? 0 : F > D ? 1 : -1) : -1;
  }, u.prototype.compareAbs = function(T) {
    var C = this.value, F = it(T).value;
    return C = C >= 0 ? C : -C, F = F >= 0 ? F : -F, C === F ? 0 : C > F ? 1 : -1;
  }, c.prototype.compare = function(T) {
    if (T === 1 / 0)
      return -1;
    if (T === -1 / 0)
      return 1;
    var C = it(T), F = this.value, D = C.value;
    return this.sign !== C.sign ? C.sign ? 1 : -1 : C.isSmall ? this.sign ? -1 : 1 : q(F, D) * (this.sign ? -1 : 1);
  }, c.prototype.compareTo = c.prototype.compare, l.prototype.compare = function(T) {
    if (T === 1 / 0)
      return -1;
    if (T === -1 / 0)
      return 1;
    var C = it(T), F = this.value, D = C.value;
    return C.isSmall ? F == D ? 0 : F > D ? 1 : -1 : F < 0 !== C.sign ? F < 0 ? -1 : 1 : F < 0 ? 1 : -1;
  }, l.prototype.compareTo = l.prototype.compare, u.prototype.compare = function(T) {
    if (T === 1 / 0)
      return -1;
    if (T === -1 / 0)
      return 1;
    var C = this.value, F = it(T).value;
    return C === F ? 0 : C > F ? 1 : -1;
  }, u.prototype.compareTo = u.prototype.compare, c.prototype.equals = function(T) {
    return this.compare(T) === 0;
  }, u.prototype.eq = u.prototype.equals = l.prototype.eq = l.prototype.equals = c.prototype.eq = c.prototype.equals, c.prototype.notEquals = function(T) {
    return this.compare(T) !== 0;
  }, u.prototype.neq = u.prototype.notEquals = l.prototype.neq = l.prototype.notEquals = c.prototype.neq = c.prototype.notEquals, c.prototype.greater = function(T) {
    return this.compare(T) > 0;
  }, u.prototype.gt = u.prototype.greater = l.prototype.gt = l.prototype.greater = c.prototype.gt = c.prototype.greater, c.prototype.lesser = function(T) {
    return this.compare(T) < 0;
  }, u.prototype.lt = u.prototype.lesser = l.prototype.lt = l.prototype.lesser = c.prototype.lt = c.prototype.lesser, c.prototype.greaterOrEquals = function(T) {
    return this.compare(T) >= 0;
  }, u.prototype.geq = u.prototype.greaterOrEquals = l.prototype.geq = l.prototype.greaterOrEquals = c.prototype.geq = c.prototype.greaterOrEquals, c.prototype.lesserOrEquals = function(T) {
    return this.compare(T) <= 0;
  }, u.prototype.leq = u.prototype.lesserOrEquals = l.prototype.leq = l.prototype.lesserOrEquals = c.prototype.leq = c.prototype.lesserOrEquals, c.prototype.isEven = function() {
    return (this.value[0] & 1) === 0;
  }, l.prototype.isEven = function() {
    return (this.value & 1) === 0;
  }, u.prototype.isEven = function() {
    return (this.value & BigInt(1)) === BigInt(0);
  }, c.prototype.isOdd = function() {
    return (this.value[0] & 1) === 1;
  }, l.prototype.isOdd = function() {
    return (this.value & 1) === 1;
  }, u.prototype.isOdd = function() {
    return (this.value & BigInt(1)) === BigInt(1);
  }, c.prototype.isPositive = function() {
    return !this.sign;
  }, l.prototype.isPositive = function() {
    return this.value > 0;
  }, u.prototype.isPositive = l.prototype.isPositive, c.prototype.isNegative = function() {
    return this.sign;
  }, l.prototype.isNegative = function() {
    return this.value < 0;
  }, u.prototype.isNegative = l.prototype.isNegative, c.prototype.isUnit = function() {
    return !1;
  }, l.prototype.isUnit = function() {
    return Math.abs(this.value) === 1;
  }, u.prototype.isUnit = function() {
    return this.abs().value === BigInt(1);
  }, c.prototype.isZero = function() {
    return !1;
  }, l.prototype.isZero = function() {
    return this.value === 0;
  }, u.prototype.isZero = function() {
    return this.value === BigInt(0);
  }, c.prototype.isDivisibleBy = function(T) {
    var C = it(T);
    return C.isZero() ? !1 : C.isUnit() ? !0 : C.compareAbs(2) === 0 ? this.isEven() : this.mod(C).isZero();
  }, u.prototype.isDivisibleBy = l.prototype.isDivisibleBy = c.prototype.isDivisibleBy;
  function U(T) {
    var C = T.abs();
    if (C.isUnit()) return !1;
    if (C.equals(2) || C.equals(3) || C.equals(5)) return !0;
    if (C.isEven() || C.isDivisibleBy(3) || C.isDivisibleBy(5)) return !1;
    if (C.lesser(49)) return !0;
  }
  function J(T, C) {
    for (var F = T.prev(), D = F, W = 0, V, j, Y; D.isEven(); ) D = D.divide(2), W++;
    t: for (j = 0; j < C.length; j++)
      if (!T.lesser(C[j]) && (Y = he(C[j]).modPow(D, T), !(Y.isUnit() || Y.equals(F)))) {
        for (V = W - 1; V != 0; V--) {
          if (Y = Y.square().mod(T), Y.isUnit()) return !1;
          if (Y.equals(F)) continue t;
        }
        return !1;
      }
    return !0;
  }
  c.prototype.isPrime = function(T) {
    var C = U(this);
    if (C !== r) return C;
    var F = this.abs(), D = F.bitLength();
    if (D <= 64)
      return J(F, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
    for (var W = Math.log(2) * D.toJSNumber(), V = Math.ceil(T === !0 ? 2 * Math.pow(W, 2) : W), j = [], Y = 0; Y < V; Y++)
      j.push(he(Y + 2));
    return J(F, j);
  }, u.prototype.isPrime = l.prototype.isPrime = c.prototype.isPrime, c.prototype.isProbablePrime = function(T, C) {
    var F = U(this);
    if (F !== r) return F;
    for (var D = this.abs(), W = T === r ? 5 : T, V = [], j = 0; j < W; j++)
      V.push(he.randBetween(2, D.minus(2), C));
    return J(D, V);
  }, u.prototype.isProbablePrime = l.prototype.isProbablePrime = c.prototype.isProbablePrime, c.prototype.modInv = function(T) {
    for (var C = he.zero, F = he.one, D = it(T), W = this.abs(), V, j, Y; !W.isZero(); )
      V = D.divide(W), j = C, Y = D, C = F, D = W, F = j.subtract(V.multiply(F)), W = Y.subtract(V.multiply(W));
    if (!D.isUnit()) throw new Error(this.toString() + " and " + T.toString() + " are not co-prime");
    return C.compare(0) === -1 && (C = C.add(T)), this.isNegative() ? C.negate() : C;
  }, u.prototype.modInv = l.prototype.modInv = c.prototype.modInv, c.prototype.next = function() {
    var T = this.value;
    return this.sign ? A(T, 1, this.sign) : new c(M(T, 1), this.sign);
  }, l.prototype.next = function() {
    var T = this.value;
    return T + 1 < i ? new l(T + 1) : new c(s, !1);
  }, u.prototype.next = function() {
    return new u(this.value + BigInt(1));
  }, c.prototype.prev = function() {
    var T = this.value;
    return this.sign ? new c(M(T, 1), !0) : A(T, 1, this.sign);
  }, l.prototype.prev = function() {
    var T = this.value;
    return T - 1 > -i ? new l(T - 1) : new c(s, !0);
  }, u.prototype.prev = function() {
    return new u(this.value - BigInt(1));
  };
  for (var X = [1]; 2 * X[X.length - 1] <= e; ) X.push(2 * X[X.length - 1]);
  var lt = X.length, ot = X[lt - 1];
  function ut(T) {
    return Math.abs(T) <= e;
  }
  c.prototype.shiftLeft = function(T) {
    var C = it(T).toJSNumber();
    if (!ut(C))
      throw new Error(String(C) + " is too large for shifting.");
    if (C < 0) return this.shiftRight(-C);
    var F = this;
    if (F.isZero()) return F;
    for (; C >= lt; )
      F = F.multiply(ot), C -= lt - 1;
    return F.multiply(X[C]);
  }, u.prototype.shiftLeft = l.prototype.shiftLeft = c.prototype.shiftLeft, c.prototype.shiftRight = function(T) {
    var C, F = it(T).toJSNumber();
    if (!ut(F))
      throw new Error(String(F) + " is too large for shifting.");
    if (F < 0) return this.shiftLeft(-F);
    for (var D = this; F >= lt; ) {
      if (D.isZero() || D.isNegative() && D.isUnit()) return D;
      C = N(D, ot), D = C[1].isNegative() ? C[0].prev() : C[0], F -= lt - 1;
    }
    return C = N(D, X[F]), C[1].isNegative() ? C[0].prev() : C[0];
  }, u.prototype.shiftRight = l.prototype.shiftRight = c.prototype.shiftRight;
  function ct(T, C, F) {
    C = it(C);
    for (var D = T.isNegative(), W = C.isNegative(), V = D ? T.not() : T, j = W ? C.not() : C, Y = 0, Z = 0, mt = null, Pt = null, St = []; !V.isZero() || !j.isZero(); )
      mt = N(V, ot), Y = mt[1].toJSNumber(), D && (Y = ot - 1 - Y), Pt = N(j, ot), Z = Pt[1].toJSNumber(), W && (Z = ot - 1 - Z), V = mt[0], j = Pt[0], St.push(F(Y, Z));
    for (var Lt = F(D ? 1 : 0, W ? 1 : 0) !== 0 ? he(-1) : he(0), Ue = St.length - 1; Ue >= 0; Ue -= 1)
      Lt = Lt.multiply(ot).add(he(St[Ue]));
    return Lt;
  }
  c.prototype.not = function() {
    return this.negate().prev();
  }, u.prototype.not = l.prototype.not = c.prototype.not, c.prototype.and = function(T) {
    return ct(this, T, function(C, F) {
      return C & F;
    });
  }, u.prototype.and = l.prototype.and = c.prototype.and, c.prototype.or = function(T) {
    return ct(this, T, function(C, F) {
      return C | F;
    });
  }, u.prototype.or = l.prototype.or = c.prototype.or, c.prototype.xor = function(T) {
    return ct(this, T, function(C, F) {
      return C ^ F;
    });
  }, u.prototype.xor = l.prototype.xor = c.prototype.xor;
  var gt = 1 << 30, Nt = (e & -e) * (e & -e) | gt;
  function ne(T) {
    var C = T.value, F = typeof C == "number" ? C | gt : typeof C == "bigint" ? C | BigInt(gt) : C[0] + C[1] * e | Nt;
    return F & -F;
  }
  function Qt(T, C) {
    if (C.compareTo(T) <= 0) {
      var F = Qt(T, C.square(C)), D = F.p, W = F.e, V = D.multiply(C);
      return V.compareTo(T) <= 0 ? { p: V, e: W * 2 + 1 } : { p: D, e: W * 2 };
    }
    return { p: he(1), e: 0 };
  }
  c.prototype.bitLength = function() {
    var T = this;
    return T.compareTo(he(0)) < 0 && (T = T.negate().subtract(he(1))), T.compareTo(he(0)) === 0 ? he(0) : he(Qt(T, he(2)).e).add(he(1));
  }, u.prototype.bitLength = l.prototype.bitLength = c.prototype.bitLength;
  function Oe(T, C) {
    return T = it(T), C = it(C), T.greater(C) ? T : C;
  }
  function xe(T, C) {
    return T = it(T), C = it(C), T.lesser(C) ? T : C;
  }
  function re(T, C) {
    if (T = it(T).abs(), C = it(C).abs(), T.equals(C)) return T;
    if (T.isZero()) return C;
    if (C.isZero()) return T;
    for (var F = h[1], D, W; T.isEven() && C.isEven(); )
      D = xe(ne(T), ne(C)), T = T.divide(D), C = C.divide(D), F = F.multiply(D);
    for (; T.isEven(); )
      T = T.divide(ne(T));
    do {
      for (; C.isEven(); )
        C = C.divide(ne(C));
      T.greater(C) && (W = C, C = T, T = W), C = C.subtract(T);
    } while (!C.isZero());
    return F.isUnit() ? T : T.multiply(F);
  }
  function Ut(T, C) {
    return T = it(T).abs(), C = it(C).abs(), T.divide(re(T, C)).multiply(C);
  }
  function G(T, C, F) {
    T = it(T), C = it(C);
    var D = F || Math.random, W = xe(T, C), V = Oe(T, C), j = V.subtract(W).add(1);
    if (j.isSmall) return W.add(Math.floor(D() * j));
    for (var Y = at(j, e).value, Z = [], mt = !0, Pt = 0; Pt < Y.length; Pt++) {
      var St = mt ? Y[Pt] + (Pt + 1 < Y.length ? Y[Pt + 1] / e : 0) : e, Lt = m(D() * St);
      Z.push(Lt), Lt < Y[Pt] && (mt = !1);
    }
    return W.add(h.fromArray(Z, e, !1));
  }
  var Q = function(T, C, F, D) {
    F = F || o, T = String(T), D || (T = T.toLowerCase(), F = F.toLowerCase());
    var W = T.length, V, j = Math.abs(C), Y = {};
    for (V = 0; V < F.length; V++)
      Y[F[V]] = V;
    for (V = 0; V < W; V++) {
      var Z = T[V];
      if (Z !== "-" && Z in Y && Y[Z] >= j) {
        if (Z === "1" && j === 1) continue;
        throw new Error(Z + " is not a valid digit in base " + C + ".");
      }
    }
    C = it(C);
    var mt = [], Pt = T[0] === "-";
    for (V = Pt ? 1 : 0; V < T.length; V++) {
      var Z = T[V];
      if (Z in Y) mt.push(it(Y[Z]));
      else if (Z === "<") {
        var St = V;
        do
          V++;
        while (T[V] !== ">" && V < T.length);
        mt.push(it(T.slice(St + 1, V)));
      } else throw new Error(Z + " is not a valid character");
    }
    return st(mt, C, Pt);
  };
  function st(T, C, F) {
    var D = h[0], W = h[1], V;
    for (V = T.length - 1; V >= 0; V--)
      D = D.add(T[V].times(W)), W = W.times(C);
    return F ? D.negate() : D;
  }
  function ft(T, C) {
    return C = C || o, T < C.length ? C[T] : "<" + T + ">";
  }
  function at(T, C) {
    if (C = he(C), C.isZero()) {
      if (T.isZero()) return { value: [0], isNegative: !1 };
      throw new Error("Cannot convert nonzero numbers to base 0.");
    }
    if (C.equals(-1)) {
      if (T.isZero()) return { value: [0], isNegative: !1 };
      if (T.isNegative())
        return {
          value: [].concat.apply(
            [],
            Array.apply(null, Array(-T.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
          ),
          isNegative: !1
        };
      var F = Array.apply(null, Array(T.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
      return F.unshift([1]), {
        value: [].concat.apply([], F),
        isNegative: !1
      };
    }
    var D = !1;
    if (T.isNegative() && C.isPositive() && (D = !0, T = T.abs()), C.isUnit())
      return T.isZero() ? { value: [0], isNegative: !1 } : {
        value: Array.apply(null, Array(T.toJSNumber())).map(Number.prototype.valueOf, 1),
        isNegative: D
      };
    for (var W = [], V = T, j; V.isNegative() || V.compareAbs(C) >= 0; ) {
      j = V.divmod(C), V = j.quotient;
      var Y = j.remainder;
      Y.isNegative() && (Y = C.minus(Y).abs(), V = V.next()), W.push(Y.toJSNumber());
    }
    return W.push(V.toJSNumber()), { value: W.reverse(), isNegative: D };
  }
  function Ct(T, C, F) {
    var D = at(T, C);
    return (D.isNegative ? "-" : "") + D.value.map(function(W) {
      return ft(W, F);
    }).join("");
  }
  c.prototype.toArray = function(T) {
    return at(this, T);
  }, l.prototype.toArray = function(T) {
    return at(this, T);
  }, u.prototype.toArray = function(T) {
    return at(this, T);
  }, c.prototype.toString = function(T, C) {
    if (T === r && (T = 10), T !== 10 || C) return Ct(this, T, C);
    for (var F = this.value, D = F.length, W = String(F[--D]), V = "0000000", j; --D >= 0; )
      j = String(F[D]), W += V.slice(j.length) + j;
    var Y = this.sign ? "-" : "";
    return Y + W;
  }, l.prototype.toString = function(T, C) {
    return T === r && (T = 10), T != 10 || C ? Ct(this, T, C) : String(this.value);
  }, u.prototype.toString = l.prototype.toString, u.prototype.toJSON = c.prototype.toJSON = l.prototype.toJSON = function() {
    return this.toString();
  }, c.prototype.valueOf = function() {
    return parseInt(this.toString(), 10);
  }, c.prototype.toJSNumber = c.prototype.valueOf, l.prototype.valueOf = function() {
    return this.value;
  }, l.prototype.toJSNumber = l.prototype.valueOf, u.prototype.valueOf = u.prototype.toJSNumber = function() {
    return parseInt(this.toString(), 10);
  };
  function _t(T) {
    if (f(+T)) {
      var C = +T;
      if (C === m(C))
        return a ? new u(BigInt(C)) : new l(C);
      throw new Error("Invalid integer: " + T);
    }
    var F = T[0] === "-";
    F && (T = T.slice(1));
    var D = T.split(/e/i);
    if (D.length > 2) throw new Error("Invalid integer: " + D.join("e"));
    if (D.length === 2) {
      var W = D[1];
      if (W[0] === "+" && (W = W.slice(1)), W = +W, W !== m(W) || !f(W)) throw new Error("Invalid integer: " + W + " is not a valid exponent.");
      var V = D[0], j = V.indexOf(".");
      if (j >= 0 && (W -= V.length - j - 1, V = V.slice(0, j) + V.slice(j + 1)), W < 0) throw new Error("Cannot include negative exponent part for integers");
      V += new Array(W + 1).join("0"), T = V;
    }
    var Y = /^([0-9][0-9]*)$/.test(T);
    if (!Y) throw new Error("Invalid integer: " + T);
    if (a)
      return new u(BigInt(F ? "-" + T : T));
    for (var Z = [], mt = T.length, Pt = n, St = mt - Pt; mt > 0; )
      Z.push(+T.slice(St, mt)), St -= Pt, St < 0 && (St = 0), mt -= Pt;
    return y(Z), new c(Z, F);
  }
  function Vt(T) {
    if (a)
      return new u(BigInt(T));
    if (f(T)) {
      if (T !== m(T)) throw new Error(T + " is not an integer.");
      return new l(T);
    }
    return _t(T.toString());
  }
  function it(T) {
    return typeof T == "number" ? Vt(T) : typeof T == "string" ? _t(T) : typeof T == "bigint" ? new u(T) : T;
  }
  for (var Dt = 0; Dt < 1e3; Dt++)
    h[Dt] = it(Dt), Dt > 0 && (h[-Dt] = it(-Dt));
  return h.one = h[1], h.zero = h[0], h.minusOne = h[-1], h.max = Oe, h.min = xe, h.gcd = re, h.lcm = Ut, h.isInstance = function(T) {
    return T instanceof c || T instanceof l || T instanceof u;
  }, h.randBetween = G, h.fromArray = function(T, C, F) {
    return st(T.map(it), it(C || 10), F);
  }, h;
}();
function aT(r, e, n = 2) {
  const i = e && e.length, s = i ? e[0] * n : r.length;
  let o = Kx(r, 0, s, n, !0);
  const a = [];
  if (!o || o.next === o.prev) return a;
  let h, c, l;
  if (i && (o = fT(r, e, o, n)), r.length > 80 * n) {
    h = 1 / 0, c = 1 / 0;
    let u = -1 / 0, f = -1 / 0;
    for (let d = n; d < s; d += n) {
      const p = r[d], y = r[d + 1];
      p < h && (h = p), y < c && (c = y), p > u && (u = p), y > f && (f = y);
    }
    l = Math.max(u - h, f - c), l = l !== 0 ? 32767 / l : 0;
  }
  return So(o, a, n, h, c, l, 0), a;
}
function Kx(r, e, n, i, s) {
  let o;
  if (s === Hl(r, e, n, i) > 0)
    for (let a = e; a < n; a += i) o = pp(a / i | 0, r[a], r[a + 1], o);
  else
    for (let a = n - i; a >= e; a -= i) o = pp(a / i | 0, r[a], r[a + 1], o);
  return o && Sr(o, o.next) && (Eo(o), o = o.next), o;
}
function Es(r, e) {
  if (!r) return r;
  e || (e = r);
  let n = r, i;
  do
    if (i = !1, !n.steiner && (Sr(n, n.next) || Ht(n.prev, n, n.next) === 0)) {
      if (Eo(n), n = e = n.prev, n === n.next) break;
      i = !0;
    } else
      n = n.next;
  while (i || n !== e);
  return e;
}
function So(r, e, n, i, s, o, a) {
  if (!r) return;
  !a && o && mT(r, i, s, o);
  let h = r;
  for (; r.prev !== r.next; ) {
    const c = r.prev, l = r.next;
    if (o ? cT(r, i, s, o) : hT(r)) {
      e.push(c.i, r.i, l.i), Eo(r), r = l.next, h = l.next;
      continue;
    }
    if (r = l, r === h) {
      a ? a === 1 ? (r = lT(Es(r), e), So(r, e, n, i, s, o, 2)) : a === 2 && uT(r, e, n, i, s, o) : So(Es(r), e, n, i, s, o, 1);
      break;
    }
  }
}
function hT(r) {
  const e = r.prev, n = r, i = r.next;
  if (Ht(e, n, i) >= 0) return !1;
  const s = e.x, o = n.x, a = i.x, h = e.y, c = n.y, l = i.y, u = Math.min(s, o, a), f = Math.min(h, c, l), d = Math.max(s, o, a), p = Math.max(h, c, l);
  let y = i.next;
  for (; y !== e; ) {
    if (y.x >= u && y.x <= d && y.y >= f && y.y <= p && Kr(s, h, o, c, a, l, y.x, y.y) && Ht(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function cT(r, e, n, i) {
  const s = r.prev, o = r, a = r.next;
  if (Ht(s, o, a) >= 0) return !1;
  const h = s.x, c = o.x, l = a.x, u = s.y, f = o.y, d = a.y, p = Math.min(h, c, l), y = Math.min(u, f, d), x = Math.max(h, c, l), m = Math.max(u, f, d), g = jl(p, y, e, n, i), w = jl(x, m, e, n, i);
  let M = r.prevZ, S = r.nextZ;
  for (; M && M.z >= g && S && S.z <= w; ) {
    if (M.x >= p && M.x <= x && M.y >= y && M.y <= m && M !== s && M !== a && Kr(h, u, c, f, l, d, M.x, M.y) && Ht(M.prev, M, M.next) >= 0 || (M = M.prevZ, S.x >= p && S.x <= x && S.y >= y && S.y <= m && S !== s && S !== a && Kr(h, u, c, f, l, d, S.x, S.y) && Ht(S.prev, S, S.next) >= 0)) return !1;
    S = S.nextZ;
  }
  for (; M && M.z >= g; ) {
    if (M.x >= p && M.x <= x && M.y >= y && M.y <= m && M !== s && M !== a && Kr(h, u, c, f, l, d, M.x, M.y) && Ht(M.prev, M, M.next) >= 0) return !1;
    M = M.prevZ;
  }
  for (; S && S.z <= w; ) {
    if (S.x >= p && S.x <= x && S.y >= y && S.y <= m && S !== s && S !== a && Kr(h, u, c, f, l, d, S.x, S.y) && Ht(S.prev, S, S.next) >= 0) return !1;
    S = S.nextZ;
  }
  return !0;
}
function lT(r, e) {
  let n = r;
  do {
    const i = n.prev, s = n.next.next;
    !Sr(i, s) && em(i, n, n.next, s) && To(i, s) && To(s, i) && (e.push(i.i, n.i, s.i), Eo(n), Eo(n.next), n = r = s), n = n.next;
  } while (n !== r);
  return Es(n);
}
function uT(r, e, n, i, s, o) {
  let a = r;
  do {
    let h = a.next.next;
    for (; h !== a.prev; ) {
      if (a.i !== h.i && bT(a, h)) {
        let c = nm(a, h);
        a = Es(a, a.next), c = Es(c, c.next), So(a, e, n, i, s, o, 0), So(c, e, n, i, s, o, 0);
        return;
      }
      h = h.next;
    }
    a = a.next;
  } while (a !== r);
}
function fT(r, e, n, i) {
  const s = [];
  for (let o = 0, a = e.length; o < a; o++) {
    const h = e[o] * i, c = o < a - 1 ? e[o + 1] * i : r.length, l = Kx(r, h, c, i, !1);
    l === l.next && (l.steiner = !0), s.push(wT(l));
  }
  s.sort(dT);
  for (let o = 0; o < s.length; o++)
    n = pT(s[o], n);
  return n;
}
function dT(r, e) {
  let n = r.x - e.x;
  if (n === 0 && (n = r.y - e.y, n === 0)) {
    const i = (r.next.y - r.y) / (r.next.x - r.x), s = (e.next.y - e.y) / (e.next.x - e.x);
    n = i - s;
  }
  return n;
}
function pT(r, e) {
  const n = yT(r, e);
  if (!n)
    return e;
  const i = nm(n, r);
  return Es(i, i.next), Es(n, n.next);
}
function yT(r, e) {
  let n = e;
  const i = r.x, s = r.y;
  let o = -1 / 0, a;
  if (Sr(r, n)) return n;
  do {
    if (Sr(r, n.next)) return n.next;
    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
      const f = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (f <= i && f > o && (o = f, a = n.x < n.next.x ? n : n.next, f === i))
        return a;
    }
    n = n.next;
  } while (n !== e);
  if (!a) return null;
  const h = a, c = a.x, l = a.y;
  let u = 1 / 0;
  n = a;
  do {
    if (i >= n.x && n.x >= c && i !== n.x && tm(s < l ? i : o, s, c, l, s < l ? o : i, s, n.x, n.y)) {
      const f = Math.abs(s - n.y) / (i - n.x);
      To(n, r) && (f < u || f === u && (n.x > a.x || n.x === a.x && xT(a, n))) && (a = n, u = f);
    }
    n = n.next;
  } while (n !== h);
  return a;
}
function xT(r, e) {
  return Ht(r.prev, r, e.prev) < 0 && Ht(e.next, r, r.next) < 0;
}
function mT(r, e, n, i) {
  let s = r;
  do
    s.z === 0 && (s.z = jl(s.x, s.y, e, n, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== r);
  s.prevZ.nextZ = null, s.prevZ = null, gT(s);
}
function gT(r) {
  let e, n = 1;
  do {
    let i = r, s;
    r = null;
    let o = null;
    for (e = 0; i; ) {
      e++;
      let a = i, h = 0;
      for (let l = 0; l < n && (h++, a = a.nextZ, !!a); l++)
        ;
      let c = n;
      for (; h > 0 || c > 0 && a; )
        h !== 0 && (c === 0 || !a || i.z <= a.z) ? (s = i, i = i.nextZ, h--) : (s = a, a = a.nextZ, c--), o ? o.nextZ = s : r = s, s.prevZ = o, o = s;
      i = a;
    }
    o.nextZ = null, n *= 2;
  } while (e > 1);
  return r;
}
function jl(r, e, n, i, s) {
  return r = (r - n) * s | 0, e = (e - i) * s | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
}
function wT(r) {
  let e = r, n = r;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== r);
  return n;
}
function tm(r, e, n, i, s, o, a, h) {
  return (s - a) * (e - h) >= (r - a) * (o - h) && (r - a) * (i - h) >= (n - a) * (e - h) && (n - a) * (o - h) >= (s - a) * (i - h);
}
function Kr(r, e, n, i, s, o, a, h) {
  return !(r === a && e === h) && tm(r, e, n, i, s, o, a, h);
}
function bT(r, e) {
  return r.next.i !== e.i && r.prev.i !== e.i && !vT(r, e) && // doesn't intersect other edges
  (To(r, e) && To(e, r) && MT(r, e) && // locally visible
  (Ht(r.prev, r, e.prev) || Ht(r, e.prev, e)) || // does not create opposite-facing sectors
  Sr(r, e) && Ht(r.prev, r, r.next) > 0 && Ht(e.prev, e, e.next) > 0);
}
function Ht(r, e, n) {
  return (e.y - r.y) * (n.x - e.x) - (e.x - r.x) * (n.y - e.y);
}
function Sr(r, e) {
  return r.x === e.x && r.y === e.y;
}
function em(r, e, n, i) {
  const s = ma(Ht(r, e, n)), o = ma(Ht(r, e, i)), a = ma(Ht(n, i, r)), h = ma(Ht(n, i, e));
  return !!(s !== o && a !== h || s === 0 && xa(r, n, e) || o === 0 && xa(r, i, e) || a === 0 && xa(n, r, i) || h === 0 && xa(n, e, i));
}
function xa(r, e, n) {
  return e.x <= Math.max(r.x, n.x) && e.x >= Math.min(r.x, n.x) && e.y <= Math.max(r.y, n.y) && e.y >= Math.min(r.y, n.y);
}
function ma(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function vT(r, e) {
  let n = r;
  do {
    if (n.i !== r.i && n.next.i !== r.i && n.i !== e.i && n.next.i !== e.i && em(n, n.next, r, e)) return !0;
    n = n.next;
  } while (n !== r);
  return !1;
}
function To(r, e) {
  return Ht(r.prev, r, r.next) < 0 ? Ht(r, e, r.next) >= 0 && Ht(r, r.prev, e) >= 0 : Ht(r, e, r.prev) < 0 || Ht(r, r.next, e) < 0;
}
function MT(r, e) {
  let n = r, i = !1;
  const s = (r.x + e.x) / 2, o = (r.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && s < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
  while (n !== r);
  return i;
}
function nm(r, e) {
  const n = Yl(r.i, r.x, r.y), i = Yl(e.i, e.x, e.y), s = r.next, o = e.prev;
  return r.next = e, e.prev = r, n.next = s, s.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
}
function pp(r, e, n, i) {
  const s = Yl(r, e, n);
  return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s;
}
function Eo(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function Yl(r, e, n) {
  return {
    i: r,
    // vertex index in coordinates array
    x: e,
    y: n,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function _T(r, e, n, i) {
  const s = e && e.length, o = s ? e[0] * n : r.length;
  let a = Math.abs(Hl(r, 0, o, n));
  if (s)
    for (let c = 0, l = e.length; c < l; c++) {
      const u = e[c] * n, f = c < l - 1 ? e[c + 1] * n : r.length;
      a -= Math.abs(Hl(r, u, f, n));
    }
  let h = 0;
  for (let c = 0; c < i.length; c += 3) {
    const l = i[c] * n, u = i[c + 1] * n, f = i[c + 2] * n;
    h += Math.abs(
      (r[l] - r[f]) * (r[u + 1] - r[l + 1]) - (r[l] - r[u]) * (r[f + 1] - r[l + 1])
    );
  }
  return a === 0 && h === 0 ? 0 : Math.abs((h - a) / a);
}
function Hl(r, e, n, i) {
  let s = 0;
  for (let o = e, a = n - i; o < n; o += i)
    s += (r[a] - r[o]) * (r[o + 1] + r[a + 1]), a = o;
  return s;
}
function ST(r) {
  const e = [], n = [], i = r[0][0].length;
  let s = 0, o = 0;
  for (const a of r) {
    for (const h of a)
      for (let c = 0; c < i; c++) e.push(h[c]);
    o && (s += o, n.push(s)), o = a.length;
  }
  return { vertices: e, holes: n, dimensions: i };
}
const hi = 11102230246251565e-32, me = 134217729, TT = (3 + 8 * hi) * hi;
function Ic(r, e, n, i, s) {
  let o, a, h, c, l = e[0], u = i[0], f = 0, d = 0;
  u > l == u > -l ? (o = l, l = e[++f]) : (o = u, u = i[++d]);
  let p = 0;
  if (f < r && d < n)
    for (u > l == u > -l ? (a = l + o, h = o - (a - l), l = e[++f]) : (a = u + o, h = o - (a - u), u = i[++d]), o = a, h !== 0 && (s[p++] = h); f < r && d < n; )
      u > l == u > -l ? (a = o + l, c = a - o, h = o - (a - c) + (l - c), l = e[++f]) : (a = o + u, c = a - o, h = o - (a - c) + (u - c), u = i[++d]), o = a, h !== 0 && (s[p++] = h);
  for (; f < r; )
    a = o + l, c = a - o, h = o - (a - c) + (l - c), l = e[++f], o = a, h !== 0 && (s[p++] = h);
  for (; d < n; )
    a = o + u, c = a - o, h = o - (a - c) + (u - c), u = i[++d], o = a, h !== 0 && (s[p++] = h);
  return (o !== 0 || p === 0) && (s[p++] = o), p;
}
function ET(r, e) {
  let n = e[0];
  for (let i = 1; i < r; i++) n += e[i];
  return n;
}
function Vo(r) {
  return new Float64Array(r);
}
const zT = (3 + 16 * hi) * hi, AT = (2 + 12 * hi) * hi, CT = (9 + 64 * hi) * hi * hi, Vs = Vo(4), yp = Vo(8), xp = Vo(12), mp = Vo(16), ve = Vo(4);
function PT(r, e, n, i, s, o, a) {
  let h, c, l, u, f, d, p, y, x, m, g, w, M, S, E, A, I, b;
  const v = r - s, _ = n - s, z = e - o, P = i - o;
  S = v * P, d = me * v, p = d - (d - v), y = v - p, d = me * P, x = d - (d - P), m = P - x, E = y * m - (S - p * x - y * x - p * m), A = z * _, d = me * z, p = d - (d - z), y = z - p, d = me * _, x = d - (d - _), m = _ - x, I = y * m - (A - p * x - y * x - p * m), g = E - I, f = E - g, Vs[0] = E - (g + f) + (f - I), w = S + g, f = w - S, M = S - (w - f) + (g - f), g = M - A, f = M - g, Vs[1] = M - (g + f) + (f - A), b = w + g, f = b - w, Vs[2] = w - (b - f) + (g - f), Vs[3] = b;
  let k = ET(4, Vs), B = AT * a;
  if (k >= B || -k >= B || (f = r - v, h = r - (v + f) + (f - s), f = n - _, l = n - (_ + f) + (f - s), f = e - z, c = e - (z + f) + (f - o), f = i - P, u = i - (P + f) + (f - o), h === 0 && c === 0 && l === 0 && u === 0) || (B = CT * a + TT * Math.abs(k), k += v * u + P * h - (z * l + _ * c), k >= B || -k >= B)) return k;
  S = h * P, d = me * h, p = d - (d - h), y = h - p, d = me * P, x = d - (d - P), m = P - x, E = y * m - (S - p * x - y * x - p * m), A = c * _, d = me * c, p = d - (d - c), y = c - p, d = me * _, x = d - (d - _), m = _ - x, I = y * m - (A - p * x - y * x - p * m), g = E - I, f = E - g, ve[0] = E - (g + f) + (f - I), w = S + g, f = w - S, M = S - (w - f) + (g - f), g = M - A, f = M - g, ve[1] = M - (g + f) + (f - A), b = w + g, f = b - w, ve[2] = w - (b - f) + (g - f), ve[3] = b;
  const R = Ic(4, Vs, 4, ve, yp);
  S = v * u, d = me * v, p = d - (d - v), y = v - p, d = me * u, x = d - (d - u), m = u - x, E = y * m - (S - p * x - y * x - p * m), A = z * l, d = me * z, p = d - (d - z), y = z - p, d = me * l, x = d - (d - l), m = l - x, I = y * m - (A - p * x - y * x - p * m), g = E - I, f = E - g, ve[0] = E - (g + f) + (f - I), w = S + g, f = w - S, M = S - (w - f) + (g - f), g = M - A, f = M - g, ve[1] = M - (g + f) + (f - A), b = w + g, f = b - w, ve[2] = w - (b - f) + (g - f), ve[3] = b;
  const L = Ic(R, yp, 4, ve, xp);
  S = h * u, d = me * h, p = d - (d - h), y = h - p, d = me * u, x = d - (d - u), m = u - x, E = y * m - (S - p * x - y * x - p * m), A = c * l, d = me * c, p = d - (d - c), y = c - p, d = me * l, x = d - (d - l), m = l - x, I = y * m - (A - p * x - y * x - p * m), g = E - I, f = E - g, ve[0] = E - (g + f) + (f - I), w = S + g, f = w - S, M = S - (w - f) + (g - f), g = M - A, f = M - g, ve[1] = M - (g + f) + (f - A), b = w + g, f = b - w, ve[2] = w - (b - f) + (g - f), ve[3] = b;
  const N = Ic(L, xp, 4, ve, mp);
  return mp[N - 1];
}
function ga(r, e, n, i, s, o) {
  const a = (e - o) * (n - s), h = (r - s) * (i - o), c = a - h, l = Math.abs(a + h);
  return Math.abs(c) >= zT * l ? c : -PT(r, e, n, i, s, o, l);
}
const gp = Math.pow(2, -52), wa = new Uint32Array(512);
class ju {
  static from(e, n = LT, i = BT) {
    const s = e.length, o = new Float64Array(s * 2);
    for (let a = 0; a < s; a++) {
      const h = e[a];
      o[2 * a] = n(h), o[2 * a + 1] = i(h);
    }
    return new ju(o);
  }
  constructor(e) {
    const n = e.length >> 1;
    if (n > 0 && typeof e[0] != "number") throw new Error("Expected coords to contain numbers.");
    this.coords = e;
    const i = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
  }
  update() {
    const { coords: e, _hullPrev: n, _hullNext: i, _hullTri: s, _hullHash: o } = this, a = e.length >> 1;
    let h = 1 / 0, c = 1 / 0, l = -1 / 0, u = -1 / 0;
    for (let v = 0; v < a; v++) {
      const _ = e[2 * v], z = e[2 * v + 1];
      _ < h && (h = _), z < c && (c = z), _ > l && (l = _), z > u && (u = z), this._ids[v] = v;
    }
    const f = (h + l) / 2, d = (c + u) / 2;
    let p, y, x;
    for (let v = 0, _ = 1 / 0; v < a; v++) {
      const z = kc(f, d, e[2 * v], e[2 * v + 1]);
      z < _ && (p = v, _ = z);
    }
    const m = e[2 * p], g = e[2 * p + 1];
    for (let v = 0, _ = 1 / 0; v < a; v++) {
      if (v === p) continue;
      const z = kc(m, g, e[2 * v], e[2 * v + 1]);
      z < _ && z > 0 && (y = v, _ = z);
    }
    let w = e[2 * y], M = e[2 * y + 1], S = 1 / 0;
    for (let v = 0; v < a; v++) {
      if (v === p || v === y) continue;
      const _ = RT(m, g, w, M, e[2 * v], e[2 * v + 1]);
      _ < S && (x = v, S = _);
    }
    let E = e[2 * x], A = e[2 * x + 1];
    if (S === 1 / 0) {
      for (let z = 0; z < a; z++)
        this._dists[z] = e[2 * z] - e[0] || e[2 * z + 1] - e[1];
      lr(this._ids, this._dists, 0, a - 1);
      const v = new Uint32Array(a);
      let _ = 0;
      for (let z = 0, P = -1 / 0; z < a; z++) {
        const k = this._ids[z], B = this._dists[k];
        B > P && (v[_++] = k, P = B);
      }
      this.hull = v.subarray(0, _), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (ga(m, g, w, M, E, A) < 0) {
      const v = y, _ = w, z = M;
      y = x, w = E, M = A, x = v, E = _, A = z;
    }
    const I = OT(m, g, w, M, E, A);
    this._cx = I.x, this._cy = I.y;
    for (let v = 0; v < a; v++)
      this._dists[v] = kc(e[2 * v], e[2 * v + 1], I.x, I.y);
    lr(this._ids, this._dists, 0, a - 1), this._hullStart = p;
    let b = 3;
    i[p] = n[x] = y, i[y] = n[p] = x, i[x] = n[y] = p, s[p] = 0, s[y] = 1, s[x] = 2, o.fill(-1), o[this._hashKey(m, g)] = p, o[this._hashKey(w, M)] = y, o[this._hashKey(E, A)] = x, this.trianglesLen = 0, this._addTriangle(p, y, x, -1, -1, -1);
    for (let v = 0, _, z; v < this._ids.length; v++) {
      const P = this._ids[v], k = e[2 * P], B = e[2 * P + 1];
      if (v > 0 && Math.abs(k - _) <= gp && Math.abs(B - z) <= gp || (_ = k, z = B, P === p || P === y || P === x)) continue;
      let R = 0;
      for (let J = 0, X = this._hashKey(k, B); J < this._hashSize && (R = o[(X + J) % this._hashSize], !(R !== -1 && R !== i[R])); J++)
        ;
      R = n[R];
      let L = R, N;
      for (; N = i[L], ga(k, B, e[2 * L], e[2 * L + 1], e[2 * N], e[2 * N + 1]) >= 0; )
        if (L = N, L === R) {
          L = -1;
          break;
        }
      if (L === -1) continue;
      let q = this._addTriangle(L, P, i[L], -1, -1, s[L]);
      s[P] = this._legalize(q + 2), s[L] = q, b++;
      let U = i[L];
      for (; N = i[U], ga(k, B, e[2 * U], e[2 * U + 1], e[2 * N], e[2 * N + 1]) < 0; )
        q = this._addTriangle(U, P, N, s[P], -1, s[U]), s[P] = this._legalize(q + 2), i[U] = U, b--, U = N;
      if (L === R)
        for (; N = n[L], ga(k, B, e[2 * N], e[2 * N + 1], e[2 * L], e[2 * L + 1]) < 0; )
          q = this._addTriangle(N, P, L, -1, s[L], s[N]), this._legalize(q + 2), s[N] = q, i[L] = L, b--, L = N;
      this._hullStart = n[P] = L, i[L] = n[U] = P, i[P] = U, o[this._hashKey(k, B)] = P, o[this._hashKey(e[2 * L], e[2 * L + 1])] = L;
    }
    this.hull = new Uint32Array(b);
    for (let v = 0, _ = this._hullStart; v < b; v++)
      this.hull[v] = _, _ = i[_];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(e, n) {
    return Math.floor(IT(e - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(e) {
    const { _triangles: n, _halfedges: i, coords: s } = this;
    let o = 0, a = 0;
    for (; ; ) {
      const h = i[e], c = e - e % 3;
      if (a = c + (e + 2) % 3, h === -1) {
        if (o === 0) break;
        e = wa[--o];
        continue;
      }
      const l = h - h % 3, u = c + (e + 1) % 3, f = l + (h + 2) % 3, d = n[a], p = n[e], y = n[u], x = n[f];
      if (kT(
        s[2 * d],
        s[2 * d + 1],
        s[2 * p],
        s[2 * p + 1],
        s[2 * y],
        s[2 * y + 1],
        s[2 * x],
        s[2 * x + 1]
      )) {
        n[e] = x, n[h] = d;
        const g = i[f];
        if (g === -1) {
          let M = this._hullStart;
          do {
            if (this._hullTri[M] === f) {
              this._hullTri[M] = e;
              break;
            }
            M = this._hullPrev[M];
          } while (M !== this._hullStart);
        }
        this._link(e, g), this._link(h, i[a]), this._link(a, f);
        const w = l + (h + 1) % 3;
        o < wa.length && (wa[o++] = w);
      } else {
        if (o === 0) break;
        e = wa[--o];
      }
    }
    return a;
  }
  _link(e, n) {
    this._halfedges[e] = n, n !== -1 && (this._halfedges[n] = e);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(e, n, i, s, o, a) {
    const h = this.trianglesLen;
    return this._triangles[h] = e, this._triangles[h + 1] = n, this._triangles[h + 2] = i, this._link(h, s), this._link(h + 1, o), this._link(h + 2, a), this.trianglesLen += 3, h;
  }
}
function IT(r, e) {
  const n = r / (Math.abs(r) + Math.abs(e));
  return (e > 0 ? 3 - n : 1 + n) / 4;
}
function kc(r, e, n, i) {
  const s = r - n, o = e - i;
  return s * s + o * o;
}
function kT(r, e, n, i, s, o, a, h) {
  const c = r - a, l = e - h, u = n - a, f = i - h, d = s - a, p = o - h, y = c * c + l * l, x = u * u + f * f, m = d * d + p * p;
  return c * (f * m - x * p) - l * (u * m - x * d) + y * (u * p - f * d) < 0;
}
function RT(r, e, n, i, s, o) {
  const a = n - r, h = i - e, c = s - r, l = o - e, u = a * a + h * h, f = c * c + l * l, d = 0.5 / (a * l - h * c), p = (l * u - h * f) * d, y = (a * f - c * u) * d;
  return p * p + y * y;
}
function OT(r, e, n, i, s, o) {
  const a = n - r, h = i - e, c = s - r, l = o - e, u = a * a + h * h, f = c * c + l * l, d = 0.5 / (a * l - h * c), p = r + (l * u - h * f) * d, y = e + (a * f - c * u) * d;
  return { x: p, y };
}
function lr(r, e, n, i) {
  if (i - n <= 20)
    for (let s = n + 1; s <= i; s++) {
      const o = r[s], a = e[o];
      let h = s - 1;
      for (; h >= n && e[r[h]] > a; ) r[h + 1] = r[h--];
      r[h + 1] = o;
    }
  else {
    const s = n + i >> 1;
    let o = n + 1, a = i;
    Vr(r, s, o), e[r[n]] > e[r[i]] && Vr(r, n, i), e[r[o]] > e[r[i]] && Vr(r, o, i), e[r[n]] > e[r[o]] && Vr(r, n, o);
    const h = r[o], c = e[h];
    for (; ; ) {
      do
        o++;
      while (e[r[o]] < c);
      do
        a--;
      while (e[r[a]] > c);
      if (a < o) break;
      Vr(r, o, a);
    }
    r[n + 1] = r[a], r[a] = h, i - o + 1 >= a - n ? (lr(r, e, o, i), lr(r, e, n, a - 1)) : (lr(r, e, n, a - 1), lr(r, e, o, i));
  }
}
function Vr(r, e, n) {
  const i = r[e];
  r[e] = r[n], r[n] = i;
}
function LT(r) {
  return r[0];
}
function BT(r) {
  return r[1];
}
const uo = 1e20;
class FT {
  constructor({
    fontSize: e = 24,
    buffer: n = 3,
    radius: i = 8,
    cutoff: s = 0.25,
    fontFamily: o = "sans-serif",
    fontWeight: a = "normal",
    fontStyle: h = "normal"
  } = {}) {
    this.buffer = n, this.cutoff = s, this.radius = i;
    const c = this.size = e + n * 4, l = this._createCanvas(c), u = this.ctx = l.getContext("2d", { willReadFrequently: !0 });
    u.font = `${h} ${a} ${e}px ${o}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(c * c), this.gridInner = new Float64Array(c * c), this.f = new Float64Array(c), this.z = new Float64Array(c + 1), this.v = new Uint16Array(c);
  }
  _createCanvas(e) {
    const n = document.createElement("canvas");
    return n.width = n.height = e, n;
  }
  draw(e) {
    const {
      width: n,
      actualBoundingBoxAscent: i,
      actualBoundingBoxDescent: s,
      actualBoundingBoxLeft: o,
      actualBoundingBoxRight: a
    } = this.ctx.measureText(e), h = Math.ceil(i), c = 0, l = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a - o))), u = Math.min(this.size - this.buffer, h + Math.ceil(s)), f = l + 2 * this.buffer, d = u + 2 * this.buffer, p = Math.max(f * d, 0), y = new Uint8ClampedArray(p), x = { data: y, width: f, height: d, glyphWidth: l, glyphHeight: u, glyphTop: h, glyphLeft: c, glyphAdvance: n };
    if (l === 0 || u === 0) return x;
    const { ctx: m, buffer: g, gridInner: w, gridOuter: M } = this;
    m.clearRect(g, g, l, u), m.fillText(e, g, g + h);
    const S = m.getImageData(g, g, l, u);
    M.fill(uo, 0, p), w.fill(0, 0, p);
    for (let E = 0; E < u; E++)
      for (let A = 0; A < l; A++) {
        const I = S.data[4 * (E * l + A) + 3] / 255;
        if (I === 0) continue;
        const b = (E + g) * f + A + g;
        if (I === 1)
          M[b] = 0, w[b] = uo;
        else {
          const v = 0.5 - I;
          M[b] = v > 0 ? v * v : 0, w[b] = v < 0 ? v * v : 0;
        }
      }
    wp(M, 0, 0, f, d, f, this.f, this.v, this.z), wp(w, g, g, l, u, f, this.f, this.v, this.z);
    for (let E = 0; E < p; E++) {
      const A = Math.sqrt(M[E]) - Math.sqrt(w[E]);
      y[E] = Math.round(255 - 255 * (A / this.radius + this.cutoff));
    }
    return x;
  }
}
function wp(r, e, n, i, s, o, a, h, c) {
  for (let l = e; l < e + i; l++) bp(r, n * o + l, o, s, a, h, c);
  for (let l = n; l < n + s; l++) bp(r, l * o + e, 1, i, a, h, c);
}
function bp(r, e, n, i, s, o, a) {
  o[0] = 0, a[0] = -uo, a[1] = uo, s[0] = r[e];
  for (let h = 1, c = 0, l = 0; h < i; h++) {
    s[h] = r[e + h * n];
    const u = h * h;
    do {
      const f = o[c];
      l = (s[h] - s[f] + u - f * f) / (h - f) / 2;
    } while (l <= a[c] && --c > -1);
    c++, o[c] = h, a[c] = l, a[c + 1] = uo;
  }
  for (let h = 0, c = 0; h < i; h++) {
    for (; a[c + 1] < h; ) c++;
    const l = o[c], u = h - l;
    r[e + h * n] = s[l] + u * u;
  }
}
class im {
  constructor(e = [], n = (i, s) => i < s ? -1 : i > s ? 1 : 0) {
    if (this.data = e, this.length = this.data.length, this.compare = n, this.length > 0)
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
  }
  push(e) {
    this.data.push(e), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    const e = this.data[0], n = this.data.pop();
    return --this.length > 0 && (this.data[0] = n, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    const { data: n, compare: i } = this, s = n[e];
    for (; e > 0; ) {
      const o = e - 1 >> 1, a = n[o];
      if (i(s, a) >= 0) break;
      n[e] = a, e = o;
    }
    n[e] = s;
  }
  _down(e) {
    const { data: n, compare: i } = this, s = this.length >> 1, o = n[e];
    for (; e < s; ) {
      let a = (e << 1) + 1;
      const h = a + 1;
      if (h < this.length && i(n[h], n[a]) < 0 && (a = h), i(n[a], o) >= 0) break;
      n[e] = n[a], e = a;
    }
    n[e] = o;
  }
}
function NT(r, e = 1, n = !1) {
  let i = 1 / 0, s = 1 / 0, o = -1 / 0, a = -1 / 0;
  for (const [g, w] of r[0])
    g < i && (i = g), w < s && (s = w), g > o && (o = g), w > a && (a = w);
  const h = o - i, c = a - s, l = Math.max(e, Math.min(h, c));
  if (l === e) {
    const g = [i, s];
    return g.distance = 0, g;
  }
  const u = new im([], (g, w) => w.max - g.max);
  let f = DT(r);
  const d = new Ah(i + h / 2, s + c / 2, 0, r);
  d.d > f.d && (f = d);
  let p = 2;
  function y(g, w, M) {
    const S = new Ah(g, w, M, r);
    p++, S.max > f.d + e && u.push(S), S.d > f.d && (f = S, n && console.log(`found best ${Math.round(1e4 * S.d) / 1e4} after ${p} probes`));
  }
  let x = l / 2;
  for (let g = i; g < o; g += l)
    for (let w = s; w < a; w += l)
      y(g + x, w + x, x);
  for (; u.length; ) {
    const { max: g, x: w, y: M, h: S } = u.pop();
    if (g - f.d <= e) break;
    x = S / 2, y(w - x, M - x, x), y(w + x, M - x, x), y(w - x, M + x, x), y(w + x, M + x, x);
  }
  n && console.log(`num probes: ${p}
best distance: ${f.d}`);
  const m = [f.x, f.y];
  return m.distance = f.d, m;
}
function Ah(r, e, n, i) {
  this.x = r, this.y = e, this.h = n, this.d = qT(r, e, i), this.max = this.d + this.h * Math.SQRT2;
}
function qT(r, e, n) {
  let i = !1, s = 1 / 0;
  for (const o of n)
    for (let a = 0, h = o.length, c = h - 1; a < h; c = a++) {
      const l = o[a], u = o[c];
      l[1] > e != u[1] > e && r < (u[0] - l[0]) * (e - l[1]) / (u[1] - l[1]) + l[0] && (i = !i), s = Math.min(s, $T(r, e, l, u));
    }
  return s === 0 ? 0 : (i ? 1 : -1) * Math.sqrt(s);
}
function DT(r) {
  let e = 0, n = 0, i = 0;
  const s = r[0];
  for (let a = 0, h = s.length, c = h - 1; a < h; c = a++) {
    const l = s[a], u = s[c], f = l[0] * u[1] - u[0] * l[1];
    n += (l[0] + u[0]) * f, i += (l[1] + u[1]) * f, e += f * 3;
  }
  const o = new Ah(n / e, i / e, 0, r);
  return e === 0 || o.d < 0 ? new Ah(s[0][0], s[0][1], 0, r) : o;
}
function $T(r, e, n, i) {
  let s = n[0], o = n[1], a = i[0] - s, h = i[1] - o;
  if (a !== 0 || h !== 0) {
    const c = ((r - s) * a + (e - o) * h) / (a * a + h * h);
    c > 1 ? (s = i[0], o = i[1]) : c > 0 && (s += a * c, o += h * c);
  }
  return a = r - s, h = e - o, a * a + h * h;
}
const VT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Delaunator: ju,
  TinySDF: FT,
  deviation: _T,
  earcut: aT,
  flatten: ST,
  polylabel: NT
}, Symbol.toStringTag, { value: "Module" })), sm = Math.PI * 2, UT = 180 / Math.PI, WT = Math.PI / 180;
var Ls = /* @__PURE__ */ ((r) => (r[r.POLY = 0] = "POLY", r[r.RECT = 1] = "RECT", r[r.CIRC = 2] = "CIRC", r[r.ELIP = 3] = "ELIP", r[r.RREC = 4] = "RREC", r))(Ls || {});
class qn {
  /** Position of the point on the x axis */
  x = 0;
  /** Position of the point on the y axis */
  y = 0;
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e = 0, n = 0) {
    this.x = e, this.y = n;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new qn(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(e) {
    return this.set(e.x, e.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(e) {
    return e.set(this.x, this.y), e;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(e = 0, n = e) {
    return this.x = e, this.y = n, this;
  }
}
process.env.DEBUG && (qn.prototype.toString = function() {
  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
});
const ba = [new qn(), new qn(), new qn(), new qn()];
class zs {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  width;
  /** @default 0 */
  height;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.RECT
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(e = 0, n = 0, i = 0, s = 0) {
    this.x = Number(e), this.y = Number(n), this.width = Number(i), this.height = Number(s), this.type = Ls.RECT;
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** A constant empty rectangle. */
  static get EMPTY() {
    return new zs(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new zs(this.x, this.y, this.width, this.height);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(e) {
    return e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(e, n) {
    return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height;
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(e, n) {
    if (!n) {
      const b = this.x < e.x ? e.x : this.x;
      if ((this.right > e.right ? e.right : this.right) <= b)
        return !1;
      const _ = this.y < e.y ? e.y : this.y;
      return (this.bottom > e.bottom ? e.bottom : this.bottom) > _;
    }
    const i = this.left, s = this.right, o = this.top, a = this.bottom;
    if (s <= i || a <= o)
      return !1;
    const h = ba[0].set(e.left, e.top), c = ba[1].set(e.left, e.bottom), l = ba[2].set(e.right, e.top), u = ba[3].set(e.right, e.bottom);
    if (l.x <= h.x || c.y <= h.y)
      return !1;
    const f = Math.sign(n.a * n.d - n.b * n.c);
    if (f === 0 || (n.apply(h, h), n.apply(c, c), n.apply(l, l), n.apply(u, u), Math.max(h.x, c.x, l.x, u.x) <= i || Math.min(h.x, c.x, l.x, u.x) >= s || Math.max(h.y, c.y, l.y, u.y) <= o || Math.min(h.y, c.y, l.y, u.y) >= a))
      return !1;
    const d = f * (c.y - h.y), p = f * (h.x - c.x), y = d * i + p * o, x = d * s + p * o, m = d * i + p * a, g = d * s + p * a;
    if (Math.max(y, x, m, g) <= d * h.x + p * h.y || Math.min(y, x, m, g) >= d * u.x + p * u.y)
      return !1;
    const w = f * (h.y - l.y), M = f * (l.x - h.x), S = w * i + M * o, E = w * s + M * o, A = w * i + M * a, I = w * s + M * a;
    return !(Math.max(S, E, A, I) <= w * h.x + M * h.y || Math.min(S, E, A, I) >= w * u.x + M * u.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(e = 0, n = e) {
    return this.x -= e, this.y -= n, this.width += e * 2, this.height += n * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(e) {
    const n = Math.max(this.x, e.x), i = Math.min(this.x + this.width, e.x + e.width), s = Math.max(this.y, e.y), o = Math.min(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = Math.max(i - n, 0), this.y = s, this.height = Math.max(o - s, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(e = 1, n = 1e-3) {
    const i = Math.ceil((this.x + this.width - n) * e) / e, s = Math.ceil((this.y + this.height - n) * e) / e;
    return this.x = Math.floor((this.x + n) * e) / e, this.y = Math.floor((this.y + n) * e) / e, this.width = i - this.x, this.height = s - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(e) {
    const n = Math.min(this.x, e.x), i = Math.max(this.x + this.width, e.x + e.width), s = Math.min(this.y, e.y), o = Math.max(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = i - n, this.y = s, this.height = o - s, this;
  }
}
process.env.DEBUG && (zs.prototype.toString = function() {
  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
});
class Uh {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.CIRC
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(e = 0, n = 0, i = 0) {
    this.x = e, this.y = n, this.radius = i, this.type = Ls.CIRC;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new Uh(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(e, n) {
    if (this.radius <= 0)
      return !1;
    const i = this.radius * this.radius;
    let s = this.x - e, o = this.y - n;
    return s *= s, o *= o, s + o <= i;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new zs(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
}
process.env.DEBUG && (Uh.prototype.toString = function() {
  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
});
class Wh {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  width;
  /** @default 0 */
  height;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.ELIP
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(e = 0, n = 0, i = 0, s = 0) {
    this.x = e, this.y = n, this.width = i, this.height = s, this.type = Ls.ELIP;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {PIXI.Ellipse} A copy of the ellipse
   */
  clone() {
    return new Wh(this.x, this.y, this.width, this.height);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(e, n) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    let i = (e - this.x) / this.width, s = (n - this.y) / this.height;
    return i *= i, s *= s, i + s <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new zs(this.x - this.width, this.y - this.height, this.width, this.height);
  }
}
process.env.DEBUG && (Wh.prototype.toString = function() {
  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
});
class jh {
  /** An array of the points of this polygon. */
  points;
  /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */
  closeStroke;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.POLY
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...e) {
    let n = Array.isArray(e[0]) ? e[0] : e;
    if (typeof n[0] != "number") {
      const i = [];
      for (let s = 0, o = n.length; s < o; s++)
        i.push(n[s].x, n[s].y);
      n = i;
    }
    this.points = n, this.type = Ls.POLY, this.closeStroke = !0;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const e = this.points.slice(), n = new jh(e);
    return n.closeStroke = this.closeStroke, n;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(e, n) {
    let i = !1;
    const s = this.points.length / 2;
    for (let o = 0, a = s - 1; o < s; a = o++) {
      const h = this.points[o * 2], c = this.points[o * 2 + 1], l = this.points[a * 2], u = this.points[a * 2 + 1];
      c > n != u > n && e < (l - h) * ((n - c) / (u - c)) + h && (i = !i);
    }
    return i;
  }
}
process.env.DEBUG && (jh.prototype.toString = function() {
  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((e, n) => `${e}, ${n}`, "")}]`;
});
class Yh {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  width;
  /** @default 0 */
  height;
  /** @default 20 */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.RREC
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(e = 0, n = 0, i = 0, s = 0, o = 20) {
    this.x = e, this.y = n, this.width = i, this.height = s, this.radius = o, this.type = Ls.RREC;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new Yh(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(e, n) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (e >= this.x && e <= this.x + this.width && n >= this.y && n <= this.y + this.height) {
      const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (n >= this.y + i && n <= this.y + this.height - i || e >= this.x + i && e <= this.x + this.width - i)
        return !0;
      let s = e - (this.x + i), o = n - (this.y + i);
      const a = i * i;
      if (s * s + o * o <= a || (s = e - (this.x + this.width - i), s * s + o * o <= a) || (o = n - (this.y + this.height - i), s * s + o * o <= a) || (s = e - (this.x + i), s * s + o * o <= a))
        return !0;
    }
    return !1;
  }
}
process.env.DEBUG && (Yh.prototype.toString = function() {
  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
});
class ci {
  /** @default 1 */
  a;
  /** @default 0 */
  b;
  /** @default 0 */
  c;
  /** @default 1 */
  d;
  /** @default 0 */
  tx;
  /** @default 0 */
  ty;
  array = null;
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(e = 1, n = 0, i = 0, s = 1, o = 0, a = 0) {
    this.a = e, this.b = n, this.c = i, this.d = s, this.tx = o, this.ty = a;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(e) {
    this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(e, n, i, s, o, a) {
    return this.a = e, this.b = n, this.c = i, this.d = s, this.tx = o, this.ty = a, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(e, n) {
    this.array || (this.array = new Float32Array(9));
    const i = n || this.array;
    return e ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, transformed through this matrix
   */
  apply(e, n) {
    n = n || new qn();
    const i = e.x, s = e.y;
    return n.x = this.a * i + this.c * s + this.tx, n.y = this.b * i + this.d * s + this.ty, n;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(e, n) {
    n = n || new qn();
    const i = 1 / (this.a * this.d + this.c * -this.b), s = e.x, o = e.y;
    return n.x = this.d * i * s + -this.c * i * o + (this.ty * this.c - this.tx * this.d) * i, n.y = this.a * i * o + -this.b * i * s + (-this.ty * this.a + this.tx * this.b) * i, n;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(e, n) {
    return this.tx += e, this.ty += n, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(e, n) {
    return this.a *= e, this.d *= n, this.c *= e, this.b *= n, this.tx *= e, this.ty *= n, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(e) {
    const n = Math.cos(e), i = Math.sin(e), s = this.a, o = this.c, a = this.tx;
    return this.a = s * n - this.b * i, this.b = s * i + this.b * n, this.c = o * n - this.d * i, this.d = o * i + this.d * n, this.tx = a * n - this.ty * i, this.ty = a * i + this.ty * n, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(e) {
    const n = this.a, i = this.b, s = this.c, o = this.d;
    return this.a = e.a * n + e.b * s, this.b = e.a * i + e.b * o, this.c = e.c * n + e.d * s, this.d = e.c * i + e.d * o, this.tx = e.tx * n + e.ty * s + this.tx, this.ty = e.tx * i + e.ty * o + this.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(e, n, i, s, o, a, h, c, l) {
    return this.a = Math.cos(h + l) * o, this.b = Math.sin(h + l) * o, this.c = -Math.sin(h - c) * a, this.d = Math.cos(h - c) * a, this.tx = e - (i * this.a + s * this.c), this.ty = n - (i * this.b + s * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(e) {
    const n = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const i = this.a, s = this.c;
      this.a = i * e.a + this.b * e.c, this.b = i * e.b + this.b * e.d, this.c = s * e.a + this.d * e.c, this.d = s * e.b + this.d * e.d;
    }
    return this.tx = n * e.a + this.ty * e.c + e.tx, this.ty = n * e.b + this.ty * e.d + e.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(e) {
    const n = this.a, i = this.b, s = this.c, o = this.d, a = e.pivot, h = -Math.atan2(-s, o), c = Math.atan2(i, n), l = Math.abs(h + c);
    return l < 1e-5 || Math.abs(sm - l) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = h, e.skew.y = c), e.scale.x = Math.sqrt(n * n + i * i), e.scale.y = Math.sqrt(s * s + o * o), e.position.x = this.tx + (a.x * n + a.y * s), e.position.y = this.ty + (a.x * i + a.y * o), e;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const e = this.a, n = this.b, i = this.c, s = this.d, o = this.tx, a = e * s - n * i;
    return this.a = s / a, this.b = -n / a, this.c = -i / a, this.d = e / a, this.tx = (i * this.ty - s * o) / a, this.ty = -(e * this.ty - n * o) / a, this;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const e = new ci();
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(e) {
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param {PIXI.Matrix} matrix - The matrix to copy from.
   * @returns {PIXI.Matrix} this
   */
  copyFrom(e) {
    return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
  }
  /**
   * A default (identity) matrix
   * @readonly
   */
  static get IDENTITY() {
    return new ci();
  }
  /**
   * A temp matrix
   * @readonly
   */
  static get TEMP_MATRIX() {
    return new ci();
  }
}
process.env.DEBUG && (ci.prototype.toString = function() {
  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
});
const hs = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], cs = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], ls = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], us = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], Xl = [], rm = [], va = Math.sign;
function jT() {
  for (let r = 0; r < 16; r++) {
    const e = [];
    Xl.push(e);
    for (let n = 0; n < 16; n++) {
      const i = va(hs[r] * hs[n] + ls[r] * cs[n]), s = va(cs[r] * hs[n] + us[r] * cs[n]), o = va(hs[r] * ls[n] + ls[r] * us[n]), a = va(cs[r] * ls[n] + us[r] * us[n]);
      for (let h = 0; h < 16; h++)
        if (hs[h] === i && cs[h] === s && ls[h] === o && us[h] === a) {
          e.push(h);
          break;
        }
    }
  }
  for (let r = 0; r < 16; r++) {
    const e = new ci();
    e.set(hs[r], cs[r], ls[r], us[r], 0, 0), rm.push(e);
  }
}
jT();
const yn = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @readonly
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @readonly
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @readonly
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @readonly
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @readonly
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @readonly
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @readonly
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @readonly
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @readonly
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @readonly
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @readonly
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @readonly
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (r) => hs[r],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (r) => cs[r],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (r) => ls[r],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (r) => us[r],
  /**
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (r) => r & 8 ? r & 15 : -r & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: (r, e) => Xl[r][e],
  /**
   * Reverse of `add`.
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: (r, e) => Xl[r][yn.inv(e)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (r) => r ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (r) => (r & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (r, e) => Math.abs(r) * 2 <= Math.abs(e) ? e >= 0 ? yn.S : yn.N : Math.abs(e) * 2 <= Math.abs(r) ? r > 0 ? yn.E : yn.W : e > 0 ? r > 0 ? yn.SE : yn.SW : r > 0 ? yn.NE : yn.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (r, e, n = 0, i = 0) => {
    const s = rm[yn.inv(e)];
    s.tx = n, s.ty = i, r.append(s);
  }
};
class gs {
  /** The callback function triggered when `x` and/or `y` are changed */
  cb;
  /** The owner of the callback */
  scope;
  _x;
  _y;
  /**
   * Creates a new `ObservablePoint`
   * @param cb - callback function triggered when `x` and/or `y` are changed
   * @param scope - owner of callback
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e, n, i = 0, s = 0) {
    this._x = i, this._y = s, this.cb = e, this.scope = n;
  }
  /**
   * Creates a clone of this point.
   * The callback and scope params can be overridden otherwise they will default
   * to the clone object's values.
   * @override
   * @param cb - The callback function triggered when `x` and/or `y` are changed
   * @param scope - The owner of the callback
   * @returns a copy of this observable point
   */
  clone(e = this.cb, n = this.scope) {
    return new gs(e, n, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(e = 0, n = e) {
    return (this._x !== e || this._y !== n) && (this._x = e, this._y = n, this.cb.call(this.scope)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `IPointData`
   * @returns The observable point instance itself
   */
  copyFrom(e) {
    return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this.cb.call(this.scope)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(e) {
    return e.set(this._x, this._y), e;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(e) {
    return e.x === this._x && e.y === this._y;
  }
  // #if _DEBUG
  toString() {
    return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`;
  }
  // #endif
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x !== e && (this._x = e, this.cb.call(this.scope));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y !== e && (this._y = e, this.cb.call(this.scope));
  }
}
class Yu {
  /**
   * A default (identity) transform.
   * @static
   * @type {PIXI.Transform}
   */
  static IDENTITY = new Yu();
  /** The world transformation matrix. */
  worldTransform;
  /** The local transformation matrix. */
  localTransform;
  /** The coordinate of the object relative to the local coordinates of the parent. */
  position;
  /** The scale factor of the object. */
  scale;
  /** The pivot point of the displayObject that it rotates around. */
  pivot;
  /** The skew amount, on the x and y axis. */
  skew;
  /** The locally unique ID of the parent's world transform used to calculate the current world transformation matrix. */
  _parentID;
  /** The locally unique ID of the world transform. */
  _worldID;
  /** The rotation amount. */
  _rotation;
  /**
   * The X-coordinate value of the normalized local X axis,
   * the first column of the local transformation matrix without a scale.
   */
  _cx;
  /**
   * The Y-coordinate value of the normalized local X axis,
   * the first column of the local transformation matrix without a scale.
   */
  _sx;
  /**
   * The X-coordinate value of the normalized local Y axis,
   * the second column of the local transformation matrix without a scale.
   */
  _cy;
  /**
   * The Y-coordinate value of the normalized local Y axis,
   * the second column of the local transformation matrix without a scale.
   */
  _sy;
  /** The locally unique ID of the local transform. */
  _localID;
  /** The locally unique ID of the local transform used to calculate the current local transformation matrix. */
  _currentLocalID;
  constructor() {
    this.worldTransform = new ci(), this.localTransform = new ci(), this.position = new gs(this.onChange, this, 0, 0), this.scale = new gs(this.onChange, this, 1, 1), this.pivot = new gs(this.onChange, this, 0, 0), this.skew = new gs(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  /** Called when a value changes. */
  onChange() {
    this._localID++;
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }
  /** Updates the local transformation matrix. */
  updateLocalTransform() {
    const e = this.localTransform;
    this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1);
  }
  /**
   * Updates the local and the world transformation matrices.
   * @param parentTransform - The parent transform
   */
  updateTransform(e) {
    const n = this.localTransform;
    if (this._localID !== this._currentLocalID && (n.a = this._cx * this.scale.x, n.b = this._sx * this.scale.x, n.c = this._cy * this.scale.y, n.d = this._sy * this.scale.y, n.tx = this.position.x - (this.pivot.x * n.a + this.pivot.y * n.c), n.ty = this.position.y - (this.pivot.x * n.b + this.pivot.y * n.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
      const i = e.worldTransform, s = this.worldTransform;
      s.a = n.a * i.a + n.b * i.c, s.b = n.a * i.b + n.b * i.d, s.c = n.c * i.a + n.d * i.c, s.d = n.c * i.b + n.d * i.d, s.tx = n.tx * i.a + n.ty * i.c + i.tx, s.ty = n.tx * i.b + n.ty * i.d + i.ty, this._parentID = e._worldID, this._worldID++;
    }
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(e) {
    e.decompose(this), this._localID++;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation !== e && (this._rotation = e, this.updateSkew());
  }
}
const YT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: Uh,
  DEG_TO_RAD: WT,
  Ellipse: Wh,
  Matrix: ci,
  ObservablePoint: gs,
  PI_2: sm,
  Point: qn,
  Polygon: jh,
  RAD_TO_DEG: UT,
  Rectangle: zs,
  RoundedRectangle: Yh,
  SHAPES: Ls,
  Transform: Yu,
  groupD8: yn
}, Symbol.toStringTag, { value: "Module" }));
function om(r, e, n = 0, i = r.length - 1, s = HT) {
  for (; i > n; ) {
    if (i - n > 600) {
      const c = i - n + 1, l = e - n + 1, u = Math.log(c), f = 0.5 * Math.exp(2 * u / 3), d = 0.5 * Math.sqrt(u * f * (c - f) / c) * (l - c / 2 < 0 ? -1 : 1), p = Math.max(n, Math.floor(e - l * f / c + d)), y = Math.min(i, Math.floor(e + (c - l) * f / c + d));
      om(r, e, p, y, s);
    }
    const o = r[e];
    let a = n, h = i;
    for (Ur(r, n, e), s(r[i], o) > 0 && Ur(r, n, i); a < h; ) {
      for (Ur(r, a, h), a++, h--; s(r[a], o) < 0; ) a++;
      for (; s(r[h], o) > 0; ) h--;
    }
    s(r[n], o) === 0 ? Ur(r, n, h) : (h++, Ur(r, h, i)), h <= e && (n = h + 1), e <= h && (i = h - 1);
  }
}
function Ur(r, e, n) {
  const i = r[e];
  r[e] = r[n], r[n] = i;
}
function HT(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
class XT {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let n = this.data;
    const i = [];
    if (!_a(e, n)) return i;
    const s = this.toBBox, o = [];
    for (; n; ) {
      for (let a = 0; a < n.children.length; a++) {
        const h = n.children[a], c = n.leaf ? s(h) : h;
        _a(e, c) && (n.leaf ? i.push(h) : Oc(e, c) ? this._all(h, i) : o.push(h));
      }
      n = o.pop();
    }
    return i;
  }
  collides(e) {
    let n = this.data;
    if (!_a(e, n)) return !1;
    const i = [];
    for (; n; ) {
      for (let s = 0; s < n.children.length; s++) {
        const o = n.children[s], a = n.leaf ? this.toBBox(o) : o;
        if (_a(e, a)) {
          if (n.leaf || Oc(e, a)) return !0;
          i.push(o);
        }
      }
      n = i.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let i = 0; i < e.length; i++)
        this.insert(e[i]);
      return this;
    }
    let n = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const i = this.data;
        this.data = n, n = i;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = or([]), this;
  }
  remove(e, n) {
    if (!e) return this;
    let i = this.data;
    const s = this.toBBox(e), o = [], a = [];
    let h, c, l;
    for (; i || o.length; ) {
      if (i || (i = o.pop(), c = o[o.length - 1], h = a.pop(), l = !0), i.leaf) {
        const u = ZT(e, i.children, n);
        if (u !== -1)
          return i.children.splice(u, 1), o.push(i), this._condense(o), this;
      }
      !l && !i.leaf && Oc(i, s) ? (o.push(i), a.push(h), h = 0, c = i, i = i.children[0]) : c ? (h++, i = c.children[h], l = !1) : i = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, n) {
    return e.minX - n.minX;
  }
  compareMinY(e, n) {
    return e.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, n) {
    const i = [];
    for (; e; )
      e.leaf ? n.push(...e.children) : i.push(...e.children), e = i.pop();
    return n;
  }
  _build(e, n, i, s) {
    const o = i - n + 1;
    let a = this._maxEntries, h;
    if (o <= a)
      return h = or(e.slice(n, i + 1)), Us(h, this.toBBox), h;
    s || (s = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, s - 1))), h = or([]), h.leaf = !1, h.height = s;
    const c = Math.ceil(o / a), l = c * Math.ceil(Math.sqrt(a));
    vp(e, n, i, l, this.compareMinX);
    for (let u = n; u <= i; u += l) {
      const f = Math.min(u + l - 1, i);
      vp(e, u, f, c, this.compareMinY);
      for (let d = u; d <= f; d += c) {
        const p = Math.min(d + c - 1, f);
        h.children.push(this._build(e, d, p, s - 1));
      }
    }
    return Us(h, this.toBBox), h;
  }
  _chooseSubtree(e, n, i, s) {
    for (; s.push(n), !(n.leaf || s.length - 1 === i); ) {
      let o = 1 / 0, a = 1 / 0, h;
      for (let c = 0; c < n.children.length; c++) {
        const l = n.children[c], u = Rc(l), f = QT(e, l) - u;
        f < a ? (a = f, o = u < o ? u : o, h = l) : f === a && u < o && (o = u, h = l);
      }
      n = h || n.children[0];
    }
    return n;
  }
  _insert(e, n, i) {
    const s = i ? e : this.toBBox(e), o = [], a = this._chooseSubtree(s, this.data, n, o);
    for (a.children.push(e), eo(a, s); n >= 0 && o[n].children.length > this._maxEntries; )
      this._split(o, n), n--;
    this._adjustParentBBoxes(s, o, n);
  }
  // split overflowed node into two
  _split(e, n) {
    const i = e[n], s = i.children.length, o = this._minEntries;
    this._chooseSplitAxis(i, o, s);
    const a = this._chooseSplitIndex(i, o, s), h = or(i.children.splice(a, i.children.length - a));
    h.height = i.height, h.leaf = i.leaf, Us(i, this.toBBox), Us(h, this.toBBox), n ? e[n - 1].children.push(h) : this._splitRoot(i, h);
  }
  _splitRoot(e, n) {
    this.data = or([e, n]), this.data.height = e.height + 1, this.data.leaf = !1, Us(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, n, i) {
    let s, o = 1 / 0, a = 1 / 0;
    for (let h = n; h <= i - n; h++) {
      const c = to(e, 0, h, this.toBBox), l = to(e, h, i, this.toBBox), u = KT(c, l), f = Rc(c) + Rc(l);
      u < o ? (o = u, s = h, a = f < a ? f : a) : u === o && f < a && (a = f, s = h);
    }
    return s || i - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, n, i) {
    const s = e.leaf ? this.compareMinX : GT, o = e.leaf ? this.compareMinY : JT, a = this._allDistMargin(e, n, i, s), h = this._allDistMargin(e, n, i, o);
    a < h && e.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, n, i, s) {
    e.children.sort(s);
    const o = this.toBBox, a = to(e, 0, n, o), h = to(e, i - n, i, o);
    let c = Ma(a) + Ma(h);
    for (let l = n; l < i - n; l++) {
      const u = e.children[l];
      eo(a, e.leaf ? o(u) : u), c += Ma(a);
    }
    for (let l = i - n - 1; l >= n; l--) {
      const u = e.children[l];
      eo(h, e.leaf ? o(u) : u), c += Ma(h);
    }
    return c;
  }
  _adjustParentBBoxes(e, n, i) {
    for (let s = i; s >= 0; s--)
      eo(n[s], e);
  }
  _condense(e) {
    for (let n = e.length - 1, i; n >= 0; n--)
      e[n].children.length === 0 ? n > 0 ? (i = e[n - 1].children, i.splice(i.indexOf(e[n]), 1)) : this.clear() : Us(e[n], this.toBBox);
  }
}
function ZT(r, e, n) {
  if (!n) return e.indexOf(r);
  for (let i = 0; i < e.length; i++)
    if (n(r, e[i])) return i;
  return -1;
}
function Us(r, e) {
  to(r, 0, r.children.length, e, r);
}
function to(r, e, n, i, s) {
  s || (s = or(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let o = e; o < n; o++) {
    const a = r.children[o];
    eo(s, r.leaf ? i(a) : a);
  }
  return s;
}
function eo(r, e) {
  return r.minX = Math.min(r.minX, e.minX), r.minY = Math.min(r.minY, e.minY), r.maxX = Math.max(r.maxX, e.maxX), r.maxY = Math.max(r.maxY, e.maxY), r;
}
function GT(r, e) {
  return r.minX - e.minX;
}
function JT(r, e) {
  return r.minY - e.minY;
}
function Rc(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function Ma(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function QT(r, e) {
  return (Math.max(e.maxX, r.maxX) - Math.min(e.minX, r.minX)) * (Math.max(e.maxY, r.maxY) - Math.min(e.minY, r.minY));
}
function KT(r, e) {
  const n = Math.max(r.minX, e.minX), i = Math.max(r.minY, e.minY), s = Math.min(r.maxX, e.maxX), o = Math.min(r.maxY, e.maxY);
  return Math.max(0, s - n) * Math.max(0, o - i);
}
function Oc(r, e) {
  return r.minX <= e.minX && r.minY <= e.minY && e.maxX <= r.maxX && e.maxY <= r.maxY;
}
function _a(r, e) {
  return e.minX <= r.maxX && e.minY <= r.maxY && e.maxX >= r.minX && e.maxY >= r.minY;
}
function or(r) {
  return {
    children: r,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function vp(r, e, n, i, s) {
  const o = [e, n];
  for (; o.length; ) {
    if (n = o.pop(), e = o.pop(), n - e <= i) continue;
    const a = e + Math.ceil((n - e) / i / 2) * i;
    om(r, a, e, n, s), o.push(e, a, a, n);
  }
}
const TP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: Wt,
  Big: oT,
  BigNumber: Mn,
  BoundingRect: Ms,
  CubicBezier: ul,
  Matrix: cu,
  Matrix2D: ue,
  Matrix3: T2,
  ObservablePoint: nr,
  QuadBezier: gr,
  RBush: XT,
  Spline: rb,
  TinyQueue: im,
  TransformableMixin: E2,
  Vector2: O,
  bernstein: zr,
  bezierCurvatureAt: Aw,
  bezierDerivative: Rw,
  bezierFirstDerivative: b1,
  bezierSecondDerivative: v1,
  bigInt: he,
  center_to_endpoint: l1,
  chopBezierAt: Xr,
  chopBezierBetween: Lw,
  chopCubicBezierAt: du,
  chopQuadBezierAt: Oh,
  chopQuadBezierAtMaxCurature: Bw,
  clipper: L_,
  computeCubicExtremas: gl,
  computeQuadExtremas: ml,
  conicBezierAt: Tw,
  conicBezierPointAt: Ew,
  contains: kv,
  core: Lv,
  cubicBezierAt: en,
  cubicBezierPointAt: fu,
  cubicBezierWithMatrixAt: Pw,
  cubicLength: Yw,
  cubicProjectPoint: S1,
  curve: sb,
  ellipseArcToCubicBezier: Rh,
  endpoint_to_center: u1,
  evalCubicBezierTangentAt: Dw,
  evalQuadBezierTangentAt: qw,
  findCubicExtrema: xl,
  findCubicMaxCurvature: Ww,
  findQuadExtrema: yl,
  findQuadMaxCurvature: M1,
  findUnitQuadRoots: pu,
  flattenCubicBezier: pl,
  flattenQuadBezier: dl,
  getBezierDerivativeControlPoints: Ow,
  getBezierPointWithBernstein: Sw,
  getBezierPointWithDeCasteljau: uu,
  getRationalBezierPointWithBernstein: zw,
  mapbox: VT,
  mathigon: JS,
  pathBool: WM,
  pathUtil: ev,
  pixi: YT,
  pointOnEllipse: f1,
  pointOnLineDistance: rh,
  pointOnSegmentDistance: Fw,
  points: D2,
  polyClip: iM,
  polytri: x_,
  quadBezierToCubic: Nw,
  quadBezierWithMatrixAt: Cw,
  quadraticBezierAt: xn,
  quadraticBezierPointAt: w1,
  quadraticLength: jw,
  quadraticProjectPoint: _1,
  quarterArcToCubicBezier: lu,
  raiseBezier: Iw,
  shapes: F2,
  shapes2: T_,
  tess: H_,
  utils: pw
}, Symbol.toStringTag, { value: "Module" })), tE = "179dev", eE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, nE = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, iE = 0, sE = 1, rE = 2, oE = 3, aE = 0, hE = 1, cE = 2, lE = 3, uE = 0, fE = 1, dE = 2, pE = 0, yE = 1, xE = 2, mE = 3, gE = 4, wE = 5, bE = 100, vE = 101, ME = 102, _E = 103, SE = 104, TE = 200, EE = 201, zE = 202, AE = 203, CE = 204, PE = 205, IE = 206, kE = 207, RE = 208, OE = 209, LE = 210, BE = 211, FE = 212, NE = 213, qE = 214, DE = 0, $E = 1, VE = 2, UE = 3, WE = 4, jE = 5, YE = 6, HE = 7, XE = 0, ZE = 1, GE = 2, JE = 0, QE = 1, KE = 2, tz = 3, ez = 4, nz = 5, iz = 6, sz = 7, rz = "attached", oz = "detached", Hu = 300, Xu = 301, az = 302, hz = 303, cz = 304, lz = 306, Zl = 1e3, Pi = 1001, Gl = 1002, zn = 1003, uz = 1004, fz = 1004, dz = 1005, pz = 1005, Tr = 1006, yz = 1007, xz = 1007, am = 1008, mz = 1008, Zu = 1009, hm = 1010, cm = 1011, lm = 1012, um = 1013, Gu = 1014, Ju = 1015, fm = 1016, dm = 1017, pm = 1018, gz = 1020, ym = 35902, xm = 1021, mm = 1022, Qu = 1023, Jl = 1026, gm = 1027, wm = 1028, bm = 1029, vm = 1030, Mm = 1031, wz = 1032, _m = 1033, Sm = 33776, Tm = 33777, Em = 33778, zm = 33779, Am = 35840, Cm = 35841, Pm = 35842, Im = 35843, km = 36196, Rm = 37492, Om = 37496, Lm = 37808, Bm = 37809, Fm = 37810, Nm = 37811, qm = 37812, Dm = 37813, $m = 37814, Vm = 37815, Um = 37816, Wm = 37817, jm = 37818, Ym = 37819, Hm = 37820, Xm = 37821, Zm = 36492, Gm = 36494, Jm = 36495, Qm = 36283, Km = 36284, tg = 36285, eg = 36286, ng = 2200, ig = 2201, sg = 2202, zo = 2300, Ch = 2301, Ka = 2302, ws = 2400, bs = 2401, Ao = 2402, Hh = 2500, Ku = 2501, bz = 0, vz = 1, Mz = 2, _z = 3200, Sz = 3201, Tz = 3202, Ez = 3203, zz = 0, Az = 1, tf = "", rn = "srgb", Ql = "srgb-linear", Kl = "linear", th = "srgb", Cz = 0, Pz = 7680, Iz = 7681, kz = 7682, Rz = 7683, Oz = 34055, Lz = 34056, Bz = 5386, Fz = 512, Nz = 513, qz = 514, Dz = 515, $z = 516, Vz = 517, Uz = 518, Wz = 519, jz = 512, Yz = 513, Hz = 514, Xz = 515, Zz = 516, Gz = 517, Jz = 518, Qz = 519, Co = 35044, Kz = 35048, tA = 35040, eA = 35045, nA = 35049, iA = 35041, sA = 35046, rA = 35050, oA = 35042, aA = "100", hA = "300 es", Dn = 2e3, Po = 2001, cA = {
  COMPUTE: "compute",
  RENDER: "render"
}, lA = {
  PERSPECTIVE: "perspective",
  LINEAR: "linear",
  FLAT: "flat"
}, uA = {
  NORMAL: "normal",
  CENTROID: "centroid",
  SAMPLE: "sample",
  FIRST: "first",
  EITHER: "either"
};
class rg {
  /**
   * Constructs a new animation action.
   *
   * @param {AnimationMixer} mixer - The mixer that is controlled by this action.
   * @param {AnimationClip} clip - The animation clip that holds the actual keyframes.
   * @param {?Object3D} [localRoot=null] - The root object on which this action is performed.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   */
  constructor(e, n, i = null, s = n.blendMode) {
    this._mixer = e, this._clip = n, this._localRoot = i, this.blendMode = s;
    const o = n.tracks, a = o.length, h = new Array(a), c = {
      endingStart: ws,
      endingEnd: ws
    };
    for (let l = 0; l !== a; ++l) {
      const u = o[l].createInterpolant(null);
      h[l] = u, u.settings = c;
    }
    this._interpolantSettings = c, this._interpolants = h, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ig, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  /**
   * Starts the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  play() {
    return this._mixer._activateAction(this), this;
  }
  /**
   * Stops the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  /**
   * Resets the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  /**
   * Returns `true` if the animation is running.
   *
   * @return {boolean} Whether the animation is running or not.
   */
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  /**
   * Returns `true` when {@link AnimationAction#play} has been called.
   *
   * @return {boolean} Whether the animation is scheduled or not.
   */
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  /**
   * Defines the time when the animation should start.
   *
   * @param {number} time - The start time in seconds.
   * @return {AnimationAction} A reference to this animation action.
   */
  startAt(e) {
    return this._startTime = e, this;
  }
  /**
   * Configures the loop settings for this action.
   *
   * @param {(LoopRepeat|LoopOnce|LoopPingPong)} mode - The loop mode.
   * @param {number} repetitions - The number of repetitions.
   * @return {AnimationAction} A reference to this animation action.
   */
  setLoop(e, n) {
    return this.loop = e, this.repetitions = n, this;
  }
  /**
   * Sets the effective weight of this action.
   *
   * An action has no effect and thus an effective weight of zero when the
   * action is disabled.
   *
   * @param {number} weight - The weight to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  /**
   * Returns the effective weight of this action.
   *
   * @return {number} The effective weight.
   */
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  /**
   * Fades the animation in by increasing its weight gradually from `0` to `1`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  /**
   * Fades the animation out by decreasing its weight gradually from `1` to `0`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  /**
   * Causes this action to fade in and the given action to fade out,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeOutAction - The animation action to fade out.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeFrom(e, n, i = !1) {
    if (e.fadeOut(n), this.fadeIn(n), i === !0) {
      const s = this._clip.duration, o = e._clip.duration, a = o / s, h = s / o;
      e.warp(1, a, n), this.warp(h, 1, n);
    }
    return this;
  }
  /**
   * Causes this action to fade out and the given action to fade in,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeInAction - The animation action to fade in.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeTo(e, n, i = !1) {
    return e.crossFadeFrom(this, n, i);
  }
  /**
   * Stops any fading which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Sets the effective time scale of this action.
   *
   * An action has no effect and thus an effective time scale of zero when the
   * action is paused.
   *
   * @param {number} timeScale - The time scale to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  /**
   * Returns the effective time scale of this action.
   *
   * @return {number} The effective time scale.
   */
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  /**
   * Sets the duration for a single loop of this action.
   *
   * @param {number} duration - The duration to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  /**
   * Synchronizes this action with the passed other action.
   *
   * @param {AnimationAction} action - The action to sync with.
   * @return {AnimationAction} A reference to this animation action.
   */
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  /**
   * Decelerates this animation's speed to `0` within the passed time interval.
   *
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  /**
   * Changes the playback speed, within the passed time interval, by modifying
   * {@link AnimationAction#timeScale} gradually from `startTimeScale` to
   * `endTimeScale`.
   *
   * @param {number} startTimeScale - The start time scale.
   * @param {number} endTimeScale - The end time scale.
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  warp(e, n, i) {
    const s = this._mixer, o = s.time, a = this.timeScale;
    let h = this._timeScaleInterpolant;
    h === null && (h = s._lendControlInterpolant(), this._timeScaleInterpolant = h);
    const c = h.parameterPositions, l = h.sampleValues;
    return c[0] = o, c[1] = o + i, l[0] = e / a, l[1] = n / a, this;
  }
  /**
   * Stops any scheduled warping which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Returns the animation mixer of this animation action.
   *
   * @return {AnimationMixer} The animation mixer.
   */
  getMixer() {
    return this._mixer;
  }
  /**
   * Returns the animation clip of this animation action.
   *
   * @return {AnimationClip} The animation clip.
   */
  getClip() {
    return this._clip;
  }
  /**
   * Returns the root object of this animation action.
   *
   * @return {Object3D} The root object.
   */
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, n, i, s) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const c = (e - o) * i;
      c < 0 || i === 0 ? n = 0 : (this._startTime = null, n = i * c);
    }
    n *= this._updateTimeScale(e);
    const a = this._updateTime(n), h = this._updateWeight(e);
    if (h > 0) {
      const c = this._interpolants, l = this._propertyBindings;
      switch (this.blendMode) {
        case Ku:
          for (let u = 0, f = c.length; u !== f; ++u)
            c[u].evaluate(a), l[u].accumulateAdditive(h);
          break;
        case Hh:
        default:
          for (let u = 0, f = c.length; u !== f; ++u)
            c[u].evaluate(a), l[u].accumulate(s, h);
      }
    }
  }
  _updateWeight(e) {
    let n = 0;
    if (this.enabled) {
      n = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const s = i.evaluate(e)[0];
        n *= s, e > i.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = n, n;
  }
  _updateTimeScale(e) {
    let n = 0;
    if (!this.paused) {
      n = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const s = i.evaluate(e)[0];
        n *= s, e > i.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n);
      }
    }
    return this._effectiveTimeScale = n, n;
  }
  _updateTime(e) {
    const n = this._clip.duration, i = this.loop;
    let s = this.time + e, o = this._loopCount;
    const a = i === sg;
    if (e === 0)
      return o === -1 ? s : a && (o & 1) === 1 ? n - s : s;
    if (i === ng) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      t: {
        if (s >= n)
          s = n;
        else if (s < 0)
          s = 0;
        else {
          this.time = s;
          break t;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = s, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= n || s < 0) {
        const h = Math.floor(s / n);
        s -= n * h, o += Math.abs(h);
        const c = this.repetitions - o;
        if (c <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? n : 0, this.time = s, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (c === 1) {
            const l = e < 0;
            this._setEndings(l, !l, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = o, this.time = s, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: h
          });
        }
      } else
        this.time = s;
      if (a && (o & 1) === 1)
        return n - s;
    }
    return s;
  }
  _setEndings(e, n, i) {
    const s = this._interpolantSettings;
    i ? (s.endingStart = bs, s.endingEnd = bs) : (e ? s.endingStart = this.zeroSlopeAtStart ? bs : ws : s.endingStart = Ao, n ? s.endingEnd = this.zeroSlopeAtEnd ? bs : ws : s.endingEnd = Ao);
  }
  _scheduleFading(e, n, i) {
    const s = this._mixer, o = s.time;
    let a = this._weightInterpolant;
    a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
    const h = a.parameterPositions, c = a.sampleValues;
    return h[0] = o, c[0] = n, h[1] = o + e, c[1] = i, this;
  }
}
const ge = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Mp = 1234567;
const Ss = Math.PI / 180, Ph = 180 / Math.PI;
function Tn() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (ge[r & 255] + ge[r >> 8 & 255] + ge[r >> 16 & 255] + ge[r >> 24 & 255] + "-" + ge[e & 255] + ge[e >> 8 & 255] + "-" + ge[e >> 16 & 15 | 64] + ge[e >> 24 & 255] + "-" + ge[n & 63 | 128] + ge[n >> 8 & 255] + "-" + ge[n >> 16 & 255] + ge[n >> 24 & 255] + ge[i & 255] + ge[i >> 8 & 255] + ge[i >> 16 & 255] + ge[i >> 24 & 255]).toLowerCase();
}
function Mt(r, e, n) {
  return Math.max(e, Math.min(n, r));
}
function ef(r, e) {
  return (r % e + e) % e;
}
function fA(r, e, n, i, s) {
  return i + (r - e) * (s - i) / (n - e);
}
function dA(r, e, n) {
  return r !== e ? (n - r) / (e - r) : 0;
}
function fo(r, e, n) {
  return (1 - n) * r + n * e;
}
function pA(r, e, n, i) {
  return fo(r, e, 1 - Math.exp(-n * i));
}
function yA(r, e = 1) {
  return e - Math.abs(ef(r, e * 2) - e);
}
function xA(r, e, n) {
  return r <= e ? 0 : r >= n ? 1 : (r = (r - e) / (n - e), r * r * (3 - 2 * r));
}
function mA(r, e, n) {
  return r <= e ? 0 : r >= n ? 1 : (r = (r - e) / (n - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function gA(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function wA(r, e) {
  return r + Math.random() * (e - r);
}
function bA(r) {
  return r * (0.5 - Math.random());
}
function vA(r) {
  r !== void 0 && (Mp = r);
  let e = Mp += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function MA(r) {
  return r * Ss;
}
function _A(r) {
  return r * Ph;
}
function SA(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function TA(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function EA(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function zA(r, e, n, i, s) {
  const o = Math.cos, a = Math.sin, h = o(n / 2), c = a(n / 2), l = o((e + i) / 2), u = a((e + i) / 2), f = o((e - i) / 2), d = a((e - i) / 2), p = o((i - e) / 2), y = a((i - e) / 2);
  switch (s) {
    case "XYX":
      r.set(h * u, c * f, c * d, h * l);
      break;
    case "YZY":
      r.set(c * d, h * u, c * f, h * l);
      break;
    case "ZXZ":
      r.set(c * f, c * d, h * u, h * l);
      break;
    case "XZX":
      r.set(h * u, c * y, c * p, h * l);
      break;
    case "YXY":
      r.set(c * p, h * u, c * y, h * l);
      break;
    case "ZYZ":
      r.set(c * y, c * p, h * u, h * l);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Ie(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Tt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const AA = {
  DEG2RAD: Ss,
  RAD2DEG: Ph,
  /**
   * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID: Tn,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp: Mt,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo: ef,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear: fA,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp: dA,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp: fo,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp: pA,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong: yA,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep: xA,
  /**
   * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep: mA,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt: gA,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat: wA,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread: bA,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom: vA,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad: MA,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg: _A,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo: SA,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo: TA,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo: EA,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler: zA,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize: Tt,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize: Ie
};
class $e {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(e = 0, n = 0, i = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = i, this._w = s;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed  in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(e, n, i, s, o, a, h) {
    let c = i[s + 0], l = i[s + 1], u = i[s + 2], f = i[s + 3];
    const d = o[a + 0], p = o[a + 1], y = o[a + 2], x = o[a + 3];
    if (h === 0) {
      e[n + 0] = c, e[n + 1] = l, e[n + 2] = u, e[n + 3] = f;
      return;
    }
    if (h === 1) {
      e[n + 0] = d, e[n + 1] = p, e[n + 2] = y, e[n + 3] = x;
      return;
    }
    if (f !== x || c !== d || l !== p || u !== y) {
      let m = 1 - h;
      const g = c * d + l * p + u * y + f * x, w = g >= 0 ? 1 : -1, M = 1 - g * g;
      if (M > Number.EPSILON) {
        const E = Math.sqrt(M), A = Math.atan2(E, g * w);
        m = Math.sin(m * A) / E, h = Math.sin(h * A) / E;
      }
      const S = h * w;
      if (c = c * m + d * S, l = l * m + p * S, u = u * m + y * S, f = f * m + x * S, m === 1 - h) {
        const E = 1 / Math.sqrt(c * c + l * l + u * u + f * f);
        c *= E, l *= E, u *= E, f *= E;
      }
    }
    e[n] = c, e[n + 1] = l, e[n + 2] = u, e[n + 3] = f;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(e, n, i, s, o, a) {
    const h = i[s], c = i[s + 1], l = i[s + 2], u = i[s + 3], f = o[a], d = o[a + 1], p = o[a + 2], y = o[a + 3];
    return e[n] = h * y + u * f + c * p - l * d, e[n + 1] = c * y + u * d + l * f - h * p, e[n + 2] = l * y + u * p + h * d - c * f, e[n + 3] = u * y - h * f - c * d - l * p, e;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(e, n, i, s) {
    return this._x = e, this._y = n, this._z = i, this._w = s, this._onChangeCallback(), this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(e, n = !0) {
    const i = e._x, s = e._y, o = e._z, a = e._order, h = Math.cos, c = Math.sin, l = h(i / 2), u = h(s / 2), f = h(o / 2), d = c(i / 2), p = c(s / 2), y = c(o / 2);
    switch (a) {
      case "XYZ":
        this._x = d * u * f + l * p * y, this._y = l * p * f - d * u * y, this._z = l * u * y + d * p * f, this._w = l * u * f - d * p * y;
        break;
      case "YXZ":
        this._x = d * u * f + l * p * y, this._y = l * p * f - d * u * y, this._z = l * u * y - d * p * f, this._w = l * u * f + d * p * y;
        break;
      case "ZXY":
        this._x = d * u * f - l * p * y, this._y = l * p * f + d * u * y, this._z = l * u * y + d * p * f, this._w = l * u * f - d * p * y;
        break;
      case "ZYX":
        this._x = d * u * f - l * p * y, this._y = l * p * f + d * u * y, this._z = l * u * y - d * p * f, this._w = l * u * f + d * p * y;
        break;
      case "YZX":
        this._x = d * u * f + l * p * y, this._y = l * p * f + d * u * y, this._z = l * u * y - d * p * f, this._w = l * u * f - d * p * y;
        break;
      case "XZY":
        this._x = d * u * f - l * p * y, this._y = l * p * f - d * u * y, this._z = l * u * y + d * p * f, this._w = l * u * f + d * p * y;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(e, n) {
    const i = n / 2, s = Math.sin(i);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(e) {
    const n = e.elements, i = n[0], s = n[4], o = n[8], a = n[1], h = n[5], c = n[9], l = n[2], u = n[6], f = n[10], d = i + h + f;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (u - c) * p, this._y = (o - l) * p, this._z = (a - s) * p;
    } else if (i > h && i > f) {
      const p = 2 * Math.sqrt(1 + i - h - f);
      this._w = (u - c) / p, this._x = 0.25 * p, this._y = (s + a) / p, this._z = (o + l) / p;
    } else if (h > f) {
      const p = 2 * Math.sqrt(1 + h - i - f);
      this._w = (o - l) / p, this._x = (s + a) / p, this._y = 0.25 * p, this._z = (c + u) / p;
    } else {
      const p = 2 * Math.sqrt(1 + f - i - h);
      this._w = (a - s) / p, this._x = (o + l) / p, this._y = (c + u) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return i < 1e-8 ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = i), this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Mt(this.dot(e), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const s = Math.min(1, n / i);
    return this.slerp(e, s), this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(e, n) {
    const i = e._x, s = e._y, o = e._z, a = e._w, h = n._x, c = n._y, l = n._z, u = n._w;
    return this._x = i * u + a * h + s * l - o * c, this._y = s * u + a * c + o * h - i * l, this._z = o * u + a * l + i * c - s * h, this._w = a * u - i * h - s * c - o * l, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x, s = this._y, o = this._z, a = this._w;
    let h = a * e._w + i * e._x + s * e._y + o * e._z;
    if (h < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, h = -h) : this.copy(e), h >= 1)
      return this._w = a, this._x = i, this._y = s, this._z = o, this;
    const c = 1 - h * h;
    if (c <= Number.EPSILON) {
      const p = 1 - n;
      return this._w = p * a + n * this._w, this._x = p * i + n * this._x, this._y = p * s + n * this._y, this._z = p * o + n * this._z, this.normalize(), this;
    }
    const l = Math.sqrt(c), u = Math.atan2(l, h), f = Math.sin((1 - n) * u) / l, d = Math.sin(n * u) / l;
    return this._w = a * f + this._w * d, this._x = i * f + this._x * d, this._y = s * f + this._y * d, this._z = o * f + this._z * d, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), i = Math.random(), s = Math.sqrt(1 - i), o = Math.sqrt(i);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      o * Math.sin(n),
      o * Math.cos(n)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
function vs(r, e) {
  return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r);
}
function og(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function ag(r) {
  function e(s, o) {
    return r[s] - r[o];
  }
  const n = r.length, i = new Array(n);
  for (let s = 0; s !== n; ++s) i[s] = s;
  return i.sort(e), i;
}
function tu(r, e, n) {
  const i = r.length, s = new r.constructor(i);
  for (let o = 0, a = 0; a !== i; ++o) {
    const h = n[o] * e;
    for (let c = 0; c !== e; ++c)
      s[a++] = r[h + c];
  }
  return s;
}
function nf(r, e, n, i) {
  let s = 1, o = r[0];
  for (; o !== void 0 && o[i] === void 0; )
    o = r[s++];
  if (o === void 0) return;
  let a = o[i];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = o[i], a !== void 0 && (e.push(o.time), n.push(...a)), o = r[s++];
      while (o !== void 0);
    else if (a.toArray !== void 0)
      do
        a = o[i], a !== void 0 && (e.push(o.time), a.toArray(n, n.length)), o = r[s++];
      while (o !== void 0);
    else
      do
        a = o[i], a !== void 0 && (e.push(o.time), n.push(a)), o = r[s++];
      while (o !== void 0);
}
function CA(r, e, n, i, s = 30) {
  const o = r.clone();
  o.name = e;
  const a = [];
  for (let c = 0; c < o.tracks.length; ++c) {
    const l = o.tracks[c], u = l.getValueSize(), f = [], d = [];
    for (let p = 0; p < l.times.length; ++p) {
      const y = l.times[p] * s;
      if (!(y < n || y >= i)) {
        f.push(l.times[p]);
        for (let x = 0; x < u; ++x)
          d.push(l.values[p * u + x]);
      }
    }
    f.length !== 0 && (l.times = vs(f, l.times.constructor), l.values = vs(d, l.values.constructor), a.push(l));
  }
  o.tracks = a;
  let h = 1 / 0;
  for (let c = 0; c < o.tracks.length; ++c)
    h > o.tracks[c].times[0] && (h = o.tracks[c].times[0]);
  for (let c = 0; c < o.tracks.length; ++c)
    o.tracks[c].shift(-1 * h);
  return o.resetDuration(), o;
}
function PA(r, e = 0, n = r, i = 30) {
  i <= 0 && (i = 30);
  const s = n.tracks.length, o = e / i;
  for (let a = 0; a < s; ++a) {
    const h = n.tracks[a], c = h.ValueTypeName;
    if (c === "bool" || c === "string") continue;
    const l = r.tracks.find(function(g) {
      return g.name === h.name && g.ValueTypeName === c;
    });
    if (l === void 0) continue;
    let u = 0;
    const f = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = f / 3);
    let d = 0;
    const p = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = p / 3);
    const y = h.times.length - 1;
    let x;
    if (o <= h.times[0]) {
      const g = u, w = f - u;
      x = h.values.slice(g, w);
    } else if (o >= h.times[y]) {
      const g = y * f + u, w = g + f - u;
      x = h.values.slice(g, w);
    } else {
      const g = h.createInterpolant(), w = u, M = f - u;
      g.evaluate(o), x = g.resultBuffer.slice(w, M);
    }
    c === "quaternion" && new $e().fromArray(x).normalize().conjugate().toArray(x);
    const m = l.times.length;
    for (let g = 0; g < m; ++g) {
      const w = g * p + d;
      if (c === "quaternion")
        $e.multiplyQuaternionsFlat(
          l.values,
          w,
          x,
          0,
          l.values,
          w
        );
      else {
        const M = p - d * 2;
        for (let S = 0; S < M; ++S)
          l.values[w + S] -= x[S];
      }
    }
  }
  return r.blendMode = Ku, r;
}
class IA {
  /**
   * Converts an array to a specific type
   *
   * @static
   * @param {TypedArray|Array} array - The array to convert.
   * @param {TypedArray.constructor} type - The constructor of a type array.
   * @return {TypedArray} The converted array
   */
  static convertArray(e, n) {
    return vs(e, n);
  }
  /**
   * Returns `true` if the given object is a typed array.
   *
   * @static
   * @param {any} object - The object to check.
   * @return {boolean} Whether the given object is a typed array.
   */
  static isTypedArray(e) {
    return og(e);
  }
  /**
   * Returns an array by which times and values can be sorted.
   *
   * @static
   * @param {Array<number>} times - The keyframe time values.
   * @return {Array<number>} The array.
   */
  static getKeyframeOrder(e) {
    return ag(e);
  }
  /**
   * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
   *
   * @static
   * @param {Array<number>} values - The values to sort.
   * @param {number} stride - The stride.
   * @param {Array<number>} order - The sort order.
   * @return {Array<number>} The sorted values.
   */
  static sortedArray(e, n, i) {
    return tu(e, n, i);
  }
  /**
   * Used for parsing AOS keyframe formats.
   *
   * @static
   * @param {Array<number>} jsonKeys - A list of JSON keyframes.
   * @param {Array<number>} times - This array will be filled with keyframe times by this method.
   * @param {Array<number>} values - This array will be filled with keyframe values by this method.
   * @param {string} valuePropertyName - The name of the property to use.
   */
  static flattenJSON(e, n, i, s) {
    nf(e, n, i, s);
  }
  /**
   * Creates a new clip, containing only the segment of the original clip between the given frames.
   *
   * @static
   * @param {AnimationClip} sourceClip - The values to sort.
   * @param {string} name - The name of the clip.
   * @param {number} startFrame - The start frame.
   * @param {number} endFrame - The end frame.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The new sub clip.
   */
  static subclip(e, n, i, s, o = 30) {
    return CA(e, n, i, s, o);
  }
  /**
   * Converts the keyframes of the given animation clip to an additive format.
   *
   * @static
   * @param {AnimationClip} targetClip - The clip to make additive.
   * @param {number} [referenceFrame=0] - The reference frame.
   * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The updated clip which is now additive.
   */
  static makeClipAdditive(e, n = 0, i = e, s = 30) {
    return PA(e, n, i, s);
  }
}
class Uo {
  /**
   * Constructs a new interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, i, s) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new n.constructor(i), this.sampleValues = n, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  /**
   * Evaluate the interpolant at position `t`.
   *
   * @param {number} t - The interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  evaluate(e) {
    const n = this.parameterPositions;
    let i = this._cachedIndex, s = n[i], o = n[i - 1];
    t: {
      e: {
        let a;
        n: {
          i: if (!(e < s)) {
            for (let h = i + 2; ; ) {
              if (s === void 0) {
                if (e < o) break i;
                return i = n.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
              }
              if (i === h) break;
              if (o = s, s = n[++i], e < s)
                break e;
            }
            a = n.length;
            break n;
          }
          if (!(e >= o)) {
            const h = n[1];
            e < h && (i = 2, o = h);
            for (let c = i - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === c) break;
              if (s = o, o = n[--i - 1], e >= o)
                break e;
            }
            a = i, i = 0;
            break n;
          }
          break t;
        }
        for (; i < a; ) {
          const h = i + a >>> 1;
          e < n[h] ? a = h : i = h + 1;
        }
        if (s = n[i], o = n[i - 1], o === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (s === void 0)
          return i = n.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, o, s);
    }
    return this.interpolate_(i, o, e, s);
  }
  /**
   * Returns the interpolation settings.
   *
   * @return {Object} The interpolation settings.
   */
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @param {number} index - An index into the sample value buffer.
   * @return {TypedArray} The result buffer.
   */
  copySampleValue_(e) {
    const n = this.resultBuffer, i = this.sampleValues, s = this.valueSize, o = e * s;
    for (let a = 0; a !== s; ++a)
      n[a] = i[o + a];
    return n;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @abstract
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   * @param {number} t1 - The next interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  interpolate_() {
    throw new Error("call to abstract method");
  }
  /**
   * Optional method that is executed when the interval has changed.
   *
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   */
  intervalChanged_() {
  }
}
class hg extends Uo {
  /**
   * Constructs a new cubic interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: ws,
      endingEnd: ws
    };
  }
  intervalChanged_(e, n, i) {
    const s = this.parameterPositions;
    let o = e - 2, a = e + 1, h = s[o], c = s[a];
    if (h === void 0)
      switch (this.getSettings_().endingStart) {
        case bs:
          o = e, h = 2 * n - i;
          break;
        case Ao:
          o = s.length - 2, h = n + s[o] - s[o + 1];
          break;
        default:
          o = e, h = i;
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case bs:
          a = e, c = 2 * i - n;
          break;
        case Ao:
          a = 1, c = i + s[1] - s[0];
          break;
        default:
          a = e - 1, c = n;
      }
    const l = (i - n) * 0.5, u = this.valueSize;
    this._weightPrev = l / (n - h), this._weightNext = l / (c - i), this._offsetPrev = o * u, this._offsetNext = a * u;
  }
  interpolate_(e, n, i, s) {
    const o = this.resultBuffer, a = this.sampleValues, h = this.valueSize, c = e * h, l = c - h, u = this._offsetPrev, f = this._offsetNext, d = this._weightPrev, p = this._weightNext, y = (i - n) / (s - n), x = y * y, m = x * y, g = -d * m + 2 * d * x - d * y, w = (1 + d) * m + (-1.5 - 2 * d) * x + (-0.5 + d) * y + 1, M = (-1 - p) * m + (1.5 + p) * x + 0.5 * y, S = p * m - p * x;
    for (let E = 0; E !== h; ++E)
      o[E] = g * a[u + E] + w * a[l + E] + M * a[c + E] + S * a[f + E];
    return o;
  }
}
class sf extends Uo {
  /**
   * Constructs a new linear interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s);
  }
  interpolate_(e, n, i, s) {
    const o = this.resultBuffer, a = this.sampleValues, h = this.valueSize, c = e * h, l = c - h, u = (i - n) / (s - n), f = 1 - u;
    for (let d = 0; d !== h; ++d)
      o[d] = a[l + d] * f + a[c + d] * u;
    return o;
  }
}
class cg extends Uo {
  /**
   * Constructs a new discrete interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class cn {
  /**
   * Constructs a new keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, i, s) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (n === void 0 || n.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = vs(n, this.TimeBufferType), this.values = vs(i, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation);
  }
  /**
   * Converts the keyframe track to JSON.
   *
   * @static
   * @param {KeyframeTrack} track - The keyframe track to serialize.
   * @return {Object} The serialized keyframe track as JSON.
   */
  static toJSON(e) {
    const n = e.constructor;
    let i;
    if (n.toJSON !== this.toJSON)
      i = n.toJSON(e);
    else {
      i = {
        name: e.name,
        times: vs(e.times, Array),
        values: vs(e.values, Array)
      };
      const s = e.getInterpolation();
      s !== e.DefaultInterpolation && (i.interpolation = s);
    }
    return i.type = e.ValueTypeName, i;
  }
  /**
   * Factory method for creating a new discrete interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {DiscreteInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodDiscrete(e) {
    return new cg(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new linear interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {LinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new sf(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new smooth interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {CubicInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodSmooth(e) {
    return new hg(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Defines the interpolation factor method for this keyframe track.
   *
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  setInterpolation(e) {
    let n;
    switch (e) {
      case zo:
        n = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ch:
        n = this.InterpolantFactoryMethodLinear;
        break;
      case Ka:
        n = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (n === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = n, this;
  }
  /**
   * Returns the current interpolation type.
   *
   * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
   */
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return zo;
      case this.InterpolantFactoryMethodLinear:
        return Ch;
      case this.InterpolantFactoryMethodSmooth:
        return Ka;
    }
  }
  /**
   * Returns the value size.
   *
   * @return {number} The value size.
   */
  getValueSize() {
    return this.values.length / this.times.length;
  }
  /**
   * Moves all keyframes either forward or backward in time.
   *
   * @param {number} timeOffset - The offset to move the time values.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  shift(e) {
    if (e !== 0) {
      const n = this.times;
      for (let i = 0, s = n.length; i !== s; ++i)
        n[i] += e;
    }
    return this;
  }
  /**
   * Scale all keyframe times by a factor (useful for frame - seconds conversions).
   *
   * @param {number} timeScale - The time scale.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  scale(e) {
    if (e !== 1) {
      const n = this.times;
      for (let i = 0, s = n.length; i !== s; ++i)
        n[i] *= e;
    }
    return this;
  }
  /**
   * Removes keyframes before and after animation without changing any values within the defined time range.
   *
   * Note: The method does not shift around keys to the start of the track time, because for interpolated
   * keys this will change their values
   *
   * @param {number} startTime - The start time.
   * @param {number} endTime - The end time.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  trim(e, n) {
    const i = this.times, s = i.length;
    let o = 0, a = s - 1;
    for (; o !== s && i[o] < e; )
      ++o;
    for (; a !== -1 && i[a] > n; )
      --a;
    if (++a, o !== 0 || a !== s) {
      o >= a && (a = Math.max(a, 1), o = a - 1);
      const h = this.getValueSize();
      this.times = i.slice(o, a), this.values = this.values.slice(o * h, a * h);
    }
    return this;
  }
  /**
   * Performs minimal validation on the keyframe track. Returns `true` if the values
   * are valid.
   *
   * @return {boolean} Whether the keyframes are valid or not.
   */
  validate() {
    let e = !0;
    const n = this.getValueSize();
    n - Math.floor(n) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const i = this.times, s = this.values, o = i.length;
    o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let a = null;
    for (let h = 0; h !== o; h++) {
      const c = i[h];
      if (typeof c == "number" && isNaN(c)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, h, c), e = !1;
        break;
      }
      if (a !== null && a > c) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, h, c, a), e = !1;
        break;
      }
      a = c;
    }
    if (s !== void 0 && og(s))
      for (let h = 0, c = s.length; h !== c; ++h) {
        const l = s[h];
        if (isNaN(l)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, h, l), e = !1;
          break;
        }
      }
    return e;
  }
  /**
   * Optimizes this keyframe track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    const e = this.times.slice(), n = this.values.slice(), i = this.getValueSize(), s = this.getInterpolation() === Ka, o = e.length - 1;
    let a = 1;
    for (let h = 1; h < o; ++h) {
      let c = !1;
      const l = e[h], u = e[h + 1];
      if (l !== u && (h !== 1 || l !== e[0]))
        if (s)
          c = !0;
        else {
          const f = h * i, d = f - i, p = f + i;
          for (let y = 0; y !== i; ++y) {
            const x = n[f + y];
            if (x !== n[d + y] || x !== n[p + y]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (h !== a) {
          e[a] = e[h];
          const f = h * i, d = a * i;
          for (let p = 0; p !== i; ++p)
            n[d + p] = n[f + p];
        }
        ++a;
      }
    }
    if (o > 0) {
      e[a] = e[o];
      for (let h = o * i, c = a * i, l = 0; l !== i; ++l)
        n[c + l] = n[h + l];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = n.slice(0, a * i)) : (this.times = e, this.values = n), this;
  }
  /**
   * Returns a new keyframe track with copied values from this instance.
   *
   * @return {KeyframeTrack} A clone of this instance.
   */
  clone() {
    const e = this.times.slice(), n = this.values.slice(), i = this.constructor, s = new i(this.name, e, n);
    return s.createInterpolant = this.createInterpolant, s;
  }
}
cn.prototype.ValueTypeName = "";
cn.prototype.TimeBufferType = Float32Array;
cn.prototype.ValueBufferType = Float32Array;
cn.prototype.DefaultInterpolation = Ch;
class Bs extends cn {
  /**
   * Constructs a new boolean keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   */
  constructor(e, n, i) {
    super(e, n, i);
  }
}
Bs.prototype.ValueTypeName = "bool";
Bs.prototype.ValueBufferType = Array;
Bs.prototype.DefaultInterpolation = zo;
Bs.prototype.InterpolantFactoryMethodLinear = void 0;
Bs.prototype.InterpolantFactoryMethodSmooth = void 0;
class rf extends cn {
  /**
   * Constructs a new color keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s);
  }
}
rf.prototype.ValueTypeName = "color";
class Io extends cn {
  /**
   * Constructs a new number keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s);
  }
}
Io.prototype.ValueTypeName = "number";
class lg extends Uo {
  /**
   * Constructs a new SLERP interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s);
  }
  interpolate_(e, n, i, s) {
    const o = this.resultBuffer, a = this.sampleValues, h = this.valueSize, c = (i - n) / (s - n);
    let l = e * h;
    for (let u = l + h; l !== u; l += 4)
      $e.slerpFlat(o, 0, a, l - h, a, l, c);
    return o;
  }
}
class Wo extends cn {
  /**
   * Constructs a new Quaternion keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s);
  }
  /**
   * Overwritten so the method returns Quaternion based interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {QuaternionLinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new lg(this.times, this.values, this.getValueSize(), e);
  }
}
Wo.prototype.ValueTypeName = "quaternion";
Wo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Fs extends cn {
  /**
   * Constructs a new string keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   */
  constructor(e, n, i) {
    super(e, n, i);
  }
}
Fs.prototype.ValueTypeName = "string";
Fs.prototype.ValueBufferType = Array;
Fs.prototype.DefaultInterpolation = zo;
Fs.prototype.InterpolantFactoryMethodLinear = void 0;
Fs.prototype.InterpolantFactoryMethodSmooth = void 0;
class ko extends cn {
  /**
   * Constructs a new vector keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, i, s) {
    super(e, n, i, s);
  }
}
ko.prototype.ValueTypeName = "vector";
class eu {
  /**
   * Constructs a new animation clip.
   *
   * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
   * use the static interface of this class for creating clips. In most cases though, animation clips
   * will automatically be created by loaders when importing animated 3D assets.
   *
   * @param {string} [name=''] - The clip's name.
   * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
   * the duration will be calculated from the passed keyframes.
   * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
   * is blended/combined when two or more animations are simultaneously played.
   */
  constructor(e = "", n = -1, i = [], s = Hh) {
    this.name = e, this.tracks = i, this.duration = n, this.blendMode = s, this.uuid = Tn(), this.duration < 0 && this.resetDuration();
  }
  /**
   * Factory method for creating an animation clip from the given JSON.
   *
   * @static
   * @param {Object} json - The serialized animation clip.
   * @return {AnimationClip} The new animation clip.
   */
  static parse(e) {
    const n = [], i = e.tracks, s = 1 / (e.fps || 1);
    for (let a = 0, h = i.length; a !== h; ++a)
      n.push(RA(i[a]).scale(s));
    const o = new this(e.name, e.duration, n, e.blendMode);
    return o.uuid = e.uuid, o;
  }
  /**
   * Serializes the given animation clip into JSON.
   *
   * @static
   * @param {AnimationClip} clip - The animation clip to serialize.
   * @return {Object} The JSON object.
   */
  static toJSON(e) {
    const n = [], i = e.tracks, s = {
      name: e.name,
      duration: e.duration,
      tracks: n,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let o = 0, a = i.length; o !== a; ++o)
      n.push(cn.toJSON(i[o]));
    return s;
  }
  /**
   * Returns a new animation clip from the passed morph targets array of a
   * geometry, taking a name and the number of frames per second.
   *
   * Note: The fps parameter is required, but the animation speed can be
   * overridden via {@link AnimationAction#setDuration}.
   *
   * @static
   * @param {string} name - The name of the animation clip.
   * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {AnimationClip} The new animation clip.
   */
  static CreateFromMorphTargetSequence(e, n, i, s) {
    const o = n.length, a = [];
    for (let h = 0; h < o; h++) {
      let c = [], l = [];
      c.push(
        (h + o - 1) % o,
        h,
        (h + 1) % o
      ), l.push(0, 1, 0);
      const u = ag(c);
      c = tu(c, 1, u), l = tu(l, 1, u), !s && c[0] === 0 && (c.push(o), l.push(l[0])), a.push(
        new Io(
          ".morphTargetInfluences[" + n[h].name + "]",
          c,
          l
        ).scale(1 / i)
      );
    }
    return new this(e, -1, a);
  }
  /**
   * Searches for an animation clip by name, taking as its first parameter
   * either an array of clips, or a mesh or geometry that contains an
   * array named "animations" property.
   *
   * @static
   * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
   * @param {string} name - The name to search for.
   * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
   */
  static findByName(e, n) {
    let i = e;
    if (!Array.isArray(e)) {
      const s = e;
      i = s.geometry && s.geometry.animations || s.animations;
    }
    for (let s = 0; s < i.length; s++)
      if (i[s].name === n)
        return i[s];
    return null;
  }
  /**
   * Returns an array of new AnimationClips created from the morph target
   * sequences of a geometry, trying to sort morph target names into
   * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
   *
   * See {@link MD2Loader#parse} as an example for how the method should be used.
   *
   * @static
   * @param {Array<Object>} morphTargets - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {Array<AnimationClip>} An array of new animation clips.
   */
  static CreateClipsFromMorphTargetSequences(e, n, i) {
    const s = {}, o = /^([\w-]*?)([\d]+)$/;
    for (let h = 0, c = e.length; h < c; h++) {
      const l = e[h], u = l.name.match(o);
      if (u && u.length > 1) {
        const f = u[1];
        let d = s[f];
        d || (s[f] = d = []), d.push(l);
      }
    }
    const a = [];
    for (const h in s)
      a.push(this.CreateFromMorphTargetSequence(h, s[h], n, i));
    return a;
  }
  /**
   * Parses the `animation.hierarchy` format and returns a new animation clip.
   *
   * @static
   * @deprecated since r175.
   * @param {Object} animation - A serialized animation clip as JSON.
   * @param {Array<Bones>} bones - An array of bones.
   * @return {?AnimationClip} The new animation clip.
   */
  static parseAnimation(e, n) {
    if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(f, d, p, y, x) {
      if (p.length !== 0) {
        const m = [], g = [];
        nf(p, m, g, y), m.length !== 0 && x.push(new f(d, m, g));
      }
    }, s = [], o = e.name || "default", a = e.fps || 30, h = e.blendMode;
    let c = e.length || -1;
    const l = e.hierarchy || [];
    for (let f = 0; f < l.length; f++) {
      const d = l[f].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const p = {};
          let y;
          for (y = 0; y < d.length; y++)
            if (d[y].morphTargets)
              for (let x = 0; x < d[y].morphTargets.length; x++)
                p[d[y].morphTargets[x]] = -1;
          for (const x in p) {
            const m = [], g = [];
            for (let w = 0; w !== d[y].morphTargets.length; ++w) {
              const M = d[y];
              m.push(M.time), g.push(M.morphTarget === x ? 1 : 0);
            }
            s.push(new Io(".morphTargetInfluence[" + x + "]", m, g));
          }
          c = p.length * a;
        } else {
          const p = ".bones[" + n[f].name + "]";
          i(
            ko,
            p + ".position",
            d,
            "pos",
            s
          ), i(
            Wo,
            p + ".quaternion",
            d,
            "rot",
            s
          ), i(
            ko,
            p + ".scale",
            d,
            "scl",
            s
          );
        }
    }
    return s.length === 0 ? null : new this(o, c, s, h);
  }
  /**
   * Sets the duration of this clip to the duration of its longest keyframe track.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  resetDuration() {
    const e = this.tracks;
    let n = 0;
    for (let i = 0, s = e.length; i !== s; ++i) {
      const o = this.tracks[i];
      n = Math.max(n, o.times[o.times.length - 1]);
    }
    return this.duration = n, this;
  }
  /**
   * Trims all tracks to the clip's duration.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  /**
   * Performs minimal validation on each track in the clip. Returns `true` if all
   * tracks are valid.
   *
   * @return {boolean} Whether the clip's keyframes are valid or not.
   */
  validate() {
    let e = !0;
    for (let n = 0; n < this.tracks.length; n++)
      e = e && this.tracks[n].validate();
    return e;
  }
  /**
   * Optimizes each track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  /**
   * Returns a new animation clip with copied values from this instance.
   *
   * @return {AnimationClip} A clone of this instance.
   */
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++)
      e.push(this.tracks[n].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  /**
   * Serializes this animation clip into JSON.
   *
   * @return {Object} The JSON object.
   */
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function kA(r) {
  switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Io;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ko;
    case "color":
      return rf;
    case "quaternion":
      return Wo;
    case "bool":
    case "boolean":
      return Bs;
    case "string":
      return Fs;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
}
function RA(r) {
  if (r.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = kA(r.type);
  if (r.times === void 0) {
    const n = [], i = [];
    nf(r.keys, n, i, "value"), r.times = n, r.values = i;
  }
  return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation);
}
class Li {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(e, n) {
    const i = this._listeners;
    return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(e, n) {
    const i = this._listeners;
    if (i === void 0) return;
    const s = i[e];
    if (s !== void 0) {
      const o = s.indexOf(n);
      o !== -1 && s.splice(o, 1);
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(e) {
    const n = this._listeners;
    if (n === void 0) return;
    const i = n[e.type];
    if (i !== void 0) {
      e.target = this;
      const s = i.slice(0);
      for (let o = 0, a = s.length; o < a; o++)
        s[o].call(this, e);
      e.target = null;
    }
  }
}
const of = "\\[\\]\\.:\\/", OA = new RegExp("[" + of + "]", "g"), af = "[^" + of + "]", LA = "[^" + of.replace("\\.", "") + "]", BA = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", af), FA = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", LA), NA = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", af), qA = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", af), DA = new RegExp(
  "^" + BA + FA + NA + qA + "$"
), $A = ["material", "materials", "bones", "map"];
class VA {
  constructor(e, n, i) {
    const s = i || kt.parseTrackName(n);
    this._targetGroup = e, this._bindings = e.subscribe_(n, s);
  }
  getValue(e, n) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, s = this._bindings[i];
    s !== void 0 && s.getValue(e, n);
  }
  setValue(e, n) {
    const i = this._bindings;
    for (let s = this._targetGroup.nCachedObjects_, o = i.length; s !== o; ++s)
      i[s].setValue(e, n);
  }
  bind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, i = e.length; n !== i; ++n)
      e[n].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, i = e.length; n !== i; ++n)
      e[n].unbind();
  }
}
class kt {
  /**
   * Constructs a new property binding.
   *
   * @param {Object} rootNode - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   */
  constructor(e, n, i) {
    this.path = n, this.parsedPath = i || kt.parseTrackName(n), this.node = kt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  /**
   * Factory method for creating a property binding from the given parameters.
   *
   * @static
   * @param {Object} root - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   * @return {PropertyBinding|Composite} The created property binding or composite.
   */
  static create(e, n, i) {
    return e && e.isAnimationObjectGroup ? new kt.Composite(e, n, i) : new kt(e, n, i);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name - Node name to be sanitized.
   * @return {string} The sanitized node name.
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(OA, "");
  }
  /**
   * Parses the given track name (an object path to an animated property) and
   * returns an object with information about the path. Matches strings in the following forms:
   *
   * - nodeName.property
   * - nodeName.property[accessor]
   * - nodeName.material.property[accessor]
   * - uuid.property[accessor]
   * - uuid.objectName[objectIndex].propertyName[propertyIndex]
   * - parentName/nodeName.property
   * - parentName/parentName/nodeName.property[index]
   * - .bone[Armature.DEF_cog].position
   * - scene:helium_balloon_model:helium_balloon_model.position
   *
   * @static
   * @param {string} trackName - The track name to parse.
   * @return {Object} The parsed track name as an object.
   */
  static parseTrackName(e) {
    const n = DA.exec(e);
    if (n === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: n[2],
      objectName: n[3],
      objectIndex: n[4],
      propertyName: n[5],
      // required
      propertyIndex: n[6]
    }, s = i.nodeName && i.nodeName.lastIndexOf(".");
    if (s !== void 0 && s !== -1) {
      const o = i.nodeName.substring(s + 1);
      $A.indexOf(o) !== -1 && (i.nodeName = i.nodeName.substring(0, s), i.objectName = o);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  /**
   * Searches for a node in the hierarchy of the given root object by the given
   * node name.
   *
   * @static
   * @param {Object} root - The root object.
   * @param {string|number} nodeName - The name of the node.
   * @return {?Object} The found node. Returns `null` if no object was found.
   */
  static findNode(e, n) {
    if (n === void 0 || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(n);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(o) {
        for (let a = 0; a < o.length; a++) {
          const h = o[a];
          if (h.name === n || h.uuid === n)
            return h;
          const c = i(h.children);
          if (c) return c;
        }
        return null;
      }, s = i(e.children);
      if (s)
        return s;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, n) {
    e[n] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, n) {
    const i = this.resolvedProperty;
    for (let s = 0, o = i.length; s !== o; ++s)
      e[n++] = i[s];
  }
  _getValue_arrayElement(e, n) {
    e[n] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, n) {
    this.resolvedProperty.toArray(e, n);
  }
  // Direct
  _setValue_direct(e, n) {
    this.targetObject[this.propertyName] = e[n];
  }
  _setValue_direct_setNeedsUpdate(e, n) {
    this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
    this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, n) {
    const i = this.resolvedProperty;
    for (let s = 0, o = i.length; s !== o; ++s)
      i[s] = e[n++];
  }
  _setValue_array_setNeedsUpdate(e, n) {
    const i = this.resolvedProperty;
    for (let s = 0, o = i.length; s !== o; ++s)
      i[s] = e[n++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
    const i = this.resolvedProperty;
    for (let s = 0, o = i.length; s !== o; ++s)
      i[s] = e[n++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n];
  }
  _setValue_arrayElement_setNeedsUpdate(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, n) {
    this.resolvedProperty.fromArray(e, n);
  }
  _setValue_fromArray_setNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, n) {
    this.bind(), this.getValue(e, n);
  }
  _setValue_unbound(e, n) {
    this.bind(), this.setValue(e, n);
  }
  /**
   * Creates a getter / setter pair for the property tracked by this binding.
   */
  bind() {
    let e = this.node;
    const n = this.parsedPath, i = n.objectName, s = n.propertyName;
    let o = n.propertyIndex;
    if (e || (e = kt.findNode(this.rootNode, n.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (i) {
      let l = n.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === l) {
              l = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (l !== void 0) {
        if (e[l] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[l];
      }
    }
    const a = e[s];
    if (a === void 0) {
      const l = n.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + s + " but it wasn't found.", e);
      return;
    }
    let h = this.Versioning.None;
    this.targetObject = e, e.isMaterial === !0 ? h = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (h = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (o !== void 0) {
      if (s === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]);
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = o;
    } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = s;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][h];
  }
  /**
   * Unbinds the property.
   */
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
kt.Composite = VA;
kt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
kt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
kt.prototype.GetterByBindingType = [
  kt.prototype._getValue_direct,
  kt.prototype._getValue_array,
  kt.prototype._getValue_arrayElement,
  kt.prototype._getValue_toArray
];
kt.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    kt.prototype._setValue_direct,
    kt.prototype._setValue_direct_setNeedsUpdate,
    kt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    kt.prototype._setValue_array,
    kt.prototype._setValue_array_setNeedsUpdate,
    kt.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    kt.prototype._setValue_arrayElement,
    kt.prototype._setValue_arrayElement_setNeedsUpdate,
    kt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    kt.prototype._setValue_fromArray,
    kt.prototype._setValue_fromArray_setNeedsUpdate,
    kt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class ug {
  /**
   * Constructs a new property mixer.
   *
   * @param {PropertyBinding} binding - The property binding.
   * @param {string} typeName - The keyframe track type name.
   * @param {number} valueSize - The keyframe track value size.
   */
  constructor(e, n, i) {
    this.binding = e, this.valueSize = i;
    let s, o, a;
    switch (n) {
      case "quaternion":
        s = this._slerp, o = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        s = this._select, o = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        s = this._lerp, o = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = s, this._mixBufferRegionAdditive = o, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  /**
   * Accumulates data in the `incoming` region into `accu<i>`.
   *
   * @param {number} accuIndex - The accumulation index.
   * @param {number} weight - The weight.
   */
  accumulate(e, n) {
    const i = this.buffer, s = this.valueSize, o = e * s + s;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let h = 0; h !== s; ++h)
        i[o + h] = i[h];
      a = n;
    } else {
      a += n;
      const h = n / a;
      this._mixBufferRegion(i, o, 0, h, s);
    }
    this.cumulativeWeight = a;
  }
  /**
   * Accumulates data in the `incoming` region into `add`.
   *
   * @param {number} weight - The weight.
   */
  accumulateAdditive(e) {
    const n = this.buffer, i = this.valueSize, s = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(n, s, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  /**
   * Applies the state of `accu<i>` to the binding when accus differ.
   *
   * @param {number} accuIndex - The accumulation index.
   */
  apply(e) {
    const n = this.valueSize, i = this.buffer, s = e * n + n, o = this.cumulativeWeight, a = this.cumulativeWeightAdditive, h = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
      const c = n * this._origIndex;
      this._mixBufferRegion(
        i,
        s,
        c,
        1 - o,
        n
      );
    }
    a > 0 && this._mixBufferRegionAdditive(i, s, this._addIndex * n, 1, n);
    for (let c = n, l = n + n; c !== l; ++c)
      if (i[c] !== i[c + n]) {
        h.setValue(i, s);
        break;
      }
  }
  /**
   * Remembers the state of the bound property and copy it to both accus.
   */
  saveOriginalState() {
    const e = this.binding, n = this.buffer, i = this.valueSize, s = i * this._origIndex;
    e.getValue(n, s);
    for (let o = i, a = s; o !== a; ++o)
      n[o] = n[s + o % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  /**
   * Applies the state previously taken via {@link PropertyMixer#saveOriginalState} to the binding.
   */
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  // internals
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, n = e + this.valueSize;
    for (let i = e; i < n; i++)
      this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, n = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[n + i] = this.buffer[e + i];
  }
  // mix functions
  _select(e, n, i, s, o) {
    if (s >= 0.5)
      for (let a = 0; a !== o; ++a)
        e[n + a] = e[i + a];
  }
  _slerp(e, n, i, s) {
    $e.slerpFlat(e, n, e, n, e, i, s);
  }
  _slerpAdditive(e, n, i, s, o) {
    const a = this._workIndex * o;
    $e.multiplyQuaternionsFlat(e, a, e, n, e, i), $e.slerpFlat(e, n, e, n, e, a, s);
  }
  _lerp(e, n, i, s, o) {
    const a = 1 - s;
    for (let h = 0; h !== o; ++h) {
      const c = n + h;
      e[c] = e[c] * a + e[i + h] * s;
    }
  }
  _lerpAdditive(e, n, i, s, o) {
    for (let a = 0; a !== o; ++a) {
      const h = n + a;
      e[h] = e[h] + e[i + a] * s;
    }
  }
}
const UA = new Float32Array(1);
class WA extends Li {
  /**
   * Constructs a new animation mixer.
   *
   * @param {Object3D} root - The object whose animations shall be played by this mixer.
   */
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, n) {
    const i = e._localRoot || this._root, s = e._clip.tracks, o = s.length, a = e._propertyBindings, h = e._interpolants, c = i.uuid, l = this._bindingsByRootAndName;
    let u = l[c];
    u === void 0 && (u = {}, l[c] = u);
    for (let f = 0; f !== o; ++f) {
      const d = s[f], p = d.name;
      let y = u[p];
      if (y !== void 0)
        ++y.referenceCount, a[f] = y;
      else {
        if (y = a[f], y !== void 0) {
          y._cacheIndex === null && (++y.referenceCount, this._addInactiveBinding(y, c, p));
          continue;
        }
        const x = n && n._propertyBindings[f].binding.parsedPath;
        y = new ug(
          kt.create(i, p, x),
          d.ValueTypeName,
          d.getValueSize()
        ), ++y.referenceCount, this._addInactiveBinding(y, c, p), a[f] = y;
      }
      h[f].resultBuffer = y.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, s = e._clip.uuid, o = this._actionsByClip[s];
        this._bindAction(
          e,
          o && o.knownActions[0]
        ), this._addInactiveAction(e, s, i);
      }
      const n = e._propertyBindings;
      for (let i = 0, s = n.length; i !== s; ++i) {
        const o = n[i];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const n = e._propertyBindings;
      for (let i = 0, s = n.length; i !== s; ++i) {
        const o = n[i];
        --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const n = e._cacheIndex;
    return n !== null && n < this._nActiveActions;
  }
  _addInactiveAction(e, n, i) {
    const s = this._actions, o = this._actionsByClip;
    let a = o[n];
    if (a === void 0)
      a = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, o[n] = a;
    else {
      const h = a.knownActions;
      e._byClipCacheIndex = h.length, h.push(e);
    }
    e._cacheIndex = s.length, s.push(e), a.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const n = this._actions, i = n[n.length - 1], s = e._cacheIndex;
    i._cacheIndex = s, n[s] = i, n.pop(), e._cacheIndex = null;
    const o = e._clip.uuid, a = this._actionsByClip, h = a[o], c = h.knownActions, l = c[c.length - 1], u = e._byClipCacheIndex;
    l._byClipCacheIndex = u, c[u] = l, c.pop(), e._byClipCacheIndex = null;
    const f = h.actionByRoot, d = (e._localRoot || this._root).uuid;
    delete f[d], c.length === 0 && delete a[o], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const n = e._propertyBindings;
    for (let i = 0, s = n.length; i !== s; ++i) {
      const o = n[i];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const n = this._actions, i = e._cacheIndex, s = this._nActiveActions++, o = n[s];
    e._cacheIndex = s, n[s] = e, o._cacheIndex = i, n[i] = o;
  }
  _takeBackAction(e) {
    const n = this._actions, i = e._cacheIndex, s = --this._nActiveActions, o = n[s];
    e._cacheIndex = s, n[s] = e, o._cacheIndex = i, n[i] = o;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, n, i) {
    const s = this._bindingsByRootAndName, o = this._bindings;
    let a = s[n];
    a === void 0 && (a = {}, s[n] = a), a[i] = e, e._cacheIndex = o.length, o.push(e);
  }
  _removeInactiveBinding(e) {
    const n = this._bindings, i = e.binding, s = i.rootNode.uuid, o = i.path, a = this._bindingsByRootAndName, h = a[s], c = n[n.length - 1], l = e._cacheIndex;
    c._cacheIndex = l, n[l] = c, n.pop(), delete h[o], Object.keys(h).length === 0 && delete a[s];
  }
  _lendBinding(e) {
    const n = this._bindings, i = e._cacheIndex, s = this._nActiveBindings++, o = n[s];
    e._cacheIndex = s, n[s] = e, o._cacheIndex = i, n[i] = o;
  }
  _takeBackBinding(e) {
    const n = this._bindings, i = e._cacheIndex, s = --this._nActiveBindings, o = n[s];
    e._cacheIndex = s, n[s] = e, o._cacheIndex = i, n[i] = o;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, n = this._nActiveControlInterpolants++;
    let i = e[n];
    return i === void 0 && (i = new sf(
      new Float32Array(2),
      new Float32Array(2),
      1,
      UA
    ), i.__cacheIndex = n, e[n] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const n = this._controlInterpolants, i = e.__cacheIndex, s = --this._nActiveControlInterpolants, o = n[s];
    e.__cacheIndex = s, n[s] = e, o.__cacheIndex = i, n[i] = o;
  }
  /**
   * Returns an instance of {@link AnimationAction} for the passed clip.
   *
   * If an action fitting the clip and root parameters doesn't yet exist, it
   * will be created by this method. Calling this method several times with the
   * same clip and root parameters always returns the same action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   * @return {?AnimationAction} The animation action.
   */
  clipAction(e, n, i) {
    const s = n || this._root, o = s.uuid;
    let a = typeof e == "string" ? eu.findByName(s, e) : e;
    const h = a !== null ? a.uuid : e, c = this._actionsByClip[h];
    let l = null;
    if (i === void 0 && (a !== null ? i = a.blendMode : i = Hh), c !== void 0) {
      const f = c.actionByRoot[o];
      if (f !== void 0 && f.blendMode === i)
        return f;
      l = c.knownActions[0], a === null && (a = l._clip);
    }
    if (a === null) return null;
    const u = new rg(this, a, n, i);
    return this._bindAction(u, l), this._addInactiveAction(u, h, o), u;
  }
  /**
   * Returns an existing animation action for the passed clip.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @return {?AnimationAction} The animation action. Returns `null` if no action was found.
   */
  existingAction(e, n) {
    const i = n || this._root, s = i.uuid, o = typeof e == "string" ? eu.findByName(i, e) : e, a = o ? o.uuid : e, h = this._actionsByClip[a];
    return h !== void 0 && h.actionByRoot[s] || null;
  }
  /**
   * Deactivates all previously scheduled actions on this mixer.
   *
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  stopAllAction() {
    const e = this._actions, n = this._nActiveActions;
    for (let i = n - 1; i >= 0; --i)
      e[i].stop();
    return this;
  }
  /**
   * Advances the global mixer time and updates the animation.
   *
   * This is usually done in the render loop by passing the delta
   * time from {@link Clock} or {@link Timer}.
   *
   * @param {number} deltaTime - The delta time in seconds.
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  update(e) {
    e *= this.timeScale;
    const n = this._actions, i = this._nActiveActions, s = this.time += e, o = Math.sign(e), a = this._accuIndex ^= 1;
    for (let l = 0; l !== i; ++l)
      n[l]._update(s, e, o, a);
    const h = this._bindings, c = this._nActiveBindings;
    for (let l = 0; l !== c; ++l)
      h[l].apply(a);
    return this;
  }
  /**
   * Sets the global mixer to a specific time and updates the animation accordingly.
   *
   * This is useful when you need to jump to an exact time in an animation. The
   * input parameter will be scaled by {@link AnimationMixer#timeScale}
   *
   * @param {number} time - The time to set in seconds.
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  setTime(e) {
    this.time = 0;
    for (let n = 0; n < this._actions.length; n++)
      this._actions[n].time = 0;
    return this.update(e);
  }
  /**
   * Returns this mixer's root object.
   *
   * @return {Object3D} The mixer's root object.
   */
  getRoot() {
    return this._root;
  }
  /**
   * Deallocates all memory resources for a clip. Before using this method make
   * sure to call {@link AnimationAction#stop} for all related actions.
   *
   * @param {AnimationClip} clip - The clip to uncache.
   */
  uncacheClip(e) {
    const n = this._actions, i = e.uuid, s = this._actionsByClip, o = s[i];
    if (o !== void 0) {
      const a = o.knownActions;
      for (let h = 0, c = a.length; h !== c; ++h) {
        const l = a[h];
        this._deactivateAction(l);
        const u = l._cacheIndex, f = n[n.length - 1];
        l._cacheIndex = null, l._byClipCacheIndex = null, f._cacheIndex = u, n[u] = f, n.pop(), this._removeInactiveBindingsForAction(l);
      }
      delete s[i];
    }
  }
  /**
   * Deallocates all memory resources for a root object. Before using this
   * method make sure to call {@link AnimationAction#stop} for all related
   * actions or alternatively {@link AnimationMixer#stopAllAction} when the
   * mixer operates on a single root.
   *
   * @param {Object3D} root - The root object to uncache.
   */
  uncacheRoot(e) {
    const n = e.uuid, i = this._actionsByClip;
    for (const a in i) {
      const h = i[a].actionByRoot, c = h[n];
      c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    const s = this._bindingsByRootAndName, o = s[n];
    if (o !== void 0)
      for (const a in o) {
        const h = o[a];
        h.restoreOriginalState(), this._removeInactiveBinding(h);
      }
  }
  /**
   * Deallocates all memory resources for an action. The action is identified by the
   * given clip and an optional root object. Before using this method make
   * sure to call {@link AnimationAction#stop} to deactivate the action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   */
  uncacheAction(e, n) {
    const i = this.existingAction(e, n);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class jA {
  /**
   * Constructs a new animation group.
   *
   * @param {...Object3D} arguments - An arbitrary number of 3D objects that share the same animation state.
   */
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = Tn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, s = arguments.length; i !== s; ++i)
      e[arguments[i].uuid] = i;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return n._bindings.length;
      }
    };
  }
  /**
   * Adds an arbitrary number of objects to this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to add.
   */
  add() {
    const e = this._objects, n = this._indicesByUUID, i = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length;
    let h, c = e.length, l = this.nCachedObjects_;
    for (let u = 0, f = arguments.length; u !== f; ++u) {
      const d = arguments[u], p = d.uuid;
      let y = n[p];
      if (y === void 0) {
        y = c++, n[p] = y, e.push(d);
        for (let x = 0, m = a; x !== m; ++x)
          o[x].push(new kt(d, i[x], s[x]));
      } else if (y < l) {
        h = e[y];
        const x = --l, m = e[x];
        n[m.uuid] = y, e[y] = m, n[p] = x, e[x] = d;
        for (let g = 0, w = a; g !== w; ++g) {
          const M = o[g], S = M[x];
          let E = M[y];
          M[y] = S, E === void 0 && (E = new kt(d, i[g], s[g])), M[x] = E;
        }
      } else e[y] !== h && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = l;
  }
  /**
   * Removes an arbitrary number of objects to this animation group
   *
   * @param {...Object3D} arguments - The 3D objects to remove.
   */
  remove() {
    const e = this._objects, n = this._indicesByUUID, i = this._bindings, s = i.length;
    let o = this.nCachedObjects_;
    for (let a = 0, h = arguments.length; a !== h; ++a) {
      const c = arguments[a], l = c.uuid, u = n[l];
      if (u !== void 0 && u >= o) {
        const f = o++, d = e[f];
        n[d.uuid] = u, e[u] = d, n[l] = f, e[f] = c;
        for (let p = 0, y = s; p !== y; ++p) {
          const x = i[p], m = x[f], g = x[u];
          x[u] = m, x[f] = g;
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  /**
   * Deallocates all memory resources for the passed 3D objects of this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to uncache.
   */
  uncache() {
    const e = this._objects, n = this._indicesByUUID, i = this._bindings, s = i.length;
    let o = this.nCachedObjects_, a = e.length;
    for (let h = 0, c = arguments.length; h !== c; ++h) {
      const l = arguments[h], u = l.uuid, f = n[u];
      if (f !== void 0)
        if (delete n[u], f < o) {
          const d = --o, p = e[d], y = --a, x = e[y];
          n[p.uuid] = f, e[f] = p, n[x.uuid] = d, e[d] = x, e.pop();
          for (let m = 0, g = s; m !== g; ++m) {
            const w = i[m], M = w[d], S = w[y];
            w[f] = M, w[d] = S, w.pop();
          }
        } else {
          const d = --a, p = e[d];
          d > 0 && (n[p.uuid] = f), e[f] = p, e.pop();
          for (let y = 0, x = s; y !== x; ++y) {
            const m = i[y];
            m[f] = m[d], m.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, n) {
    const i = this._bindingsIndicesByPath;
    let s = i[e];
    const o = this._bindings;
    if (s !== void 0) return o[s];
    const a = this._paths, h = this._parsedPaths, c = this._objects, l = c.length, u = this.nCachedObjects_, f = new Array(l);
    s = o.length, i[e] = s, a.push(e), h.push(n), o.push(f);
    for (let d = u, p = c.length; d !== p; ++d) {
      const y = c[d];
      f[d] = new kt(y, e, n);
    }
    return f;
  }
  unsubscribe_(e) {
    const n = this._bindingsIndicesByPath, i = n[e];
    if (i !== void 0) {
      const s = this._paths, o = this._parsedPaths, a = this._bindings, h = a.length - 1, c = a[h], l = e[h];
      n[l] = i, a[i] = c, a.pop(), o[i] = o[h], o.pop(), s[i] = s[h], s.pop();
    }
  }
}
class $ {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(e = 0, n = 0, i = 0) {
    $.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = i;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(e, n, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = n, this.z = i, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(e) {
    return this.applyQuaternion(_p.setFromEuler(e));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(e, n) {
    return this.applyQuaternion(_p.setFromAxisAngle(e, n));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(e) {
    const n = this.x, i = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[3] * i + o[6] * s, this.y = o[1] * n + o[4] * i + o[7] * s, this.z = o[2] * n + o[5] * i + o[8] * s, this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(e) {
    const n = this.x, i = this.y, s = this.z, o = e.elements, a = 1 / (o[3] * n + o[7] * i + o[11] * s + o[15]);
    return this.x = (o[0] * n + o[4] * i + o[8] * s + o[12]) * a, this.y = (o[1] * n + o[5] * i + o[9] * s + o[13]) * a, this.z = (o[2] * n + o[6] * i + o[10] * s + o[14]) * a, this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(e) {
    const n = this.x, i = this.y, s = this.z, o = e.x, a = e.y, h = e.z, c = e.w, l = 2 * (a * s - h * i), u = 2 * (h * n - o * s), f = 2 * (o * i - a * n);
    return this.x = n + c * l + a * f - h * u, this.y = i + c * u + h * l - o * f, this.z = s + c * f + o * u - a * l, this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(e) {
    const n = this.x, i = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[4] * i + o[8] * s, this.y = o[1] * n + o[5] * i + o[9] * s, this.z = o[2] * n + o[6] * i + o[10] * s, this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(e, n) {
    return this.x = Mt(this.x, e.x, n.x), this.y = Mt(this.y, e.y, n.y), this.z = Mt(this.z, e.z, n.z), this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(e, n) {
    return this.x = Mt(this.x, e, n), this.y = Mt(this.y, e, n), this.z = Mt(this.z, e, n), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Mt(i, e, n));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(e) {
    return this.crossVectors(this, e);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(e, n) {
    const i = e.x, s = e.y, o = e.z, a = n.x, h = n.y, c = n.z;
    return this.x = s * c - o * h, this.y = o * a - i * c, this.z = i * h - s * a, this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(e) {
    return Lc.copy(this).projectOnVector(e), this.sub(Lc);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(e) {
    return this.sub(Lc.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Mt(i, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y, s = this.z - e.z;
    return n * n + i * i + s * s;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(e, n, i) {
    const s = Math.sin(n) * e;
    return this.x = s * Math.sin(i), this.y = Math.cos(n) * e, this.z = s * Math.cos(i), this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(e, n, i) {
    return this.x = e * Math.sin(n), this.y = i, this.z = e * Math.cos(n), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = i, this.z = s, this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, i = Math.sqrt(1 - n * n);
    return this.x = i * Math.cos(e), this.y = n, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Lc = /* @__PURE__ */ new $(), _p = /* @__PURE__ */ new $e();
class te {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(e, n, i, s, o, a, h, c, l, u, f, d, p, y, x, m) {
    te.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, s, o, a, h, c, l, u, f, d, p, y, x, m);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(e, n, i, s, o, a, h, c, l, u, f, d, p, y, x, m) {
    const g = this.elements;
    return g[0] = e, g[4] = n, g[8] = i, g[12] = s, g[1] = o, g[5] = a, g[9] = h, g[13] = c, g[2] = l, g[6] = u, g[10] = f, g[14] = d, g[3] = p, g[7] = y, g[11] = x, g[15] = m, this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new te().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(e) {
    const n = this.elements, i = e.elements;
    return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(e, n, i) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(e, n, i) {
    return this.set(
      e.x,
      n.x,
      i.x,
      0,
      e.y,
      n.y,
      i.y,
      0,
      e.z,
      n.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(e) {
    const n = this.elements, i = e.elements, s = 1 / Ws.setFromMatrixColumn(e, 0).length(), o = 1 / Ws.setFromMatrixColumn(e, 1).length(), a = 1 / Ws.setFromMatrixColumn(e, 2).length();
    return n[0] = i[0] * s, n[1] = i[1] * s, n[2] = i[2] * s, n[3] = 0, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[7] = 0, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(e) {
    const n = this.elements, i = e.x, s = e.y, o = e.z, a = Math.cos(i), h = Math.sin(i), c = Math.cos(s), l = Math.sin(s), u = Math.cos(o), f = Math.sin(o);
    if (e.order === "XYZ") {
      const d = a * u, p = a * f, y = h * u, x = h * f;
      n[0] = c * u, n[4] = -c * f, n[8] = l, n[1] = p + y * l, n[5] = d - x * l, n[9] = -h * c, n[2] = x - d * l, n[6] = y + p * l, n[10] = a * c;
    } else if (e.order === "YXZ") {
      const d = c * u, p = c * f, y = l * u, x = l * f;
      n[0] = d + x * h, n[4] = y * h - p, n[8] = a * l, n[1] = a * f, n[5] = a * u, n[9] = -h, n[2] = p * h - y, n[6] = x + d * h, n[10] = a * c;
    } else if (e.order === "ZXY") {
      const d = c * u, p = c * f, y = l * u, x = l * f;
      n[0] = d - x * h, n[4] = -a * f, n[8] = y + p * h, n[1] = p + y * h, n[5] = a * u, n[9] = x - d * h, n[2] = -a * l, n[6] = h, n[10] = a * c;
    } else if (e.order === "ZYX") {
      const d = a * u, p = a * f, y = h * u, x = h * f;
      n[0] = c * u, n[4] = y * l - p, n[8] = d * l + x, n[1] = c * f, n[5] = x * l + d, n[9] = p * l - y, n[2] = -l, n[6] = h * c, n[10] = a * c;
    } else if (e.order === "YZX") {
      const d = a * c, p = a * l, y = h * c, x = h * l;
      n[0] = c * u, n[4] = x - d * f, n[8] = y * f + p, n[1] = f, n[5] = a * u, n[9] = -h * u, n[2] = -l * u, n[6] = p * f + y, n[10] = d - x * f;
    } else if (e.order === "XZY") {
      const d = a * c, p = a * l, y = h * c, x = h * l;
      n[0] = c * u, n[4] = -f, n[8] = l * u, n[1] = d * f + x, n[5] = a * u, n[9] = p * f - y, n[2] = y * f - p, n[6] = h * u, n[10] = x * f + d;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(e) {
    return this.compose(YA, e, HA);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(e, n, i) {
    const s = this.elements;
    return We.subVectors(e, n), We.lengthSq() === 0 && (We.z = 1), We.normalize(), gi.crossVectors(i, We), gi.lengthSq() === 0 && (Math.abs(i.z) === 1 ? We.x += 1e-4 : We.z += 1e-4, We.normalize(), gi.crossVectors(i, We)), gi.normalize(), Sa.crossVectors(We, gi), s[0] = gi.x, s[4] = Sa.x, s[8] = We.x, s[1] = gi.y, s[5] = Sa.y, s[9] = We.y, s[2] = gi.z, s[6] = Sa.z, s[10] = We.z, this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(e, n) {
    const i = e.elements, s = n.elements, o = this.elements, a = i[0], h = i[4], c = i[8], l = i[12], u = i[1], f = i[5], d = i[9], p = i[13], y = i[2], x = i[6], m = i[10], g = i[14], w = i[3], M = i[7], S = i[11], E = i[15], A = s[0], I = s[4], b = s[8], v = s[12], _ = s[1], z = s[5], P = s[9], k = s[13], B = s[2], R = s[6], L = s[10], N = s[14], q = s[3], U = s[7], J = s[11], X = s[15];
    return o[0] = a * A + h * _ + c * B + l * q, o[4] = a * I + h * z + c * R + l * U, o[8] = a * b + h * P + c * L + l * J, o[12] = a * v + h * k + c * N + l * X, o[1] = u * A + f * _ + d * B + p * q, o[5] = u * I + f * z + d * R + p * U, o[9] = u * b + f * P + d * L + p * J, o[13] = u * v + f * k + d * N + p * X, o[2] = y * A + x * _ + m * B + g * q, o[6] = y * I + x * z + m * R + g * U, o[10] = y * b + x * P + m * L + g * J, o[14] = y * v + x * k + m * N + g * X, o[3] = w * A + M * _ + S * B + E * q, o[7] = w * I + M * z + S * R + E * U, o[11] = w * b + M * P + S * L + E * J, o[15] = w * v + M * k + S * N + E * X, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, n = e[0], i = e[4], s = e[8], o = e[12], a = e[1], h = e[5], c = e[9], l = e[13], u = e[2], f = e[6], d = e[10], p = e[14], y = e[3], x = e[7], m = e[11], g = e[15];
    return y * (+o * c * f - s * l * f - o * h * d + i * l * d + s * h * p - i * c * p) + x * (+n * c * p - n * l * d + o * a * d - s * a * p + s * l * u - o * c * u) + m * (+n * l * f - n * h * p - o * a * f + i * a * p + o * h * u - i * l * u) + g * (-s * h * u - n * c * f + n * h * d + s * a * f - i * a * d + i * c * u);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(e, n, i) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = n, s[14] = i), this;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = e[9], d = e[10], p = e[11], y = e[12], x = e[13], m = e[14], g = e[15], w = f * m * l - x * d * l + x * c * p - h * m * p - f * c * g + h * d * g, M = y * d * l - u * m * l - y * c * p + a * m * p + u * c * g - a * d * g, S = u * x * l - y * f * l + y * h * p - a * x * p - u * h * g + a * f * g, E = y * f * c - u * x * c - y * h * d + a * x * d + u * h * m - a * f * m, A = n * w + i * M + s * S + o * E;
    if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const I = 1 / A;
    return e[0] = w * I, e[1] = (x * d * o - f * m * o - x * s * p + i * m * p + f * s * g - i * d * g) * I, e[2] = (h * m * o - x * c * o + x * s * l - i * m * l - h * s * g + i * c * g) * I, e[3] = (f * c * o - h * d * o - f * s * l + i * d * l + h * s * p - i * c * p) * I, e[4] = M * I, e[5] = (u * m * o - y * d * o + y * s * p - n * m * p - u * s * g + n * d * g) * I, e[6] = (y * c * o - a * m * o - y * s * l + n * m * l + a * s * g - n * c * g) * I, e[7] = (a * d * o - u * c * o + u * s * l - n * d * l - a * s * p + n * c * p) * I, e[8] = S * I, e[9] = (y * f * o - u * x * o - y * i * p + n * x * p + u * i * g - n * f * g) * I, e[10] = (a * x * o - y * h * o + y * i * l - n * x * l - a * i * g + n * h * g) * I, e[11] = (u * h * o - a * f * o - u * i * l + n * f * l + a * i * p - n * h * p) * I, e[12] = E * I, e[13] = (u * x * s - y * f * s + y * i * d - n * x * d - u * i * m + n * f * m) * I, e[14] = (y * h * s - a * x * s - y * i * c + n * x * c + a * i * m - n * h * m) * I, e[15] = (a * f * s - u * h * s + u * i * c - n * f * c - a * i * d + n * h * d) * I, this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(e) {
    const n = this.elements, i = e.x, s = e.y, o = e.z;
    return n[0] *= i, n[4] *= s, n[8] *= o, n[1] *= i, n[5] *= s, n[9] *= o, n[2] *= i, n[6] *= s, n[10] *= o, n[3] *= i, n[7] *= s, n[11] *= o, this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, s));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(e, n, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(e, n) {
    const i = Math.cos(n), s = Math.sin(n), o = 1 - i, a = e.x, h = e.y, c = e.z, l = o * a, u = o * h;
    return this.set(
      l * a + i,
      l * h - s * c,
      l * c + s * h,
      0,
      l * h + s * c,
      u * h + i,
      u * c - s * a,
      0,
      l * c - s * h,
      u * c + s * a,
      o * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(e, n, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(e, n, i, s, o, a) {
    return this.set(
      1,
      i,
      o,
      0,
      e,
      1,
      a,
      0,
      n,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(e, n, i) {
    const s = this.elements, o = n._x, a = n._y, h = n._z, c = n._w, l = o + o, u = a + a, f = h + h, d = o * l, p = o * u, y = o * f, x = a * u, m = a * f, g = h * f, w = c * l, M = c * u, S = c * f, E = i.x, A = i.y, I = i.z;
    return s[0] = (1 - (x + g)) * E, s[1] = (p + S) * E, s[2] = (y - M) * E, s[3] = 0, s[4] = (p - S) * A, s[5] = (1 - (d + g)) * A, s[6] = (m + w) * A, s[7] = 0, s[8] = (y + M) * I, s[9] = (m - w) * I, s[10] = (1 - (d + x)) * I, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(e, n, i) {
    const s = this.elements;
    let o = Ws.set(s[0], s[1], s[2]).length();
    const a = Ws.set(s[4], s[5], s[6]).length(), h = Ws.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (o = -o), e.x = s[12], e.y = s[13], e.z = s[14], fn.copy(this);
    const l = 1 / o, u = 1 / a, f = 1 / h;
    return fn.elements[0] *= l, fn.elements[1] *= l, fn.elements[2] *= l, fn.elements[4] *= u, fn.elements[5] *= u, fn.elements[6] *= u, fn.elements[8] *= f, fn.elements[9] *= f, fn.elements[10] *= f, n.setFromRotationMatrix(fn), i.x = o, i.y = a, i.z = h, this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(e, n, i, s, o, a, h = Dn) {
    const c = this.elements, l = 2 * o / (n - e), u = 2 * o / (i - s), f = (n + e) / (n - e), d = (i + s) / (i - s);
    let p, y;
    if (h === Dn)
      p = -(a + o) / (a - o), y = -2 * a * o / (a - o);
    else if (h === Po)
      p = -a / (a - o), y = -a * o / (a - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + h);
    return c[0] = l, c[4] = 0, c[8] = f, c[12] = 0, c[1] = 0, c[5] = u, c[9] = d, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = p, c[14] = y, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(e, n, i, s, o, a, h = Dn) {
    const c = this.elements, l = 1 / (n - e), u = 1 / (i - s), f = 1 / (a - o), d = (n + e) * l, p = (i + s) * u;
    let y, x;
    if (h === Dn)
      y = (a + o) * f, x = -2 * f;
    else if (h === Po)
      y = o * f, x = -1 * f;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + h);
    return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -d, c[1] = 0, c[5] = 2 * u, c[9] = 0, c[13] = -p, c[2] = 0, c[6] = 0, c[10] = x, c[14] = -y, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let s = 0; s < 16; s++)
      if (n[s] !== i[s]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e[n + 9] = i[9], e[n + 10] = i[10], e[n + 11] = i[11], e[n + 12] = i[12], e[n + 13] = i[13], e[n + 14] = i[14], e[n + 15] = i[15], e;
  }
}
const Ws = /* @__PURE__ */ new $(), fn = /* @__PURE__ */ new te(), YA = /* @__PURE__ */ new $(0, 0, 0), HA = /* @__PURE__ */ new $(1, 1, 1), gi = /* @__PURE__ */ new $(), Sa = /* @__PURE__ */ new $(), We = /* @__PURE__ */ new $(), Sp = /* @__PURE__ */ new te(), Tp = /* @__PURE__ */ new $e();
class As {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(e = 0, n = 0, i = 0, s = As.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = i, this._order = s;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(e, n, i, s = this._order) {
    return this._x = e, this._y = n, this._z = i, this._order = s, this._onChangeCallback(), this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const s = e.elements, o = s[0], a = s[4], h = s[8], c = s[1], l = s[5], u = s[9], f = s[2], d = s[6], p = s[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(Mt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Mt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(h, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-f, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Mt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-f, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Mt(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l));
        break;
      case "YZX":
        this._z = Math.asin(Mt(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-f, o)) : (this._x = 0, this._y = Math.atan2(h, p));
        break;
      case "XZY":
        this._z = Math.asin(-Mt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(h, o)) : (this._x = Math.atan2(-u, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, i === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(e, n, i) {
    return Sp.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Sp, n, i);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(e) {
    return Tp.setFromEuler(this), this.setFromQuaternion(Tp, e);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
As.DEFAULT_ORDER = "XYZ";
class hf {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = -1;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
class Wn {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(e, n, i, s, o, a, h, c, l) {
    Wn.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, s, o, a, h, c, l);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(e, n, i, s, o, a, h, c, l) {
    const u = this.elements;
    return u[0] = e, u[1] = s, u[2] = h, u[3] = n, u[4] = o, u[5] = c, u[6] = i, u[7] = a, u[8] = l, this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(e, n, i) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(e, n) {
    const i = e.elements, s = n.elements, o = this.elements, a = i[0], h = i[3], c = i[6], l = i[1], u = i[4], f = i[7], d = i[2], p = i[5], y = i[8], x = s[0], m = s[3], g = s[6], w = s[1], M = s[4], S = s[7], E = s[2], A = s[5], I = s[8];
    return o[0] = a * x + h * w + c * E, o[3] = a * m + h * M + c * A, o[6] = a * g + h * S + c * I, o[1] = l * x + u * w + f * E, o[4] = l * m + u * M + f * A, o[7] = l * g + u * S + f * I, o[2] = d * x + p * w + y * E, o[5] = d * m + p * M + y * A, o[8] = d * g + p * S + y * I, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], h = e[5], c = e[6], l = e[7], u = e[8];
    return n * a * u - n * h * l - i * o * u + i * h * c + s * o * l - s * a * c;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = u * a - h * l, d = h * c - u * o, p = l * o - a * c, y = n * f + i * d + s * p;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / y;
    return e[0] = f * x, e[1] = (s * l - u * i) * x, e[2] = (h * i - s * a) * x, e[3] = d * x, e[4] = (u * n - s * c) * x, e[5] = (s * o - h * n) * x, e[6] = p * x, e[7] = (i * c - l * n) * x, e[8] = (a * n - i * o) * x, this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(e, n, i, s, o, a, h) {
    const c = Math.cos(o), l = Math.sin(o);
    return this.set(
      i * c,
      i * l,
      -i * (c * a + l * h) + a + e,
      -s * l,
      s * c,
      -s * (-l * a + c * h) + h + n,
      0,
      0,
      1
    ), this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(e, n) {
    return this.premultiply(Bc.makeScale(e, n)), this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(e) {
    return this.premultiply(Bc.makeRotation(-e)), this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(e, n) {
    return this.premultiply(Bc.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      i,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let s = 0; s < 9; s++)
      if (n[s] !== i[s]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Bc = /* @__PURE__ */ new Wn();
let XA = 0;
const Ep = /* @__PURE__ */ new $(), js = /* @__PURE__ */ new $e(), Zn = /* @__PURE__ */ new te(), Ta = /* @__PURE__ */ new $(), Wr = /* @__PURE__ */ new $(), ZA = /* @__PURE__ */ new $(), GA = /* @__PURE__ */ new $e(), zp = /* @__PURE__ */ new $(1, 0, 0), Ap = /* @__PURE__ */ new $(0, 1, 0), Cp = /* @__PURE__ */ new $(0, 0, 1), Pp = { type: "added" }, JA = { type: "removed" }, Ys = { type: "childadded", child: null }, Fc = { type: "childremoved", child: null };
class Ve extends Li {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: XA++ }), this.uuid = Tn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ve.DEFAULT_UP.clone();
    const e = new $(), n = new As(), i = new $e(), s = new $(1, 1, 1);
    function o() {
      i.setFromEuler(n, !1);
    }
    function a() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(o), i._onChange(a), Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new te()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new Wn()
      }
    }), this.matrix = new te(), this.matrixWorld = new te(), this.matrixAutoUpdate = Ve.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ve.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new hf(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(e, n) {
    return js.setFromAxisAngle(e, n), this.quaternion.multiply(js), this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(e, n) {
    return js.setFromAxisAngle(e, n), this.quaternion.premultiply(js), this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(e) {
    return this.rotateOnAxis(zp, e);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(e) {
    return this.rotateOnAxis(Ap, e);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(e) {
    return this.rotateOnAxis(Cp, e);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(e, n) {
    return Ep.copy(e).applyQuaternion(this.quaternion), this.position.add(Ep.multiplyScalar(n)), this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(e) {
    return this.translateOnAxis(zp, e);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(e) {
    return this.translateOnAxis(Ap, e);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(e) {
    return this.translateOnAxis(Cp, e);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Zn.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(e, n, i) {
    e.isVector3 ? Ta.copy(e) : Ta.set(e, n, i);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), Wr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Zn.lookAt(Wr, Ta, this.up) : Zn.lookAt(Ta, Wr, this.up), this.quaternion.setFromRotationMatrix(Zn), s && (Zn.extractRotation(s.matrixWorld), js.setFromRotationMatrix(Zn), this.quaternion.premultiply(js.invert()));
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Pp), Ys.child = e, this.dispatchEvent(Ys), Ys.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(JA), Fc.child = e, this.dispatchEvent(Fc), Fc.child = null), this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Zn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Zn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Zn), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Pp), Ys.child = e, this.dispatchEvent(Ys), Ys.child = null, this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, s = this.children.length; i < s; i++) {
      const a = this.children[i].getObjectByProperty(e, n);
      if (a !== void 0)
        return a;
    }
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const s = this.children;
    for (let o = 0, a = s.length; o < a; o++)
      s[o].getObjectsByProperty(e, n, i);
    return i;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wr, e, ZA), e;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wr, GA, e), e;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++)
      n[i].traverse(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++)
      n[i].traverseVisible(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++)
      n[i].updateMatrixWorld(e);
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) {
      const s = this.children;
      for (let o = 0, a = s.length; o < a; o++)
        s[o].updateWorldMatrix(!1, !0);
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", i = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.7,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.geometryInfo = this._geometryInfo.map((h) => ({
      ...h,
      boundingBox: h.boundingBox ? h.boundingBox.toJSON() : void 0,
      boundingSphere: h.boundingSphere ? h.boundingSphere.toJSON() : void 0
    })), s.instanceInfo = this._instanceInfo.map((h) => ({ ...h })), s.availableInstanceIds = this._availableInstanceIds.slice(), s.availableGeometryIds = this._availableGeometryIds.slice(), s.nextIndexStart = this._nextIndexStart, s.nextVertexStart = this._nextVertexStart, s.geometryCount = this._geometryCount, s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.matricesTexture = this._matricesTexture.toJSON(e), s.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (s.boundingBox = this.boundingBox.toJSON()));
    function o(h, c) {
      return h[c.uuid] === void 0 && (h[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = o(e.geometries, this.geometry);
      const h = this.geometry.parameters;
      if (h !== void 0 && h.shapes !== void 0) {
        const c = h.shapes;
        if (Array.isArray(c))
          for (let l = 0, u = c.length; l < u; l++) {
            const f = c[l];
            o(e.shapes, f);
          }
        else
          o(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const h = [];
        for (let c = 0, l = this.material.length; c < l; c++)
          h.push(o(e.materials, this.material[c]));
        s.material = h;
      } else
        s.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let h = 0; h < this.children.length; h++)
        s.children.push(this.children[h].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let h = 0; h < this.animations.length; h++) {
        const c = this.animations[h];
        s.animations.push(o(e.animations, c));
      }
    }
    if (n) {
      const h = a(e.geometries), c = a(e.materials), l = a(e.textures), u = a(e.images), f = a(e.shapes), d = a(e.skeletons), p = a(e.animations), y = a(e.nodes);
      h.length > 0 && (i.geometries = h), c.length > 0 && (i.materials = c), l.length > 0 && (i.textures = l), u.length > 0 && (i.images = u), f.length > 0 && (i.shapes = f), d.length > 0 && (i.skeletons = d), p.length > 0 && (i.animations = p), y.length > 0 && (i.nodes = y);
    }
    return i.object = s, i;
    function a(h) {
      const c = [];
      for (const l in h) {
        const u = h[l];
        delete u.metadata, c.push(u);
      }
      return c;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let i = 0; i < e.children.length; i++) {
        const s = e.children[i];
        this.add(s.clone());
      }
    return this;
  }
}
Ve.DEFAULT_UP = /* @__PURE__ */ new $(0, 1, 0);
Ve.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ve.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
class fg extends Ve {
  /**
   * Constructs a new audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  /**
   * Returns the output audio node.
   *
   * @return {GainNode} The output node.
   */
  getOutput() {
    return this.gain;
  }
  /**
   * Sets the given audio node as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `audioNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {AudioNode} audioNode - The audio node like an instance of `OscillatorNode`.
   * @return {Audio} A reference to this instance.
   */
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  /**
   * Sets the given media element as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {HTMLMediaElement} mediaElement - The media element.
   * @return {Audio} A reference to this instance.
   */
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  /**
   * Sets the given media stream as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaStreamNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {MediaStream} mediaStream - The media stream.
   * @return {Audio} A reference to this instance.
   */
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  /**
   * Sets the given audio buffer as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `buffer` and {@link Audio#hasPlaybackControl} to `true`.
   *
   * @param {AudioBuffer} audioBuffer - The audio buffer.
   * @return {Audio} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  /**
   * Starts the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should start playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const n = this.context.createBufferSource();
    return n.buffer = this.buffer, n.loop = this.loop, n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.onended = this.onEnded.bind(this), n.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = n, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  /**
   * Pauses the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  /**
   * Stops the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should stop playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this;
  }
  /**
   * Connects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio} A reference to this instance.
   */
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, n = this.filters.length; e < n; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  /**
   * Disconnects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, n = this.filters.length; e < n; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  /**
   * Returns the current set filters.
   *
   * @return {Array<AudioNode>} The list of filters.
   */
  getFilters() {
    return this.filters;
  }
  /**
   * Sets an array of filters and connects them with the audio source.
   *
   * @param {Array<AudioNode>} [value] - A list of filters.
   * @return {Audio} A reference to this instance.
   */
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  /**
   * Defines the detuning of oscillation in cents.
   *
   * @param {number} value - The detuning of oscillation in cents.
   * @return {Audio} A reference to this instance.
   */
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  /**
   * Returns the detuning of oscillation in cents.
   *
   * @return {number} The detuning of oscillation in cents.
   */
  getDetune() {
    return this.detune;
  }
  /**
   * Returns the first filter in the list of filters.
   *
   * @return {AudioNode|undefined} The first filter in the list of filters.
   */
  getFilter() {
    return this.getFilters()[0];
  }
  /**
   * Applies a single filter node to the audio.
   *
   * @param {AudioNode} [filter] - The filter to set.
   * @return {Audio} A reference to this instance.
   */
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  /**
   * Sets the playback rate.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [value] - The playback rate to set.
   * @return {Audio|undefined} A reference to this instance.
   */
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  /**
  	 * Returns the current playback rate.
  
  	 * @return {number} The playback rate.
  	 */
  getPlaybackRate() {
    return this.playbackRate;
  }
  /**
   * Automatically called when playback finished.
   */
  onEnded() {
    this.isPlaying = !1, this._progress = 0;
  }
  /**
   * Returns the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {boolean} Whether the audio should loop or not.
   */
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  /**
   * Sets the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {boolean} value - Whether the audio should loop or not.
   * @return {Audio|undefined} A reference to this instance.
   */
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  /**
   * Sets the loop start value which defines where in the audio buffer the replay should
   * start, in seconds.
   *
   * @param {number} value - The loop start value.
   * @return {Audio} A reference to this instance.
   */
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  /**
   * Sets the loop end value which defines where in the audio buffer the replay should
   * stop, in seconds.
   *
   * @param {number} value - The loop end value.
   * @return {Audio} A reference to this instance.
   */
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  /**
   * Returns the volume.
   *
   * @return {number} The volume.
   */
  getVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the volume.
   *
   * @param {number} value - The volume to set.
   * @return {Audio} A reference to this instance.
   */
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  copy(e, n) {
    return super.copy(e, n), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this);
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
class QA {
  /**
   * Constructs a new audio analyzer.
   *
   * @param {Audio} audio - The audio to analyze.
   * @param {number} [fftSize=2048] - The window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data.
   */
  constructor(e, n = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = n, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  /**
   * Returns an array with frequency data of the audio.
   *
   * Each item in the array represents the decibel value for a specific frequency.
   * The frequencies are spread linearly from 0 to 1/2 of the sample rate.
   * For example, for 48000 sample rate, the last item of the array will represent
   * the decibel value for 24000 Hz.
   *
   * @return {Uint8Array} The frequency data.
   */
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  /**
   * Returns the average of the frequencies returned by {@link AudioAnalyser#getFrequencyData}.
   *
   * @return {number} The average frequency.
   */
  getAverageFrequency() {
    let e = 0;
    const n = this.getFrequencyData();
    for (let i = 0; i < n.length; i++)
      e += n[i];
    return e / n.length;
  }
}
let Ea;
class dg {
  /**
   * Returns the global native audio context.
   *
   * @return {AudioContext} The native audio context.
   */
  static getContext() {
    return Ea === void 0 && (Ea = new (window.AudioContext || window.webkitAudioContext)()), Ea;
  }
  /**
   * Allows to set the global native audio context from outside.
   *
   * @param {AudioContext} value - The native context to set.
   */
  static setContext(e) {
    Ea = e;
  }
}
class pg {
  /**
   * Constructs a new clock.
   *
   * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
   * `getDelta()` is called for the first time.
   */
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  /**
   * Starts the clock. When `autoStart` is set to `true`, the method is automatically
   * called by the class.
   */
  start() {
    this.startTime = performance.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  /**
   * Stops the clock.
   */
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  /**
   * Returns the elapsed time in seconds.
   *
   * @return {number} The elapsed time.
   */
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  /**
   * Returns the delta time in seconds.
   *
   * @return {number} The delta time.
   */
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const n = performance.now();
      e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e;
    }
    return e;
  }
}
const Zi = /* @__PURE__ */ new $(), Nc = /* @__PURE__ */ new $e(), KA = /* @__PURE__ */ new $(), Gi = /* @__PURE__ */ new $(), Ji = /* @__PURE__ */ new $();
class tC extends Ve {
  /**
   * Constructs a new audio listener.
   */
  constructor() {
    super(), this.type = "AudioListener", this.context = dg.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new pg();
  }
  /**
   * Returns the listener's input node.
   *
   * This method is used by other audio nodes to connect to this listener.
   *
   * @return {GainNode} The input node.
   */
  getInput() {
    return this.gain;
  }
  /**
   * Removes the current filter from this listener.
   *
   * @return {AudioListener} A reference to this listener.
   */
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  /**
   * Returns the current set filter.
   *
   * @return {?AudioNode} The filter.
   */
  getFilter() {
    return this.filter;
  }
  /**
   * Sets the given filter to this listener.
   *
   * @param {AudioNode} value - The filter to set.
   * @return {AudioListener} A reference to this listener.
   */
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  /**
   * Returns the applications master volume.
   *
   * @return {number} The master volume.
   */
  getMasterVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the applications master volume. This volume setting affects
   * all audio nodes in the scene.
   *
   * @param {number} value - The master volume to set.
   * @return {AudioListener} A reference to this listener.
   */
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const n = this.context.listener;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Zi, Nc, KA), Gi.set(0, 0, -1).applyQuaternion(Nc), Ji.set(0, 1, 0).applyQuaternion(Nc), n.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      n.positionX.linearRampToValueAtTime(Zi.x, i), n.positionY.linearRampToValueAtTime(Zi.y, i), n.positionZ.linearRampToValueAtTime(Zi.z, i), n.forwardX.linearRampToValueAtTime(Gi.x, i), n.forwardY.linearRampToValueAtTime(Gi.y, i), n.forwardZ.linearRampToValueAtTime(Gi.z, i), n.upX.linearRampToValueAtTime(Ji.x, i), n.upY.linearRampToValueAtTime(Ji.y, i), n.upZ.linearRampToValueAtTime(Ji.z, i);
    } else
      n.setPosition(Zi.x, Zi.y, Zi.z), n.setOrientation(Gi.x, Gi.y, Gi.z, Ji.x, Ji.y, Ji.z);
  }
}
const Qi = /* @__PURE__ */ new $(), Ip = /* @__PURE__ */ new $e(), eC = /* @__PURE__ */ new $(), Ki = /* @__PURE__ */ new $();
class nC extends fg {
  /**
   * Constructs a positional audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  /**
   * Returns the current reference distance.
   *
   * @return {number} The reference distance.
   */
  getRefDistance() {
    return this.panner.refDistance;
  }
  /**
   * Defines the reference distance for reducing volume as the audio source moves
   * further from the listener – i.e. the distance at which the volume reduction
   * starts taking effect.
   *
   * @param {number} value - The reference distance to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  /**
   * Returns the current rolloff factor.
   *
   * @return {number} The rolloff factor.
   */
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  /**
   * Defines how quickly the volume is reduced as the source moves away from the listener.
   *
   * @param {number} value - The rolloff factor.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  /**
   * Returns the current distance model.
   *
   * @return {('linear'|'inverse'|'exponential')} The distance model.
   */
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  /**
   * Defines which algorithm to use to reduce the volume of the audio source
   * as it moves away from the listener.
   *
   * Read [the spec]{@link https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype}
   * for more details.
   *
   * @param {('linear'|'inverse'|'exponential')} value - The distance model to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  /**
   * Returns the current max distance.
   *
   * @return {number} The max distance.
   */
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  /**
   * Defines the maximum distance between the audio source and the listener,
   * after which the volume is not reduced any further.
   *
   * This value is used only by the `linear` distance model.
   *
   * @param {number} value - The max distance.
   * @return {PositionalAudio} A reference to this instance.
   */
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  /**
   * Sets the directional cone in which the audio can be listened.
   *
   * @param {number} coneInnerAngle - An angle, in degrees, of a cone inside of which there will be no volume reduction.
   * @param {number} coneOuterAngle - An angle, in degrees, of a cone outside of which the volume will be reduced by a constant value, defined by the `coneOuterGain` parameter.
   * @param {number} coneOuterGain - The amount of volume reduction outside the cone defined by the `coneOuterAngle`. When set to `0`, no sound can be heard.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDirectionalCone(e, n, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = n, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Qi, Ip, eC), Ki.set(0, 0, 1).applyQuaternion(Ip);
    const n = this.panner;
    if (n.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      n.positionX.linearRampToValueAtTime(Qi.x, i), n.positionY.linearRampToValueAtTime(Qi.y, i), n.positionZ.linearRampToValueAtTime(Qi.z, i), n.orientationX.linearRampToValueAtTime(Ki.x, i), n.orientationY.linearRampToValueAtTime(Ki.y, i), n.orientationZ.linearRampToValueAtTime(Ki.z, i);
    } else
      n.setPosition(Qi.x, Qi.y, Qi.z), n.setOrientation(Ki.x, Ki.y, Ki.z);
  }
}
class cf extends Ve {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new te(), this.projectionMatrix = new te(), this.projectionMatrixInverse = new te(), this.coordinateSystem = Dn;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class nt {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(e = 0, n = 0) {
    nt.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(e) {
    const n = this.x, i = this.y, s = e.elements;
    return this.x = s[0] * n + s[3] * i + s[6], this.y = s[1] * n + s[4] * i + s[7], this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(e, n) {
    return this.x = Mt(this.x, e.x, n.x), this.y = Mt(this.y, e.y, n.y), this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(e, n) {
    return this.x = Mt(this.x, e, n), this.y = Mt(this.y, e, n), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Mt(i, e, n));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Mt(i, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(e, n) {
    const i = Math.cos(n), s = Math.sin(n), o = this.x - e.x, a = this.y - e.y;
    return this.x = o * i - a * s + e.x, this.y = o * s + a * i + e.y, this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
const wi = /* @__PURE__ */ new $(), kp = /* @__PURE__ */ new nt(), Rp = /* @__PURE__ */ new nt();
class Bn extends cf {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = 50, n = 1, i = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = s, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = Ph * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const e = Math.tan(Ss * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return Ph * 2 * Math.atan(
      Math.tan(Ss * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(e, n, i) {
    wi.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(wi.x, wi.y).multiplyScalar(-e / wi.z), wi.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(wi.x, wi.y).multiplyScalar(-e / wi.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, kp, Rp), n.subVectors(Rp, kp);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(e, n, i, s, o, a) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = s, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(Ss * 0.5 * this.fov) / this.zoom, i = 2 * n, s = this.aspect * i, o = -0.5 * s;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth, l = a.fullHeight;
      o += a.offsetX * s / c, n -= a.offsetY * i / l, s *= a.width / c, i *= a.height / l;
    }
    const h = this.filmOffset;
    h !== 0 && (o += e * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + s, n, n - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
class iC extends Bn {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e;
  }
}
const Hs = -90, Xs = 1;
class sC extends Ve {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(e, n, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new Bn(Hs, Xs, e, n);
    s.layers = this.layers, this.add(s);
    const o = new Bn(Hs, Xs, e, n);
    o.layers = this.layers, this.add(o);
    const a = new Bn(Hs, Xs, e, n);
    a.layers = this.layers, this.add(a);
    const h = new Bn(Hs, Xs, e, n);
    h.layers = this.layers, this.add(h);
    const c = new Bn(Hs, Xs, e, n);
    c.layers = this.layers, this.add(c);
    const l = new Bn(Hs, Xs, e, n);
    l.layers = this.layers, this.add(l);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [i, s, o, a, h, c] = n;
    for (const l of n) this.remove(l);
    if (e === Dn)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), h.up.set(0, 1, 0), h.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === Po)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), h.up.set(0, -1, 0), h.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const l of n)
      this.add(l), l.updateMatrixWorld();
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, a, h, c, l, u] = this.children, f = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), y = e.xr.enabled;
    e.xr.enabled = !1;
    const x = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, s), e.render(n, o), e.setRenderTarget(i, 1, s), e.render(n, a), e.setRenderTarget(i, 2, s), e.render(n, h), e.setRenderTarget(i, 3, s), e.render(n, c), e.setRenderTarget(i, 4, s), e.render(n, l), i.texture.generateMipmaps = x, e.setRenderTarget(i, 5, s), e.render(n, u), e.setRenderTarget(f, d, p), e.xr.enabled = y, i.texture.needsPMREMUpdate = !0;
  }
}
class rC extends cf {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = -1, n = 1, i = 1, s = -1, o = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = i, this.bottom = s, this.near = o, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(e, n, i, s, o, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = s, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let o = i - e, a = i + e, h = s + n, c = s - n;
    if (this.view !== null && this.view.enabled) {
      const l = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += l * this.view.offsetX, a = o + l * this.view.width, h -= u * this.view.offsetY, c = h - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, a, h, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const Op = /* @__PURE__ */ new te(), Lp = /* @__PURE__ */ new te(), ts = /* @__PURE__ */ new te();
class oC {
  /**
   * Constructs a new stereo camera.
   */
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Bn(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Bn(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  /**
   * Updates the stereo camera based on the given perspective camera.
   *
   * @param {PerspectiveCamera} camera - The perspective camera.
   */
  update(e) {
    const n = this._cache;
    if (n.focus !== e.focus || n.fov !== e.fov || n.aspect !== e.aspect * this.aspect || n.near !== e.near || n.far !== e.far || n.zoom !== e.zoom || n.eyeSep !== this.eyeSep) {
      n.focus = e.focus, n.fov = e.fov, n.aspect = e.aspect * this.aspect, n.near = e.near, n.far = e.far, n.zoom = e.zoom, n.eyeSep = this.eyeSep, ts.copy(e.projectionMatrix);
      const s = n.eyeSep / 2, o = s * n.near / n.focus, a = n.near * Math.tan(Ss * n.fov * 0.5) / n.zoom;
      let h, c;
      Lp.elements[12] = -s, Op.elements[12] = s, h = -a * n.aspect + o, c = a * n.aspect + o, ts.elements[0] = 2 * n.near / (c - h), ts.elements[8] = (c + h) / (c - h), this.cameraL.projectionMatrix.copy(ts), h = -a * n.aspect - o, c = a * n.aspect - o, ts.elements[0] = 2 * n.near / (c - h), ts.elements[8] = (c + h) / (c - h), this.cameraR.projectionMatrix.copy(ts);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Lp), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Op);
  }
}
const si = /* @__PURE__ */ aC();
function aC() {
  const r = new ArrayBuffer(4), e = new Float32Array(r), n = new Uint32Array(r), i = new Uint32Array(512), s = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const l = c - 127;
    l < -27 ? (i[c] = 0, i[c | 256] = 32768, s[c] = 24, s[c | 256] = 24) : l < -14 ? (i[c] = 1024 >> -l - 14, i[c | 256] = 1024 >> -l - 14 | 32768, s[c] = -l - 1, s[c | 256] = -l - 1) : l <= 15 ? (i[c] = l + 15 << 10, i[c | 256] = l + 15 << 10 | 32768, s[c] = 13, s[c | 256] = 13) : l < 128 ? (i[c] = 31744, i[c | 256] = 64512, s[c] = 24, s[c | 256] = 24) : (i[c] = 31744, i[c | 256] = 64512, s[c] = 13, s[c | 256] = 13);
  }
  const o = new Uint32Array(2048), a = new Uint32Array(64), h = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let l = c << 13, u = 0;
    for (; (l & 8388608) === 0; )
      l <<= 1, u -= 8388608;
    l &= -8388609, u += 947912704, o[c] = l | u;
  }
  for (let c = 1024; c < 2048; ++c)
    o[c] = 939524096 + (c - 1024 << 13);
  for (let c = 1; c < 31; ++c)
    a[c] = c << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let c = 33; c < 63; ++c)
    a[c] = 2147483648 + (c - 32 << 23);
  a[63] = 3347054592;
  for (let c = 1; c < 64; ++c)
    c !== 32 && (h[c] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: i,
    shiftTable: s,
    mantissaTable: o,
    exponentTable: a,
    offsetTable: h
  };
}
function Be(r) {
  Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = Mt(r, -65504, 65504), si.floatView[0] = r;
  const e = si.uint32View[0], n = e >> 23 & 511;
  return si.baseTable[n] + ((e & 8388607) >> si.shiftTable[n]);
}
function no(r) {
  const e = r >> 10;
  return si.uint32View[0] = si.mantissaTable[si.offsetTable[e] + (r & 1023)] + si.exponentTable[e], si.floatView[0];
}
class hC {
  /**
   * Returns a half precision floating point value (FP16) from the given single
   * precision floating point value (FP32).
   *
   * @param {number} val - A single precision floating point value.
   * @return {number} The FP16 value.
   */
  static toHalfFloat(e) {
    return Be(e);
  }
  /**
   * Returns a single precision floating point value (FP32) from the given half
   * precision floating point value (FP16).
   *
   * @param {number} val - A half precision floating point value.
   * @return {number} The FP32 value.
   */
  static fromHalfFloat(e) {
    return no(e);
  }
}
const Kt = /* @__PURE__ */ new $(), za = /* @__PURE__ */ new nt();
let cC = 0;
class ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: cC++ }), this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = i, this.usage = Co, this.updateRanges = [], this.gpuType = Ju, this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(e, n, i) {
    e *= this.itemSize, i *= n.itemSize;
    for (let s = 0, o = this.itemSize; s < o; s++)
      this.array[e + s] = n.array[i + s];
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(e) {
    return this.array.set(e), this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        za.fromBufferAttribute(this, n), za.applyMatrix3(e), this.setXY(n, za.x, za.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        Kt.fromBufferAttribute(this, n), Kt.applyMatrix3(e), this.setXYZ(n, Kt.x, Kt.y, Kt.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Kt.fromBufferAttribute(this, n), Kt.applyMatrix4(e), this.setXYZ(n, Kt.x, Kt.y, Kt.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Kt.fromBufferAttribute(this, n), Kt.applyNormalMatrix(e), this.setXYZ(n, Kt.x, Kt.y, Kt.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Kt.fromBufferAttribute(this, n), Kt.transformDirection(e), this.setXYZ(n, Kt.x, Kt.y, Kt.z);
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = Ie(i, this.array)), i;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(e, n, i) {
    return this.normalized && (i = Tt(i, this.array)), this.array[e * this.itemSize + n] = i, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(e, n, i) {
    return e *= this.itemSize, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(e, n, i, s) {
    return e *= this.itemSize, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array), s = Tt(s, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = s, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(e, n, i, s, o) {
    return e *= this.itemSize, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array), s = Tt(s, this.array), o = Tt(o, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = s, this.array[e + 3] = o, this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Co && (e.usage = this.usage), e;
  }
}
class lC extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Int8Array(e), n, i);
  }
}
class uC extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Uint8Array(e), n, i);
  }
}
class fC extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8ClampedArray)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Uint8ClampedArray(e), n, i);
  }
}
class dC extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Int16Array(e), n, i);
  }
}
class yg extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class pC extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Int32Array(e), n, i);
  }
}
class xg extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class yC extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let n = no(this.array[e * this.itemSize]);
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize] = Be(n), this;
  }
  getY(e) {
    let n = no(this.array[e * this.itemSize + 1]);
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize + 1] = Be(n), this;
  }
  getZ(e) {
    let n = no(this.array[e * this.itemSize + 2]);
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize + 2] = Be(n), this;
  }
  getW(e) {
    let n = no(this.array[e * this.itemSize + 3]);
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize + 3] = Be(n), this;
  }
  setXY(e, n, i) {
    return e *= this.itemSize, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array)), this.array[e + 0] = Be(n), this.array[e + 1] = Be(i), this;
  }
  setXYZ(e, n, i, s) {
    return e *= this.itemSize, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array), s = Tt(s, this.array)), this.array[e + 0] = Be(n), this.array[e + 1] = Be(i), this.array[e + 2] = Be(s), this;
  }
  setXYZW(e, n, i, s, o) {
    return e *= this.itemSize, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array), s = Tt(s, this.array), o = Tt(o, this.array)), this.array[e + 0] = Be(n), this.array[e + 1] = Be(i), this.array[e + 2] = Be(s), this.array[e + 3] = Be(o), this;
  }
}
class wt extends ke {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
class Ar {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new $(1 / 0, 1 / 0, 1 / 0), n = new $(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(dn.fromArray(e, n));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(dn.fromBufferAttribute(e, n));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(e, n) {
    const i = dn.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const o = i.getAttribute("position");
      if (n === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, h = o.count; a < h; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, dn) : dn.fromBufferAttribute(o, a), dn.applyMatrix4(e.matrixWorld), this.expandByPoint(dn);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Aa.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Aa.copy(i.boundingBox)), Aa.applyMatrix4(e.matrixWorld), this.union(Aa);
    }
    const s = e.children;
    for (let o = 0, a = s.length; o < a; o++)
      this.expandByObject(s[o], n);
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(e) {
    return this.clampPoint(e.center, dn), dn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(e) {
    let n, i;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, i += e.normal.z * this.min.z), n <= -e.constant && i >= -e.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(jr), Ca.subVectors(this.max, jr), Zs.subVectors(e.a, jr), Gs.subVectors(e.b, jr), Js.subVectors(e.c, jr), bi.subVectors(Gs, Zs), vi.subVectors(Js, Gs), es.subVectors(Zs, Js);
    let n = [
      0,
      -bi.z,
      bi.y,
      0,
      -vi.z,
      vi.y,
      0,
      -es.z,
      es.y,
      bi.z,
      0,
      -bi.x,
      vi.z,
      0,
      -vi.x,
      es.z,
      0,
      -es.x,
      -bi.y,
      bi.x,
      0,
      -vi.y,
      vi.x,
      0,
      -es.y,
      es.x,
      0
    ];
    return !qc(n, Zs, Gs, Js, Ca) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !qc(n, Zs, Gs, Js, Ca)) ? !1 : (Pa.crossVectors(bi, vi), n = [Pa.x, Pa.y, Pa.z], qc(n, Zs, Gs, Js, Ca));
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, dn).distanceTo(e);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(dn).length() * 0.5), e;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Gn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Gn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Gn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Gn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Gn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Gn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Gn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Gn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Gn), this);
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @param {Object} json - The serialized json to set the box from.
   * @return {Box3} A reference to this bounding box.
   */
  fromJSON(e) {
    return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
  }
}
const Gn = [
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $()
], dn = /* @__PURE__ */ new $(), Aa = /* @__PURE__ */ new Ar(), Zs = /* @__PURE__ */ new $(), Gs = /* @__PURE__ */ new $(), Js = /* @__PURE__ */ new $(), bi = /* @__PURE__ */ new $(), vi = /* @__PURE__ */ new $(), es = /* @__PURE__ */ new $(), jr = /* @__PURE__ */ new $(), Ca = /* @__PURE__ */ new $(), Pa = /* @__PURE__ */ new $(), ns = /* @__PURE__ */ new $();
function qc(r, e, n, i, s) {
  for (let o = 0, a = r.length - 3; o <= a; o += 3) {
    ns.fromArray(r, o);
    const h = s.x * Math.abs(ns.x) + s.y * Math.abs(ns.y) + s.z * Math.abs(ns.z), c = e.dot(ns), l = n.dot(ns), u = i.dot(ns);
    if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > h)
      return !1;
  }
  return !0;
}
const xC = /* @__PURE__ */ new Ar(), Yr = /* @__PURE__ */ new $(), Dc = /* @__PURE__ */ new $();
class lf {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(e = new $(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : xC.setFromPoints(e).getCenter(i);
    let s = 0;
    for (let o = 0, a = e.length; o < a; o++)
      s = Math.max(s, i.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(s), this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(e) {
    return this.center.add(e), this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Yr.subVectors(e, this.center);
    const n = Yr.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n), s = (i - this.radius) * 0.5;
      this.center.addScaledVector(Yr, s / i), this.radius += s;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Dc.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Yr.copy(e.center).add(Dc)), this.expandByPoint(Yr.copy(e.center).sub(Dc))), this);
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @param {Object} json - The serialized json to set the sphere from.
   * @return {Box3} A reference to this bounding sphere.
   */
  fromJSON(e) {
    return this.radius = e.radius, this.center.fromArray(e.center), this;
  }
}
function mC(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function nu(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function gC() {
  const r = nu("canvas");
  return r.style.display = "block", r;
}
const Bp = {};
function Fp(r) {
  r in Bp || (Bp[r] = !0, console.warn(r));
}
let wC = 0;
const Ge = /* @__PURE__ */ new te(), $c = /* @__PURE__ */ new Ve(), Qs = /* @__PURE__ */ new $(), je = /* @__PURE__ */ new Ar(), Hr = /* @__PURE__ */ new Ar(), ae = /* @__PURE__ */ new $();
class ee extends Li {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: wC++ }), this.uuid = Tn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (mC(e) ? xg : yg)(e, 1) : this.index = e, this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(e) {
    return this.indirect = e, this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(e, n, i = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: i
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const o = new Wn().getNormalMatrix(e);
      i.applyNormalMatrix(o), i.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(e) {
    return Ge.makeRotationFromQuaternion(e), this.applyMatrix4(Ge), this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(e) {
    return Ge.makeRotationX(e), this.applyMatrix4(Ge), this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(e) {
    return Ge.makeRotationY(e), this.applyMatrix4(Ge), this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(e) {
    return Ge.makeRotationZ(e), this.applyMatrix4(Ge), this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(e, n, i) {
    return Ge.makeTranslation(e, n, i), this.applyMatrix4(Ge), this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(e, n, i) {
    return Ge.makeScale(e, n, i), this.applyMatrix4(Ge), this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(e) {
    return $c.lookAt(e), $c.updateMatrix(), this.applyMatrix4($c.matrix), this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Qs).negate(), this.translate(Qs.x, Qs.y, Qs.z), this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const i = [];
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        i.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new wt(i, 3));
    } else {
      const i = Math.min(e.length, n.count);
      for (let s = 0; s < i; s++) {
        const o = e[s];
        n.setXYZ(s, o.x, o.y, o.z || 0);
      }
      e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ar());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new $(-1 / 0, -1 / 0, -1 / 0),
        new $(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let i = 0, s = n.length; i < s; i++) {
          const o = n[i];
          je.setFromBufferAttribute(o), this.morphTargetsRelative ? (ae.addVectors(this.boundingBox.min, je.min), this.boundingBox.expandByPoint(ae), ae.addVectors(this.boundingBox.max, je.max), this.boundingBox.expandByPoint(ae)) : (this.boundingBox.expandByPoint(je.min), this.boundingBox.expandByPoint(je.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new lf());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new $(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (je.setFromBufferAttribute(e), n)
        for (let o = 0, a = n.length; o < a; o++) {
          const h = n[o];
          Hr.setFromBufferAttribute(h), this.morphTargetsRelative ? (ae.addVectors(je.min, Hr.min), je.expandByPoint(ae), ae.addVectors(je.max, Hr.max), je.expandByPoint(ae)) : (je.expandByPoint(Hr.min), je.expandByPoint(Hr.max));
        }
      je.getCenter(i);
      let s = 0;
      for (let o = 0, a = e.count; o < a; o++)
        ae.fromBufferAttribute(e, o), s = Math.max(s, i.distanceToSquared(ae));
      if (n)
        for (let o = 0, a = n.length; o < a; o++) {
          const h = n[o], c = this.morphTargetsRelative;
          for (let l = 0, u = h.count; l < u; l++)
            ae.fromBufferAttribute(h, l), c && (Qs.fromBufferAttribute(e, l), ae.add(Qs)), s = Math.max(s, i.distanceToSquared(ae));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = n.position, s = n.normal, o = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ke(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute("tangent"), h = [], c = [];
    for (let b = 0; b < i.count; b++)
      h[b] = new $(), c[b] = new $();
    const l = new $(), u = new $(), f = new $(), d = new nt(), p = new nt(), y = new nt(), x = new $(), m = new $();
    function g(b, v, _) {
      l.fromBufferAttribute(i, b), u.fromBufferAttribute(i, v), f.fromBufferAttribute(i, _), d.fromBufferAttribute(o, b), p.fromBufferAttribute(o, v), y.fromBufferAttribute(o, _), u.sub(l), f.sub(l), p.sub(d), y.sub(d);
      const z = 1 / (p.x * y.y - y.x * p.y);
      isFinite(z) && (x.copy(u).multiplyScalar(y.y).addScaledVector(f, -p.y).multiplyScalar(z), m.copy(f).multiplyScalar(p.x).addScaledVector(u, -y.x).multiplyScalar(z), h[b].add(x), h[v].add(x), h[_].add(x), c[b].add(m), c[v].add(m), c[_].add(m));
    }
    let w = this.groups;
    w.length === 0 && (w = [{
      start: 0,
      count: e.count
    }]);
    for (let b = 0, v = w.length; b < v; ++b) {
      const _ = w[b], z = _.start, P = _.count;
      for (let k = z, B = z + P; k < B; k += 3)
        g(
          e.getX(k + 0),
          e.getX(k + 1),
          e.getX(k + 2)
        );
    }
    const M = new $(), S = new $(), E = new $(), A = new $();
    function I(b) {
      E.fromBufferAttribute(s, b), A.copy(E);
      const v = h[b];
      M.copy(v), M.sub(E.multiplyScalar(E.dot(v))).normalize(), S.crossVectors(A, v);
      const z = S.dot(c[b]) < 0 ? -1 : 1;
      a.setXYZW(b, M.x, M.y, M.z, z);
    }
    for (let b = 0, v = w.length; b < v; ++b) {
      const _ = w[b], z = _.start, P = _.count;
      for (let k = z, B = z + P; k < B; k += 3)
        I(e.getX(k + 0)), I(e.getX(k + 1)), I(e.getX(k + 2));
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new ke(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let d = 0, p = i.count; d < p; d++)
          i.setXYZ(d, 0, 0, 0);
      const s = new $(), o = new $(), a = new $(), h = new $(), c = new $(), l = new $(), u = new $(), f = new $();
      if (e)
        for (let d = 0, p = e.count; d < p; d += 3) {
          const y = e.getX(d + 0), x = e.getX(d + 1), m = e.getX(d + 2);
          s.fromBufferAttribute(n, y), o.fromBufferAttribute(n, x), a.fromBufferAttribute(n, m), u.subVectors(a, o), f.subVectors(s, o), u.cross(f), h.fromBufferAttribute(i, y), c.fromBufferAttribute(i, x), l.fromBufferAttribute(i, m), h.add(u), c.add(u), l.add(u), i.setXYZ(y, h.x, h.y, h.z), i.setXYZ(x, c.x, c.y, c.z), i.setXYZ(m, l.x, l.y, l.z);
        }
      else
        for (let d = 0, p = n.count; d < p; d += 3)
          s.fromBufferAttribute(n, d + 0), o.fromBufferAttribute(n, d + 1), a.fromBufferAttribute(n, d + 2), u.subVectors(a, o), f.subVectors(s, o), u.cross(f), i.setXYZ(d + 0, u.x, u.y, u.z), i.setXYZ(d + 1, u.x, u.y, u.z), i.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      ae.fromBufferAttribute(e, n), ae.normalize(), e.setXYZ(n, ae.x, ae.y, ae.z);
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function e(h, c) {
      const l = h.array, u = h.itemSize, f = h.normalized, d = new l.constructor(c.length * u);
      let p = 0, y = 0;
      for (let x = 0, m = c.length; x < m; x++) {
        h.isInterleavedBufferAttribute ? p = c[x] * h.data.stride + h.offset : p = c[x] * u;
        for (let g = 0; g < u; g++)
          d[y++] = l[p++];
      }
      return new ke(d, u, f);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new ee(), i = this.index.array, s = this.attributes;
    for (const h in s) {
      const c = s[h], l = e(c, i);
      n.setAttribute(h, l);
    }
    const o = this.morphAttributes;
    for (const h in o) {
      const c = [], l = o[h];
      for (let u = 0, f = l.length; u < f; u++) {
        const d = l[u], p = e(d, i);
        c.push(p);
      }
      n.morphAttributes[h] = c;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let h = 0, c = a.length; h < c; h++) {
      const l = a[h];
      n.addGroup(l.start, l.count, l.materialIndex);
    }
    return n;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const l in c)
        c[l] !== void 0 && (e[l] = c[l]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const l = i[c];
      e.data.attributes[c] = l.toJSON(e.data);
    }
    const s = {};
    let o = !1;
    for (const c in this.morphAttributes) {
      const l = this.morphAttributes[c], u = [];
      for (let f = 0, d = l.length; f < d; f++) {
        const p = l[f];
        u.push(p.toJSON(e.data));
      }
      u.length > 0 && (s[c] = u, o = !0);
    }
    o && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const h = this.boundingSphere;
    return h !== null && (e.data.boundingSphere = h.toJSON()), e;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone());
    const s = e.attributes;
    for (const l in s) {
      const u = s[l];
      this.setAttribute(l, u.clone(n));
    }
    const o = e.morphAttributes;
    for (const l in o) {
      const u = [], f = o[l];
      for (let d = 0, p = f.length; d < p; d++)
        u.push(f[d].clone(n));
      this.morphAttributes[l] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let l = 0, u = a.length; l < u; l++) {
      const f = a[l];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const h = e.boundingBox;
    h !== null && (this.boundingBox = h.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class bC {
  /**
   * Constructs a new GL buffer attribute.
   *
   * @param {WebGLBuffer} buffer - The native WebGL buffer.
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} itemSize - The item size.
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @param {number} count - The expected number of vertices in VBO.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i, s, o, a = !1) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = n, this.itemSize = i, this.elementSize = s, this.count = o, this.normalized = a, this.version = 0;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the given native WebGL buffer.
   *
   * @param {WebGLBuffer} buffer - The buffer to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this;
  }
  /**
   * Sets the given native data type and element size.
   *
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @return {BufferAttribute} A reference to this instance.
   */
  setType(e, n) {
    return this.type = e, this.elementSize = n, this;
  }
  /**
   * Sets the item size.
   *
   * @param {number} itemSize - The item size.
   * @return {BufferAttribute} A reference to this instance.
   */
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  /**
   * Sets the count (the expected number of vertices in VBO).
   *
   * @param {number} count - The count.
   * @return {BufferAttribute} A reference to this instance.
   */
  setCount(e) {
    return this.count = e, this;
  }
}
class vC extends ke {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(e, n, i, s = 1) {
    super(e, n, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class MC extends ee {
  /**
   * Constructs a new instanced buffer geometry.
   */
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class mg {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(e, n) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = n, this.count = e !== void 0 ? e.length / n : 0, this.usage = Co, this.updateRanges = [], this.version = 0, this.uuid = Tn();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(e, n, i) {
    e *= this.stride, i *= n.stride;
    for (let s = 0, o = this.stride; s < o; s++)
      this.array[e + s] = n.array[i + s];
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Tn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const n = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(n, this.stride);
    return i.setUsage(this.usage), i;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Tn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
class _C extends mg {
  /**
   * Constructs a new instanced interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
   */
  constructor(e, n, i = 1) {
    super(e, n), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const n = super.clone(e);
    return n.meshPerAttribute = this.meshPerAttribute, n;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.isInstancedInterleavedBuffer = !0, n.meshPerAttribute = this.meshPerAttribute, n;
  }
}
const Me = /* @__PURE__ */ new $();
class uf {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, i, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = n, this.offset = i, this.normalized = s;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let n = 0, i = this.data.count; n < i; n++)
      Me.fromBufferAttribute(this, n), Me.applyMatrix4(e), this.setXYZ(n, Me.x, Me.y, Me.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Me.fromBufferAttribute(this, n), Me.applyNormalMatrix(e), this.setXYZ(n, Me.x, Me.y, Me.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Me.fromBufferAttribute(this, n), Me.transformDirection(e), this.setXYZ(n, Me.x, Me.y, Me.z);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, n) {
    let i = this.array[e * this.data.stride + this.offset + n];
    return this.normalized && (i = Ie(i, this.array)), i;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(e, n, i) {
    return this.normalized && (i = Tt(i, this.array)), this.data.array[e * this.data.stride + this.offset + n] = i, this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.data.array[e * this.data.stride + this.offset] = n, this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = n, this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = n, this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(e, n) {
    return this.normalized && (n = Tt(n, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = n, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let n = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (n = Ie(n, this.array)), n;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(e, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = i, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(e, n, i, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array), s = Tt(s, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = i, this.data.array[e + 2] = s, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(e, n, i, s, o) {
    return e = e * this.data.stride + this.offset, this.normalized && (n = Tt(n, this.array), i = Tt(i, this.array), s = Tt(s, this.array), o = Tt(o, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = i, this.data.array[e + 2] = s, this.data.array[e + 3] = o, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const n = [];
      for (let i = 0; i < this.count; i++) {
        const s = i * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          n.push(this.data.array[s + o]);
      }
      return new ke(new this.array.constructor(n), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new uf(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const n = [];
      for (let i = 0; i < this.count; i++) {
        const s = i * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          n.push(this.data.array[s + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: n,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
const Jn = /* @__PURE__ */ new $(), Vc = /* @__PURE__ */ new $(), Ia = /* @__PURE__ */ new $(), Mi = /* @__PURE__ */ new $(), Uc = /* @__PURE__ */ new $(), ka = /* @__PURE__ */ new $(), Wc = /* @__PURE__ */ new $();
class gg {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(e = new $(), n = new $(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(e) {
    return this.origin.copy(this.at(e, Jn)), this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(e) {
    const n = Jn.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (Jn.copy(this.origin).addScaledVector(this.direction, n), Jn.distanceToSquared(e));
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(e, n, i, s) {
    Vc.copy(e).add(n).multiplyScalar(0.5), Ia.copy(n).sub(e).normalize(), Mi.copy(this.origin).sub(Vc);
    const o = e.distanceTo(n) * 0.5, a = -this.direction.dot(Ia), h = Mi.dot(this.direction), c = -Mi.dot(Ia), l = Mi.lengthSq(), u = Math.abs(1 - a * a);
    let f, d, p, y;
    if (u > 0)
      if (f = a * c - h, d = a * h - c, y = o * u, f >= 0)
        if (d >= -y)
          if (d <= y) {
            const x = 1 / u;
            f *= x, d *= x, p = f * (f + a * d + 2 * h) + d * (a * f + d + 2 * c) + l;
          } else
            d = o, f = Math.max(0, -(a * d + h)), p = -f * f + d * (d + 2 * c) + l;
        else
          d = -o, f = Math.max(0, -(a * d + h)), p = -f * f + d * (d + 2 * c) + l;
      else
        d <= -y ? (f = Math.max(0, -(-a * o + h)), d = f > 0 ? -o : Math.min(Math.max(-o, -c), o), p = -f * f + d * (d + 2 * c) + l) : d <= y ? (f = 0, d = Math.min(Math.max(-o, -c), o), p = d * (d + 2 * c) + l) : (f = Math.max(0, -(a * o + h)), d = f > 0 ? o : Math.min(Math.max(-o, -c), o), p = -f * f + d * (d + 2 * c) + l);
    else
      d = a > 0 ? -o : o, f = Math.max(0, -(a * d + h)), p = -f * f + d * (d + 2 * c) + l;
    return i && i.copy(this.origin).addScaledVector(this.direction, f), s && s.copy(Vc).addScaledVector(Ia, d), p;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(e, n) {
    Jn.subVectors(e.center, this.origin);
    const i = Jn.dot(this.direction), s = Jn.dot(Jn) - i * i, o = e.radius * e.radius;
    if (s > o) return null;
    const a = Math.sqrt(o - s), h = i - a, c = i + a;
    return c < 0 ? null : h < 0 ? this.at(c, n) : this.at(h, n);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(e) {
    return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(e, n) {
    let i, s, o, a, h, c;
    const l = 1 / this.direction.x, u = 1 / this.direction.y, f = 1 / this.direction.z, d = this.origin;
    return l >= 0 ? (i = (e.min.x - d.x) * l, s = (e.max.x - d.x) * l) : (i = (e.max.x - d.x) * l, s = (e.min.x - d.x) * l), u >= 0 ? (o = (e.min.y - d.y) * u, a = (e.max.y - d.y) * u) : (o = (e.max.y - d.y) * u, a = (e.min.y - d.y) * u), i > a || o > s || ((o > i || isNaN(i)) && (i = o), (a < s || isNaN(s)) && (s = a), f >= 0 ? (h = (e.min.z - d.z) * f, c = (e.max.z - d.z) * f) : (h = (e.max.z - d.z) * f, c = (e.min.z - d.z) * f), i > c || h > s) || ((h > i || i !== i) && (i = h), (c < s || s !== s) && (s = c), s < 0) ? null : this.at(i >= 0 ? i : s, n);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(e) {
    return this.intersectBox(e, Jn) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(e, n, i, s, o) {
    Uc.subVectors(n, e), ka.subVectors(i, e), Wc.crossVectors(Uc, ka);
    let a = this.direction.dot(Wc), h;
    if (a > 0) {
      if (s) return null;
      h = 1;
    } else if (a < 0)
      h = -1, a = -a;
    else
      return null;
    Mi.subVectors(this.origin, e);
    const c = h * this.direction.dot(ka.crossVectors(Mi, ka));
    if (c < 0)
      return null;
    const l = h * this.direction.dot(Uc.cross(Mi));
    if (l < 0 || c + l > a)
      return null;
    const u = -h * Mi.dot(Wc);
    return u < 0 ? null : this.at(u / a, o);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const Np = /* @__PURE__ */ new te();
class SC {
  /**
   * Constructs a new raycaster.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   * @param {number} [near=0] - All results returned are further away than near. Near can't be negative.
   * @param {number} [far=Infinity] - All results returned are closer than far. Far can't be lower than near.
   */
  constructor(e, n, i = 0, s = 1 / 0) {
    this.ray = new gg(e, n), this.near = i, this.far = s, this.camera = null, this.layers = new hf(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  /**
   * Updates the ray with a new origin and direction by copying the values from the arguments.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   */
  set(e, n) {
    this.ray.set(e, n);
  }
  /**
   * Uses the given coordinates and camera to compute a new origin and direction for the internal ray.
   *
   * @param {Vector2} coords - 2D coordinates of the mouse, in normalized device coordinates (NDC).
   * X and Y components should be between `-1` and `1`.
   * @param {Camera} camera - The camera from which the ray should originate.
   */
  setFromCamera(e, n) {
    n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  /**
   * Uses the given WebXR controller to compute a new origin and direction for the internal ray.
   *
   * @param {WebXRController} controller - The controller to copy the position and direction from.
   * @return {Raycaster} A reference to this raycaster.
   */
  setFromXRController(e) {
    return Np.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Np), this;
  }
  /**
   * The intersection point of a raycaster intersection test.
   * @typedef {Object} Raycaster~Intersection
   * @property {number} distance - The distance from the ray's origin to the intersection point.
   * @property {number} distanceToRay -  Some 3D objects e.g. {@link Points} provide the distance of the
   * intersection to the nearest point on the ray. For other objects it will be `undefined`.
   * @property {Vector3} point - The intersection point, in world coordinates.
   * @property {Object} face - The face that has been intersected.
   * @property {number} faceIndex - The face index.
   * @property {Object3D} object - The 3D object that has been intersected.
   * @property {Vector2} uv - U,V coordinates at point of intersection.
   * @property {Vector2} uv1 - Second set of U,V coordinates at point of intersection.
   * @property {Vector3} uv1 - Interpolated normal vector at point of intersection.
   * @property {number} instanceId - The index number of the instance where the ray
   * intersects the {@link InstancedMesh}.
   */
  /**
   * Checks all intersection between the ray and the object with or without the
   * descendants. Intersections are returned sorted by distance, closest first.
   *
   * `Raycaster` delegates to the `raycast()` method of the passed 3D object, when
   * evaluating whether the ray intersects the object or not. This allows meshes to respond
   * differently to ray casting than lines or points.
   *
   * Note that for meshes, faces must be pointed towards the origin of the ray in order
   * to be detected; intersections of the ray passing through the back of a face will not
   * be detected. To raycast against both faces of an object, you'll want to set  {@link Material#side}
   * to `THREE.DoubleSide`.
   *
   * @param {Object3D} object - The 3D object to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObject(e, n = !0, i = []) {
    return iu(e, this, i, n), i.sort(qp), i;
  }
  /**
   * Checks all intersection between the ray and the objects with or without
   * the descendants. Intersections are returned sorted by distance, closest first.
   *
   * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObjects(e, n = !0, i = []) {
    for (let s = 0, o = e.length; s < o; s++)
      iu(e[s], this, i, n);
    return i.sort(qp), i;
  }
}
function qp(r, e) {
  return r.distance - e.distance;
}
function iu(r, e, n, i) {
  let s = !0;
  if (r.layers.test(e.layers) && r.raycast(e, n) === !1 && (s = !1), s === !0 && i === !0) {
    const o = r.children;
    for (let a = 0, h = o.length; a < h; a++)
      iu(o[a], e, n, !0);
  }
}
const Dp = /* @__PURE__ */ new Wn().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), $p = /* @__PURE__ */ new Wn().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function TC() {
  const r = {
    enabled: !0,
    workingColorSpace: Ql,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(s, o, a) {
      return this.enabled === !1 || o === a || !o || !a || (this.spaces[o].transfer === th && (s.r = li(s.r), s.g = li(s.g), s.b = li(s.b)), this.spaces[o].primaries !== this.spaces[a].primaries && (s.applyMatrix3(this.spaces[o].toXYZ), s.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === th && (s.r = xr(s.r), s.g = xr(s.g), s.b = xr(s.b))), s;
    },
    workingToColorSpace: function(s, o) {
      return this.convert(s, this.workingColorSpace, o);
    },
    colorSpaceToWorking: function(s, o) {
      return this.convert(s, o, this.workingColorSpace);
    },
    getPrimaries: function(s) {
      return this.spaces[s].primaries;
    },
    getTransfer: function(s) {
      return s === tf ? Kl : this.spaces[s].transfer;
    },
    getLuminanceCoefficients: function(s, o = this.workingColorSpace) {
      return s.fromArray(this.spaces[o].luminanceCoefficients);
    },
    define: function(s) {
      Object.assign(this.spaces, s);
    },
    // Internal APIs
    _getMatrix: function(s, o, a) {
      return s.copy(this.spaces[o].toXYZ).multiply(this.spaces[a].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(s) {
      return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(s = this.workingColorSpace) {
      return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
    },
    // Deprecated
    fromWorkingColorSpace: function(s, o) {
      return Fp("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), r.workingToColorSpace(s, o);
    },
    toWorkingColorSpace: function(s, o) {
      return Fp("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), r.colorSpaceToWorking(s, o);
    }
  }, e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], n = [0.2126, 0.7152, 0.0722], i = [0.3127, 0.329];
  return r.define({
    [Ql]: {
      primaries: e,
      whitePoint: i,
      transfer: Kl,
      toXYZ: Dp,
      fromXYZ: $p,
      luminanceCoefficients: n,
      workingColorSpaceConfig: { unpackColorSpace: rn },
      outputColorSpaceConfig: { drawingBufferColorSpace: rn }
    },
    [rn]: {
      primaries: e,
      whitePoint: i,
      transfer: th,
      toXYZ: Dp,
      fromXYZ: $p,
      luminanceCoefficients: n,
      outputColorSpaceConfig: { drawingBufferColorSpace: rn }
    }
  }), r;
}
const Ke = /* @__PURE__ */ TC();
function li(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function xr(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
let Ks;
class wg {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(e, n = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let i;
    if (e instanceof HTMLCanvasElement)
      i = e;
    else {
      Ks === void 0 && (Ks = nu("canvas")), Ks.width = e.width, Ks.height = e.height;
      const s = Ks.getContext("2d");
      e instanceof ImageData ? s.putImageData(e, 0, 0) : s.drawImage(e, 0, 0, e.width, e.height), i = Ks;
    }
    return i.toDataURL(n);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = nu("canvas");
      n.width = e.width, n.height = e.height;
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const s = i.getImageData(0, 0, e.width, e.height), o = s.data;
      for (let a = 0; a < o.length; a++)
        o[a] = li(o[a] / 255) * 255;
      return i.putImageData(s, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(li(n[i] / 255) * 255) : n[i] = li(n[i]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let EC = 0;
class Xh {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: EC++ }), this.uuid = Tn(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  getSize(e) {
    const n = this.data;
    return n instanceof HTMLVideoElement ? e.set(n.videoWidth, n.videoHeight) : n !== null ? e.set(n.width, n.height, n.depth || 0) : e.set(0, 0, 0), e;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let o;
      if (Array.isArray(s)) {
        o = [];
        for (let a = 0, h = s.length; a < h; a++)
          s[a].isDataTexture ? o.push(jc(s[a].image)) : o.push(jc(s[a]));
      } else
        o = jc(s);
      i.url = o;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function jc(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? wg.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let zC = 0;
const Yc = /* @__PURE__ */ new $();
class de extends Li {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = de.DEFAULT_IMAGE, n = de.DEFAULT_MAPPING, i = Pi, s = Pi, o = Tr, a = am, h = Qu, c = Zu, l = de.DEFAULT_ANISOTROPY, u = tf) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: zC++ }), this.uuid = Tn(), this.name = "", this.source = new Xh(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = i, this.wrapT = s, this.magFilter = o, this.minFilter = a, this.anisotropy = l, this.format = h, this.internalFormat = null, this.type = c, this.offset = new nt(0, 0), this.repeat = new nt(1, 1), this.center = new nt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Wn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0;
  }
  /**
   * The width of the texture in pixels.
   */
  get width() {
    return this.source.getSize(Yc).x;
  }
  /**
   * The height of the texture in pixels.
   */
  get height() {
    return this.source.getSize(Yc).y;
  }
  /**
   * The depth of the texture in pixels.
   */
  get depth() {
    return this.source.getSize(Yc).z;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Adds a range of data in the data texture to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  /**
   * Sets this texture's properties based on `values`.
   * @param {Object} values - A container with texture parameters.
   */
  setValues(e) {
    for (const n in e) {
      const i = e[n];
      if (i === void 0) {
        console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);
        continue;
      }
      const s = this[n];
      if (s === void 0) {
        console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);
        continue;
      }
      s && i && s.isVector2 && i.isVector2 || s && i && s.isVector3 && i.isVector3 || s && i && s.isMatrix3 && i.isMatrix3 ? s.copy(i) : this[n] = i;
    }
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), n || (e.textures[this.uuid] = i), i;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(e) {
    if (this.mapping !== Hu) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Zl:
          e.x = e.x - Math.floor(e.x);
          break;
        case Pi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Gl:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Zl:
          e.y = e.y - Math.floor(e.y);
          break;
        case Pi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Gl:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
de.DEFAULT_IMAGE = null;
de.DEFAULT_MAPPING = Hu;
de.DEFAULT_ANISOTROPY = 1;
class Oi {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(e = 0, n = 0, i = 0, s = 1) {
    Oi.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = i, this.w = s;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(e, n, i, s) {
    return this.x = e, this.y = n, this.z = i, this.w = s, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(e) {
    return this.w = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(e) {
    const n = this.x, i = this.y, s = this.z, o = this.w, a = e.elements;
    return this.x = a[0] * n + a[4] * i + a[8] * s + a[12] * o, this.y = a[1] * n + a[5] * i + a[9] * s + a[13] * o, this.z = a[2] * n + a[6] * i + a[10] * s + a[14] * o, this.w = a[3] * n + a[7] * i + a[11] * s + a[15] * o, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(e) {
    let n, i, s, o;
    const c = e.elements, l = c[0], u = c[4], f = c[8], d = c[1], p = c[5], y = c[9], x = c[2], m = c[6], g = c[10];
    if (Math.abs(u - d) < 0.01 && Math.abs(f - x) < 0.01 && Math.abs(y - m) < 0.01) {
      if (Math.abs(u + d) < 0.1 && Math.abs(f + x) < 0.1 && Math.abs(y + m) < 0.1 && Math.abs(l + p + g - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const M = (l + 1) / 2, S = (p + 1) / 2, E = (g + 1) / 2, A = (u + d) / 4, I = (f + x) / 4, b = (y + m) / 4;
      return M > S && M > E ? M < 0.01 ? (i = 0, s = 0.707106781, o = 0.707106781) : (i = Math.sqrt(M), s = A / i, o = I / i) : S > E ? S < 0.01 ? (i = 0.707106781, s = 0, o = 0.707106781) : (s = Math.sqrt(S), i = A / s, o = b / s) : E < 0.01 ? (i = 0.707106781, s = 0.707106781, o = 0) : (o = Math.sqrt(E), i = I / o, s = b / o), this.set(i, s, o, n), this;
    }
    let w = Math.sqrt((m - y) * (m - y) + (f - x) * (f - x) + (d - u) * (d - u));
    return Math.abs(w) < 1e-3 && (w = 1), this.x = (m - y) / w, this.y = (f - x) / w, this.z = (d - u) / w, this.w = Math.acos((l + p + g - 1) / 2), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(e, n) {
    return this.x = Mt(this.x, e.x, n.x), this.y = Mt(this.y, e.y, n.y), this.z = Mt(this.z, e.z, n.z), this.w = Mt(this.w, e.w, n.w), this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(e, n) {
    return this.x = Mt(this.x, e, n), this.y = Mt(this.y, e, n), this.z = Mt(this.z, e, n), this.w = Mt(this.w, e, n), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Mt(i, e, n));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this.w = e.w + (n.w - e.w) * i, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class bg extends Li {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   * @property {number} [depth=1] - The texture depth.
   * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, n = 1, i = {}) {
    super(), i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Tr,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1,
      depth: 1,
      multiview: !1
    }, i), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = i.depth, this.scissor = new Oi(0, 0, e, n), this.scissorTest = !1, this.viewport = new Oi(0, 0, e, n);
    const s = { width: e, height: n, depth: i.depth }, o = new de(s);
    this.textures = [];
    const a = i.count;
    for (let h = 0; h < a; h++)
      this.textures[h] = o.clone(), this.textures[h].isRenderTargetTexture = !0, this.textures[h].renderTarget = this;
    this._setTextureOptions(i), this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples, this.multiview = i.multiview;
  }
  _setTextureOptions(e = {}) {
    const n = {
      minFilter: Tr,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null
    };
    e.mapping !== void 0 && (n.mapping = e.mapping), e.wrapS !== void 0 && (n.wrapS = e.wrapS), e.wrapT !== void 0 && (n.wrapT = e.wrapT), e.wrapR !== void 0 && (n.wrapR = e.wrapR), e.magFilter !== void 0 && (n.magFilter = e.magFilter), e.minFilter !== void 0 && (n.minFilter = e.minFilter), e.format !== void 0 && (n.format = e.format), e.type !== void 0 && (n.type = e.type), e.anisotropy !== void 0 && (n.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (n.colorSpace = e.colorSpace), e.flipY !== void 0 && (n.flipY = e.flipY), e.generateMipmaps !== void 0 && (n.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (n.internalFormat = e.internalFormat);
    for (let i = 0; i < this.textures.length; i++)
      this.textures[i].setValues(n);
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      this.width = e, this.height = n, this.depth = i;
      for (let s = 0, o = this.textures.length; s < o; s++)
        this.textures[s].image.width = e, this.textures[s].image.height = n, this.textures[s].image.depth = i, this.textures[s].isArrayTexture = this.textures[s].image.depth > 1;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, i = e.textures.length; n < i; n++) {
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0, this.textures[n].renderTarget = this;
      const s = Object.assign({}, e.textures[n].image);
      this.textures[n].source = new Xh(s);
    }
    return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class vg extends de {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, n = 1, i = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: i, depth: s }, this.magFilter = zn, this.minFilter = zn, this.wrapR = Pi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class AC extends bg {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, n = 1, i = 1, s = {}) {
    super(e, n, s), this.isRenderTarget3D = !0, this.depth = i, this.texture = new vg(null, e, n, i), this._setTextureOptions(s), this.texture.isRenderTargetTexture = !0;
  }
}
class ff {
  /**
   * Constructs a new uniform.
   *
   * @param {any} value - The uniform value.
   */
  constructor(e) {
    this.value = e;
  }
  /**
   * Returns a new uniform with copied values from this instance.
   * If the value has a `clone()` method, the value is cloned as well.
   *
   * @return {Uniform} A clone of this instance.
   */
  clone() {
    return new ff(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let CC = 0;
class PC extends Li {
  /**
   * Constructs a new uniforms group.
   */
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: CC++ }), this.name = "", this.usage = Co, this.uniforms = [];
  }
  /**
   * Adds the given uniform to this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  add(e) {
    return this.uniforms.push(e), this;
  }
  /**
   * Removes the given uniform from this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  remove(e) {
    const n = this.uniforms.indexOf(e);
    return n !== -1 && this.uniforms.splice(n, 1), this;
  }
  /**
   * Sets the name of this uniforms group.
   *
   * @param {string} name - The name to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the usage of this uniforms group.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Copies the values of the given uniforms group to this instance.
   *
   * @param {UniformsGroup} source - The uniforms group to copy.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const n = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, s = n.length; i < s; i++) {
      const o = Array.isArray(n[i]) ? n[i] : [n[i]];
      for (let a = 0; a < o.length; a++)
        this.uniforms.push(o[a].clone());
    }
    return this;
  }
  /**
   * Returns a new uniforms group with copied values from this instance.
   *
   * @return {UniformsGroup} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class IC extends Li {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, n = null) {
    super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  /**
   * Connects the controls to the DOM. This method has so called "side effects" since
   * it adds the module's event listeners to the DOM.
   *
   * @param {HTMLDOMElement} element - The DOM element to connect to.
   */
  connect(e) {
    if (e === void 0) {
      console.warn("THREE.Controls: connect() now requires an element.");
      return;
    }
    this.domElement !== null && this.disconnect(), this.domElement = e;
  }
  /**
   * Disconnects the controls from the DOM.
   */
  disconnect() {
  }
  /**
   * Call this method if you no longer want use to the controls. It frees all internal
   * resources and removes all event listeners.
   */
  dispose() {
  }
  /**
   * Controls should implement this method if they have to update their internal state
   * per simulation step.
   *
   * @param {number} [delta] - The time delta in seconds.
   */
  update() {
  }
}
class An {
  /**
   * Constructs a new curve.
   */
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor.
   *
   * @abstract
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor. Unlike {@link Curve#getPoint}, this method honors the length
   * of the curve which equidistant samples.
   *
   * @param {number} u - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPointAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, n);
  }
  /**
   * This method samples the curve via {@link Curve#getPoint} and returns an array of points representing
   * the curve shape.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return n;
  }
  // Get sequence of points using getPointAt( u )
  /**
   * This method samples the curve via {@link Curve#getPointAt} and returns an array of points representing
   * the curve shape. Unlike {@link Curve#getPoints}, this method returns equi-spaced points across the entire
   * curve.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getSpacedPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPointAt(i / e));
    return n;
  }
  /**
   * Returns the total arc length of the curve.
   *
   * @return {number} The length of the curve.
   */
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  /**
   * Returns an array of cumulative segment lengths of the curve.
   *
   * @param {number} [divisions=this.arcLengthDivisions] - The number of divisions.
   * @return {Array<number>} An array holding the cumulative segment lengths.
   */
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let i, s = this.getPoint(0), o = 0;
    n.push(0);
    for (let a = 1; a <= e; a++)
      i = this.getPoint(a / e), o += i.distanceTo(s), n.push(o), s = i;
    return this.cacheArcLengths = n, n;
  }
  /**
   * Update the cumulative segment distance cache. The method must be called
   * every time curve parameters are changed. If an updated curve is part of a
   * composed curve like {@link CurvePath}, this method must be called on the
   * composed curve, too.
   */
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  /**
   * Given an interpolation factor in the range `[0,1]`, this method returns an updated
   * interpolation factor in the same range that can be ued to sample equidistant points
   * from a curve.
   *
   * @param {number} u - The interpolation factor.
   * @param {?number} distance - An optional distance on the curve.
   * @return {number} The updated interpolation factor.
   */
  getUtoTmapping(e, n = null) {
    const i = this.getLengths();
    let s = 0;
    const o = i.length;
    let a;
    n ? a = n : a = e * i[o - 1];
    let h = 0, c = o - 1, l;
    for (; h <= c; )
      if (s = Math.floor(h + (c - h) / 2), l = i[s] - a, l < 0)
        h = s + 1;
      else if (l > 0)
        c = s - 1;
      else {
        c = s;
        break;
      }
    if (s = c, i[s] === a)
      return s / (o - 1);
    const u = i[s], d = i[s + 1] - u, p = (a - u) / d;
    return (s + p) / (o - 1);
  }
  /**
   * Returns a unit vector tangent for the given interpolation factor.
   * If the derived curve does not implement its tangent derivation,
   * two points a small delta apart will be used to find its gradient
   * which seems to give a reasonable approximation.
   *
   * @param {number} t - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   */
  getTangent(e, n) {
    let s = e - 1e-4, o = e + 1e-4;
    s < 0 && (s = 0), o > 1 && (o = 1);
    const a = this.getPoint(s), h = this.getPoint(o), c = n || (a.isVector2 ? new nt() : new $());
    return c.copy(h).sub(a).normalize(), c;
  }
  /**
   * Same as {@link Curve#getTangent} but with equidistant samples.
   *
   * @param {number} u - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   * @see {@link Curve#getPointAt}
   */
  getTangentAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, n);
  }
  /**
   * Generates the Frenet Frames. Requires a curve definition in 3D space. Used
   * in geometries like {@link TubeGeometry} or {@link ExtrudeGeometry}.
   *
   * @param {number} segments - The number of segments.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @return {{tangents: Array<Vector3>, normals: Array<Vector3>, binormals: Array<Vector3>}} The Frenet Frames.
   */
  computeFrenetFrames(e, n = !1) {
    const i = new $(), s = [], o = [], a = [], h = new $(), c = new te();
    for (let p = 0; p <= e; p++) {
      const y = p / e;
      s[p] = this.getTangentAt(y, new $());
    }
    o[0] = new $(), a[0] = new $();
    let l = Number.MAX_VALUE;
    const u = Math.abs(s[0].x), f = Math.abs(s[0].y), d = Math.abs(s[0].z);
    u <= l && (l = u, i.set(1, 0, 0)), f <= l && (l = f, i.set(0, 1, 0)), d <= l && i.set(0, 0, 1), h.crossVectors(s[0], i).normalize(), o[0].crossVectors(s[0], h), a[0].crossVectors(s[0], o[0]);
    for (let p = 1; p <= e; p++) {
      if (o[p] = o[p - 1].clone(), a[p] = a[p - 1].clone(), h.crossVectors(s[p - 1], s[p]), h.length() > Number.EPSILON) {
        h.normalize();
        const y = Math.acos(Mt(s[p - 1].dot(s[p]), -1, 1));
        o[p].applyMatrix4(c.makeRotationAxis(h, y));
      }
      a[p].crossVectors(s[p], o[p]);
    }
    if (n === !0) {
      let p = Math.acos(Mt(o[0].dot(o[e]), -1, 1));
      p /= e, s[0].dot(h.crossVectors(o[0], o[e])) > 0 && (p = -p);
      for (let y = 1; y <= e; y++)
        o[y].applyMatrix4(c.makeRotationAxis(s[y], p * y)), a[y].crossVectors(s[y], o[y]);
    }
    return {
      tangents: s,
      normals: o,
      binormals: a
    };
  }
  /**
   * Returns a new curve with copied values from this instance.
   *
   * @return {Curve} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given curve to this instance.
   *
   * @param {Curve} source - The curve to copy.
   * @return {Curve} A reference to this curve.
   */
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  /**
   * Serializes the curve into JSON.
   *
   * @return {Object} A JSON object representing the serialized curve.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  /**
   * Deserializes the curve from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized curve.
   * @return {Curve} A reference to this curve.
   */
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Zh extends An {
  /**
   * Constructs a new ellipse curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   */
  constructor(e = 0, n = 0, i = 1, s = 1, o = 0, a = Math.PI * 2, h = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = i, this.yRadius = s, this.aStartAngle = o, this.aEndAngle = a, this.aClockwise = h, this.aRotation = c;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new nt()) {
    const i = n, s = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += s;
    for (; o > s; ) o -= s;
    o < Number.EPSILON && (a ? o = 0 : o = s), this.aClockwise === !0 && !a && (o === s ? o = -s : o = o - s);
    const h = this.aStartAngle + e * o;
    let c = this.aX + this.xRadius * Math.cos(h), l = this.aY + this.yRadius * Math.sin(h);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), f = Math.sin(this.aRotation), d = c - this.aX, p = l - this.aY;
      c = d * u - p * f + this.aX, l = d * f + p * u + this.aY;
    }
    return i.set(c, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Mg extends Zh {
  /**
   * Constructs a new arc curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [aRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   */
  constructor(e, n, i, s, o, a) {
    super(e, n, i, i, s, o, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function df() {
  let r = 0, e = 0, n = 0, i = 0;
  function s(o, a, h, c) {
    r = o, e = h, n = -3 * o + 3 * a - 2 * h - c, i = 2 * o - 2 * a + h + c;
  }
  return {
    initCatmullRom: function(o, a, h, c, l) {
      s(a, h, l * (h - o), l * (c - a));
    },
    initNonuniformCatmullRom: function(o, a, h, c, l, u, f) {
      let d = (a - o) / l - (h - o) / (l + u) + (h - a) / u, p = (h - a) / u - (c - a) / (u + f) + (c - h) / f;
      d *= u, p *= u, s(a, h, d, p);
    },
    calc: function(o) {
      const a = o * o, h = a * o;
      return r + e * o + n * a + i * h;
    }
  };
}
const Ra = /* @__PURE__ */ new $(), Hc = /* @__PURE__ */ new df(), Xc = /* @__PURE__ */ new df(), Zc = /* @__PURE__ */ new df();
class _g extends An {
  /**
   * Constructs a new Catmull-Rom curve.
   *
   * @param {Array<Vector3>} [points] - An array of 3D points defining the curve.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @param {('centripetal'|'chordal'|'catmullrom')} [curveType='centripetal'] - The curve type.
   * @param {number} [tension=0.5] - Tension of the curve.
   */
  constructor(e = [], n = !1, i = "centripetal", s = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = i, this.tension = s;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, n = new $()) {
    const i = n, s = this.points, o = s.length, a = (o - (this.closed ? 0 : 1)) * e;
    let h = Math.floor(a), c = a - h;
    this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / o) + 1) * o : c === 0 && h === o - 1 && (h = o - 2, c = 1);
    let l, u;
    this.closed || h > 0 ? l = s[(h - 1) % o] : (Ra.subVectors(s[0], s[1]).add(s[0]), l = Ra);
    const f = s[h % o], d = s[(h + 1) % o];
    if (this.closed || h + 2 < o ? u = s[(h + 2) % o] : (Ra.subVectors(s[o - 1], s[o - 2]).add(s[o - 1]), u = Ra), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let y = Math.pow(l.distanceToSquared(f), p), x = Math.pow(f.distanceToSquared(d), p), m = Math.pow(d.distanceToSquared(u), p);
      x < 1e-4 && (x = 1), y < 1e-4 && (y = x), m < 1e-4 && (m = x), Hc.initNonuniformCatmullRom(l.x, f.x, d.x, u.x, y, x, m), Xc.initNonuniformCatmullRom(l.y, f.y, d.y, u.y, y, x, m), Zc.initNonuniformCatmullRom(l.z, f.z, d.z, u.z, y, x, m);
    } else this.curveType === "catmullrom" && (Hc.initCatmullRom(l.x, f.x, d.x, u.x, this.tension), Xc.initCatmullRom(l.y, f.y, d.y, u.y, this.tension), Zc.initCatmullRom(l.z, f.z, d.z, u.z, this.tension));
    return i.set(
      Hc.calc(c),
      Xc.calc(c),
      Zc.calc(c)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(s.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const s = this.points[n];
      e.points.push(s.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(new $().fromArray(s));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function Vp(r, e, n, i, s) {
  const o = (i - e) * 0.5, a = (s - n) * 0.5, h = r * r, c = r * h;
  return (2 * n - 2 * i + o + a) * c + (-3 * n + 3 * i - 2 * o - a) * h + o * r + n;
}
function kC(r, e) {
  const n = 1 - r;
  return n * n * e;
}
function RC(r, e) {
  return 2 * (1 - r) * r * e;
}
function OC(r, e) {
  return r * r * e;
}
function po(r, e, n, i) {
  return kC(r, e) + RC(r, n) + OC(r, i);
}
function LC(r, e) {
  const n = 1 - r;
  return n * n * n * e;
}
function BC(r, e) {
  const n = 1 - r;
  return 3 * n * n * r * e;
}
function FC(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function NC(r, e) {
  return r * r * r * e;
}
function yo(r, e, n, i, s) {
  return LC(r, e) + BC(r, n) + FC(r, i) + NC(r, s);
}
class pf extends An {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The first control point.
   * @param {Vector2} [v2] - The second control point.
   * @param {Vector2} [v3] - The end point.
   */
  constructor(e = new nt(), n = new nt(), i = new nt(), s = new nt()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = s;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new nt()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2, h = this.v3;
    return i.set(
      yo(e, s.x, o.x, a.x, h.x),
      yo(e, s.y, o.y, a.y, h.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Sg extends An {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The first control point.
   * @param {Vector3} [v2] - The second control point.
   * @param {Vector3} [v3] - The end point.
   */
  constructor(e = new $(), n = new $(), i = new $(), s = new $()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = s;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, n = new $()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2, h = this.v3;
    return i.set(
      yo(e, s.x, o.x, a.x, h.x),
      yo(e, s.y, o.y, a.y, h.y),
      yo(e, s.z, o.z, a.z, h.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class yf extends An {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector2} [v1] - The start point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new nt(), n = new nt()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the line.
   */
  getPoint(e, n = new nt()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new nt()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Tg extends An {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector3} [v1] - The start point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new $(), n = new $()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the line.
   */
  getPoint(e, n = new $()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new $()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class xf extends An {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The control point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new nt(), n = new nt(), i = new nt()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new nt()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2;
    return i.set(
      po(e, s.x, o.x, a.x),
      po(e, s.y, o.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class mf extends An {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The control point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new $(), n = new $(), i = new $()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, n = new $()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2;
    return i.set(
      po(e, s.x, o.x, a.x),
      po(e, s.y, o.y, a.y),
      po(e, s.z, o.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class gf extends An {
  /**
   * Constructs a new 2D spline curve.
   *
   * @param {Array<Vector2>} [points] -  An array of 2D points defining the curve.
   */
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new nt()) {
    const i = n, s = this.points, o = (s.length - 1) * e, a = Math.floor(o), h = o - a, c = s[a === 0 ? a : a - 1], l = s[a], u = s[a > s.length - 2 ? s.length - 1 : a + 1], f = s[a > s.length - 3 ? s.length - 1 : a + 2];
    return i.set(
      Vp(h, c.x, l.x, u.x, f.x),
      Vp(h, c.y, l.y, u.y, f.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const s = this.points[n];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(new nt().fromArray(s));
    }
    return this;
  }
}
const Ih = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcCurve: Mg,
  CatmullRomCurve3: _g,
  CubicBezierCurve: pf,
  CubicBezierCurve3: Sg,
  EllipseCurve: Zh,
  LineCurve: yf,
  LineCurve3: Tg,
  QuadraticBezierCurve: xf,
  QuadraticBezierCurve3: mf,
  SplineCurve: gf
}, Symbol.toStringTag, { value: "Module" }));
class Eg extends An {
  /**
   * Constructs a new curve path.
   */
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  /**
   * Adds a curve to this curve path.
   *
   * @param {Curve} curve - The curve to add.
   */
  add(e) {
    this.curves.push(e);
  }
  /**
   * Adds a line curve to close the path.
   *
   * @return {CurvePath} A reference to this curve path.
   */
  closePath() {
    const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Ih[i](n, e));
    }
    return this;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definitions)
   * for the given interpolation factor.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint(e, n) {
    const i = e * this.getLength(), s = this.getCurveLengths();
    let o = 0;
    for (; o < s.length; ) {
      if (s[o] >= i) {
        const a = s[o] - i, h = this.curves[o], c = h.getLength(), l = c === 0 ? 0 : 1 - a / c;
        return h.getPointAt(l, n);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  /**
   * Returns list of cumulative curve lengths of the defined curves.
   *
   * @return {Array<number>} The curve lengths.
   */
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let i = 0, s = this.curves.length; i < s; i++)
      n += this.curves[i].getLength(), e.push(n);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let i;
    for (let s = 0, o = this.curves; s < o.length; s++) {
      const a = o[s], h = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, c = a.getPoints(h);
      for (let l = 0; l < c.length; l++) {
        const u = c[l];
        i && i.equals(u) || (n.push(u), i = u);
      }
    }
    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const s = e.curves[n];
      this.curves.push(s.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let n = 0, i = this.curves.length; n < i; n++) {
      const s = this.curves[n];
      e.curves.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const s = e.curves[n];
      this.curves.push(new Ih[s.type]().fromJSON(s));
    }
    return this;
  }
}
class kh extends Eg {
  /**
   * Constructs a new path.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the path.
   */
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new nt(), e && this.setFromPoints(e);
  }
  /**
   * Creates a path from the given list of points. The points are added
   * to the path as instances of {@link LineCurve}.
   *
   * @param {Array<Vector2>} points - An array of 2D points.
   * @return {Path} A reference to this path.
   */
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, i = e.length; n < i; n++)
      this.lineTo(e[n].x, e[n].y);
    return this;
  }
  /**
   * Moves {@link Path#currentPoint} to the given point.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {Path} A reference to this path.
   */
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  lineTo(e, n) {
    const i = new yf(this.currentPoint.clone(), new nt(e, n));
    return this.curves.push(i), this.currentPoint.set(e, n), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  quadraticCurveTo(e, n, i, s) {
    const o = new xf(
      this.currentPoint.clone(),
      new nt(e, n),
      new nt(i, s)
    );
    return this.curves.push(o), this.currentPoint.set(i, s), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  bezierCurveTo(e, n, i, s, o, a) {
    const h = new pf(
      this.currentPoint.clone(),
      new nt(e, n),
      new nt(i, s),
      new nt(o, a)
    );
    return this.curves.push(h), this.currentPoint.set(o, a), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {Path} A reference to this path.
   */
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e), i = new gf(n);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  /**
   * Adds an arc as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point.
   *
   * @param {number} [aX=0] - The x coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} [aY=0] - The y coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} [aRadius=1] - The radius of the arc.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  arc(e, n, i, s, o, a) {
    const h = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + h,
      n + c,
      i,
      s,
      o,
      a
    ), this;
  }
  /**
   * Adds an absolutely positioned arc as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} [aX=0] - The x coordinate of the center of the arc.
   * @param {number} [aY=0] - The y coordinate of the center of the arc.
   * @param {number} [aRadius=1] - The radius of the arc.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  absarc(e, n, i, s, o, a) {
    return this.absellipse(e, n, i, i, s, o, a), this;
  }
  /**
   * Adds an ellipse as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point
   *
   * @param {number} [aX=0] - The x coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} [aY=0] - The y coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  ellipse(e, n, i, s, o, a, h, c) {
    const l = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + l, n + u, i, s, o, a, h, c), this;
  }
  /**
   * Adds an absolutely positioned ellipse as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} [aX=0] - The x coordinate of the absolute center of the ellipse.
   * @param {number} [aY=0] - The y coordinate of the absolute center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  absellipse(e, n, i, s, o, a, h, c) {
    const l = new Zh(e, n, i, s, o, a, h, c);
    if (this.curves.length > 0) {
      const f = l.getPoint(0);
      f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class mr extends kh {
  /**
   * Constructs a new shape.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the shape.
   */
  constructor(e) {
    super(e), this.uuid = Tn(), this.type = "Shape", this.holes = [];
  }
  /**
   * Returns an array representing each contour of the holes
   * as a list of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {Array<Array<Vector2>>} The holes as a series of 2D points.
   */
  getPointsHoles(e) {
    const n = [];
    for (let i = 0, s = this.holes.length; i < s; i++)
      n[i] = this.holes[i].getPoints(e);
    return n;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  /**
   * Returns an object that holds contour data for the shape and its holes as
   * arrays of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {{shape:Array<Vector2>,holes:Array<Array<Vector2>>}} An object with contour data.
   */
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const s = e.holes[n];
      this.holes.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let n = 0, i = this.holes.length; n < i; n++) {
      const s = this.holes[n];
      e.holes.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const s = e.holes[n];
      this.holes.push(new kh().fromJSON(s));
    }
    return this;
  }
}
const zg = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, _i = { h: 0, s: 0, l: 0 }, Oa = { h: 0, s: 0, l: 0 };
function Gc(r, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? r + (e - r) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - n) : r;
}
class Cr {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(e, n, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, i);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, n, i);
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(e, n = rn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ke.colorSpaceToWorking(this, n), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(e, n, i, s = Ke.workingColorSpace) {
    return this.r = e, this.g = n, this.b = i, Ke.colorSpaceToWorking(this, s), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(e, n, i, s = Ke.workingColorSpace) {
    if (e = ef(e, 1), n = Mt(n, 0, 1), i = Mt(i, 0, 1), n === 0)
      this.r = this.g = this.b = i;
    else {
      const o = i <= 0.5 ? i * (1 + n) : i + n - i * n, a = 2 * i - o;
      this.r = Gc(a, o, e + 1 / 3), this.g = Gc(a, o, e), this.b = Gc(a, o, e - 1 / 3);
    }
    return Ke.colorSpaceToWorking(this, s), this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(e, n = rn) {
    function i(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const a = s[1], h = s[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return i(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              n
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return i(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return i(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = s[1], a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          n
        );
      if (a === 6)
        return this.setHex(parseInt(o, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(e, n = rn) {
    const i = zg[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(e) {
    return this.r = li(e.r), this.g = li(e.g), this.b = li(e.b), this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(e) {
    return this.r = xr(e.r), this.g = xr(e.g), this.b = xr(e.b), this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(e = rn) {
    return Ke.workingToColorSpace(we.copy(this), e), Math.round(Mt(we.r * 255, 0, 255)) * 65536 + Math.round(Mt(we.g * 255, 0, 255)) * 256 + Math.round(Mt(we.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(e = rn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(e, n = Ke.workingColorSpace) {
    Ke.workingToColorSpace(we.copy(this), n);
    const i = we.r, s = we.g, o = we.b, a = Math.max(i, s, o), h = Math.min(i, s, o);
    let c, l;
    const u = (h + a) / 2;
    if (h === a)
      c = 0, l = 0;
    else {
      const f = a - h;
      switch (l = u <= 0.5 ? f / (a + h) : f / (2 - a - h), a) {
        case i:
          c = (s - o) / f + (s < o ? 6 : 0);
          break;
        case s:
          c = (o - i) / f + 2;
          break;
        case o:
          c = (i - s) / f + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = l, e.l = u, e;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(e, n = Ke.workingColorSpace) {
    return Ke.workingToColorSpace(we.copy(this), n), e.r = we.r, e.g = we.g, e.b = we.b, e;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(e = rn) {
    Ke.workingToColorSpace(we.copy(this), e);
    const n = we.r, i = we.g, s = we.b;
    return e !== rn ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(s * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(e, n, i) {
    return this.getHSL(_i), this.setHSL(_i.h + e, _i.s + n, _i.l + i);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(e, n, i) {
    return this.r = e.r + (n.r - e.r) * i, this.g = e.g + (n.g - e.g) * i, this.b = e.b + (n.b - e.b) * i, this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(e, n) {
    this.getHSL(_i), e.getHSL(Oa);
    const i = fo(_i.h, Oa.h, n), s = fo(_i.s, Oa.s, n), o = fo(_i.l, Oa.l, n);
    return this.setHSL(i, s, o), this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(e) {
    const n = this.r, i = this.g, s = this.b, o = e.elements;
    return this.r = o[0] * n + o[3] * i + o[6] * s, this.g = o[1] * n + o[4] * i + o[7] * s, this.b = o[2] * n + o[5] * i + o[8] * s, this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const we = /* @__PURE__ */ new Cr();
Cr.NAMES = zg;
function qC(r, e, n = 2) {
  const i = e && e.length, s = i ? e[0] * n : r.length;
  let o = Ag(r, 0, s, n, !0);
  const a = [];
  if (!o || o.next === o.prev) return a;
  let h, c, l;
  if (i && (o = WC(r, e, o, n)), r.length > 80 * n) {
    h = 1 / 0, c = 1 / 0;
    let u = -1 / 0, f = -1 / 0;
    for (let d = n; d < s; d += n) {
      const p = r[d], y = r[d + 1];
      p < h && (h = p), y < c && (c = y), p > u && (u = p), y > f && (f = y);
    }
    l = Math.max(u - h, f - c), l = l !== 0 ? 32767 / l : 0;
  }
  return Ro(o, a, n, h, c, l, 0), a;
}
function Ag(r, e, n, i, s) {
  let o;
  if (s === ou(r, e, n, i) > 0)
    for (let a = e; a < n; a += i) o = Up(a / i | 0, r[a], r[a + 1], o);
  else
    for (let a = n - i; a >= e; a -= i) o = Up(a / i | 0, r[a], r[a + 1], o);
  return o && Er(o, o.next) && (Lo(o), o = o.next), o;
}
function Cs(r, e) {
  if (!r) return r;
  e || (e = r);
  let n = r, i;
  do
    if (i = !1, !n.steiner && (Er(n, n.next) || Xt(n.prev, n, n.next) === 0)) {
      if (Lo(n), n = e = n.prev, n === n.next) break;
      i = !0;
    } else
      n = n.next;
  while (i || n !== e);
  return e;
}
function Ro(r, e, n, i, s, o, a) {
  if (!r) return;
  !a && o && ZC(r, i, s, o);
  let h = r;
  for (; r.prev !== r.next; ) {
    const c = r.prev, l = r.next;
    if (o ? $C(r, i, s, o) : DC(r)) {
      e.push(c.i, r.i, l.i), Lo(r), r = l.next, h = l.next;
      continue;
    }
    if (r = l, r === h) {
      a ? a === 1 ? (r = VC(Cs(r), e), Ro(r, e, n, i, s, o, 2)) : a === 2 && UC(r, e, n, i, s, o) : Ro(Cs(r), e, n, i, s, o, 1);
      break;
    }
  }
}
function DC(r) {
  const e = r.prev, n = r, i = r.next;
  if (Xt(e, n, i) >= 0) return !1;
  const s = e.x, o = n.x, a = i.x, h = e.y, c = n.y, l = i.y, u = Math.min(s, o, a), f = Math.min(h, c, l), d = Math.max(s, o, a), p = Math.max(h, c, l);
  let y = i.next;
  for (; y !== e; ) {
    if (y.x >= u && y.x <= d && y.y >= f && y.y <= p && io(s, h, o, c, a, l, y.x, y.y) && Xt(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function $C(r, e, n, i) {
  const s = r.prev, o = r, a = r.next;
  if (Xt(s, o, a) >= 0) return !1;
  const h = s.x, c = o.x, l = a.x, u = s.y, f = o.y, d = a.y, p = Math.min(h, c, l), y = Math.min(u, f, d), x = Math.max(h, c, l), m = Math.max(u, f, d), g = su(p, y, e, n, i), w = su(x, m, e, n, i);
  let M = r.prevZ, S = r.nextZ;
  for (; M && M.z >= g && S && S.z <= w; ) {
    if (M.x >= p && M.x <= x && M.y >= y && M.y <= m && M !== s && M !== a && io(h, u, c, f, l, d, M.x, M.y) && Xt(M.prev, M, M.next) >= 0 || (M = M.prevZ, S.x >= p && S.x <= x && S.y >= y && S.y <= m && S !== s && S !== a && io(h, u, c, f, l, d, S.x, S.y) && Xt(S.prev, S, S.next) >= 0)) return !1;
    S = S.nextZ;
  }
  for (; M && M.z >= g; ) {
    if (M.x >= p && M.x <= x && M.y >= y && M.y <= m && M !== s && M !== a && io(h, u, c, f, l, d, M.x, M.y) && Xt(M.prev, M, M.next) >= 0) return !1;
    M = M.prevZ;
  }
  for (; S && S.z <= w; ) {
    if (S.x >= p && S.x <= x && S.y >= y && S.y <= m && S !== s && S !== a && io(h, u, c, f, l, d, S.x, S.y) && Xt(S.prev, S, S.next) >= 0) return !1;
    S = S.nextZ;
  }
  return !0;
}
function VC(r, e) {
  let n = r;
  do {
    const i = n.prev, s = n.next.next;
    !Er(i, s) && Pg(i, n, n.next, s) && Oo(i, s) && Oo(s, i) && (e.push(i.i, n.i, s.i), Lo(n), Lo(n.next), n = r = s), n = n.next;
  } while (n !== r);
  return Cs(n);
}
function UC(r, e, n, i, s, o) {
  let a = r;
  do {
    let h = a.next.next;
    for (; h !== a.prev; ) {
      if (a.i !== h.i && QC(a, h)) {
        let c = Ig(a, h);
        a = Cs(a, a.next), c = Cs(c, c.next), Ro(a, e, n, i, s, o, 0), Ro(c, e, n, i, s, o, 0);
        return;
      }
      h = h.next;
    }
    a = a.next;
  } while (a !== r);
}
function WC(r, e, n, i) {
  const s = [];
  for (let o = 0, a = e.length; o < a; o++) {
    const h = e[o] * i, c = o < a - 1 ? e[o + 1] * i : r.length, l = Ag(r, h, c, i, !1);
    l === l.next && (l.steiner = !0), s.push(JC(l));
  }
  s.sort(jC);
  for (let o = 0; o < s.length; o++)
    n = YC(s[o], n);
  return n;
}
function jC(r, e) {
  let n = r.x - e.x;
  if (n === 0 && (n = r.y - e.y, n === 0)) {
    const i = (r.next.y - r.y) / (r.next.x - r.x), s = (e.next.y - e.y) / (e.next.x - e.x);
    n = i - s;
  }
  return n;
}
function YC(r, e) {
  const n = HC(r, e);
  if (!n)
    return e;
  const i = Ig(n, r);
  return Cs(i, i.next), Cs(n, n.next);
}
function HC(r, e) {
  let n = e;
  const i = r.x, s = r.y;
  let o = -1 / 0, a;
  if (Er(r, n)) return n;
  do {
    if (Er(r, n.next)) return n.next;
    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
      const f = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (f <= i && f > o && (o = f, a = n.x < n.next.x ? n : n.next, f === i))
        return a;
    }
    n = n.next;
  } while (n !== e);
  if (!a) return null;
  const h = a, c = a.x, l = a.y;
  let u = 1 / 0;
  n = a;
  do {
    if (i >= n.x && n.x >= c && i !== n.x && Cg(s < l ? i : o, s, c, l, s < l ? o : i, s, n.x, n.y)) {
      const f = Math.abs(s - n.y) / (i - n.x);
      Oo(n, r) && (f < u || f === u && (n.x > a.x || n.x === a.x && XC(a, n))) && (a = n, u = f);
    }
    n = n.next;
  } while (n !== h);
  return a;
}
function XC(r, e) {
  return Xt(r.prev, r, e.prev) < 0 && Xt(e.next, r, r.next) < 0;
}
function ZC(r, e, n, i) {
  let s = r;
  do
    s.z === 0 && (s.z = su(s.x, s.y, e, n, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== r);
  s.prevZ.nextZ = null, s.prevZ = null, GC(s);
}
function GC(r) {
  let e, n = 1;
  do {
    let i = r, s;
    r = null;
    let o = null;
    for (e = 0; i; ) {
      e++;
      let a = i, h = 0;
      for (let l = 0; l < n && (h++, a = a.nextZ, !!a); l++)
        ;
      let c = n;
      for (; h > 0 || c > 0 && a; )
        h !== 0 && (c === 0 || !a || i.z <= a.z) ? (s = i, i = i.nextZ, h--) : (s = a, a = a.nextZ, c--), o ? o.nextZ = s : r = s, s.prevZ = o, o = s;
      i = a;
    }
    o.nextZ = null, n *= 2;
  } while (e > 1);
  return r;
}
function su(r, e, n, i, s) {
  return r = (r - n) * s | 0, e = (e - i) * s | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
}
function JC(r) {
  let e = r, n = r;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== r);
  return n;
}
function Cg(r, e, n, i, s, o, a, h) {
  return (s - a) * (e - h) >= (r - a) * (o - h) && (r - a) * (i - h) >= (n - a) * (e - h) && (n - a) * (o - h) >= (s - a) * (i - h);
}
function io(r, e, n, i, s, o, a, h) {
  return !(r === a && e === h) && Cg(r, e, n, i, s, o, a, h);
}
function QC(r, e) {
  return r.next.i !== e.i && r.prev.i !== e.i && !KC(r, e) && // dones't intersect other edges
  (Oo(r, e) && Oo(e, r) && t5(r, e) && // locally visible
  (Xt(r.prev, r, e.prev) || Xt(r, e.prev, e)) || // does not create opposite-facing sectors
  Er(r, e) && Xt(r.prev, r, r.next) > 0 && Xt(e.prev, e, e.next) > 0);
}
function Xt(r, e, n) {
  return (e.y - r.y) * (n.x - e.x) - (e.x - r.x) * (n.y - e.y);
}
function Er(r, e) {
  return r.x === e.x && r.y === e.y;
}
function Pg(r, e, n, i) {
  const s = Ba(Xt(r, e, n)), o = Ba(Xt(r, e, i)), a = Ba(Xt(n, i, r)), h = Ba(Xt(n, i, e));
  return !!(s !== o && a !== h || s === 0 && La(r, n, e) || o === 0 && La(r, i, e) || a === 0 && La(n, r, i) || h === 0 && La(n, e, i));
}
function La(r, e, n) {
  return e.x <= Math.max(r.x, n.x) && e.x >= Math.min(r.x, n.x) && e.y <= Math.max(r.y, n.y) && e.y >= Math.min(r.y, n.y);
}
function Ba(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function KC(r, e) {
  let n = r;
  do {
    if (n.i !== r.i && n.next.i !== r.i && n.i !== e.i && n.next.i !== e.i && Pg(n, n.next, r, e)) return !0;
    n = n.next;
  } while (n !== r);
  return !1;
}
function Oo(r, e) {
  return Xt(r.prev, r, r.next) < 0 ? Xt(r, e, r.next) >= 0 && Xt(r, r.prev, e) >= 0 : Xt(r, e, r.prev) < 0 || Xt(r, r.next, e) < 0;
}
function t5(r, e) {
  let n = r, i = !1;
  const s = (r.x + e.x) / 2, o = (r.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && s < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
  while (n !== r);
  return i;
}
function Ig(r, e) {
  const n = ru(r.i, r.x, r.y), i = ru(e.i, e.x, e.y), s = r.next, o = e.prev;
  return r.next = e, e.prev = r, n.next = s, s.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
}
function Up(r, e, n, i) {
  const s = ru(r, e, n);
  return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s;
}
function Lo(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function ru(r, e, n) {
  return {
    i: r,
    // vertex index in coordinates array
    x: e,
    y: n,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function e5(r, e, n, i) {
  const s = e && e.length, o = s ? e[0] * n : r.length;
  let a = Math.abs(ou(r, 0, o, n));
  if (s)
    for (let c = 0, l = e.length; c < l; c++) {
      const u = e[c] * n, f = c < l - 1 ? e[c + 1] * n : r.length;
      a -= Math.abs(ou(r, u, f, n));
    }
  let h = 0;
  for (let c = 0; c < i.length; c += 3) {
    const l = i[c] * n, u = i[c + 1] * n, f = i[c + 2] * n;
    h += Math.abs(
      (r[l] - r[f]) * (r[u + 1] - r[l + 1]) - (r[l] - r[u]) * (r[f + 1] - r[l + 1])
    );
  }
  return a === 0 && h === 0 ? 0 : Math.abs((h - a) / a);
}
function ou(r, e, n, i) {
  let s = 0;
  for (let o = e, a = n - i; o < n; o += i)
    s += (r[a] - r[o]) * (r[o + 1] + r[a + 1]), a = o;
  return s;
}
function n5(r) {
  const e = [], n = [], i = r[0][0].length;
  let s = 0, o = 0;
  for (const a of r) {
    for (const h of a)
      for (let c = 0; c < i; c++) e.push(h[c]);
    o && (s += o, n.push(s)), o = a.length;
  }
  return { vertices: e, holes: n, dimensions: i };
}
class i5 {
  /**
   * Triangulates the given shape definition by returning an array of triangles.
   *
   * @param {Array<number>} data - An array with 2D points.
   * @param {Array<number>} holeIndices - An array with indices defining holes.
   * @param {number} [dim=2] - The number of coordinates per vertex in the input array.
   * @return {Array<number>} An array representing the triangulated faces. Each face is defined by three consecutive numbers
   * representing vertex indices.
   */
  static triangulate(e, n, i = 2) {
    return qC(e, n, i);
  }
}
class Sn {
  /**
   * Calculate area of a ( 2D ) contour polygon.
   *
   * @param {Array<Vector2>} contour - An array of 2D points.
   * @return {number} The area.
   */
  static area(e) {
    const n = e.length;
    let i = 0;
    for (let s = n - 1, o = 0; o < n; s = o++)
      i += e[s].x * e[o].y - e[o].x * e[s].y;
    return i * 0.5;
  }
  /**
   * Returns `true` if the given contour uses a clockwise winding order.
   *
   * @param {Array<Vector2>} pts - An array of 2D points defining a polygon.
   * @return {boolean} Whether the given contour uses a clockwise winding order or not.
   */
  static isClockWise(e) {
    return Sn.area(e) < 0;
  }
  /**
   * Triangulates the given shape definition.
   *
   * @param {Array<Vector2>} contour - An array of 2D points defining the contour.
   * @param {Array<Array<Vector2>>} holes - An array that holds arrays of 2D points defining the holes.
   * @return {Array<Array<number>>} An array that holds for each face definition an array with three indices.
   */
  static triangulateShape(e, n) {
    const i = [], s = [], o = [];
    Wp(e), jp(i, e);
    let a = e.length;
    n.forEach(Wp);
    for (let c = 0; c < n.length; c++)
      s.push(a), a += n[c].length, jp(i, n[c]);
    const h = i5.triangulate(i, s);
    for (let c = 0; c < h.length; c += 3)
      o.push(h.slice(c, c + 3));
    return o;
  }
}
function Wp(r) {
  const e = r.length;
  e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function jp(r, e) {
  for (let n = 0; n < e.length; n++)
    r.push(e[n].x), r.push(e[n].y);
}
class s5 {
  /**
   * Constructs a new shape path.
   */
  constructor() {
    this.type = "ShapePath", this.color = new Cr(), this.subPaths = [], this.currentPath = null;
  }
  /**
   * Creates a new path and moves it current point to the given one.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {ShapePath} A reference to this shape path.
   */
  moveTo(e, n) {
    return this.currentPath = new kh(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, n), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  lineTo(e, n) {
    return this.currentPath.lineTo(e, n), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  quadraticCurveTo(e, n, i, s) {
    return this.currentPath.quadraticCurveTo(e, n, i, s), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  bezierCurveTo(e, n, i, s, o, a) {
    return this.currentPath.bezierCurveTo(e, n, i, s, o, a), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {ShapePath} A reference to this shape path.
   */
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  /**
   * Converts the paths into an array of shapes.
   *
   * @param {boolean} isCCW - By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW).
   * If this flag is set to `true`, then those are flipped.
   * @return {Array<Shape>} An array of shapes.
   */
  toShapes(e) {
    function n(g) {
      const w = [];
      for (let M = 0, S = g.length; M < S; M++) {
        const E = g[M], A = new mr();
        A.curves = E.curves, w.push(A);
      }
      return w;
    }
    function i(g, w) {
      const M = w.length;
      let S = !1;
      for (let E = M - 1, A = 0; A < M; E = A++) {
        let I = w[E], b = w[A], v = b.x - I.x, _ = b.y - I.y;
        if (Math.abs(_) > Number.EPSILON) {
          if (_ < 0 && (I = w[A], v = -v, b = w[E], _ = -_), g.y < I.y || g.y > b.y) continue;
          if (g.y === I.y) {
            if (g.x === I.x) return !0;
          } else {
            const z = _ * (g.x - I.x) - v * (g.y - I.y);
            if (z === 0) return !0;
            if (z < 0) continue;
            S = !S;
          }
        } else {
          if (g.y !== I.y) continue;
          if (b.x <= g.x && g.x <= I.x || I.x <= g.x && g.x <= b.x) return !0;
        }
      }
      return S;
    }
    const s = Sn.isClockWise, o = this.subPaths;
    if (o.length === 0) return [];
    let a, h, c;
    const l = [];
    if (o.length === 1)
      return h = o[0], c = new mr(), c.curves = h.curves, l.push(c), l;
    let u = !s(o[0].getPoints());
    u = e ? !u : u;
    const f = [], d = [];
    let p = [], y = 0, x;
    d[y] = void 0, p[y] = [];
    for (let g = 0, w = o.length; g < w; g++)
      h = o[g], x = h.getPoints(), a = s(x), a = e ? !a : a, a ? (!u && d[y] && y++, d[y] = { s: new mr(), p: x }, d[y].s.curves = h.curves, u && y++, p[y] = []) : p[y].push({ h, p: x[0] });
    if (!d[0]) return n(o);
    if (d.length > 1) {
      let g = !1, w = 0;
      for (let M = 0, S = d.length; M < S; M++)
        f[M] = [];
      for (let M = 0, S = d.length; M < S; M++) {
        const E = p[M];
        for (let A = 0; A < E.length; A++) {
          const I = E[A];
          let b = !0;
          for (let v = 0; v < d.length; v++)
            i(I.p, d[v].p) && (M !== v && w++, b ? (b = !1, f[v].push(I)) : g = !0);
          b && f[M].push(I);
        }
      }
      w > 0 && g === !1 && (p = f);
    }
    let m;
    for (let g = 0, w = d.length; g < w; g++) {
      c = d[g].s, l.push(c), m = p[g];
      for (let M = 0, S = m.length; M < S; M++)
        c.holes.push(m[M].h);
    }
    return l;
  }
}
function r5(r, e) {
  const n = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return n > e ? (r.repeat.x = 1, r.repeat.y = n / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2) : (r.repeat.x = e / n, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0), r;
}
function o5(r, e) {
  const n = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return n > e ? (r.repeat.x = e / n, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0) : (r.repeat.x = 1, r.repeat.y = n / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2), r;
}
function a5(r) {
  return r.repeat.x = 1, r.repeat.y = 1, r.offset.x = 0, r.offset.y = 0, r;
}
function h5(r, e, n, i) {
  const s = c5(i);
  switch (n) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case xm:
      return r * e;
    case wm:
      return r * e / s.components * s.byteLength;
    case bm:
      return r * e / s.components * s.byteLength;
    case vm:
      return r * e * 2 / s.components * s.byteLength;
    case Mm:
      return r * e * 2 / s.components * s.byteLength;
    case mm:
      return r * e * 3 / s.components * s.byteLength;
    case Qu:
      return r * e * 4 / s.components * s.byteLength;
    case _m:
      return r * e * 4 / s.components * s.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case Sm:
    case Tm:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Em:
    case zm:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case Cm:
    case Im:
      return Math.max(r, 16) * Math.max(e, 8) / 4;
    case Am:
    case Pm:
      return Math.max(r, 8) * Math.max(e, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case km:
    case Rm:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Om:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case Lm:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Bm:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Fm:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Nm:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case qm:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Dm:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case $m:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Vm:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Um:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Wm:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case jm:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Ym:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Hm:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Xm:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case Zm:
    case Gm:
    case Jm:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case Qm:
    case Km:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case tg:
    case eg:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${n} format.`
  );
}
function c5(r) {
  switch (r) {
    case Zu:
    case hm:
      return { byteLength: 1, components: 1 };
    case lm:
    case cm:
    case fm:
      return { byteLength: 2, components: 1 };
    case dm:
    case pm:
      return { byteLength: 2, components: 4 };
    case Gu:
    case um:
    case Ju:
      return { byteLength: 4, components: 1 };
    case ym:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
class l5 {
  /**
   * Scales the texture as large as possible within its surface without cropping
   * or stretching the texture. The method preserves the original aspect ratio of
   * the texture. Akin to CSS `object-fit: contain`
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static contain(e, n) {
    return r5(e, n);
  }
  /**
   * Scales the texture to the smallest possible size to fill the surface, leaving
   * no empty space. The method preserves the original aspect ratio of the texture.
   * Akin to CSS `object-fit: cover`.
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static cover(e, n) {
    return o5(e, n);
  }
  /**
   * Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.
   *
   * @param {Texture} texture - The texture.
   * @return {Texture} The updated texture.
   */
  static fill(e) {
    return a5(e);
  }
  /**
   * Determines how many bytes must be used to represent the texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} format - The texture's format.
   * @param {number} type - The texture's type.
   * @return {number} The byte length.
   */
  static getByteLength(e, n, i, s) {
    return h5(e, n, i, s);
  }
}
class wf extends ee {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(e = 1, n = 1, i = 1, s = 1, o = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: i,
      widthSegments: s,
      heightSegments: o,
      depthSegments: a
    };
    const h = this;
    s = Math.floor(s), o = Math.floor(o), a = Math.floor(a);
    const c = [], l = [], u = [], f = [];
    let d = 0, p = 0;
    y("z", "y", "x", -1, -1, i, n, e, a, o, 0), y("z", "y", "x", 1, -1, i, n, -e, a, o, 1), y("x", "z", "y", 1, 1, e, i, n, s, a, 2), y("x", "z", "y", 1, -1, e, i, -n, s, a, 3), y("x", "y", "z", 1, -1, e, n, i, s, o, 4), y("x", "y", "z", -1, -1, e, n, -i, s, o, 5), this.setIndex(c), this.setAttribute("position", new wt(l, 3)), this.setAttribute("normal", new wt(u, 3)), this.setAttribute("uv", new wt(f, 2));
    function y(x, m, g, w, M, S, E, A, I, b, v) {
      const _ = S / I, z = E / b, P = S / 2, k = E / 2, B = A / 2, R = I + 1, L = b + 1;
      let N = 0, q = 0;
      const U = new $();
      for (let J = 0; J < L; J++) {
        const X = J * z - k;
        for (let lt = 0; lt < R; lt++) {
          const ot = lt * _ - P;
          U[x] = ot * w, U[m] = X * M, U[g] = B, l.push(U.x, U.y, U.z), U[x] = 0, U[m] = 0, U[g] = A > 0 ? 1 : -1, u.push(U.x, U.y, U.z), f.push(lt / I), f.push(1 - J / b), N += 1;
        }
      }
      for (let J = 0; J < b; J++)
        for (let X = 0; X < I; X++) {
          const lt = d + X + R * J, ot = d + X + R * (J + 1), ut = d + (X + 1) + R * (J + 1), ct = d + (X + 1) + R * J;
          c.push(lt, ot, ct), c.push(ot, ut, ct), q += 6;
        }
      h.addGroup(p, q, v), p += q, d += N;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(e) {
    return new wf(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
class bf extends ee {
  /**
   * Constructs a new capsule geometry.
   *
   * @param {number} [radius=1] - Radius of the capsule.
   * @param {number} [height=1] - Height of the middle section.
   * @param {number} [capSegments=4] - Number of curve segments used to build each cap.
   * @param {number} [radialSegments=8] - Number of segmented faces around the circumference of the capsule. Must be an integer >= 3.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the middle section. Must be an integer >= 1.
   */
  constructor(e = 1, n = 1, i = 4, s = 8, o = 1) {
    super(), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: n,
      capSegments: i,
      radialSegments: s,
      heightSegments: o
    }, n = Math.max(0, n), i = Math.max(1, Math.floor(i)), s = Math.max(3, Math.floor(s)), o = Math.max(1, Math.floor(o));
    const a = [], h = [], c = [], l = [], u = n / 2, f = Math.PI / 2 * e, d = n, p = 2 * f + d, y = i * 2 + o, x = s + 1, m = new $(), g = new $();
    for (let w = 0; w <= y; w++) {
      let M = 0, S = 0, E = 0, A = 0;
      if (w <= i) {
        const v = w / i, _ = v * Math.PI / 2;
        S = -u - e * Math.cos(_), E = e * Math.sin(_), A = -e * Math.cos(_), M = v * f;
      } else if (w <= i + o) {
        const v = (w - i) / o;
        S = -u + v * n, E = e, A = 0, M = f + v * d;
      } else {
        const v = (w - i - o) / i, _ = v * Math.PI / 2;
        S = u + e * Math.sin(_), E = e * Math.cos(_), A = e * Math.sin(_), M = f + d + v * f;
      }
      const I = Math.max(0, Math.min(1, M / p));
      let b = 0;
      w === 0 ? b = 0.5 / s : w === y && (b = -0.5 / s);
      for (let v = 0; v <= s; v++) {
        const _ = v / s, z = _ * Math.PI * 2, P = Math.sin(z), k = Math.cos(z);
        g.x = -E * k, g.y = S, g.z = E * P, h.push(g.x, g.y, g.z), m.set(
          -E * k,
          A,
          E * P
        ), m.normalize(), c.push(m.x, m.y, m.z), l.push(_ + b, I);
      }
      if (w > 0) {
        const v = (w - 1) * x;
        for (let _ = 0; _ < s; _++) {
          const z = v + _, P = v + _ + 1, k = w * x + _, B = w * x + _ + 1;
          a.push(z, P, k), a.push(P, B, k);
        }
      }
    }
    this.setIndex(a), this.setAttribute("position", new wt(h, 3)), this.setAttribute("normal", new wt(c, 3)), this.setAttribute("uv", new wt(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CapsuleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new bf(e.radius, e.height, e.capSegments, e.radialSegments, e.heightSegments);
  }
}
class vf extends ee {
  /**
   * Constructs a new circle geometry.
   *
   * @param {number} [radius=1] - Radius of the circle.
   * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.
   * @param {number} [thetaStart=0] - Start angle for first segment in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,
   * of the circular sector in radians. The default value results in a complete circle.
   */
  constructor(e = 1, n = 32, i = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: n,
      thetaStart: i,
      thetaLength: s
    }, n = Math.max(3, n);
    const o = [], a = [], h = [], c = [], l = new $(), u = new nt();
    a.push(0, 0, 0), h.push(0, 0, 1), c.push(0.5, 0.5);
    for (let f = 0, d = 3; f <= n; f++, d += 3) {
      const p = i + f / n * s;
      l.x = e * Math.cos(p), l.y = e * Math.sin(p), a.push(l.x, l.y, l.z), h.push(0, 0, 1), u.x = (a[d] / e + 1) / 2, u.y = (a[d + 1] / e + 1) / 2, c.push(u.x, u.y);
    }
    for (let f = 1; f <= n; f++)
      o.push(f, f + 1, 0);
    this.setIndex(o), this.setAttribute("position", new wt(a, 3)), this.setAttribute("normal", new wt(h, 3)), this.setAttribute("uv", new wt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CircleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new vf(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Gh extends ee {
  /**
   * Constructs a new cylinder geometry.
   *
   * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
   * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
   * @param {number} [height=1] - Height of the cylinder.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
   * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cylinder.
   */
  constructor(e = 1, n = 1, i = 1, s = 32, o = 1, a = !1, h = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: i,
      radialSegments: s,
      heightSegments: o,
      openEnded: a,
      thetaStart: h,
      thetaLength: c
    };
    const l = this;
    s = Math.floor(s), o = Math.floor(o);
    const u = [], f = [], d = [], p = [];
    let y = 0;
    const x = [], m = i / 2;
    let g = 0;
    w(), a === !1 && (e > 0 && M(!0), n > 0 && M(!1)), this.setIndex(u), this.setAttribute("position", new wt(f, 3)), this.setAttribute("normal", new wt(d, 3)), this.setAttribute("uv", new wt(p, 2));
    function w() {
      const S = new $(), E = new $();
      let A = 0;
      const I = (n - e) / i;
      for (let b = 0; b <= o; b++) {
        const v = [], _ = b / o, z = _ * (n - e) + e;
        for (let P = 0; P <= s; P++) {
          const k = P / s, B = k * c + h, R = Math.sin(B), L = Math.cos(B);
          E.x = z * R, E.y = -_ * i + m, E.z = z * L, f.push(E.x, E.y, E.z), S.set(R, I, L).normalize(), d.push(S.x, S.y, S.z), p.push(k, 1 - _), v.push(y++);
        }
        x.push(v);
      }
      for (let b = 0; b < s; b++)
        for (let v = 0; v < o; v++) {
          const _ = x[v][b], z = x[v + 1][b], P = x[v + 1][b + 1], k = x[v][b + 1];
          (e > 0 || v !== 0) && (u.push(_, z, k), A += 3), (n > 0 || v !== o - 1) && (u.push(z, P, k), A += 3);
        }
      l.addGroup(g, A, 0), g += A;
    }
    function M(S) {
      const E = y, A = new nt(), I = new $();
      let b = 0;
      const v = S === !0 ? e : n, _ = S === !0 ? 1 : -1;
      for (let P = 1; P <= s; P++)
        f.push(0, m * _, 0), d.push(0, _, 0), p.push(0.5, 0.5), y++;
      const z = y;
      for (let P = 0; P <= s; P++) {
        const B = P / s * c + h, R = Math.cos(B), L = Math.sin(B);
        I.x = v * L, I.y = m * _, I.z = v * R, f.push(I.x, I.y, I.z), d.push(0, _, 0), A.x = R * 0.5 + 0.5, A.y = L * 0.5 * _ + 0.5, p.push(A.x, A.y), y++;
      }
      for (let P = 0; P < s; P++) {
        const k = E + P, B = z + P;
        S === !0 ? u.push(B, B + 1, k) : u.push(B + 1, B, k), b += 3;
      }
      l.addGroup(g, b, S === !0 ? 1 : 2), g += b;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CylinderGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Gh(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Mf extends Gh {
  /**
   * Constructs a new cone geometry.
   *
   * @param {number} [radius=1] - Radius of the cone base.
   * @param {number} [height=1] - Height of the cone.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cone.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cone.
   * @param {boolean} [openEnded=false] - Whether the base of the cone is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cone.
   */
  constructor(e = 1, n = 1, i = 32, s = 1, o = !1, a = 0, h = Math.PI * 2) {
    super(0, e, n, i, s, o, a, h), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: n,
      radialSegments: i,
      heightSegments: s,
      openEnded: o,
      thetaStart: a,
      thetaLength: h
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {ConeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Mf(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Ns extends ee {
  /**
   * Constructs a new polyhedron geometry.
   *
   * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.
   * @param {Array<number>} [indices] - A flat array of indices describing the base shape.
   * @param {number} [radius=1] - The radius of the shape.
   * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.
   */
  constructor(e = [], n = [], i = 1, s = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: n,
      radius: i,
      detail: s
    };
    const o = [], a = [];
    h(s), l(i), u(), this.setAttribute("position", new wt(o, 3)), this.setAttribute("normal", new wt(o.slice(), 3)), this.setAttribute("uv", new wt(a, 2)), s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function h(w) {
      const M = new $(), S = new $(), E = new $();
      for (let A = 0; A < n.length; A += 3)
        p(n[A + 0], M), p(n[A + 1], S), p(n[A + 2], E), c(M, S, E, w);
    }
    function c(w, M, S, E) {
      const A = E + 1, I = [];
      for (let b = 0; b <= A; b++) {
        I[b] = [];
        const v = w.clone().lerp(S, b / A), _ = M.clone().lerp(S, b / A), z = A - b;
        for (let P = 0; P <= z; P++)
          P === 0 && b === A ? I[b][P] = v : I[b][P] = v.clone().lerp(_, P / z);
      }
      for (let b = 0; b < A; b++)
        for (let v = 0; v < 2 * (A - b) - 1; v++) {
          const _ = Math.floor(v / 2);
          v % 2 === 0 ? (d(I[b][_ + 1]), d(I[b + 1][_]), d(I[b][_])) : (d(I[b][_ + 1]), d(I[b + 1][_ + 1]), d(I[b + 1][_]));
        }
    }
    function l(w) {
      const M = new $();
      for (let S = 0; S < o.length; S += 3)
        M.x = o[S + 0], M.y = o[S + 1], M.z = o[S + 2], M.normalize().multiplyScalar(w), o[S + 0] = M.x, o[S + 1] = M.y, o[S + 2] = M.z;
    }
    function u() {
      const w = new $();
      for (let M = 0; M < o.length; M += 3) {
        w.x = o[M + 0], w.y = o[M + 1], w.z = o[M + 2];
        const S = m(w) / 2 / Math.PI + 0.5, E = g(w) / Math.PI + 0.5;
        a.push(S, 1 - E);
      }
      y(), f();
    }
    function f() {
      for (let w = 0; w < a.length; w += 6) {
        const M = a[w + 0], S = a[w + 2], E = a[w + 4], A = Math.max(M, S, E), I = Math.min(M, S, E);
        A > 0.9 && I < 0.1 && (M < 0.2 && (a[w + 0] += 1), S < 0.2 && (a[w + 2] += 1), E < 0.2 && (a[w + 4] += 1));
      }
    }
    function d(w) {
      o.push(w.x, w.y, w.z);
    }
    function p(w, M) {
      const S = w * 3;
      M.x = e[S + 0], M.y = e[S + 1], M.z = e[S + 2];
    }
    function y() {
      const w = new $(), M = new $(), S = new $(), E = new $(), A = new nt(), I = new nt(), b = new nt();
      for (let v = 0, _ = 0; v < o.length; v += 9, _ += 6) {
        w.set(o[v + 0], o[v + 1], o[v + 2]), M.set(o[v + 3], o[v + 4], o[v + 5]), S.set(o[v + 6], o[v + 7], o[v + 8]), A.set(a[_ + 0], a[_ + 1]), I.set(a[_ + 2], a[_ + 3]), b.set(a[_ + 4], a[_ + 5]), E.copy(w).add(M).add(S).divideScalar(3);
        const z = m(E);
        x(A, _ + 0, w, z), x(I, _ + 2, M, z), x(b, _ + 4, S, z);
      }
    }
    function x(w, M, S, E) {
      E < 0 && w.x === 1 && (a[M] = w.x - 1), S.x === 0 && S.z === 0 && (a[M] = E / 2 / Math.PI + 0.5);
    }
    function m(w) {
      return Math.atan2(w.z, -w.x);
    }
    function g(w) {
      return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PolyhedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Ns(e.vertices, e.indices, e.radius, e.details);
  }
}
class _f extends Ns {
  /**
   * Constructs a new dodecahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the dodecahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron.
   */
  constructor(e = 1, n = 0) {
    const i = (1 + Math.sqrt(5)) / 2, s = 1 / i, o = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -s,
      -i,
      0,
      -s,
      i,
      0,
      s,
      -i,
      0,
      s,
      i,
      // (±1/φ, ±φ, 0)
      -s,
      -i,
      0,
      -s,
      i,
      0,
      s,
      -i,
      0,
      s,
      i,
      0,
      // (±φ, 0, ±1/φ)
      -i,
      0,
      -s,
      i,
      0,
      -s,
      -i,
      0,
      s,
      i,
      0,
      s
    ], a = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(o, a, e, n), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {DodecahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new _f(e.radius, e.detail);
  }
}
const pn = /* @__PURE__ */ new $(), Qn = /* @__PURE__ */ new $(), Jc = /* @__PURE__ */ new $(), Kn = /* @__PURE__ */ new $(), tr = /* @__PURE__ */ new $(), er = /* @__PURE__ */ new $(), Yp = /* @__PURE__ */ new $(), Qc = /* @__PURE__ */ new $(), Kc = /* @__PURE__ */ new $(), tl = /* @__PURE__ */ new $(), el = /* @__PURE__ */ new Oi(), nl = /* @__PURE__ */ new Oi(), il = /* @__PURE__ */ new Oi();
class zi {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(e = new $(), n = new $(), i = new $()) {
    this.a = e, this.b = n, this.c = i;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(e, n, i, s) {
    s.subVectors(i, n), pn.subVectors(e, n), s.cross(pn);
    const o = s.lengthSq();
    return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(e, n, i, s, o) {
    pn.subVectors(s, n), Qn.subVectors(i, n), Jc.subVectors(e, n);
    const a = pn.dot(pn), h = pn.dot(Qn), c = pn.dot(Jc), l = Qn.dot(Qn), u = Qn.dot(Jc), f = a * l - h * h;
    if (f === 0)
      return o.set(0, 0, 0), null;
    const d = 1 / f, p = (l * c - h * u) * d, y = (a * u - h * c) * d;
    return o.set(1 - p - y, y, p);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(e, n, i, s) {
    return this.getBarycoord(e, n, i, s, Kn) === null ? !1 : Kn.x >= 0 && Kn.y >= 0 && Kn.x + Kn.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(e, n, i, s, o, a, h, c) {
    return this.getBarycoord(e, n, i, s, Kn) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(o, Kn.x), c.addScaledVector(a, Kn.y), c.addScaledVector(h, Kn.z), c);
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(e, n, i, s, o, a) {
    return el.setScalar(0), nl.setScalar(0), il.setScalar(0), el.fromBufferAttribute(e, n), nl.fromBufferAttribute(e, i), il.fromBufferAttribute(e, s), a.setScalar(0), a.addScaledVector(el, o.x), a.addScaledVector(nl, o.y), a.addScaledVector(il, o.z), a;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(e, n, i, s) {
    return pn.subVectors(i, n), Qn.subVectors(e, n), pn.cross(Qn).dot(s) < 0;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(e, n, i, s) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[s]), this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(e, n, i, s) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, s), this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    return pn.subVectors(this.c, this.b), Qn.subVectors(this.a, this.b), pn.cross(Qn).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(e) {
    return zi.getNormal(this.a, this.b, this.c, e);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(e, n) {
    return zi.getBarycoord(e, this.a, this.b, this.c, n);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(e, n, i, s, o) {
    return zi.getInterpolation(e, this.a, this.b, this.c, n, i, s, o);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(e) {
    return zi.containsPoint(e, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(e) {
    return zi.isFrontFacing(this.a, this.b, this.c, e);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(e, n) {
    const i = this.a, s = this.b, o = this.c;
    let a, h;
    tr.subVectors(s, i), er.subVectors(o, i), Qc.subVectors(e, i);
    const c = tr.dot(Qc), l = er.dot(Qc);
    if (c <= 0 && l <= 0)
      return n.copy(i);
    Kc.subVectors(e, s);
    const u = tr.dot(Kc), f = er.dot(Kc);
    if (u >= 0 && f <= u)
      return n.copy(s);
    const d = c * f - u * l;
    if (d <= 0 && c >= 0 && u <= 0)
      return a = c / (c - u), n.copy(i).addScaledVector(tr, a);
    tl.subVectors(e, o);
    const p = tr.dot(tl), y = er.dot(tl);
    if (y >= 0 && p <= y)
      return n.copy(o);
    const x = p * l - c * y;
    if (x <= 0 && l >= 0 && y <= 0)
      return h = l / (l - y), n.copy(i).addScaledVector(er, h);
    const m = u * y - p * f;
    if (m <= 0 && f - u >= 0 && p - y >= 0)
      return Yp.subVectors(o, s), h = (f - u) / (f - u + (p - y)), n.copy(s).addScaledVector(Yp, h);
    const g = 1 / (m + x + d);
    return a = x * g, h = d * g, n.copy(i).addScaledVector(tr, a).addScaledVector(er, h);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Fa = /* @__PURE__ */ new $(), Na = /* @__PURE__ */ new $(), sl = /* @__PURE__ */ new $(), qa = /* @__PURE__ */ new zi();
class u5 extends ee {
  /**
   * Constructs a new edges geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   * @param {number} [thresholdAngle=1] - An edge is only rendered if the angle (in degrees)
   * between the face normals of the adjoining faces exceeds this value.
   */
  constructor(e = null, n = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: n
    }, e !== null) {
      const s = Math.pow(10, 4), o = Math.cos(Ss * n), a = e.getIndex(), h = e.getAttribute("position"), c = a ? a.count : h.count, l = [0, 0, 0], u = ["a", "b", "c"], f = new Array(3), d = {}, p = [];
      for (let y = 0; y < c; y += 3) {
        a ? (l[0] = a.getX(y), l[1] = a.getX(y + 1), l[2] = a.getX(y + 2)) : (l[0] = y, l[1] = y + 1, l[2] = y + 2);
        const { a: x, b: m, c: g } = qa;
        if (x.fromBufferAttribute(h, l[0]), m.fromBufferAttribute(h, l[1]), g.fromBufferAttribute(h, l[2]), qa.getNormal(sl), f[0] = `${Math.round(x.x * s)},${Math.round(x.y * s)},${Math.round(x.z * s)}`, f[1] = `${Math.round(m.x * s)},${Math.round(m.y * s)},${Math.round(m.z * s)}`, f[2] = `${Math.round(g.x * s)},${Math.round(g.y * s)},${Math.round(g.z * s)}`, !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0]))
          for (let w = 0; w < 3; w++) {
            const M = (w + 1) % 3, S = f[w], E = f[M], A = qa[u[w]], I = qa[u[M]], b = `${S}_${E}`, v = `${E}_${S}`;
            v in d && d[v] ? (sl.dot(d[v].normal) <= o && (p.push(A.x, A.y, A.z), p.push(I.x, I.y, I.z)), d[v] = null) : b in d || (d[b] = {
              index0: l[w],
              index1: l[M],
              normal: sl.clone()
            });
          }
      }
      for (const y in d)
        if (d[y]) {
          const { index0: x, index1: m } = d[y];
          Fa.fromBufferAttribute(h, x), Na.fromBufferAttribute(h, m), p.push(Fa.x, Fa.y, Fa.z), p.push(Na.x, Na.y, Na.z);
        }
      this.setAttribute("position", new wt(p, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class Sf extends ee {
  /**
   * Constructs a new extrude geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {ExtrudeGeometry~Options} [options] - The extrude settings.
   */
  constructor(e = new mr([new nt(0.5, 0.5), new nt(-0.5, 0.5), new nt(-0.5, -0.5), new nt(0.5, -0.5)]), n = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: n
    }, e = Array.isArray(e) ? e : [e];
    const i = this, s = [], o = [];
    for (let h = 0, c = e.length; h < c; h++) {
      const l = e[h];
      a(l);
    }
    this.setAttribute("position", new wt(s, 3)), this.setAttribute("uv", new wt(o, 2)), this.computeVertexNormals();
    function a(h) {
      const c = [], l = n.curveSegments !== void 0 ? n.curveSegments : 12, u = n.steps !== void 0 ? n.steps : 1, f = n.depth !== void 0 ? n.depth : 1;
      let d = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0, p = n.bevelThickness !== void 0 ? n.bevelThickness : 0.2, y = n.bevelSize !== void 0 ? n.bevelSize : p - 0.1, x = n.bevelOffset !== void 0 ? n.bevelOffset : 0, m = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const g = n.extrudePath, w = n.UVGenerator !== void 0 ? n.UVGenerator : f5;
      let M, S = !1, E, A, I, b;
      g && (M = g.getSpacedPoints(u), S = !0, d = !1, E = g.computeFrenetFrames(u, !1), A = new $(), I = new $(), b = new $()), d || (m = 0, p = 0, y = 0, x = 0);
      const v = h.extractPoints(l);
      let _ = v.shape;
      const z = v.holes;
      if (!Sn.isClockWise(_)) {
        _ = _.reverse();
        for (let G = 0, Q = z.length; G < Q; G++) {
          const st = z[G];
          Sn.isClockWise(st) && (z[G] = st.reverse());
        }
      }
      function k(G) {
        const st = 10000000000000001e-36;
        let ft = G[0];
        for (let at = 1; at <= G.length; at++) {
          const Ct = at % G.length, _t = G[Ct], Vt = _t.x - ft.x, it = _t.y - ft.y, Dt = Vt * Vt + it * it, T = Math.max(
            Math.abs(_t.x),
            Math.abs(_t.y),
            Math.abs(ft.x),
            Math.abs(ft.y)
          ), C = st * T * T;
          if (Dt <= C) {
            G.splice(Ct, 1), at--;
            continue;
          }
          ft = _t;
        }
      }
      k(_), z.forEach(k);
      const B = z.length, R = _;
      for (let G = 0; G < B; G++) {
        const Q = z[G];
        _ = _.concat(Q);
      }
      function L(G, Q, st) {
        return Q || console.error("THREE.ExtrudeGeometry: vec does not exist"), G.clone().addScaledVector(Q, st);
      }
      const N = _.length;
      function q(G, Q, st) {
        let ft, at, Ct;
        const _t = G.x - Q.x, Vt = G.y - Q.y, it = st.x - G.x, Dt = st.y - G.y, T = _t * _t + Vt * Vt, C = _t * Dt - Vt * it;
        if (Math.abs(C) > Number.EPSILON) {
          const F = Math.sqrt(T), D = Math.sqrt(it * it + Dt * Dt), W = Q.x - Vt / F, V = Q.y + _t / F, j = st.x - Dt / D, Y = st.y + it / D, Z = ((j - W) * Dt - (Y - V) * it) / (_t * Dt - Vt * it);
          ft = W + _t * Z - G.x, at = V + Vt * Z - G.y;
          const mt = ft * ft + at * at;
          if (mt <= 2)
            return new nt(ft, at);
          Ct = Math.sqrt(mt / 2);
        } else {
          let F = !1;
          _t > Number.EPSILON ? it > Number.EPSILON && (F = !0) : _t < -Number.EPSILON ? it < -Number.EPSILON && (F = !0) : Math.sign(Vt) === Math.sign(Dt) && (F = !0), F ? (ft = -Vt, at = _t, Ct = Math.sqrt(T)) : (ft = _t, at = Vt, Ct = Math.sqrt(T / 2));
        }
        return new nt(ft / Ct, at / Ct);
      }
      const U = [];
      for (let G = 0, Q = R.length, st = Q - 1, ft = G + 1; G < Q; G++, st++, ft++)
        st === Q && (st = 0), ft === Q && (ft = 0), U[G] = q(R[G], R[st], R[ft]);
      const J = [];
      let X, lt = U.concat();
      for (let G = 0, Q = B; G < Q; G++) {
        const st = z[G];
        X = [];
        for (let ft = 0, at = st.length, Ct = at - 1, _t = ft + 1; ft < at; ft++, Ct++, _t++)
          Ct === at && (Ct = 0), _t === at && (_t = 0), X[ft] = q(st[ft], st[Ct], st[_t]);
        J.push(X), lt = lt.concat(X);
      }
      let ot;
      if (m === 0)
        ot = Sn.triangulateShape(R, z);
      else {
        const G = [], Q = [];
        for (let st = 0; st < m; st++) {
          const ft = st / m, at = p * Math.cos(ft * Math.PI / 2), Ct = y * Math.sin(ft * Math.PI / 2) + x;
          for (let _t = 0, Vt = R.length; _t < Vt; _t++) {
            const it = L(R[_t], U[_t], Ct);
            Qt(it.x, it.y, -at), ft === 0 && G.push(it);
          }
          for (let _t = 0, Vt = B; _t < Vt; _t++) {
            const it = z[_t];
            X = J[_t];
            const Dt = [];
            for (let T = 0, C = it.length; T < C; T++) {
              const F = L(it[T], X[T], Ct);
              Qt(F.x, F.y, -at), ft === 0 && Dt.push(F);
            }
            ft === 0 && Q.push(Dt);
          }
        }
        ot = Sn.triangulateShape(G, Q);
      }
      const ut = ot.length, ct = y + x;
      for (let G = 0; G < N; G++) {
        const Q = d ? L(_[G], lt[G], ct) : _[G];
        S ? (I.copy(E.normals[0]).multiplyScalar(Q.x), A.copy(E.binormals[0]).multiplyScalar(Q.y), b.copy(M[0]).add(I).add(A), Qt(b.x, b.y, b.z)) : Qt(Q.x, Q.y, 0);
      }
      for (let G = 1; G <= u; G++)
        for (let Q = 0; Q < N; Q++) {
          const st = d ? L(_[Q], lt[Q], ct) : _[Q];
          S ? (I.copy(E.normals[G]).multiplyScalar(st.x), A.copy(E.binormals[G]).multiplyScalar(st.y), b.copy(M[G]).add(I).add(A), Qt(b.x, b.y, b.z)) : Qt(st.x, st.y, f / u * G);
        }
      for (let G = m - 1; G >= 0; G--) {
        const Q = G / m, st = p * Math.cos(Q * Math.PI / 2), ft = y * Math.sin(Q * Math.PI / 2) + x;
        for (let at = 0, Ct = R.length; at < Ct; at++) {
          const _t = L(R[at], U[at], ft);
          Qt(_t.x, _t.y, f + st);
        }
        for (let at = 0, Ct = z.length; at < Ct; at++) {
          const _t = z[at];
          X = J[at];
          for (let Vt = 0, it = _t.length; Vt < it; Vt++) {
            const Dt = L(_t[Vt], X[Vt], ft);
            S ? Qt(Dt.x, Dt.y + M[u - 1].y, M[u - 1].x + st) : Qt(Dt.x, Dt.y, f + st);
          }
        }
      }
      gt(), Nt();
      function gt() {
        const G = s.length / 3;
        if (d) {
          let Q = 0, st = N * Q;
          for (let ft = 0; ft < ut; ft++) {
            const at = ot[ft];
            Oe(at[2] + st, at[1] + st, at[0] + st);
          }
          Q = u + m * 2, st = N * Q;
          for (let ft = 0; ft < ut; ft++) {
            const at = ot[ft];
            Oe(at[0] + st, at[1] + st, at[2] + st);
          }
        } else {
          for (let Q = 0; Q < ut; Q++) {
            const st = ot[Q];
            Oe(st[2], st[1], st[0]);
          }
          for (let Q = 0; Q < ut; Q++) {
            const st = ot[Q];
            Oe(st[0] + N * u, st[1] + N * u, st[2] + N * u);
          }
        }
        i.addGroup(G, s.length / 3 - G, 0);
      }
      function Nt() {
        const G = s.length / 3;
        let Q = 0;
        ne(R, Q), Q += R.length;
        for (let st = 0, ft = z.length; st < ft; st++) {
          const at = z[st];
          ne(at, Q), Q += at.length;
        }
        i.addGroup(G, s.length / 3 - G, 1);
      }
      function ne(G, Q) {
        let st = G.length;
        for (; --st >= 0; ) {
          const ft = st;
          let at = st - 1;
          at < 0 && (at = G.length - 1);
          for (let Ct = 0, _t = u + m * 2; Ct < _t; Ct++) {
            const Vt = N * Ct, it = N * (Ct + 1), Dt = Q + ft + Vt, T = Q + at + Vt, C = Q + at + it, F = Q + ft + it;
            xe(Dt, T, C, F);
          }
        }
      }
      function Qt(G, Q, st) {
        c.push(G), c.push(Q), c.push(st);
      }
      function Oe(G, Q, st) {
        re(G), re(Q), re(st);
        const ft = s.length / 3, at = w.generateTopUV(i, s, ft - 3, ft - 2, ft - 1);
        Ut(at[0]), Ut(at[1]), Ut(at[2]);
      }
      function xe(G, Q, st, ft) {
        re(G), re(Q), re(ft), re(Q), re(st), re(ft);
        const at = s.length / 3, Ct = w.generateSideWallUV(i, s, at - 6, at - 3, at - 2, at - 1);
        Ut(Ct[0]), Ut(Ct[1]), Ut(Ct[3]), Ut(Ct[1]), Ut(Ct[2]), Ut(Ct[3]);
      }
      function re(G) {
        s.push(c[G * 3 + 0]), s.push(c[G * 3 + 1]), s.push(c[G * 3 + 2]);
      }
      function Ut(G) {
        o.push(G.x), o.push(G.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes, i = this.parameters.options;
    return d5(n, i, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ExtrudeGeometry} A new instance.
   */
  static fromJSON(e, n) {
    const i = [];
    for (let o = 0, a = e.shapes.length; o < a; o++) {
      const h = n[e.shapes[o]];
      i.push(h);
    }
    const s = e.options.extrudePath;
    return s !== void 0 && (e.options.extrudePath = new Ih[s.type]().fromJSON(s)), new Sf(i, e.options);
  }
}
const f5 = {
  generateTopUV: function(r, e, n, i, s) {
    const o = e[n * 3], a = e[n * 3 + 1], h = e[i * 3], c = e[i * 3 + 1], l = e[s * 3], u = e[s * 3 + 1];
    return [
      new nt(o, a),
      new nt(h, c),
      new nt(l, u)
    ];
  },
  generateSideWallUV: function(r, e, n, i, s, o) {
    const a = e[n * 3], h = e[n * 3 + 1], c = e[n * 3 + 2], l = e[i * 3], u = e[i * 3 + 1], f = e[i * 3 + 2], d = e[s * 3], p = e[s * 3 + 1], y = e[s * 3 + 2], x = e[o * 3], m = e[o * 3 + 1], g = e[o * 3 + 2];
    return Math.abs(h - u) < Math.abs(a - l) ? [
      new nt(a, 1 - c),
      new nt(l, 1 - f),
      new nt(d, 1 - y),
      new nt(x, 1 - g)
    ] : [
      new nt(h, 1 - c),
      new nt(u, 1 - f),
      new nt(p, 1 - y),
      new nt(m, 1 - g)
    ];
  }
};
function d5(r, e, n) {
  if (n.shapes = [], Array.isArray(r))
    for (let i = 0, s = r.length; i < s; i++) {
      const o = r[i];
      n.shapes.push(o.uuid);
    }
  else
    n.shapes.push(r.uuid);
  return n.options = Object.assign({}, e), e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
class Tf extends Ns {
  /**
   * Constructs a new icosahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the icosahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a icosahedron.
   */
  constructor(e = 1, n = 0) {
    const i = (1 + Math.sqrt(5)) / 2, s = [
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      0,
      0,
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      i,
      0,
      -1,
      i,
      0,
      1,
      -i,
      0,
      -1,
      -i,
      0,
      1
    ], o = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(s, o, e, n), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {IcosahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Tf(e.radius, e.detail);
  }
}
class Ef extends ee {
  /**
   * Constructs a new lathe geometry.
   *
   * @param {Array<Vector2|Vector3>} [points] - An array of points in 2D space. The x-coordinate of each point
   * must be greater than zero.
   * @param {number} [segments=12] - The number of circumference segments to generate.
   * @param {number} [phiStart=0] - The starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The radian (0 to 2PI) range of the lathed section 2PI is a
   * closed lathe, less than 2PI is a portion.
   */
  constructor(e = [new nt(0, -0.5), new nt(0.5, 0), new nt(0, 0.5)], n = 12, i = 0, s = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: n,
      phiStart: i,
      phiLength: s
    }, n = Math.floor(n), s = Mt(s, 0, Math.PI * 2);
    const o = [], a = [], h = [], c = [], l = [], u = 1 / n, f = new $(), d = new nt(), p = new $(), y = new $(), x = new $();
    let m = 0, g = 0;
    for (let w = 0; w <= e.length - 1; w++)
      switch (w) {
        case 0:
          m = e[w + 1].x - e[w].x, g = e[w + 1].y - e[w].y, p.x = g * 1, p.y = -m, p.z = g * 0, x.copy(p), p.normalize(), c.push(p.x, p.y, p.z);
          break;
        case e.length - 1:
          c.push(x.x, x.y, x.z);
          break;
        default:
          m = e[w + 1].x - e[w].x, g = e[w + 1].y - e[w].y, p.x = g * 1, p.y = -m, p.z = g * 0, y.copy(p), p.x += x.x, p.y += x.y, p.z += x.z, p.normalize(), c.push(p.x, p.y, p.z), x.copy(y);
      }
    for (let w = 0; w <= n; w++) {
      const M = i + w * u * s, S = Math.sin(M), E = Math.cos(M);
      for (let A = 0; A <= e.length - 1; A++) {
        f.x = e[A].x * S, f.y = e[A].y, f.z = e[A].x * E, a.push(f.x, f.y, f.z), d.x = w / n, d.y = A / (e.length - 1), h.push(d.x, d.y);
        const I = c[3 * A + 0] * S, b = c[3 * A + 1], v = c[3 * A + 0] * E;
        l.push(I, b, v);
      }
    }
    for (let w = 0; w < n; w++)
      for (let M = 0; M < e.length - 1; M++) {
        const S = M + w * e.length, E = S, A = S + e.length, I = S + e.length + 1, b = S + 1;
        o.push(E, A, b), o.push(I, b, A);
      }
    this.setIndex(o), this.setAttribute("position", new wt(a, 3)), this.setAttribute("uv", new wt(h, 2)), this.setAttribute("normal", new wt(l, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {LatheGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Ef(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class zf extends Ns {
  /**
   * Constructs a new octahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the octahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a octahedron.
   */
  constructor(e = 1, n = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], s = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, s, e, n), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {OctahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new zf(e.radius, e.detail);
  }
}
class Af extends ee {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(e = 1, n = 1, i = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: i,
      heightSegments: s
    };
    const o = e / 2, a = n / 2, h = Math.floor(i), c = Math.floor(s), l = h + 1, u = c + 1, f = e / h, d = n / c, p = [], y = [], x = [], m = [];
    for (let g = 0; g < u; g++) {
      const w = g * d - a;
      for (let M = 0; M < l; M++) {
        const S = M * f - o;
        y.push(S, -w, 0), x.push(0, 0, 1), m.push(M / h), m.push(1 - g / c);
      }
    }
    for (let g = 0; g < c; g++)
      for (let w = 0; w < h; w++) {
        const M = w + l * g, S = w + l * (g + 1), E = w + 1 + l * (g + 1), A = w + 1 + l * g;
        p.push(M, S, A), p.push(S, E, A);
      }
    this.setIndex(p), this.setAttribute("position", new wt(y, 3)), this.setAttribute("normal", new wt(x, 3)), this.setAttribute("uv", new wt(m, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Af(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Cf extends ee {
  /**
   * Constructs a new ring geometry.
   *
   * @param {number} [innerRadius=0.5] - The inner radius of the ring.
   * @param {number} [outerRadius=1] - The outer radius of the ring.
   * @param {number} [thetaSegments=32] - Number of segments. A higher number means the ring will be more round. Minimum is `3`.
   * @param {number} [phiSegments=1] - Number of segments per ring segment. Minimum is `1`.
   * @param {number} [thetaStart=0] - Starting angle in radians.
   * @param {number} [thetaLength=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 0.5, n = 1, i = 32, s = 1, o = 0, a = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: n,
      thetaSegments: i,
      phiSegments: s,
      thetaStart: o,
      thetaLength: a
    }, i = Math.max(3, i), s = Math.max(1, s);
    const h = [], c = [], l = [], u = [];
    let f = e;
    const d = (n - e) / s, p = new $(), y = new nt();
    for (let x = 0; x <= s; x++) {
      for (let m = 0; m <= i; m++) {
        const g = o + m / i * a;
        p.x = f * Math.cos(g), p.y = f * Math.sin(g), c.push(p.x, p.y, p.z), l.push(0, 0, 1), y.x = (p.x / n + 1) / 2, y.y = (p.y / n + 1) / 2, u.push(y.x, y.y);
      }
      f += d;
    }
    for (let x = 0; x < s; x++) {
      const m = x * (i + 1);
      for (let g = 0; g < i; g++) {
        const w = g + m, M = w, S = w + i + 1, E = w + i + 2, A = w + 1;
        h.push(M, S, A), h.push(S, E, A);
      }
    }
    this.setIndex(h), this.setAttribute("position", new wt(c, 3)), this.setAttribute("normal", new wt(l, 3)), this.setAttribute("uv", new wt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {RingGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Cf(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Pf extends ee {
  /**
   * Constructs a new shape geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {number} [curveSegments=12] - Number of segments per shape.
   */
  constructor(e = new mr([new nt(0, 0.5), new nt(-0.5, -0.5), new nt(0.5, -0.5)]), n = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const i = [], s = [], o = [], a = [];
    let h = 0, c = 0;
    if (Array.isArray(e) === !1)
      l(e);
    else
      for (let u = 0; u < e.length; u++)
        l(e[u]), this.addGroup(h, c, u), h += c, c = 0;
    this.setIndex(i), this.setAttribute("position", new wt(s, 3)), this.setAttribute("normal", new wt(o, 3)), this.setAttribute("uv", new wt(a, 2));
    function l(u) {
      const f = s.length / 3, d = u.extractPoints(n);
      let p = d.shape;
      const y = d.holes;
      Sn.isClockWise(p) === !1 && (p = p.reverse());
      for (let m = 0, g = y.length; m < g; m++) {
        const w = y[m];
        Sn.isClockWise(w) === !0 && (y[m] = w.reverse());
      }
      const x = Sn.triangulateShape(p, y);
      for (let m = 0, g = y.length; m < g; m++) {
        const w = y[m];
        p = p.concat(w);
      }
      for (let m = 0, g = p.length; m < g; m++) {
        const w = p[m];
        s.push(w.x, w.y, 0), o.push(0, 0, 1), a.push(w.x, w.y);
      }
      for (let m = 0, g = x.length; m < g; m++) {
        const w = x[m], M = w[0] + f, S = w[1] + f, E = w[2] + f;
        i.push(M, S, E), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes;
    return p5(n, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ShapeGeometry} A new instance.
   */
  static fromJSON(e, n) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = n[e.shapes[s]];
      i.push(a);
    }
    return new Pf(i, e.curveSegments);
  }
}
function p5(r, e) {
  if (e.shapes = [], Array.isArray(r))
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(r.uuid);
  return e;
}
class If extends ee {
  /**
   * Constructs a new sphere geometry.
   *
   * @param {number} [radius=1] - The sphere radius.
   * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
   * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
   * @param {number} [phiStart=0] - The horizontal starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
   * @param {number} [thetaStart=0] - The vertical starting angle in radians.
   * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
   */
  constructor(e = 1, n = 32, i = 16, s = 0, o = Math.PI * 2, a = 0, h = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: i,
      phiStart: s,
      phiLength: o,
      thetaStart: a,
      thetaLength: h
    }, n = Math.max(3, Math.floor(n)), i = Math.max(2, Math.floor(i));
    const c = Math.min(a + h, Math.PI);
    let l = 0;
    const u = [], f = new $(), d = new $(), p = [], y = [], x = [], m = [];
    for (let g = 0; g <= i; g++) {
      const w = [], M = g / i;
      let S = 0;
      g === 0 && a === 0 ? S = 0.5 / n : g === i && c === Math.PI && (S = -0.5 / n);
      for (let E = 0; E <= n; E++) {
        const A = E / n;
        f.x = -e * Math.cos(s + A * o) * Math.sin(a + M * h), f.y = e * Math.cos(a + M * h), f.z = e * Math.sin(s + A * o) * Math.sin(a + M * h), y.push(f.x, f.y, f.z), d.copy(f).normalize(), x.push(d.x, d.y, d.z), m.push(A + S, 1 - M), w.push(l++);
      }
      u.push(w);
    }
    for (let g = 0; g < i; g++)
      for (let w = 0; w < n; w++) {
        const M = u[g][w + 1], S = u[g][w], E = u[g + 1][w], A = u[g + 1][w + 1];
        (g !== 0 || a > 0) && p.push(M, S, A), (g !== i - 1 || c < Math.PI) && p.push(S, E, A);
      }
    this.setIndex(p), this.setAttribute("position", new wt(y, 3)), this.setAttribute("normal", new wt(x, 3)), this.setAttribute("uv", new wt(m, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {SphereGeometry} A new instance.
   */
  static fromJSON(e) {
    return new If(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class kf extends Ns {
  /**
   * Constructs a new tetrahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the tetrahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron.
   */
  constructor(e = 1, n = 0) {
    const i = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], s = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(i, s, e, n), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TetrahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new kf(e.radius, e.detail);
  }
}
class Rf extends ee {
  /**
   * Constructs a new torus geometry.
   *
   * @param {number} [radius=1] - Radius of the torus, from the center of the torus to the center of the tube.
   * @param {number} [tube=0.4] - Radius of the tube. Must be smaller than `radius`.
   * @param {number} [radialSegments=12] - The number of radial segments.
   * @param {number} [tubularSegments=48] - The number of tubular segments.
   * @param {number} [arc=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 1, n = 0.4, i = 12, s = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: n,
      radialSegments: i,
      tubularSegments: s,
      arc: o
    }, i = Math.floor(i), s = Math.floor(s);
    const a = [], h = [], c = [], l = [], u = new $(), f = new $(), d = new $();
    for (let p = 0; p <= i; p++)
      for (let y = 0; y <= s; y++) {
        const x = y / s * o, m = p / i * Math.PI * 2;
        f.x = (e + n * Math.cos(m)) * Math.cos(x), f.y = (e + n * Math.cos(m)) * Math.sin(x), f.z = n * Math.sin(m), h.push(f.x, f.y, f.z), u.x = e * Math.cos(x), u.y = e * Math.sin(x), d.subVectors(f, u).normalize(), c.push(d.x, d.y, d.z), l.push(y / s), l.push(p / i);
      }
    for (let p = 1; p <= i; p++)
      for (let y = 1; y <= s; y++) {
        const x = (s + 1) * p + y - 1, m = (s + 1) * (p - 1) + y - 1, g = (s + 1) * (p - 1) + y, w = (s + 1) * p + y;
        a.push(x, m, w), a.push(m, g, w);
      }
    this.setIndex(a), this.setAttribute("position", new wt(h, 3)), this.setAttribute("normal", new wt(c, 3)), this.setAttribute("uv", new wt(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Rf(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Of extends ee {
  /**
   * Constructs a new torus knot geometry.
   *
   * @param {number} [radius=1] - Radius of the torus knot.
   * @param {number} [tube=0.4] - Radius of the tube.
   * @param {number} [tubularSegments=64] - The number of tubular segments.
   * @param {number} [radialSegments=8] - The number of radial segments.
   * @param {number} [p=2] - This value determines, how many times the geometry winds around its axis of rotational symmetry.
   * @param {number} [q=3] - This value determines, how many times the geometry winds around a circle in the interior of the torus.
   */
  constructor(e = 1, n = 0.4, i = 64, s = 8, o = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: n,
      tubularSegments: i,
      radialSegments: s,
      p: o,
      q: a
    }, i = Math.floor(i), s = Math.floor(s);
    const h = [], c = [], l = [], u = [], f = new $(), d = new $(), p = new $(), y = new $(), x = new $(), m = new $(), g = new $();
    for (let M = 0; M <= i; ++M) {
      const S = M / i * o * Math.PI * 2;
      w(S, o, a, e, p), w(S + 0.01, o, a, e, y), m.subVectors(y, p), g.addVectors(y, p), x.crossVectors(m, g), g.crossVectors(x, m), x.normalize(), g.normalize();
      for (let E = 0; E <= s; ++E) {
        const A = E / s * Math.PI * 2, I = -n * Math.cos(A), b = n * Math.sin(A);
        f.x = p.x + (I * g.x + b * x.x), f.y = p.y + (I * g.y + b * x.y), f.z = p.z + (I * g.z + b * x.z), c.push(f.x, f.y, f.z), d.subVectors(f, p).normalize(), l.push(d.x, d.y, d.z), u.push(M / i), u.push(E / s);
      }
    }
    for (let M = 1; M <= i; M++)
      for (let S = 1; S <= s; S++) {
        const E = (s + 1) * (M - 1) + (S - 1), A = (s + 1) * M + (S - 1), I = (s + 1) * M + S, b = (s + 1) * (M - 1) + S;
        h.push(E, A, b), h.push(A, I, b);
      }
    this.setIndex(h), this.setAttribute("position", new wt(c, 3)), this.setAttribute("normal", new wt(l, 3)), this.setAttribute("uv", new wt(u, 2));
    function w(M, S, E, A, I) {
      const b = Math.cos(M), v = Math.sin(M), _ = E / S * M, z = Math.cos(_);
      I.x = A * (2 + z) * 0.5 * b, I.y = A * (2 + z) * v * 0.5, I.z = A * Math.sin(_) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusKnotGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Of(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Lf extends ee {
  /**
   * Constructs a new tube geometry.
   *
   * @param {Curve} [path=QuadraticBezierCurve3] - A 3D curve defining the path of the tube.
   * @param {number} [tubularSegments=64] - The number of segments that make up the tube.
   * @param {number} [radius=1] -The radius of the tube.
   * @param {number} [radialSegments=8] - The number of segments that make up the cross-section.
   * @param {boolean} [closed=false] - Whether the tube is closed or not.
   */
  constructor(e = new mf(new $(-1, -1, 0), new $(-1, 1, 0), new $(1, 1, 0)), n = 64, i = 1, s = 8, o = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: n,
      radius: i,
      radialSegments: s,
      closed: o
    };
    const a = e.computeFrenetFrames(n, o);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const h = new $(), c = new $(), l = new nt();
    let u = new $();
    const f = [], d = [], p = [], y = [];
    x(), this.setIndex(y), this.setAttribute("position", new wt(f, 3)), this.setAttribute("normal", new wt(d, 3)), this.setAttribute("uv", new wt(p, 2));
    function x() {
      for (let M = 0; M < n; M++)
        m(M);
      m(o === !1 ? n : 0), w(), g();
    }
    function m(M) {
      u = e.getPointAt(M / n, u);
      const S = a.normals[M], E = a.binormals[M];
      for (let A = 0; A <= s; A++) {
        const I = A / s * Math.PI * 2, b = Math.sin(I), v = -Math.cos(I);
        c.x = v * S.x + b * E.x, c.y = v * S.y + b * E.y, c.z = v * S.z + b * E.z, c.normalize(), d.push(c.x, c.y, c.z), h.x = u.x + i * c.x, h.y = u.y + i * c.y, h.z = u.z + i * c.z, f.push(h.x, h.y, h.z);
      }
    }
    function g() {
      for (let M = 1; M <= n; M++)
        for (let S = 1; S <= s; S++) {
          const E = (s + 1) * (M - 1) + (S - 1), A = (s + 1) * M + (S - 1), I = (s + 1) * M + S, b = (s + 1) * (M - 1) + S;
          y.push(E, A, b), y.push(A, I, b);
        }
    }
    function w() {
      for (let M = 0; M <= n; M++)
        for (let S = 0; S <= s; S++)
          l.x = M / n, l.y = S / s, p.push(l.x, l.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TubeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Lf(
      new Ih[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class y5 extends ee {
  /**
   * Constructs a new wireframe geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   */
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const n = [], i = /* @__PURE__ */ new Set(), s = new $(), o = new $();
      if (e.index !== null) {
        const a = e.attributes.position, h = e.index;
        let c = e.groups;
        c.length === 0 && (c = [{ start: 0, count: h.count, materialIndex: 0 }]);
        for (let l = 0, u = c.length; l < u; ++l) {
          const f = c[l], d = f.start, p = f.count;
          for (let y = d, x = d + p; y < x; y += 3)
            for (let m = 0; m < 3; m++) {
              const g = h.getX(y + m), w = h.getX(y + (m + 1) % 3);
              s.fromBufferAttribute(a, g), o.fromBufferAttribute(a, w), Hp(s, o, i) === !0 && (n.push(s.x, s.y, s.z), n.push(o.x, o.y, o.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let h = 0, c = a.count / 3; h < c; h++)
          for (let l = 0; l < 3; l++) {
            const u = 3 * h + l, f = 3 * h + (l + 1) % 3;
            s.fromBufferAttribute(a, u), o.fromBufferAttribute(a, f), Hp(s, o, i) === !0 && (n.push(s.x, s.y, s.z), n.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new wt(n, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function Hp(r, e, n) {
  const i = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`, s = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
  return n.has(i) === !0 || n.has(s) === !0 ? !1 : (n.add(i), n.add(s), !0);
}
const Xp = /* @__PURE__ */ new nt();
class x5 {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector2} [min=(Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector2} [max=(-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new nt(1 / 0, 1 / 0), n = new nt(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = n;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector2} min - The lower boundary of the box.
   * @param {Vector2} max - The upper boundary of the box.
   * @return {Box2} A reference to this bounding box.
   */
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector2>} points - An array holding 2D position data as instances of {@link Vector2}.
   * @return {Box2} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector2} center - The center of the box.
   * @param {Vector2} size - The x and y dimensions of the box.
   * @return {Box2} A reference to this bounding box.
   */
  setFromCenterAndSize(e, n) {
    const i = Xp.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box2} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box2} box - The box to copy.
   * @return {Box2} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 2D.
   *
   * @return {Box2} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector2} point - The point that should be included by the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions.
   *
   * @param {Vector2} vector - The vector that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector2} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  /**
   * Returns a point as a proportion of this box's width and height.
   *
   * @param {Vector2} point - A point in 2D space.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} A point as a proportion of this box's width and height.
   */
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector2} point - The point to clamp.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The clamped point.
   */
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector2} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, Xp).distanceTo(e);
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box2} box - The bounding box to intersect with.
   * @return {Box2} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box2} box - The bounding box that will be unioned with this instance.
   * @return {Box2} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 2D space.
   *
   * @param {Vector2} offset - The offset that should be used to translate the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box2} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
class m5 {
  /**
   * Constructs a new cylindrical.
   *
   * @param {number} [radius=1] - The distance from the origin to a point in the x-z plane.
   * @param {number} [theta=0] - A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.
   * @param {number} [y=0] - The height above the x-z plane.
   */
  constructor(e = 1, n = 0, i = 0) {
    this.radius = e, this.theta = n, this.y = i;
  }
  /**
   * Sets the cylindrical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle.
   * @param {number} y - The height value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  set(e, n, i) {
    return this.radius = e, this.theta = n, this.y = i, this;
  }
  /**
   * Copies the values of the given cylindrical to this instance.
   *
   * @param {Cylindrical} other - The cylindrical to copy.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  /**
   * Sets the cylindrical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the cylindrical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromCartesianCoords(e, n, i) {
    return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = n, this;
  }
  /**
   * Returns a new cylindrical with copied values from this instance.
   *
   * @return {Cylindrical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const rl = /* @__PURE__ */ new $(), g5 = /* @__PURE__ */ new $(), w5 = /* @__PURE__ */ new Wn();
class fs {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(e = new $(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(e, n, i, s) {
    return this.normal.set(e, n, i), this.constant = s, this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(e, n, i) {
    const s = rl.subVectors(i, n).cross(g5.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(e, n) {
    const i = e.delta(rl), s = this.normal.dot(i);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / s;
    return o < 0 || o > 1 ? null : n.copy(e.start).addScaledVector(i, o);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return n < 0 && i > 0 || i < 0 && n > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(e, n) {
    const i = n || w5.getNormalMatrix(e), s = this.coplanarPoint(rl).applyMatrix4(e), o = this.normal.applyMatrix3(i).normalize();
    return this.constant = -s.dot(o), this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const is = /* @__PURE__ */ new lf(), b5 = /* @__PURE__ */ new nt(0.5, 0.5), Da = /* @__PURE__ */ new $();
class kg {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(e = new fs(), n = new fs(), i = new fs(), s = new fs(), o = new fs(), a = new fs()) {
    this.planes = [e, n, i, s, o, a];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(e, n, i, s, o, a) {
    const h = this.planes;
    return h[0].copy(e), h[1].copy(n), h[2].copy(i), h[3].copy(s), h[4].copy(o), h[5].copy(a), this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      n[i].copy(e.planes[i]);
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(e, n = Dn) {
    const i = this.planes, s = e.elements, o = s[0], a = s[1], h = s[2], c = s[3], l = s[4], u = s[5], f = s[6], d = s[7], p = s[8], y = s[9], x = s[10], m = s[11], g = s[12], w = s[13], M = s[14], S = s[15];
    if (i[0].setComponents(c - o, d - l, m - p, S - g).normalize(), i[1].setComponents(c + o, d + l, m + p, S + g).normalize(), i[2].setComponents(c + a, d + u, m + y, S + w).normalize(), i[3].setComponents(c - a, d - u, m - y, S - w).normalize(), i[4].setComponents(c - h, d - f, m - x, S - M).normalize(), n === Dn)
      i[5].setComponents(c + h, d + f, m + x, S + M).normalize();
    else if (n === Po)
      i[5].setComponents(h, f, x, M).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), is.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), is.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(is);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(e) {
    is.center.set(0, 0, 0);
    const n = b5.distanceTo(e.center);
    return is.radius = 0.7071067811865476 + n, is.applyMatrix4(e.matrixWorld), this.intersectsSphere(is);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(e) {
    const n = this.planes, i = e.center, s = -e.radius;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(i) < s)
        return !1;
    return !0;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const s = n[i];
      if (Da.x = s.normal.x > 0 ? e.max.x : e.min.x, Da.y = s.normal.y > 0 ? e.max.y : e.min.y, Da.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(Da) < 0)
        return !1;
    }
    return !0;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      if (n[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const On = /* @__PURE__ */ new te(), Ln = /* @__PURE__ */ new kg();
class Bf {
  /**
   * Constructs a new frustum array.
   *
   */
  constructor() {
    this.coordinateSystem = Dn;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Object3D} object - The 3D object to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the 3D object is visible in any camera.
   */
  intersectsObject(e, n) {
    if (!n.isArrayCamera || n.cameras.length === 0)
      return !1;
    for (let i = 0; i < n.cameras.length; i++) {
      const s = n.cameras[i];
      if (On.multiplyMatrices(
        s.projectionMatrix,
        s.matrixWorldInverse
      ), Ln.setFromProjectionMatrix(
        On,
        this.coordinateSystem
      ), Ln.intersectsObject(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given sprite is intersecting any frustum
   * from the camera array.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sprite is visible in any camera.
   */
  intersectsSprite(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let i = 0; i < n.cameras.length; i++) {
      const s = n.cameras[i];
      if (On.multiplyMatrices(
        s.projectionMatrix,
        s.matrixWorldInverse
      ), Ln.setFromProjectionMatrix(
        On,
        this.coordinateSystem
      ), Ln.intersectsSprite(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sphere is visible in any camera.
   */
  intersectsSphere(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let i = 0; i < n.cameras.length; i++) {
      const s = n.cameras[i];
      if (On.multiplyMatrices(
        s.projectionMatrix,
        s.matrixWorldInverse
      ), Ln.setFromProjectionMatrix(
        On,
        this.coordinateSystem
      ), Ln.intersectsSphere(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding box is intersecting any frustum
   * from the camera array.
   *
   * @param {Box3} box - The bounding box to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the box is visible in any camera.
   */
  intersectsBox(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let i = 0; i < n.cameras.length; i++) {
      const s = n.cameras[i];
      if (On.multiplyMatrices(
        s.projectionMatrix,
        s.matrixWorldInverse
      ), Ln.setFromProjectionMatrix(
        On,
        this.coordinateSystem
      ), Ln.intersectsBox(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given point lies within any frustum
   * from the camera array.
   *
   * @param {Vector3} point - The point to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the point is visible in any camera.
   */
  containsPoint(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let i = 0; i < n.cameras.length; i++) {
      const s = n.cameras[i];
      if (On.multiplyMatrices(
        s.projectionMatrix,
        s.matrixWorldInverse
      ), Ln.setFromProjectionMatrix(
        On,
        this.coordinateSystem
      ), Ln.containsPoint(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns a new frustum array with copied values from this instance.
   *
   * @return {FrustumArray} A clone of this instance.
   */
  clone() {
    return new Bf();
  }
}
const Zp = /* @__PURE__ */ new $(), $a = /* @__PURE__ */ new $();
class v5 {
  /**
   * Constructs a new line segment.
   *
   * @param {Vector3} [start=(0,0,0)] - Start of the line segment.
   * @param {Vector3} [end=(0,0,0)] - End of the line segment.
   */
  constructor(e = new $(), n = new $()) {
    this.start = e, this.end = n;
  }
  /**
   * Sets the start and end values by copying the given vectors.
   *
   * @param {Vector3} start - The start point.
   * @param {Vector3} end - The end point.
   * @return {Line3} A reference to this line segment.
   */
  set(e, n) {
    return this.start.copy(e), this.end.copy(n), this;
  }
  /**
   * Copies the values of the given line segment to this instance.
   *
   * @param {Line3} line - The line segment to copy.
   * @return {Line3} A reference to this line segment.
   */
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  /**
   * Returns the center of the line segment.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  /**
   * Returns the delta vector of the line segment's start and end point.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  /**
   * Returns the squared Euclidean distance between the line' start and end point.
   *
   * @return {number} The squared Euclidean distance.
   */
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  /**
   * Returns the Euclidean distance between the line' start and end point.
   *
   * @return {number} The Euclidean distance.
   */
  distance() {
    return this.start.distanceTo(this.end);
  }
  /**
   * Returns a vector at a certain position along the line segment.
   *
   * @param {number} t - A value between `[0,1]` to represent a position along the line segment.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  at(e, n) {
    return this.delta(n).multiplyScalar(e).add(this.start);
  }
  /**
   * Returns a point parameter based on the closest point as projected on the line segment.
   *
   * @param {Vector3} point - The point for which to return a point parameter.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @return {number} The point parameter.
   */
  closestPointToPointParameter(e, n) {
    Zp.subVectors(e, this.start), $a.subVectors(this.end, this.start);
    const i = $a.dot($a);
    let o = $a.dot(Zp) / i;
    return n && (o = Mt(o, 0, 1)), o;
  }
  /**
   * Returns the closets point on the line for a given point.
   *
   * @param {Vector3} point - The point to compute the closest point on the line for.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @param {Vector3} target -  The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the line.
   */
  closestPointToPoint(e, n, i) {
    const s = this.closestPointToPointParameter(e, n);
    return this.delta(i).multiplyScalar(s).add(this.start);
  }
  /**
   * Applies a 4x4 transformation matrix to this line segment.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Line3} A reference to this line segment.
   */
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  /**
   * Returns `true` if this line segment is equal with the given one.
   *
   * @param {Line3} line - The line segment to test for equality.
   * @return {boolean} Whether this line segment is equal with the given one.
   */
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  /**
   * Returns a new line segment with copied values from this instance.
   *
   * @return {Line3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ff {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(e, n, i, s) {
    Ff.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, s);
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(e, n = 0) {
    for (let i = 0; i < 4; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(e, n, i, s) {
    const o = this.elements;
    return o[0] = e, o[2] = n, o[1] = i, o[3] = s, this;
  }
}
class M5 {
  /**
   * Constructs a new spherical.
   *
   * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
   * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
   * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
   */
  constructor(e = 1, n = 0, i = 0) {
    this.radius = e, this.phi = n, this.theta = i;
  }
  /**
   * Sets the spherical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The polar angle.
   * @param {number} theta - The azimuthal angle.
   * @return {Spherical} A reference to this spherical.
   */
  set(e, n, i) {
    return this.radius = e, this.phi = n, this.theta = i, this;
  }
  /**
   * Copies the values of the given spherical to this instance.
   *
   * @param {Spherical} other - The spherical to copy.
   * @return {Spherical} A reference to this spherical.
   */
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  /**
   * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
   * `0.000001`.
   *
   * @return {Spherical} A reference to this spherical.
   */
  makeSafe() {
    return this.phi = Mt(this.phi, 1e-6, Math.PI - 1e-6), this;
  }
  /**
   * Sets the spherical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Spherical} A reference to this spherical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the spherical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Spherical} A reference to this spherical.
   */
  setFromCartesianCoords(e, n, i) {
    return this.radius = Math.sqrt(e * e + n * n + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(Mt(n / this.radius, -1, 1))), this;
  }
  /**
   * Returns a new spherical with copied values from this instance.
   *
   * @return {Spherical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class _5 {
  /**
   * Constructs a new spherical harmonics.
   */
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new $());
  }
  /**
   * Sets the given SH coefficients to this instance by copying
   * the values.
   *
   * @param {Array<Vector3>} coefficients - The SH coefficients.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  set(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].copy(e[n]);
    return this;
  }
  /**
   * Sets all SH coefficients to `0`.
   *
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  /**
   * Returns the radiance in the direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The radiance.
   */
  getAt(e, n) {
    const i = e.x, s = e.y, o = e.z, a = this.coefficients;
    return n.copy(a[0]).multiplyScalar(0.282095), n.addScaledVector(a[1], 0.488603 * s), n.addScaledVector(a[2], 0.488603 * o), n.addScaledVector(a[3], 0.488603 * i), n.addScaledVector(a[4], 1.092548 * (i * s)), n.addScaledVector(a[5], 1.092548 * (s * o)), n.addScaledVector(a[6], 0.315392 * (3 * o * o - 1)), n.addScaledVector(a[7], 1.092548 * (i * o)), n.addScaledVector(a[8], 0.546274 * (i * i - s * s)), n;
  }
  /**
   * Returns the irradiance (radiance convolved with cosine lobe) in the
   * direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The irradiance.
   */
  getIrradianceAt(e, n) {
    const i = e.x, s = e.y, o = e.z, a = this.coefficients;
    return n.copy(a[0]).multiplyScalar(0.886227), n.addScaledVector(a[1], 2 * 0.511664 * s), n.addScaledVector(a[2], 2 * 0.511664 * o), n.addScaledVector(a[3], 2 * 0.511664 * i), n.addScaledVector(a[4], 2 * 0.429043 * i * s), n.addScaledVector(a[5], 2 * 0.429043 * s * o), n.addScaledVector(a[6], 0.743125 * o * o - 0.247708), n.addScaledVector(a[7], 2 * 0.429043 * i * o), n.addScaledVector(a[8], 0.429043 * (i * i - s * s)), n;
  }
  /**
   * Adds the given SH to this instance.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  add(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].add(e.coefficients[n]);
    return this;
  }
  /**
   * A convenience method for performing {@link SphericalHarmonics3#add} and
   * {@link SphericalHarmonics3#scale} at once.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  addScaledSH(e, n) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], n);
    return this;
  }
  /**
   * Scales this SH by the given scale factor.
   *
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  scale(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].multiplyScalar(e);
    return this;
  }
  /**
   * Linear interpolates between the given SH and this instance by the given
   * alpha factor.
   *
   * @param {SphericalHarmonics3} sh - The SH to interpolate with.
   * @param {number} alpha - The alpha factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  lerp(e, n) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].lerp(e.coefficients[i], n);
    return this;
  }
  /**
   * Returns `true` if this spherical harmonics is equal with the given one.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
   * @return {boolean} Whether this spherical harmonics is equal with the given one.
   */
  equals(e) {
    for (let n = 0; n < 9; n++)
      if (!this.coefficients[n].equals(e.coefficients[n]))
        return !1;
    return !0;
  }
  /**
   * Copies the values of the given spherical harmonics to this instance.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  copy(e) {
    return this.set(e.coefficients);
  }
  /**
   * Returns a new spherical harmonics with copied values from this instance.
   *
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the SH coefficients of this instance from the given array.
   *
   * @param {Array<number>} array - An array holding the SH coefficients.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  fromArray(e, n = 0) {
    const i = this.coefficients;
    for (let s = 0; s < 9; s++)
      i[s].fromArray(e, n + s * 3);
    return this;
  }
  /**
   * Returns an array with the SH coefficients, or copies them into the provided
   * array. The coefficients are represented as numbers.
   *
   * @param {Array<number>} [array=[]] - The target array.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {Array<number>} An array with flat SH coefficients.
   */
  toArray(e = [], n = 0) {
    const i = this.coefficients;
    for (let s = 0; s < 9; s++)
      i[s].toArray(e, n + s * 3);
    return e;
  }
  /**
   * Computes the SH basis for the given normal vector.
   *
   * @param {Vector3} normal - The normal.
   * @param {Array<number>} shBasis - The target array holding the SH basis.
   */
  static getBasisAt(e, n) {
    const i = e.x, s = e.y, o = e.z;
    n[0] = 0.282095, n[1] = 0.488603 * s, n[2] = 0.488603 * o, n[3] = 0.488603 * i, n[4] = 1.092548 * i * s, n[5] = 1.092548 * s * o, n[6] = 0.315392 * (3 * o * o - 1), n[7] = 1.092548 * i * o, n[8] = 0.546274 * (i * i - s * s);
  }
}
class Nf {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [near=1] - The minimum distance to start applying fog.
   * @param {number} [far=1000] - The maximum distance at which fog stops being calculated and applied.
   */
  constructor(e, n = 1, i = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Cr(e), this.near = n, this.far = i;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {Fog} A clone of this instance.
   */
  clone() {
    return new Nf(this.color, this.near, this.far);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class qf {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [density=0.00025] - Defines how fast the fog will grow dense.
   */
  constructor(e, n = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Cr(e), this.density = n;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {FogExp2} A clone of this instance.
   */
  clone() {
    return new qf(this.color, this.density);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class S5 extends Ve {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new As(), this.environmentIntensity = 1, this.environmentRotation = new As(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class T5 extends de {
  /**
   * Constructs a new texture.
   *
   * @param {HTMLCanvasElement} [canvas] - The HTML canvas element.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, n, i, s, o, a, h, c, l) {
    super(e, n, i, s, o, a, h, c, l), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Df extends de {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e, n, i, s, o, a, h, c, l, u, f, d) {
    super(null, a, h, c, l, u, s, o, f, d), this.isCompressedTexture = !0, this.image = { width: n, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class E5 extends Df {
  /**
   * Constructs a new compressed array texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} depth - The depth of the texture.
   * @param {number} [format=RGBAFormat] - The min filter value.
   * @param {number} [type=UnsignedByteType] - The min filter value.
   */
  constructor(e, n, i, s, o, a) {
    super(e, n, i, o, a), this.isCompressedArrayTexture = !0, this.image.depth = s, this.wrapR = Pi, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire compressed texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class z5 extends Df {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<CompressedTexture>} images - An array of compressed textures.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   */
  constructor(e, n, i) {
    super(void 0, e[0].width, e[0].height, n, i, Xu), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class A5 extends de {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(e = [], n = Xu, i, s, o, a, h, c, l, u) {
    super(e, n, i, s, o, a, h, c, l, u), this.isCubeTexture = !0, this.flipY = !1;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class C5 extends de {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, n = 1, i = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: i, depth: s }, this.magFilter = zn, this.minFilter = zn, this.wrapR = Pi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class P5 extends de {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = null, n = 1, i = 1, s, o, a, h, c, l = zn, u = zn, f, d) {
    super(null, a, h, c, l, u, s, o, f, d), this.isDataTexture = !0, this.image = { data: e, width: n, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class I5 extends de {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e, n, i = Gu, s, o, a, h = zn, c = zn, l, u = Jl, f = 1) {
    if (u !== Jl && u !== gm)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    const d = { width: e, height: n, depth: f };
    super(d, s, o, a, h, c, u, i, l), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.source = new Xh(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
class k5 extends de {
  /**
   * Constructs a new framebuffer texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   */
  constructor(e, n) {
    super({ width: e, height: n }), this.isFramebufferTexture = !0, this.magFilter = zn, this.minFilter = zn, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class Rg extends de {
  /**
   * Constructs a new video texture.
   *
   * @param {HTMLVideoElement} video - The video element to use as a data source for the texture.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, n, i, s, o = Tr, a = Tr, h, c, l) {
    super(e, n, i, s, o, a, h, c, l), this.isVideoTexture = !0, this.generateMipmaps = !1;
    const u = this;
    function f() {
      u.needsUpdate = !0, e.requestVideoFrameCallback(f);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(f);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  /**
   * This method is called automatically by the renderer and sets {@link Texture#needsUpdate}
   * to `true` every time a new frame is available.
   *
   * Only relevant if `requestVideoFrameCallback` is not supported in the browser.
   */
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class R5 extends Rg {
  /**
   * Constructs a new video frame texture.
   *
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, n, i, s, o, a, h, c) {
    super({}, e, n, i, s, o, a, h, c), this.isVideoFrameTexture = !0;
  }
  /**
   * This method overwritten with an empty implementation since
   * this type of texture is updated via `setFrame()`.
   */
  update() {
  }
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the current frame of the video. This will automatically update the texture
   * so the data can be used for rendering.
   *
   * @param {VideoFrame} frame - The video frame.
   */
  setFrame(e) {
    this.image = e, this.needsUpdate = !0;
  }
}
const EP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: ez,
  AddEquation: bE,
  AddOperation: GE,
  AdditiveAnimationBlendMode: Ku,
  AdditiveBlending: xE,
  AgXToneMapping: iz,
  AlphaFormat: xm,
  AlwaysCompare: Qz,
  AlwaysDepth: $E,
  AlwaysStencilFunc: Wz,
  AnimationAction: rg,
  AnimationClip: eu,
  AnimationMixer: WA,
  AnimationObjectGroup: jA,
  AnimationUtils: IA,
  ArcCurve: Mg,
  ArrayCamera: iC,
  AttachedBindMode: rz,
  Audio: fg,
  AudioAnalyser: QA,
  AudioContext: dg,
  AudioListener: tC,
  BackSide: fE,
  BasicDepthPacking: _z,
  BasicShadowMap: aE,
  BooleanKeyframeTrack: Bs,
  Box2: x5,
  Box3: Ar,
  BoxGeometry: wf,
  BufferAttribute: ke,
  BufferGeometry: ee,
  ByteType: hm,
  Camera: cf,
  CanvasTexture: T5,
  CapsuleGeometry: bf,
  CatmullRomCurve3: _g,
  CineonToneMapping: tz,
  CircleGeometry: vf,
  ClampToEdgeWrapping: Pi,
  Clock: pg,
  Color: Cr,
  ColorKeyframeTrack: rf,
  ColorManagement: Ke,
  CompressedArrayTexture: E5,
  CompressedCubeTexture: z5,
  CompressedTexture: Df,
  ConeGeometry: Mf,
  ConstantAlphaFactor: NE,
  ConstantColorFactor: BE,
  Controls: IC,
  CubeCamera: sC,
  CubeReflectionMapping: Xu,
  CubeRefractionMapping: az,
  CubeTexture: A5,
  CubeUVReflectionMapping: lz,
  CubicBezierCurve: pf,
  CubicBezierCurve3: Sg,
  CubicInterpolant: hg,
  CullFaceBack: sE,
  CullFaceFront: rE,
  CullFaceFrontBack: oE,
  CullFaceNone: iE,
  Curve: An,
  CurvePath: Eg,
  CustomBlending: wE,
  CustomToneMapping: nz,
  CylinderGeometry: Gh,
  Cylindrical: m5,
  Data3DTexture: vg,
  DataArrayTexture: C5,
  DataTexture: P5,
  DataUtils: hC,
  DecrementStencilOp: Rz,
  DecrementWrapStencilOp: Lz,
  DepthFormat: Jl,
  DepthStencilFormat: gm,
  DepthTexture: I5,
  DetachedBindMode: oz,
  DiscreteInterpolant: cg,
  DodecahedronGeometry: _f,
  DoubleSide: dE,
  DstAlphaFactor: IE,
  DstColorFactor: RE,
  DynamicCopyUsage: rA,
  DynamicDrawUsage: Kz,
  DynamicReadUsage: nA,
  EdgesGeometry: u5,
  EllipseCurve: Zh,
  EqualCompare: Hz,
  EqualDepth: WE,
  EqualStencilFunc: qz,
  EquirectangularReflectionMapping: hz,
  EquirectangularRefractionMapping: cz,
  Euler: As,
  EventDispatcher: Li,
  ExtrudeGeometry: Sf,
  Float16BufferAttribute: yC,
  Float32BufferAttribute: wt,
  FloatType: Ju,
  Fog: Nf,
  FogExp2: qf,
  FramebufferTexture: k5,
  FrontSide: uE,
  Frustum: kg,
  FrustumArray: Bf,
  GLBufferAttribute: bC,
  GLSL1: aA,
  GLSL3: hA,
  GreaterCompare: Zz,
  GreaterDepth: YE,
  GreaterEqualCompare: Jz,
  GreaterEqualDepth: jE,
  GreaterEqualStencilFunc: Uz,
  GreaterStencilFunc: $z,
  HalfFloatType: fm,
  IcosahedronGeometry: Tf,
  ImageUtils: wg,
  IncrementStencilOp: kz,
  IncrementWrapStencilOp: Oz,
  InstancedBufferAttribute: vC,
  InstancedBufferGeometry: MC,
  InstancedInterleavedBuffer: _C,
  Int16BufferAttribute: dC,
  Int32BufferAttribute: pC,
  Int8BufferAttribute: lC,
  IntType: um,
  InterleavedBuffer: mg,
  InterleavedBufferAttribute: uf,
  Interpolant: Uo,
  InterpolateDiscrete: zo,
  InterpolateLinear: Ch,
  InterpolateSmooth: Ka,
  InterpolationSamplingMode: uA,
  InterpolationSamplingType: lA,
  InvertStencilOp: Bz,
  KeepStencilOp: Pz,
  KeyframeTrack: cn,
  LatheGeometry: Ef,
  Layers: hf,
  LessCompare: Yz,
  LessDepth: VE,
  LessEqualCompare: Xz,
  LessEqualDepth: UE,
  LessEqualStencilFunc: Dz,
  LessStencilFunc: Nz,
  Line3: v5,
  LineCurve: yf,
  LineCurve3: Tg,
  LinearFilter: Tr,
  LinearInterpolant: sf,
  LinearMipMapLinearFilter: mz,
  LinearMipMapNearestFilter: xz,
  LinearMipmapLinearFilter: am,
  LinearMipmapNearestFilter: yz,
  LinearSRGBColorSpace: Ql,
  LinearToneMapping: QE,
  LinearTransfer: Kl,
  LoopOnce: ng,
  LoopPingPong: sg,
  LoopRepeat: ig,
  MOUSE: eE,
  MathUtils: AA,
  Matrix2: Ff,
  Matrix3: Wn,
  Matrix4: te,
  MaxEquation: SE,
  MinEquation: _E,
  MirroredRepeatWrapping: Gl,
  MixOperation: ZE,
  MultiplyBlending: gE,
  MultiplyOperation: XE,
  NearestFilter: zn,
  NearestMipMapLinearFilter: pz,
  NearestMipMapNearestFilter: fz,
  NearestMipmapLinearFilter: dz,
  NearestMipmapNearestFilter: uz,
  NeutralToneMapping: sz,
  NeverCompare: jz,
  NeverDepth: DE,
  NeverStencilFunc: Fz,
  NoBlending: pE,
  NoColorSpace: tf,
  NoToneMapping: JE,
  NormalAnimationBlendMode: Hh,
  NormalBlending: yE,
  NotEqualCompare: Gz,
  NotEqualDepth: HE,
  NotEqualStencilFunc: Vz,
  NumberKeyframeTrack: Io,
  Object3D: Ve,
  ObjectSpaceNormalMap: Az,
  OctahedronGeometry: zf,
  OneFactor: EE,
  OneMinusConstantAlphaFactor: qE,
  OneMinusConstantColorFactor: FE,
  OneMinusDstAlphaFactor: kE,
  OneMinusDstColorFactor: OE,
  OneMinusSrcAlphaFactor: PE,
  OneMinusSrcColorFactor: AE,
  OrthographicCamera: rC,
  PCFShadowMap: hE,
  PCFSoftShadowMap: cE,
  Path: kh,
  PerspectiveCamera: Bn,
  Plane: fs,
  PlaneGeometry: Af,
  PolyhedronGeometry: Ns,
  PositionalAudio: nC,
  PropertyBinding: kt,
  PropertyMixer: ug,
  QuadraticBezierCurve: xf,
  QuadraticBezierCurve3: mf,
  Quaternion: $e,
  QuaternionKeyframeTrack: Wo,
  QuaternionLinearInterpolant: lg,
  RED_GREEN_RGTC2_Format: tg,
  RED_RGTC1_Format: Qm,
  REVISION: tE,
  RGBADepthPacking: Sz,
  RGBAFormat: Qu,
  RGBAIntegerFormat: _m,
  RGBA_ASTC_10x10_Format: Ym,
  RGBA_ASTC_10x5_Format: Um,
  RGBA_ASTC_10x6_Format: Wm,
  RGBA_ASTC_10x8_Format: jm,
  RGBA_ASTC_12x10_Format: Hm,
  RGBA_ASTC_12x12_Format: Xm,
  RGBA_ASTC_4x4_Format: Lm,
  RGBA_ASTC_5x4_Format: Bm,
  RGBA_ASTC_5x5_Format: Fm,
  RGBA_ASTC_6x5_Format: Nm,
  RGBA_ASTC_6x6_Format: qm,
  RGBA_ASTC_8x5_Format: Dm,
  RGBA_ASTC_8x6_Format: $m,
  RGBA_ASTC_8x8_Format: Vm,
  RGBA_BPTC_Format: Zm,
  RGBA_ETC2_EAC_Format: Om,
  RGBA_PVRTC_2BPPV1_Format: Im,
  RGBA_PVRTC_4BPPV1_Format: Pm,
  RGBA_S3TC_DXT1_Format: Tm,
  RGBA_S3TC_DXT3_Format: Em,
  RGBA_S3TC_DXT5_Format: zm,
  RGBDepthPacking: Tz,
  RGBFormat: mm,
  RGBIntegerFormat: wz,
  RGB_BPTC_SIGNED_Format: Gm,
  RGB_BPTC_UNSIGNED_Format: Jm,
  RGB_ETC1_Format: km,
  RGB_ETC2_Format: Rm,
  RGB_PVRTC_2BPPV1_Format: Cm,
  RGB_PVRTC_4BPPV1_Format: Am,
  RGB_S3TC_DXT1_Format: Sm,
  RGDepthPacking: Ez,
  RGFormat: vm,
  RGIntegerFormat: Mm,
  Ray: gg,
  Raycaster: SC,
  RedFormat: wm,
  RedIntegerFormat: bm,
  ReinhardToneMapping: KE,
  RenderTarget: bg,
  RenderTarget3D: AC,
  RepeatWrapping: Zl,
  ReplaceStencilOp: Iz,
  ReverseSubtractEquation: ME,
  RingGeometry: Cf,
  SIGNED_RED_GREEN_RGTC2_Format: eg,
  SIGNED_RED_RGTC1_Format: Km,
  SRGBColorSpace: rn,
  SRGBTransfer: th,
  Scene: S5,
  Shape: mr,
  ShapeGeometry: Pf,
  ShapePath: s5,
  ShapeUtils: Sn,
  ShortType: cm,
  Source: Xh,
  Sphere: lf,
  SphereGeometry: If,
  Spherical: M5,
  SphericalHarmonics3: _5,
  SplineCurve: gf,
  SrcAlphaFactor: CE,
  SrcAlphaSaturateFactor: LE,
  SrcColorFactor: zE,
  StaticCopyUsage: sA,
  StaticDrawUsage: Co,
  StaticReadUsage: eA,
  StereoCamera: oC,
  StreamCopyUsage: oA,
  StreamDrawUsage: tA,
  StreamReadUsage: iA,
  StringKeyframeTrack: Fs,
  SubtractEquation: vE,
  SubtractiveBlending: mE,
  TOUCH: nE,
  TangentSpaceNormalMap: zz,
  TetrahedronGeometry: kf,
  Texture: de,
  TextureUtils: l5,
  TimestampQuery: cA,
  TorusGeometry: Rf,
  TorusKnotGeometry: Of,
  Triangle: zi,
  TriangleFanDrawMode: Mz,
  TriangleStripDrawMode: vz,
  TrianglesDrawMode: bz,
  TubeGeometry: Lf,
  UVMapping: Hu,
  Uint16BufferAttribute: yg,
  Uint32BufferAttribute: xg,
  Uint8BufferAttribute: uC,
  Uint8ClampedBufferAttribute: fC,
  Uniform: ff,
  UniformsGroup: PC,
  UnsignedByteType: Zu,
  UnsignedInt248Type: gz,
  UnsignedInt5999Type: ym,
  UnsignedIntType: Gu,
  UnsignedShort4444Type: dm,
  UnsignedShort5551Type: pm,
  UnsignedShortType: lm,
  VSMShadowMap: lE,
  Vector2: nt,
  Vector3: $,
  Vector4: Oi,
  VectorKeyframeTrack: ko,
  VideoFrameTexture: R5,
  VideoTexture: Rg,
  WebGLCoordinateSystem: Dn,
  WebGPUCoordinateSystem: Po,
  WireframeGeometry: y5,
  WrapAroundEnding: Ao,
  ZeroCurvatureEnding: ws,
  ZeroFactor: TE,
  ZeroSlopeEnding: bs,
  ZeroStencilOp: Cz,
  createCanvasElement: gC,
  deviation: e5,
  flatten: n5
}, Symbol.toStringTag, { value: "Module" })), O5 = 1e-5;
function eh(r, e, n = O5) {
  return Math.abs(r - e) < n;
}
function Re(r, e, n, i) {
  const s = r - n, o = e - i;
  return Math.sqrt(s * s + o * o);
}
function Jh(r, e) {
  const n = Math.min(...r), i = Math.min(...e), s = Math.max(...r), o = Math.max(...e);
  return {
    x: n,
    y: i,
    width: s - n,
    height: o - i
  };
}
function Og(r) {
  return (r + Math.PI * 2) % (Math.PI * 2);
}
function Gp(r, e) {
  const n = Math.abs(r);
  return e > 0 ? n : n * -1;
}
function L5(r, e, n, i, s, o) {
  const a = n, h = i;
  if (a === 0 || h === 0)
    return {
      x: r,
      y: e
    };
  const c = s - r, l = o - e, u = Math.abs(c), f = Math.abs(l), d = a * a, p = h * h;
  let y = Math.PI / 4, x = 0, m = 0;
  for (let g = 0; g < 4; g++) {
    x = a * Math.cos(y), m = h * Math.sin(y);
    const w = (d - p) * Math.cos(y) ** 3 / a, M = (p - d) * Math.sin(y) ** 3 / h, S = x - w, E = m - M, A = u - w, I = f - M, b = Math.hypot(E, S), v = Math.hypot(I, A), z = b * Math.asin((S * I - E * A) / (b * v)) / Math.sqrt(d + p - x * x - m * m);
    y += z, y = Math.min(Math.PI / 2, Math.max(0, y));
  }
  return {
    x: r + Gp(x, c),
    y: e + Gp(m, l)
  };
}
function B5(r, e, n, i, s, o, a, h) {
  return -1 * n * Math.cos(s) * Math.sin(h) - i * Math.sin(s) * Math.cos(h);
}
function F5(r, e, n, i, s, o, a, h) {
  return -1 * n * Math.sin(s) * Math.sin(h) + i * Math.cos(s) * Math.cos(h);
}
function N5(r, e, n) {
  return Math.atan(-e / r * Math.tan(n));
}
function q5(r, e, n) {
  return Math.atan(e / (r * Math.tan(n)));
}
function D5(r, e, n, i, s, o) {
  return n * Math.cos(s) * Math.cos(o) - i * Math.sin(s) * Math.sin(o) + r;
}
function $5(r, e, n, i, s, o) {
  return n * Math.sin(s) * Math.cos(o) + i * Math.cos(s) * Math.sin(o) + e;
}
function V5(r, e, n, i) {
  return (Math.atan2(i * r, n * e) + Math.PI * 2) % (Math.PI * 2);
}
function Jp(r, e, n) {
  return {
    x: r * Math.cos(n),
    y: e * Math.sin(n)
  };
}
function Qp(r, e, n) {
  const i = Math.cos(n), s = Math.sin(n);
  return [r * i - e * s, r * s + e * i];
}
function U5(r, e, n, i, s, o, a) {
  const h = N5(n, i, s);
  let c = 1 / 0, l = -1 / 0;
  const u = [o, a];
  for (let x = -Math.PI * 2; x <= Math.PI * 2; x += Math.PI) {
    const m = h + x;
    o < a ? o < m && m < a && u.push(m) : a < m && m < o && u.push(m);
  }
  for (let x = 0; x < u.length; x++) {
    const m = D5(r, e, n, i, s, u[x]);
    m < c && (c = m), m > l && (l = m);
  }
  const f = q5(n, i, s);
  let d = 1 / 0, p = -1 / 0;
  const y = [o, a];
  for (let x = -Math.PI * 2; x <= Math.PI * 2; x += Math.PI) {
    const m = f + x;
    o < a ? o < m && m < a && y.push(m) : a < m && m < o && y.push(m);
  }
  for (let x = 0; x < y.length; x++) {
    const m = $5(r, e, n, i, s, y[x]);
    m < d && (d = m), m > p && (p = m);
  }
  return {
    x: c,
    y: d,
    width: l - c,
    height: p - d
  };
}
function W5(r, e, n, i, s, o, a, h, c) {
  const l = Qp(h - r, c - e, -s), [u, f] = l;
  let d = L5(0, 0, n, i, u, f);
  const p = V5(n, i, d.x, d.y);
  p < o ? d = Jp(n, i, o) : p > a && (d = Jp(n, i, a));
  const y = Qp(d.x, d.y, s);
  return {
    x: y[0] + r,
    y: y[1] + e
  };
}
function j5(r, e, n, i, s, o, a, h) {
  const c = (a - o) * h + o, l = B5(
    r,
    e,
    n,
    i,
    s,
    o,
    a,
    c
  ), u = F5(
    r,
    e,
    n,
    i,
    s,
    o,
    a,
    c
  );
  return Og(Math.atan2(u, l));
}
const Y5 = 1e-4;
function Lg(r, e, n, i, s, o) {
  let a = -1, h = 1 / 0;
  const c = [n, i];
  let l = 20;
  o && o > 200 && (l = o / 10);
  const u = 1 / l;
  let f = u / 10;
  for (let d = 0; d <= l; d++) {
    const p = d * u, y = [
      s(...r.concat([p])),
      s(...e.concat([p]))
    ], x = Re(c[0], c[1], y[0], y[1]);
    x < h && (a = p, h = x);
  }
  if (a === 0)
    return {
      x: r[0],
      y: e[0]
    };
  if (a === 1) {
    const d = r.length;
    return {
      x: r[d - 1],
      y: e[d - 1]
    };
  }
  h = 1 / 0;
  for (let d = 0; d < 32 && !(f < Y5); d++) {
    const p = a - f, y = a + f, x = [
      s(...r.concat([p])),
      s(...e.concat([p]))
    ], m = Re(c[0], c[1], x[0], x[1]);
    if (p >= 0 && m < h)
      a = p, h = m;
    else {
      const g = [
        s(...r.concat([y])),
        s(...e.concat([y]))
      ], w = Re(c[0], c[1], g[0], g[1]);
      y <= 1 && w < h ? (a = y, h = w) : f *= 0.5;
    }
  }
  return {
    x: s(...r.concat([a])),
    y: s(...e.concat([a]))
  };
}
function H5(r, e) {
  let n = 0;
  const i = r.length;
  for (let s = 0; s < i; s++) {
    const o = r[s], a = e[s], h = r[(s + 1) % i], c = e[(s + 1) % i];
    n += Re(o, a, h, c);
  }
  return n / 2;
}
function X5(r, e, n, i) {
  return Jh([r, n], [e, i]);
}
function Z5(r, e, n, i) {
  return Re(r, e, n, i);
}
function ri(r, e, n, i, s) {
  return {
    x: (1 - s) * r + s * n,
    y: (1 - s) * e + s * i
  };
}
function Bg(r, e, n, i, s, o) {
  const a = (n - r) * (s - r) + (i - e) * (o - e);
  if (a < 0)
    return Re(r, e, s, o);
  const h = (n - r) * (n - r) + (i - e) * (i - e);
  return a > h ? Re(n, i, s, o) : Fg(r, e, n, i, s, o);
}
function Fg(r, e, n, i, s, o) {
  const a = [n - r, i - e];
  if (et.exactEquals(a, [0, 0]))
    return Math.sqrt((s - r) * (s - r) + (o - e) * (o - e));
  const h = [-a[1], a[0]];
  et.normalize(h, h);
  const c = [s - r, o - e];
  return Math.abs(et.dot(c, h));
}
function G5(r, e, n, i) {
  return Math.atan2(i - e, n - r);
}
function Ps(r, e, n, i, s) {
  const o = 1 - s;
  return o * o * o * r + 3 * e * s * o * o + 3 * n * s * s * o + i * s * s * s;
}
function Kp(r, e, n, i, s) {
  const o = 1 - s;
  return 3 * (o * o * (e - r) + 2 * o * s * (n - e) + s * s * (i - n));
}
function t1(r, e, n, i) {
  const s = -3 * r + 9 * e - 9 * n + 3 * i, o = 6 * r - 12 * e + 6 * n, a = 3 * e - 3 * r, h = [];
  let c, l, u;
  if (eh(s, 0))
    eh(o, 0) || (c = -a / o, c >= 0 && c <= 1 && h.push(c));
  else {
    const f = o * o - 4 * s * a;
    eh(f, 0) ? h.push(-o / (2 * s)) : f > 0 && (u = Math.sqrt(f), c = (-o + u) / (2 * s), l = (-o - u) / (2 * s), c >= 0 && c <= 1 && h.push(c), l >= 0 && l <= 1 && h.push(l));
  }
  return h;
}
function J5(r, e, n, i, s, o, a, h, c) {
  const l = Ps(r, n, s, a, c), u = Ps(e, i, o, h, c), f = ri(r, e, n, i, c), d = ri(n, i, s, o, c), p = ri(s, o, a, h, c), y = ri(f.x, f.y, d.x, d.y, c), x = ri(d.x, d.y, p.x, p.y, c);
  return [
    [r, e, f.x, f.y, y.x, y.y, l, u],
    [l, u, x.x, x.y, p.x, p.y, a, h]
  ];
}
function au(r, e, n, i, s, o, a, h, c) {
  if (c === 0)
    return H5([r, n, s, a], [e, i, o, h]);
  const l = J5(r, e, n, i, s, o, a, h, 0.5), u = [...l[0], c - 1], f = [...l[1], c - 1];
  return au(...u) + au(...f);
}
function Q5(r, e, n, i, s, o, a, h) {
  const c = [r, a], l = [e, h], u = t1(r, n, s, a), f = t1(e, i, o, h);
  for (let d = 0; d < u.length; d++)
    c.push(Ps(r, n, s, a, u[d]));
  for (let d = 0; d < f.length; d++)
    l.push(Ps(e, i, o, h, f[d]));
  return Jh(c, l);
}
function K5(r, e, n, i, s, o, a, h) {
  return au(r, e, n, i, s, o, a, h, 3);
}
function Ng(r, e, n, i, s, o, a, h, c, l, u) {
  return Lg(
    [r, n, s, a],
    [e, i, o, h],
    c,
    l,
    Ps,
    u
  );
}
function tP(r, e, n, i, s, o, a, h, c, l, u) {
  const f = Ng(r, e, n, i, s, o, a, h, c, l, u);
  return Re(f.x, f.y, c, l);
}
function eP(r, e, n, i, s, o, a, h, c) {
  return {
    x: Ps(r, n, s, a, c),
    y: Ps(e, i, o, h, c)
  };
}
function nP(r, e, n, i, s, o, a, h, c) {
  const l = Kp(r, n, s, a, c), u = Kp(e, i, o, h, c);
  return Og(Math.atan2(u, l));
}
function qg(r) {
  let e = 0;
  const n = [];
  for (let i = 0; i < r.length - 1; i++) {
    const s = r[i], o = r[i + 1], a = Re(s[0], s[1], o[0], o[1]), h = {
      from: s,
      to: o,
      length: a
    };
    n.push(h), e += a;
  }
  return { segments: n, totalLength: e };
}
function Dg(r) {
  if (r.length < 2)
    return 0;
  let e = 0;
  for (let n = 0; n < r.length - 1; n++) {
    const i = r[n], s = r[n + 1];
    e += Re(i[0], i[1], s[0], s[1]);
  }
  return e;
}
function $g(r, e) {
  if (e > 1 || e < 0 || r.length < 2)
    return null;
  const { segments: n, totalLength: i } = qg(r);
  if (i === 0)
    return {
      x: r[0][0],
      y: r[0][1]
    };
  let s = 0, o = null;
  for (let a = 0; a < n.length; a++) {
    const h = n[a], { from: c, to: l } = h, u = h.length / i;
    if (e >= s && e <= s + u) {
      const f = (e - s) / u;
      o = ri(c[0], c[1], l[0], l[1], f);
      break;
    }
    s += u;
  }
  return o;
}
function Vg(r, e) {
  if (e > 1 || e < 0 || r.length < 2)
    return 0;
  const { segments: n, totalLength: i } = qg(r);
  let s = 0, o = 0;
  for (let a = 0; a < n.length; a++) {
    const h = n[a], { from: c, to: l } = h, u = h.length / i;
    if (e >= s && e <= s + u) {
      o = Math.atan2(l[1] - c[1], l[0] - c[0]);
      break;
    }
    s += u;
  }
  return o;
}
function Ug(r, e, n) {
  let i = 1 / 0;
  for (let s = 0; s < r.length - 1; s++) {
    const o = r[s], a = r[s + 1], h = Bg(
      o[0],
      o[1],
      a[0],
      a[1],
      e,
      n
    );
    h < i && (i = h);
  }
  return i;
}
function Wg(r) {
  const e = [], n = [];
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    e.push(s[0]), n.push(s[1]);
  }
  return Jh(e, n);
}
function iP(r) {
  return Dg(r);
}
function sP(r, e) {
  return $g(r, e);
}
function rP(r, e, n) {
  return Ug(r, e, n);
}
function oP(r, e) {
  return Vg(r, e);
}
function Qh(r) {
  const e = r.slice(0);
  return r.length && e.push(r[0]), e;
}
function aP(r) {
  return Wg(r);
}
function hP(r) {
  return Dg(Qh(r));
}
function cP(r, e) {
  return $g(Qh(r), e);
}
function lP(r, e, n) {
  return Ug(Qh(r), e, n);
}
function uP(r, e) {
  return Vg(Qh(r), e);
}
function Bo(r, e, n, i) {
  const s = 1 - i;
  return s * s * r + 2 * i * s * e + i * i * n;
}
function e1(r, e, n) {
  const i = r + n - 2 * e;
  if (eh(i, 0))
    return [0.5];
  const s = (r - e) / i;
  return s <= 1 && s >= 0 ? [s] : [];
}
function fP(r, e, n, i, s, o, a) {
  const h = Bo(r, n, s, a), c = Bo(e, i, o, a), l = ri(r, e, n, i, a), u = ri(n, i, s, o, a);
  return [
    [r, e, l.x, l.y, h, c],
    [h, c, u.x, u.y, s, o]
  ];
}
function hu(r, e, n, i, s, o, a) {
  if (a === 0)
    return (Re(r, e, n, i) + Re(n, i, s, o) + Re(r, e, s, o)) / 2;
  const h = fP(r, e, n, i, s, o, 0.5), c = h[0], l = h[1];
  return c.push(a - 1), l.push(a - 1), hu(...c) + hu(...l);
}
function dP(r, e, n, i, s, o) {
  const a = e1(r, n, s)[0], h = e1(e, i, o)[0], c = [r, s], l = [e, o];
  return a !== void 0 && c.push(Bo(r, n, s, a)), h !== void 0 && l.push(Bo(e, i, o, h)), Jh(c, l);
}
function pP(r, e, n, i, s, o) {
  return hu(r, e, n, i, s, o, 3);
}
function jg(r, e, n, i, s, o, a, h) {
  return Lg([r, n, s], [e, i, o], a, h, Bo);
}
function yP(r, e, n, i, s, o, a, h) {
  const c = jg(r, e, n, i, s, o, a, h);
  return Re(c.x, c.y, a, h);
}
const zP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arcBox: U5,
  arcNearestPoint: W5,
  arcTangentAngle: j5,
  cubicBox: Q5,
  cubicLength: K5,
  cubicNearestPoint: Ng,
  cubicPointAt: eP,
  cubicPointDistance: tP,
  cubicTangentAngle: nP,
  distance: Re,
  lineBox: X5,
  lineLength: Z5,
  linePointAt: ri,
  linePointDistance: Bg,
  linePointToLine: Fg,
  lineTangentAngle: G5,
  polygonBox: aP,
  polygonLength: hP,
  polygonPointAt: cP,
  polygonPointDistance: lP,
  polygonTangentAngle: uP,
  polylineBox: Wg,
  polylineLength: iP,
  polylinePointAt: sP,
  polylinePointDistance: rP,
  polylineTangentAngle: oP,
  quadBox: dP,
  quadLength: pP,
  quadNearestPoint: jg,
  quadPointDistance: yP
}, Symbol.toStringTag, { value: "Module" }));
export {
  zP as gMath,
  wP as glMatrix,
  TP as m2d,
  EP as m3d
};
