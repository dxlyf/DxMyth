function Fh(i, e, n) {
  return i[0] = e, i[1] = n, i;
}
function ap(i, e, n, s, r) {
  let a = e, o = n, h = Math.sqrt(a * a + o * o);
  if (h === 0 || !Number.isFinite(h))
    return !1;
  let c = s / h;
  return e *= c, n *= c, i[0] = e, i[1] = n, !0;
}
function z_(i, e) {
  return i[0] = e, i[1] = e, i;
}
function Tu(i, e, n) {
  return i[0] = e[0] + n[0], i[1] = e[1] + n[1], i;
}
function $a(i, e, n) {
  return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i;
}
function Lr(i, e, n) {
  return i[0] = e[0] * n[0], i[1] = e[1] * n[1], i;
}
function Eu(i, e, n) {
  return i[0] = e[0] * n, i[1] = e[1] * n, i;
}
function Va(i, e, n) {
  return i[0] = e[0] / n[0], i[1] = e[1] / n[1], i;
}
function ul(i, e) {
  return i[0] * e[0] + i[1] * e[1];
}
function Df(i, e) {
  return i[0] * e[1] - i[1] * e[0];
}
function op(i, e) {
  return Math.sqrt((i[0] - e[0]) * (i[0] - e[0]) + (i[1] - e[1]) * (i[1] - e[1]));
}
function hp(i, e) {
  return (i[0] - e[0]) * (i[0] - e[0]) + (i[1] - e[1]) * (i[1] - e[1]);
}
function cp(i) {
  return i[0] * i[0] + i[1] * i[1];
}
function Go(i) {
  return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
}
function lp(i, e) {
  return Math.abs(i[0] - e[0]) + Math.abs(i[1] - e[1]);
}
function up(i, e) {
  return Math.max(Math.abs(i[0] - e[0]), Math.abs(i[1] - e[1]));
}
function fl(i, e) {
  const n = Go(e);
  return i[0] = e[0] / n, i[1] = e[1] / n, i;
}
function qf(i, e, n, s) {
  return i[0] = e[0] + (n[0] - e[0]) * s, i[1] = e[1] + (n[1] - e[1]) * s, i;
}
function fp(i, e, n, s) {
  s = s < 0 ? 0 : s > 1 ? 1 : s;
  const r = s * s * (3 - 2 * s);
  return qf(i, e, n, r);
}
function dp(i) {
  return Math.atan2(i[1], i[0]);
}
function pp(i, e) {
  return Math.acos(ul(i, e) / (Go(i) * Go(e)));
}
function C_(i, e = [0, 0]) {
  return Math.atan2(i[1] - e[1], i[0] - e[0]);
}
function yp(i, e) {
  return Math.atan2(Df(e, i), ul(i, e));
}
function zu(i, e) {
  return i[0] = -e[1], i[1] = e[0], i;
}
function xp(i, e, n) {
  const s = 2 * (e[0] * n[0] + e[1] * n[1]);
  return i[0] = e[0] - s * n[0], i[1] = e[1] - s * n[1], i;
}
function A_(i, e, n, s, r) {
  const a = fl(N.default(), n), o = fl(N.default(), e), h = s / r, c = -o.dot(a), l = Math.sqrt(1 - c * c), u = h * l;
  if (u > 1)
    return null;
  const f = Math.sqrt(1 - u * u);
  return o.multiplyScalar(h).add(a.multiplyScalar(h * c - f)), i[0] = o[0], i[1] = o[1], i;
}
function gp(i, e) {
  return i[0] = -e[0], i[1] = -e[1], i;
}
function mp(i, e) {
  return i[0] = Math.abs(e[0]), i[1] = Math.abs(e[1]), i;
}
function vp(i, e) {
  return i[0] = Math.round(e[0]), i[1] = Math.round(e[1]), i;
}
function wp(i, e) {
  return i[0] = Math.floor(e[0]), i[1] = Math.floor(e[1]), i;
}
function Mp(i, e) {
  return i[0] = Math.ceil(e[0]), i[1] = Math.ceil(e[1]), i;
}
function bp(i, e, n) {
  return i[0] = Math.min(e[0], n[0]), i[1] = Math.min(e[1], n[1]), i;
}
function _p(i, e, n) {
  return i[0] = Math.max(e[0], n[0]), i[1] = Math.max(e[1], n[1]), i;
}
function Sp(i, e, n, s) {
  return i[0] = Math.max(n[0], Math.min(s[0], e[0])), i[1] = Math.max(n[1], Math.min(s[1], e[1])), i;
}
function Tp(i, e) {
  return i[0] = e[0] - Math.floor(e[0]), i[1] = e[1] - Math.floor(e[1]), i;
}
function Ep(i, e, n) {
  return i[0] = e[0] - n[0] * Math.floor(e[0] / n[0]), i[1] = e[1] - n[1] * Math.floor(e[1] / n[1]), i;
}
function P_(i, e, n) {
  return i[0] = e[0] - n[0] * Math.ceil(e[0] / n[0]), i[1] = e[1] - n[1] * Math.ceil(e[1] / n[1]), i;
}
function zp(i, e, n) {
  const s = Math.cos(n), r = Math.sin(n), a = e[0], o = e[1];
  return i[0] = a * s - o * r, i[1] = a * r + o * s, i;
}
function Cp(i, e, n, s) {
  const r = Math.cos(s), a = Math.sin(s), o = e[0] - n[0], h = e[1] - n[1];
  return i[0] = o * r - h * a + n[0], i[1] = o * a + h * r + n[1], i;
}
function Ap(i, e, n, s) {
  return i[0] = e[0] * n, i[1] = e[1] * s, i;
}
function Pp(i, e, n, s) {
  return i[0] = (e[0] - n[0]) * s[0] + n[0], i[1] = (e[1] - n[1]) * s[1] + n[1], i;
}
function Ip(i, e, n, s) {
  return i[0] = e[0] + n, i[1] = e[1] + s, i;
}
function Rp(i, e, n) {
  return i[0] = e[0] * n[0] + e[1] * n[2] + n[4], i[1] = e[0] * n[1] + e[1] * n[3] + n[5], i;
}
function Op(i, e, n) {
  return i[0] = e[0] * n[0] + e[1] * n[4] + n[8], i[1] = e[0] * n[1] + e[1] * n[5] + n[9], i;
}
function I_(i, e) {
  return i[0] === e[0] && i[1] === e[1];
}
function R_(i) {
  return i[0] === 0 && i[1] === 0;
}
function O_(i, e, n = 1e-6) {
  return Math.abs(i[0] - e[0]) < n && Math.abs(i[1] - e[1]) < n;
}
let N = class extends Float32Array {
  static BYTE_LENGTH = 2 * Float32Array.BYTES_PER_ELEMENT;
  static create(e, n) {
    return new this(e, n);
  }
  static from(e) {
    return this.create(e[0], e[1]);
  }
  static fromPoint(e) {
    return this.create(e.x, e.y);
  }
  static fromRotation(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.create(n, s);
  }
  static default() {
    return this.create(0, 0);
  }
  static zero() {
    return this.create(0, 0);
  }
  static splat(e) {
    return this.create(e, e);
  }
  static makeZeroArray(e) {
    return Array.from({ length: e }, () => this.zero());
  }
  static set = Fh;
  static setXY = Fh;
  static add = Tu;
  static sub = $a;
  static mul = Lr;
  static mulScalar = Eu;
  static multiply = Lr;
  static div = Va;
  static divide = Va;
  static dot = ul;
  static cross = Df;
  static distance = op;
  static distanceSquared = hp;
  static lengthSquared = cp;
  static length = Go;
  static manhattanDistance = lp;
  static chebyshevDistance = up;
  static normalize = fl;
  static lerp = qf;
  static smoonthStep = fp;
  static angle = dp;
  static angleTo = pp;
  static angleBetweenPI2 = yp;
  static perpendicular = zu;
  static perp = zu;
  static reflect = xp;
  static negate = gp;
  static abs = mp;
  static round = vp;
  static floor = wp;
  static ceil = Mp;
  static min = bp;
  static max = _p;
  static clamp = Sp;
  static fractal = Tp;
  static floorMod = Ep;
  static rotate = zp;
  static rotateAround = Cp;
  static scale = Ap;
  static scaleAround = Pp;
  static translate = Ip;
  static transformMat2d = Rp;
  static transformMat3d = Op;
  static equals = I_;
  static isZero = R_;
  static equalsEpsilon = O_;
  constructor(...e) {
    e.length === 0 ? super(2) : Array.isArray(e[0]) ? super(e[0]) : super(e);
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this;
  }
  clone() {
    return this.constructor.create(this[0], this[1]);
  }
  set(e, n) {
    return Array.isArray(e) ? (super.set(e, n), this) : Fh(this, e, n);
  }
  setXY(e, n) {
    return Fh(this, e, n);
  }
  setLength(e) {
    return ap(this, this.x, this.y, e), this;
  }
  setLengthFromPoint(e, n, s) {
    return ap(this, e, n, s), this;
  }
  setRotation(e) {
    return this.setXY(Math.cos(e), Math.sin(e));
  }
  splat(e) {
    return z_(this, e);
  }
  add(e) {
    return Tu(this, this, e);
  }
  addVectors(e, n) {
    return Tu(this, e, n);
  }
  subtract(e) {
    return $a(this, this, e);
  }
  sub(e) {
    return $a(this, this, e);
  }
  subVectors(e, n) {
    return $a(this, e, n);
  }
  subtractVectors(e, n) {
    return $a(this, e, n);
  }
  mul(e) {
    return Lr(this, this, e);
  }
  multiply(e) {
    return Lr(this, this, e);
  }
  multiplyVectors(e, n) {
    return Lr(this, e, n);
  }
  mulVectors(e, n) {
    return Lr(this, e, n);
  }
  mulScalar(e) {
    return Eu(this, this, e);
  }
  multiplyScalar(e) {
    return Eu(this, this, e);
  }
  div(e) {
    return Va(this, this, e);
  }
  divide(e) {
    return Va(this, this, e);
  }
  divideVectors(e, n) {
    return Va(this, e, n);
  }
  dot(e) {
    return ul(this, e);
  }
  cross(e) {
    return Df(this, e);
  }
  distance(e) {
    return op(this, e);
  }
  distanceSquared(e) {
    return hp(this, e);
  }
  magnitudeSquared() {
    return cp(this);
  }
  magnitude() {
    return Go(this);
  }
  manhattanDistance(e) {
    return lp(this, e);
  }
  chebyshevDistance(e) {
    return up(this, e);
  }
  normalize() {
    return fl(this, this);
  }
  lerp(e, n) {
    return qf(this, this, e, n);
  }
  smoonthStep(e, n) {
    return fp(this, this, e, n);
  }
  angle() {
    return dp(this);
  }
  angleTo(e) {
    return pp(this, e);
  }
  angleToOrigin(e) {
    return C_(this, e);
  }
  angleBetween(e, n) {
    return yp(e, n);
  }
  perp() {
    return zu(this, this);
  }
  ccw() {
    return this.setXY(this.y, -this.x);
  }
  cw() {
    return this.setXY(-this.y, this.x);
  }
  reflect(e) {
    return xp(this, this, e);
  }
  refract(e, n, s, r) {
    return A_(this, e, n, s, r);
  }
  negate() {
    return gp(this, this);
  }
  abs() {
    return mp(this, this);
  }
  round() {
    return vp(this, this);
  }
  floor() {
    return wp(this, this);
  }
  ceil() {
    return Mp(this, this);
  }
  min(e) {
    return bp(this, this, e);
  }
  max(e) {
    return _p(this, this, e);
  }
  clamp(e, n) {
    return Sp(this, this, e, n);
  }
  fractal() {
    return Tp(this, this);
  }
  modDown(e) {
    return Ep(this, this, e);
  }
  modUp(e) {
    return P_(this, this, e);
  }
  rotate(e) {
    return zp(this, this, e);
  }
  rotateAround(e, n) {
    return Cp(this, this, e, n);
  }
  scale(e, n) {
    return Ap(this, this, e, n);
  }
  scaleAround(e, n) {
    return Pp(this, this, e, n);
  }
  translate(e, n) {
    return Ip(this, this, e, n);
  }
  transformMat2d(e) {
    return Rp(this, this, e);
  }
  applyMatrix2D(e) {
    return this.transformMat2d(e);
  }
  applyMatrix3D(e) {
    return this.transformMat3d(e);
  }
  transformMat3d(e) {
    return Op(this, this, e);
  }
  isFinite() {
    return isFinite(this.x) && isFinite(this.y);
  }
  isZero() {
    return this.x === 0 && this.y === 0;
  }
  equals(e) {
    return this[0] === e[0] && this[1] === e[1];
  }
  equalsEpsilon(e, n = 1e-6) {
    return Math.abs(this[0] - e[0]) < n && Math.abs(this[1] - e[1]) < n;
  }
  canNormalize() {
    return this.isFinite() && (this.x !== 0 || this.y !== 0);
  }
  toZero(e) {
    let n = this;
    return n[0] + e[0] == n[0] ? e[0] = 0 : n[0] + e[0] == e[0] && (n[0] = 0), n[1] + e[1] == n[1] ? e[1] = 0 : n[1] + e[1] == e[1] && (n[1] = 0), this;
  }
  toArray() {
    return [this[0], this[1]];
  }
};
const k_ = Math.PI * 2;
function Cu(i, e, n, s, r, a, o) {
  return i[0] = e, i[1] = n, i[2] = s, i[3] = r, i[4] = a, i[5] = o, i;
}
function Au(i) {
  return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 1, i[4] = 0, i[5] = 0, i;
}
function kp(i, e, n) {
  const s = e[0], r = e[2], a = e[4], o = e[1], h = e[3], c = e[5];
  return i[0] = s, i[1] = o, i[2] = r, i[3] = h, i[4] = a + s * n[0] + r * n[1], i[5] = c + o * n[0] + h * n[1], i;
}
function Lp(i, e, n) {
  const s = e[0], r = e[2], a = e[4], o = e[1], h = e[3], c = e[5], l = Math.cos(n), u = Math.sin(n);
  return i[0] = s * l + r * u, i[1] = o * l + h * u, i[2] = s * -u + r * l, i[3] = o * u + h * l, i[4] = a, i[5] = c, i;
}
function Fp(i, e, n) {
  const s = e[0], r = e[2], a = e[4], o = e[1], h = e[3], c = e[5], l = n[0], u = n[1];
  return i[0] = s * l, i[1] = o * l, i[2] = r * u, i[3] = h * u, i[4] = a, i[5] = c, i;
}
function Np(i, e) {
  return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 1, i[4] = e[0], i[5] = e[1], i;
}
function Bp(i, e) {
  const n = Math.cos(e), s = Math.sin(e);
  return i[0] = n, i[1] = s, i[2] = -s, i[3] = n, i[4] = 0, i[5] = 0, i;
}
function Dp(i, e) {
  const n = e[0], s = e[1];
  return i[0] = n, i[1] = 0, i[2] = 0, i[3] = s, i[4] = 0, i[5] = 0, i;
}
function L_(i, e) {
  const n = Math.tan(e[0]), s = Math.tan(e[1]);
  return i[0] = 1, i[1] = s, i[2] = n, i[3] = 1, i[4] = 0, i[5] = 0, i;
}
function qp(i, e, n, s) {
  const r = Math.cos(n), a = Math.sin(n);
  return i[0] = r * s[0], i[1] = a * s[0], i[2] = -a * s[1], i[3] = r * s[1], i[4] = e[0], i[5] = e[1], i;
}
function F_(i, e, n, s, r) {
  const a = Math.cos(n), o = Math.sin(n), h = e[0] + r[0], c = e[1] + r[1];
  return i[0] = a * s[0], i[1] = o * s[0], i[2] = -o * s[1], i[3] = a * s[1], i[4] = h - (r[0] * i[0] + r[1] * i[2]), i[5] = c - (r[0] * i[1] + r[1] * i[3]), i;
}
function N_(i, e, n, s, r, a) {
  const o = Math.cos(s), h = Math.sin(s), c = Math.tan(n[0]), l = Math.tan(n[1]), u = e[0] + a[0], f = e[1] + a[1];
  return i[0] = (o + c * h) * r[0], i[1] = (l * h + o) * r[0], i[2] = (-h + c * o) * r[1], i[3] = (l * -h + o) * r[1], i[4] = u - (a[0] * i[0] + a[1] * i[2]), i[5] = f - (a[0] * i[1] + a[1] * i[3]), i;
}
function B_(i, e, n, s, r, a) {
  const o = Math.cos(n), h = Math.sin(n), c = e[0] + r[0], l = e[1] + r[1], u = a[0] + r[0], f = a[1] + r[1];
  return i[0] = o * s[0], i[1] = h * s[0], i[2] = -h * s[1], i[3] = o * s[1], i[4] = c - (u * i[0] + f * i[2]), i[5] = l - (u * i[1] + f * i[3]), i;
}
function D_(i, e, n, s, r, a, o) {
  const h = Math.cos(s), c = Math.sin(s), l = Math.tan(n[0]), u = Math.tan(n[1]), f = e[0] + a[0], d = e[1] + a[1], p = o[0] + a[0], y = o[1] + a[1];
  return i[0] = (h + l * c) * r[0], i[1] = (u * h + c) * r[0], i[2] = (-c + l * h) * r[1], i[3] = (u * -c + h) * r[1], i[4] = f - (p * i[0] + y * i[2]), i[5] = d - (p * i[1] + y * i[3]), i;
}
function q_(i, e, n, s, r, a, o) {
  const h = Math.cos(s + n[1]), c = Math.sin(s + n[1]), l = -Math.sin(s - n[0]), u = Math.cos(s - n[0]), f = a[0], d = a[1], p = e[0], y = e[1], x = o[0] + f, g = o[1] + d;
  return i[0] = h * r[0], i[1] = c * r[0], i[2] = l * r[1], i[3] = u * r[1], i[4] = p - (x * i[0] + g * i[2]) + f, i[5] = y - (x * i[1] + g * i[3]) + d, i;
}
function $p(i, e) {
  return i[0] = e[4], i[1] = e[5], i;
}
function dl(i) {
  return Math.atan2(i[1], i[0]);
}
function Vp(i, e) {
  return i[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), i[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), i;
}
function Gp(i, e) {
  const n = Math.cos(dl(e)), s = Math.sin(dl(e));
  return i[0] = e[4] + n * e[2] * -e[4] - s * e[3] * -e[5], i[1] = e[5] + s * e[2] * -e[4] + n * e[3] * -e[5], i;
}
function $_(i, e) {
  let s = i[0], r = i[1], a = i[2], o = i[3], h = i[4], c = i[5], l = e.origin.x, u = e.origin.y, f = e.pivot.x, d = e.pivot.y, p = Math.hypot(s, r), y = Math.hypot(a, o);
  p < 1e-6 && (p = 0), y < 1e-6 && (y = 0), s * o - r * a < 0 && (p > y ? (y *= -1, a *= -1, o *= -1) : (p *= -1, s *= -1, r *= -1));
  let g = Math.atan2(r, s), m = 0, v = 0;
  if (p > 1e-6 && y > 1e-6) {
    const A = s / p, M = r / p, _ = a / y, T = o / y;
    m = Math.atan(A * _ + M * T), v = Math.atan(A * M + _ * T);
  }
  const w = s * (f + l) + a * (d + u), b = r * (f + l) + o * (d + u), S = h + w - l, E = c + b - u;
  e.position.setXY(S, E), e.skew.set(m, v), e.scale.set(p, y), e.rotation = g;
}
function V_(i) {
  const e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], h = a, c = o;
  let l = Math.sqrt(e * e + n * n), u = Math.sqrt(s * s + r * r), f = Math.atan2(n, e);
  return e * r - n * s < 0 && (l > u ? u = -u : l = -l), {
    position: { x: h, y: c },
    rotation: f,
    scale: { x: l, y: u }
  };
}
function Nh(i, e, n) {
  const s = e[0], r = e[1], a = e[2], o = e[3], h = e[4], c = e[5], l = n[0], u = n[1], f = n[2], d = n[3], p = n[4], y = n[5];
  return i[0] = s * l + a * u, i[1] = r * l + o * u, i[2] = s * f + a * d, i[3] = r * f + o * d, i[4] = s * p + a * y + h, i[5] = r * p + o * y + c, i;
}
function Up(i, e) {
  const n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = n * a - s * r;
  if (!c)
    return null;
  const l = 1 / c;
  return i[0] = a * l, i[1] = -s * l, i[2] = -r * l, i[3] = n * l, i[4] = (r * h - a * o) * l, i[5] = (s * o - n * h) * l, i;
}
function $f(i, e, n) {
  const s = n[0], r = n[1];
  return i[0] = e[0] * s + e[2] * r + e[4], i[1] = e[1] * s + e[3] * r + e[5], i;
}
function Wp(i, e, n) {
  for (let s = 0; s < n.length; s += 2)
    $f(i[s], e, n[s]);
  return i;
}
function Yp(i) {
  return i[0] === 1 && i[1] === 0 && i[2] === 0 && i[3] === 1 && i[4] === 0 && i[5] === 0;
}
function G_(i) {
  return i[4] !== 0 || i[5] !== 0;
}
function jp(i) {
  return i[0] !== 1 || i[1] !== 0 || i[2] !== 0 || i[3] !== 1;
}
function Hp(i) {
  return i[0] !== 1 || i[3] !== 1;
}
class Pe extends Float32Array {
  static IENTITY_MATRIX = new Pe();
  static default() {
    return new this();
  }
  // 列主序
  static fromColumns(e, n, s, r, a, o) {
    return Cu(new this(), e, n, s, r, a, o);
  }
  static fromRows(e, n, s, r, a, o) {
    return Cu(new this(), e, r, n, a, s, o);
  }
  static fromMatrix2D(e) {
    const n = this.default();
    return n.set(e), n;
  }
  static fromSinCos(e, n) {
    return this.fromRows(n, e, -e, n, 0, 0);
  }
  static fromScale(e, n) {
    return this.fromRows(e, 0, 0, n, 0, 0);
  }
  static fromTranslate(e, n) {
    return this.fromRows(1, 0, e, 1, n, 0);
  }
  static fromRotation(e) {
    return this.fromSinCos(Math.sin(e), Math.cos(e));
  }
  static fromAngle(e) {
    return this.fromRotation(e * Math.PI / 180);
  }
  static identity = Au;
  static multiply = Nh;
  static invert = Up;
  static translate = kp;
  static scale = Fp;
  static rotation = Lp;
  static makeTranslation = Np;
  static makeRotation = Bp;
  static makeScale = Dp;
  static makeTranslationRotationScale = qp;
  static makeTranslationRotationScaleOrigin = F_;
  static makeTranslationSkewRotationScaleOrigin = N_;
  static makeTranslationRotationScaleOriginPivot = B_;
  static makeTranslationSkewRotationScaleOriginPivot = D_;
  static extractTranslation = $p;
  static extractRotation = dl;
  static extractScale = Vp;
  static extractOrigin = Gp;
  static decomposeTKRSPO = $_;
  static decompose = V_;
  static mapPoint = $f;
  static mapPoints = Wp;
  static hasTranslation = G_;
  static hasRotation = jp;
  static hasScale = Hp;
  static hasIdentity = Yp;
  constructor() {
    super(6), Au(this);
  }
  get a() {
    return this[0];
  }
  set a(e) {
    this[0] = e;
  }
  get b() {
    return this[1];
  }
  set b(e) {
    this[1] = e;
  }
  get c() {
    return this[2];
  }
  set c(e) {
    this[2] = e;
  }
  get d() {
    return this[3];
  }
  set d(e) {
    this[3] = e;
  }
  get e() {
    return this[4];
  }
  set e(e) {
    this[4] = e;
  }
  get f() {
    return this[5];
  }
  set f(e) {
    this[5] = e;
  }
  get tx() {
    return this[4];
  }
  set tx(e) {
    this[4] = e;
  }
  get ty() {
    return this[5];
  }
  set ty(e) {
    this[5] = e;
  }
  copy(e) {
    return Cu(this, e[0], e[1], e[2], e[3], e[4], e[5]), this;
  }
  clone() {
    return this.constructor.default().copy(this);
  }
  identity() {
    return Au(this);
  }
  multiplyMatrices(e, n) {
    return Nh(this, e, n);
  }
  premultiply(e) {
    return Nh(this, e, this);
  }
  multiply(e) {
    return Nh(this, this, e);
  }
  invert() {
    return Up(this, this);
  }
  translate(e) {
    return kp(this, this, e);
  }
  rotate(e) {
    return Lp(this, this, e);
  }
  scale(e) {
    return Fp(this, this, e);
  }
  makeTranslation(e) {
    return Np(this, e);
  }
  makeRotation(e) {
    return Bp(this, e);
  }
  makeScale(e) {
    return Dp(this, e);
  }
  makeSkew(e) {
    return L_(this, e);
  }
  makeTRS(e, n, s) {
    return qp(this, e, n, s);
  }
  makeTKRSOP(e, n, s, r, a, o) {
    return q_(this, e, n, s, r, a, o);
  }
  extractTranslation(e) {
    return $p(e, this);
  }
  extractRotation() {
    return dl(this);
  }
  extractScale(e) {
    return Vp(e, this);
  }
  extractOrigin(e) {
    return Gp(e, this);
  }
  preScale(e, n) {
    return this.multiplyMatrices(this, Pe.fromScale(e, n));
  }
  postScale(e, n) {
    return this.multiplyMatrices(Pe.fromScale(e, n), this);
  }
  preRotate(e) {
    return this.multiplyMatrices(this, Pe.fromRotation(e));
  }
  preRotateDegrees(e) {
    return this.preRotate(e * Math.PI / 180);
  }
  postRotate(e) {
    return this.multiplyMatrices(Pe.fromRotation(e), this);
  }
  postRotateDegrees(e) {
    return this.postRotate(e * Math.PI / 180);
  }
  preTranslate(e, n) {
    return this.multiplyMatrices(this, Pe.fromTranslate(e, n));
  }
  postTranslate(e, n) {
    return this.multiplyMatrices(Pe.fromTranslate(e, n), this);
  }
  mapPoint(e, n = e) {
    return $f(n, this, e);
  }
  mapPoints(e, n = e) {
    return Wp(n, this, e);
  }
  hasIdentity() {
    return Yp(this);
  }
  hasRotation() {
    return jp(this);
  }
  hasScale() {
    return Hp(this);
  }
  decompose(e) {
    const n = this.a, s = this.b, r = this.c, a = this.d, o = e.pivot, h = -Math.atan2(-r, a), c = Math.atan2(s, n), l = Math.abs(h + c);
    l < 1e-5 || Math.abs(k_ - l) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = h, e.skew.y = c), e.scale.x = Math.sqrt(n * n + s * s), e.scale.y = Math.sqrt(r * r + a * a);
    const u = o.x + e.origin.x, f = o.y + e.origin.y;
    return e.position.x = this.tx + (u * n + f * r) - e.origin.x, e.position.y = this.ty + (u * s + f * a) - e.origin.y, e;
  }
  toMatrix3x3(e = !0) {
    return e ? new Float32Array([
      this.a,
      this.b,
      0,
      this.c,
      this.d,
      0,
      this.tx,
      this.ty,
      1
    ]) : new Float32Array([
      this.a,
      this.c,
      this.tx,
      this.b,
      this.d,
      this.ty,
      0,
      0,
      1
    ]);
  }
}
function Pu(i) {
  return i[0] = 1, i[3] = 0, i[6] = 0, i[1] = 0, i[4] = 1, i[7] = 0, i[2] = 0, i[5] = 0, i[8] = 1, i;
}
function Bh(i, e, n) {
  const s = e[0], r = e[3], a = e[6], o = e[1], h = e[4], c = e[7], l = e[2], u = e[5], f = e[8], d = n[0], p = n[3], y = n[6], x = n[1], g = n[4], m = n[7], v = n[2], w = n[5], b = n[8];
  return i[0] = s * d + r * x + a * v, i[1] = o * d + h * x + c * v, i[2] = l * y + u * x + f * v, i[3] = s * p + r * g + a * w, i[4] = o * p + h * g + c * w, i[5] = l * p + u * g + f * w, i[6] = s * y + r * m + a * b, i[7] = o * y + h * m + c * b, i[8] = l * y + u * m + f * b, i;
}
function U_(i, e, n) {
  const s = e[0], r = e[3], a = e[6], o = e[1], h = e[4], c = e[7], l = e[2], u = e[5], f = e[8];
  return i[0] = s, i[1] = o, i[2] = l, i[3] = r, i[4] = h, i[5] = u, i[6] = s * n[0] + r * n[1] + a, i[7] = o * n[0] + h * n[1] + c, i[8] = f, i;
}
function W_(i, e, n) {
  const s = Math.sin(n), r = Math.cos(n), a = e[0], o = e[3], h = e[6], c = e[1], l = e[4], u = e[7], f = e[2], d = e[5], p = e[8];
  return i[0] = a * r + o * s, i[1] = c * r + l * s, i[2] = f * r + d * s, i[3] = a * -s + o * r, i[4] = c * -s + l * r, i[5] = f * -s + d * r, i[6] = h, i[7] = u, i[8] = p, i;
}
function Y_(i, e, n) {
  const s = n[0], r = n[1], a = e[0], o = e[3], h = e[6], c = e[1], l = e[4], u = e[7], f = e[2], d = e[5], p = e[8];
  return i[0] = a * s, i[1] = c * s, i[2] = f * s, i[3] = o * r, i[4] = l * r, i[5] = d * r, i[6] = h, i[7] = u, i[8] = p, i;
}
function Xp(i, e) {
  return i[0] = 1, i[3] = 0, i[6] = e[0], i[1] = 0, i[4] = 1, i[7] = e[1], i[2] = 0, i[5] = 0, i[8] = 1, i;
}
function Zp(i, e) {
  const n = Math.sin(e), s = Math.cos(e);
  return i[0] = s, i[3] = -n, i[6] = 0, i[1] = n, i[4] = s, i[7] = 0, i[2] = 0, i[5] = 0, i[8] = 1, i;
}
function Jp(i, e) {
  return i[0] = e[0], i[3] = 0, i[6] = 0, i[1] = 0, i[4] = e[1], i[7] = 0, i[2] = 0, i[5] = 0, i[8] = 1, i;
}
function Qp(i, e) {
  return i[0] = 1, i[3] = Math.tan(e[0]), i[6] = 0, i[1] = Math.tan(e[1]), i[4] = 1, i[7] = 0, i[2] = 0, i[5] = 0, i[8] = 1, i;
}
function j_(i, e, n) {
  return i[0] = 2 / e, i[3] = 0, i[6] = -1, i[1] = 0, i[4] = -2 / n, i[7] = 1, i[2] = 0, i[5] = 0, i[8] = 1, i;
}
function Kp(i, e, n, s) {
  const r = Math.sin(n), a = Math.cos(n);
  return i[0] = s[0] * a, i[3] = s[1] * -r, i[6] = e[0], i[1] = s[0] * r, i[4] = s[1] * a, i[7] = e[1], i[2] = 0, i[5] = 0, i[8] = 1, i;
}
function H_(i, e, n, s, r) {
  const a = Math.cos(n), o = Math.sin(n), h = s[0], c = s[1], l = e[0] + r[0], u = e[1] + r[1];
  return i[0] = a * h, i[1] = o * h, i[2] = 0, i[3] = -o * c, i[4] = a * c, i[5] = 0, i[6] = l - (r[0] * i[0] + r[1] * i[3]), i[7] = u - (r[0] * i[1] + r[1] * i[4]), i[8] = 1, i;
}
function X_(i, e, n, s, r, a) {
  const o = Math.cos(n), h = Math.sin(n), c = s[0], l = s[1], u = e[0] + r[0], f = e[1] + r[1], d = a[0] + r[0], p = a[1] + r[1];
  return i[0] = o * c, i[1] = h * c, i[2] = 0, i[3] = -h * l, i[4] = o * l, i[5] = 0, i[6] = u - (d * i[0] + p * i[3]), i[7] = f - (d * i[1] + p * i[4]), i[8] = 1, i;
}
function Z_(i, e, n, s, r, a, o) {
  const h = Math.cos(s), c = Math.sin(s), l = r[0], u = r[1], f = Math.tan(n[0]), d = Math.tan(n[1]), p = e[0] + a[0], y = e[1] + a[1], x = o[0] + a[0], g = o[1] + a[1];
  return i[0] = (h + f * c) * l, i[1] = (d * c + h) * l, i[2] = 0, i[3] = (-c + f * h) * u, i[4] = (d * -c + h) * u, i[5] = 0, i[6] = p - (x * i[0] + g * i[3]), i[7] = y - (x * i[1] + g * i[4]), i[8] = 1, i;
}
function J_(i, e) {
  return i[0] = e[6], i[1] = e[7], i;
}
function Q_(i) {
  return Math.atan2(i[3], i[0]);
}
function K_(i, e) {
  return i[0] = Math.sqrt(e[0] * e[0] + e[3] * e[3]), i[1] = Math.sqrt(e[1] * e[1] + e[4] * e[4]), i;
}
function t3(i, e) {
  const n = e[0], s = e[3], r = e[6], a = e[1], o = e[4], h = e[7], c = e[2], l = e[5], u = e[8];
  let f = n, d = s, p = r, y = a, x = o, g = h, m = c, v = l, w = u, b = 0, S = 0;
  return Math.abs(f) >= Math.abs(y) && Math.abs(f) >= Math.abs(m) ? (S = 1 / f, f *= S, d *= S, p *= S, y *= S, x *= S, g *= S, m *= S, v *= S, w *= S, b = f, f = 1, y -= d, x -= d, g -= d, m -= p, v -= p, w -= p) : Math.abs(y) >= Math.abs(f) && Math.abs(y) >= Math.abs(m) ? (S = 1 / y, f *= S, d *= S, p *= S, y *= S, x *= S, g *= S, m *= S, v *= S, w *= S, b = -y, y = 0, d -= x, p -= g, v -= g, w -= g) : (S = 1 / m, f *= S, d *= S, p *= S, y *= S, x *= S, g *= S, m *= S, v *= S, w *= S, b = m, m = 0, p -= v, d -= v, g -= v, x -= v), i[0] = f, i[3] = d, i[6] = p, i[1] = y, i[4] = x, i[7] = g, i[2] = m, i[5] = v, i[8] = w, b;
}
function ty(i, e) {
  const n = e[0], s = e[3], r = e[6], a = e[1], o = e[4], h = e[7], c = e[2], l = e[5], u = e[8];
  return i[0] = o * u - h * l, i[3] = -a * u + h * c, i[6] = a * l - o * c, i[1] = -s * u + r * l, i[4] = n * u - r * c, i[7] = -n * l + s * c, i[2] = s * h - r * o, i[5] = -n * h + r * a, i[8] = n * o - s * a, i;
}
function ey(i) {
  const e = i[0], n = i[3], s = i[6], r = i[1], a = i[4], o = i[7], h = i[2], c = i[5], l = i[8];
  return e * (a * l - c * o) - n * (r * l - o * h) + s * (r * c - a * h);
}
function ny(i, e) {
  const n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = u * o - h * l, d = -u * a + h * c, p = l * a - o * c;
  let y = n * f + s * d + r * p;
  return y ? (y = 1 / y, i[0] = f * y, i[1] = (-u * s + r * l) * y, i[2] = (h * s - r * o) * y, i[3] = d * y, i[4] = (u * n - r * c) * y, i[5] = (-h * n + r * a) * y, i[6] = p * y, i[7] = (-l * n + s * c) * y, i[8] = (o * n - s * a) * y, i) : null;
}
function iy(i, e) {
  const n = e[0], s = e[3], r = e[6], a = e[1], o = e[4], h = e[7], c = e[2], l = e[5], u = e[8];
  i[0] = n, i[1] = a, i[2] = c, i[3] = s, i[4] = o, i[5] = l, i[6] = r, i[7] = h, i[8] = u;
}
function e3(i) {
  return i[6] !== 0 || i[7] !== 0 || i[8] !== 1;
}
function n3(i) {
  return i[0] !== 1 || i[3] !== 0 || i[6] !== 0 || i[1] !== 0 || i[4] !== 1 || i[7] !== 0 || i[2] !== 0 || i[5] !== 0 || i[8] !== 1;
}
function i3(i) {
  return i[0] !== 1 || i[3] !== 0 || i[6] !== 0 || i[1] !== 0 || i[4] !== 1 || i[7] !== 0 || i[2] !== 0 || i[5] !== 0 || i[8] !== 1;
}
function s3(i) {
  return i[0] !== 1 || i[3] !== 0 || i[6] !== 0 || i[1] !== 0 || i[4] !== 1 || i[7] !== 0 || i[2] !== 0 || i[5] !== 0 || i[8] !== 1;
}
function r3(i, e, n, s, r, a, o, h, c, l) {
  return i[0] = e, i[3] = n, i[6] = s, i[1] = r, i[4] = a, i[7] = o, i[2] = h, i[5] = c, i[8] = l, i;
}
function Vf(i, e, n) {
  let s = n[0], r = n[1];
  return i[0] = e[0] * s + e[3] * r + e[6], i[1] = e[1] * s + e[4] * r + e[7], i;
}
function sy(i, e, n) {
  for (let s = 0; s < n.length; s += 2)
    Vf(i[s], e, n[s]);
  return i;
}
function ry(i, e, n) {
  let s = 2 / e, r = -2 / n;
  return i[0] = s, i[3] = 0, i[6] = -1, i[1] = 0, i[4] = r, i[7] = 1, i[2] = 0, i[5] = 0, i[8] = 1, i;
}
let a3 = class extends Float32Array {
  static default() {
    return new this();
  }
  static identity = Pu;
  static multiply = Bh;
  static invert = ny;
  static makeProjection = j_;
  static makeTranslation = Xp;
  static makeRotation = Zp;
  static makeScale = Jp;
  static makeTranslationRotationScale = Kp;
  static makeTranslationRotationScaleOrigin = H_;
  static makeTranslationRotationScaleOriginPivot = X_;
  static makeTranslationSkewRotationScaleOriginPivot = Z_;
  static extractTranslation = J_;
  static extractRotation = Q_;
  static extractScale = K_;
  //static extractOrigin=extractOrigin
  static decompose = t3;
  static adjugate = ty;
  static determinant = ey;
  static transpose = iy;
  static fromValues = r3;
  static makeSkew = Qp;
  static mapPoint = Vf;
  static mapPoints = sy;
  static projection = ry;
  constructor() {
    super(9), Pu(this);
  }
  identity() {
    return Pu(this);
  }
  multiplyMatrices(e, n) {
    return Bh(this, e, n);
  }
  premultiply(e) {
    return Bh(this, e, this);
  }
  multiply(e) {
    return Bh(this, this, e);
  }
  translate(e) {
    return U_(this, this, e);
  }
  rotate(e) {
    return W_(this, this, e);
  }
  scale(e) {
    return Y_(this, this, e);
  }
  makeTranslation(e) {
    return Xp(this, e);
  }
  makeRotation(e) {
    return Zp(this, e);
  }
  makeScale(e) {
    return Jp(this, e);
  }
  makeSkew(e) {
    return Qp(this, e);
  }
  // makeTranslationRotationScale(v: Vector2Like, radian: number, scale: Vector2Like) {
  //     return makeTranslationRotationScale(this, v, radian, scale);
  // }
  // makeTranslationRotationScaleOrigin(v: Vector2Like, radian: number, scale: Vector2Like, origin: Vector2Like) {
  //     return makeTranslationRotationScaleOrigin(this, v, radian, scale, origin);
  // }
  // makeTranslationRotationScaleOriginPivot(v: Vector2Like, radian: number, scale: Vector2Like, origin: Vector2Like, pivot: Vector2Like) {
  //     return makeTranslationRotationScaleOriginPivot(this, v, radian, scale, origin, pivot);
  // }
  // makeTranslationSkewRotationScaleOriginPivot(v: Vector2Like, skew: Vector2Like, radian: number, scale: Vector2Like, origin: Vector2Like, pivot: Vector2Like) {
  //     return makeTranslationSkewRotationScaleOriginPivot(this, v, skew, radian, scale, origin, pivot);
  // }
  makeTRS(e, n, s) {
    return Kp(this, e, n, s);
  }
  adjugate() {
    return ty(this, this);
  }
  determinant() {
    return ey(this);
  }
  invert() {
    return ny(this, this);
  }
  transpose() {
    return iy(this, this);
  }
  hasTranslation() {
    return e3(this);
  }
  hasRotation() {
    return n3(this);
  }
  hasScale() {
    return i3(this);
  }
  hasIdentity() {
    return s3(this);
  }
  mapPoint(e, n = e) {
    return Vf(n, this, e);
  }
  mapPoints(e, n = e) {
    return sy(n, this, e);
  }
  projection(e, n) {
    return ry(this, e, n);
  }
}, ea = class extends Float32Array {
  static create(e, n) {
    return new this(e, n);
  }
  constructor(e, n) {
    super(2), this[0] = e, this[1] = n;
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  set x(e) {
    this[0] !== e && (this[0] = e, this._change(this));
  }
  set y(e) {
    this[1] !== e && (this[1] = e, this._change(this));
  }
  _change(e) {
  }
  onChange(e) {
    this._change = e;
  }
  copy(e) {
    this.setXY(e[0], e[1]);
  }
  setXY(e, n) {
    (this[0] !== e || this[1] !== n) && (this[0] = e, this[1] = n, this._change(this));
  }
  set(e, n) {
    this.setXY(e, n);
  }
};
class o3 {
  position = ea.create(0, 0);
  _rotation = 0;
  _cx = 1;
  _sx = 0;
  _cy = 0;
  _sy = 1;
  skew = ea.create(0, 0);
  // 斜切
  scale = ea.create(1, 1);
  // 缩放向量
  origin = ea.create(0, 0);
  // 图形的变换原点
  pivot = ea.create(0, 0);
  // 图形的轴点
  _matrix = Pe.default();
  // 本地矩阵
  _matrixWorld = Pe.default();
  // 世界矩阵
  localMatrixDirty = !1;
  // 本地矩阵是否需要更新
  worldMatrixId = 0;
  // 当前世界矩阵每次更新的自增ID
  parentWorldMatrixId = 0;
  // 父级世界矩阵ID，相同代表不需要更新
  parent = null;
  children = null;
  constructor(e) {
    this.position.onChange(this.onUpdateTransformable), this.scale.onChange(this.onUpdateTransformable), this.origin.onChange(this.onUpdateTransformable), this.pivot.onChange(this.onUpdateTransformable), this.skew.onChange(this.onUpdateTransformable), this.setTransformWithOptions(e);
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation !== e && (this._rotation = e, this.onUpdateTransformable(this.skew));
  }
  get angle() {
    return this._rotation / Math.PI * 180;
  }
  set angle(e) {
    this.rotation = e / 180 * Math.PI;
  }
  // 递归计算父级世界矩阵是否变化
  get hasWorldMatrixDirty() {
    return this.parent ? this.parentWorldMatrixId === -1 || this.parentWorldMatrixId !== this.parent.worldMatrixId || this.parent.hasWorldMatrixDirty : this.parentWorldMatrixId === -1;
  }
  get matrix() {
    return this.updateMatrix(), this._matrix;
  }
  get worldMatrix() {
    return this.updateWorldMatrix(), this._matrixWorld;
  }
  setTransformWithOptions(e) {
    e && (e.position && this.position.setXY(e.position.x, e.position.y), e.rotation !== void 0 && (this.rotation = e.rotation), e.angle !== void 0 && (this.angle = e.angle), e.scale && this.scale.setXY(e.scale.x, e.scale.y), e.origin && this.origin.setXY(e.origin.x, e.origin.y), e.pivot && this.pivot.setXY(e.pivot.x, e.pivot.y), e.skew && this.skew.setXY(e.skew.x, e.skew.y));
  }
  setTransformFromMatrix(e) {
    e.decompose(this), this.onUpdateTransformable();
  }
  // 更新局部矩阵，但不更新世界矩阵
  updateMatrix() {
    if (!this.localMatrixDirty)
      return;
    this.localMatrixDirty = !1;
    const e = this.position.x, n = this.position.y, s = this.pivot.x, r = this.pivot.y, a = -this.origin.x, o = -this.origin.y, h = this.scale.x, c = this.scale.y, l = this._matrix;
    l.a = this._cx * h, l.b = this._sx * h, l.c = this._cy * c, l.d = this._sy * c, l.tx = e - (s * l.a + r * l.c) + (a * l.a + o * l.c) - a, l.ty = n - (s * l.b + r * l.d) + (a * l.b + o * l.d) - o;
  }
  updateWorldMatrix() {
    this.hasWorldMatrixDirty && (this.parent ? (this._matrixWorld.multiplyMatrices(this.parent.worldMatrix, this.matrix), this.parentWorldMatrixId = this.parent.worldMatrixId) : (this._matrixWorld.copy(this.matrix), this.parentWorldMatrixId = 0), this.worldMatrixId += 1);
  }
  onUpdateTransformable = (e) => {
    e === this.skew && this._updateSkew(), this.localMatrixDirty = !0, this.parentWorldMatrixId = -1, this.onTransformChange();
  };
  _updateSkew() {
    const e = this._rotation, n = this.skew;
    this._cx = Math.cos(e + n.y), this._sx = Math.sin(e + n.y), this._cy = -Math.sin(e - n.x), this._sy = Math.cos(e - n.x);
  }
  onTransformChange() {
  }
}
let gr = class $g {
  static empty() {
    return this.fromLTRB(0, 0, 0, 0);
  }
  static default() {
    return new this();
  }
  static fromXYWH(e, n, s, r) {
    return this.fromLTRB(e, n, e + s, n + r);
  }
  static fromLTRB(e, n, s, r) {
    return new this(N.create(e, n), N.create(s, r));
  }
  min;
  max;
  constructor(e = N.create(1 / 0, 1 / 0), n = N.create(-1 / 0, -1 / 0)) {
    this.min = e, this.max = n;
  }
  get left() {
    return this.min.x;
  }
  get top() {
    return this.min.y;
  }
  get right() {
    return this.max.x;
  }
  get bottom() {
    return this.max.y;
  }
  get x() {
    return this.min.x;
  }
  get y() {
    return this.min.y;
  }
  get width() {
    return this.max.x - this.min.x;
  }
  get height() {
    return this.max.y - this.min.y;
  }
  get cx() {
    return this.left * 0.5 + this.right * 0.5;
  }
  get cy() {
    return this.top * 0.5 + this.bottom * 0.5;
  }
  get center() {
    return N.create(this.cx, this.cy);
  }
  isEmpty() {
    return this.min.x > this.max.x || this.min.y > this.max.y;
  }
  clone() {
    return new $g().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  makeZero() {
    return this.min.x = this.min.y = 0, this.max.x = this.max.y = 0, this;
  }
  setViewport(e, n, s, r) {
    return this.min.set(e, n), this.max.set(e + s, n + r), this;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  fromCircle(e, n, s) {
    return this.min.set(e - s, n - s), this.max.set(e + s, n + s), this;
  }
  fromLine(e, n, s, r, a) {
    const o = s - e, h = r - n, c = Math.sqrt(o * o + h * h);
    if (c === 0) {
      this.makeZero();
      return;
    }
    const l = o / c, f = -(h / c), d = l, p = f * a / 2, y = d * a / 2, x = [
      { x: e - p, y: n - y },
      // 起点左侧
      { x: e + p, y: n + y },
      // 起点右侧
      { x: s - p, y: r - y },
      // 终点左侧
      { x: s + p, y: r + y }
      // 终点右侧
    ];
    return this.setFromPoints(x), this;
  }
  fromRect(e, n, s, r) {
    return this.min.set(e, n), this.max.set(e + s, n + r), this;
  }
  setFromVertices(e) {
    this.makeEmpty();
    for (let n = 0, s = e.length; n < s; n += 2)
      this.expandByXY(e[n], e[n + 1]);
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, s = e.length; n < s; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  expandByStrokeWidth(e) {
    let n = e * 0.5;
    return this.min.translate(-n, -n), this.max.translate(n, n), this;
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByXY(e, n) {
    return this.min.set(Math.min(this.min.x, e), Math.min(this.min.y, n)), this.max.set(Math.max(this.max.x, e), Math.max(this.max.y, n)), this;
  }
  // isEmpty() {
  //     return !(this.left < this.right && this.top < this.bottom);
  // }
  isValid() {
    return this.isFinite() && this.left <= this.right && this.top <= this.bottom;
  }
  isZero() {
    return this.width === 0 || this.height === 0;
  }
  isFinite() {
    return this.isEmpty();
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  translate(e, n) {
    this.min.translate(e, n), this.max.translate(e, n);
  }
  inset(e, n) {
    this.min.translate(e, n), this.max.translate(-e, -n);
  }
  outset(e, n) {
    this.inset(-e, -n);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  containsXY(e, n) {
    return !(e < this.left || e > this.right || n < this.top || n > this.bottom);
  }
  containsPoint(e) {
    return this.containsXY(e.x, e.y);
  }
  containsBox(e) {
    return !(e.min.x < this.min.x || e.max.x > this.max.x || e.min.y < this.min.y || e.max.y > this.max.y);
  }
  intersectBox3(e, n) {
    if (!e)
      return !1;
    const s = this, r = s.left, a = s.right, o = s.top, h = s.bottom, c = e.left, l = e.right, u = e.top, f = e.bottom, d = N.default(), p = N.default();
    let y = !(a < c || l < r || h < u || f < o);
    if (n) {
      let x = 1 / 0, g = 0;
      const m = Math.abs(a - c), v = Math.abs(l - r), w = Math.abs(h - u), b = Math.abs(f - o), S = Math.min(m, v), E = Math.min(w, b);
      a < c || l < r ? S > g && (g = S, m < v ? d.set(-m, 0) : d.set(v, 0)) : S < x && (x = S, m < v ? p.set(m, 0) : p.set(-v, 0)), h < u || f < o ? E > g && (g = E, w < b ? d.set(0, -w) : d.set(0, b)) : S < x && (x = S, w < b ? p.set(0, w) : p.set(0, -b));
    }
    return n && n.copy(y ? p : d), y;
  }
  intersectionBox(e) {
    return !(this.left > e.right || this.right < e.left || this.top > e.bottom || this.bottom < e.top);
  }
  // intersectionBox2(box:BoundingRect) {
  //     return (box.min.x >= this.min.x && box.min.x <= this.max.x || box.max.x >= this.min.x && box.max.x <= this.max.x) && (box.min.y >= this.min.y && box.min.y <= this.max.y || box.max.y >= this.min.y && box.max.y <= this.max.y)
  // }
  applyMatrix(e) {
    if (e.hasIdentity())
      return;
    const n = N.create(this.left, this.top), s = N.create(this.right, this.top), r = N.create(this.left, this.bottom), a = N.create(this.right, this.bottom);
    n.applyMatrix2D(e), s.applyMatrix2D(e), r.applyMatrix2D(e), a.applyMatrix2D(e), this.makeEmpty(), this.expandByPoint(n), this.expandByPoint(s), this.expandByPoint(r), this.expandByPoint(a);
  }
  getObjectBoundingBox(e) {
    if (e.hasIdentity())
      return;
    const n = N.create(this.left, this.top), s = N.create(this.right, this.top), r = N.create(this.left, this.bottom), a = N.create(this.right, this.bottom);
    return n.applyMatrix2D(e), s.applyMatrix2D(e), r.applyMatrix2D(e), a.applyMatrix2D(e), [n, s, a, r];
  }
};
const h3 = Math.PI * 2;
let Mn = class Vg {
  /**
   * Position of the point on the x axis
   * @example
   * ```ts
   * // Set x position
   * const point = new Point();
   * point.x = 100;
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   */
  x = 0;
  /**
   * Position of the point on the y axis
   * @example
   * ```ts
   * // Set y position
   * const point = new Point();
   * point.y = 200;
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   */
  y = 0;
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e = 0, n = 0) {
    this.x = e, this.y = n;
  }
  /**
   * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
   * @example
   * ```ts
   * // Basic point cloning
   * const original = new Point(100, 200);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.set(300, 400);
   *
   * // Verify independence
   * console.log(original); // Point(100, 200)
   * console.log(modified); // Point(300, 400)
   * ```
   * @remarks
   * - Creates new Point instance
   * - Deep copies x and y values
   * - Independent from original
   * - Useful for preserving values
   * @returns A clone of this point
   * @see {@link Point.copyFrom} For copying into existing point
   * @see {@link Point.copyTo} For copying to existing point
   */
  clone() {
    return new Vg(this.x, this.y);
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new Point()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link Point.copyTo} For copying to another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyFrom(e) {
    return this.set(e.x, e.y), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyTo(e) {
    return e.set(this.x, this.y), e;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new Point(100, 200);
   * const p2 = new Point(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new Point(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link Point.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new Point();
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   *
   * // Chain with other operations
   * point
   *     .set(10, 20)
   *     .copyTo(otherPoint);
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.equals} For comparing positions
   */
  set(e = 0, n = e) {
    return this.x = e, this.y = n, this;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  // #endif
  /**
   * A static Point object with `x` and `y` values of `0`.
   *
   * This shared instance is reset to zero values when accessed.
   *
   * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempPoint = Point.shared;
   * tempPoint.set(100, 200);
   * matrix.apply(tempPoint);
   *
   * // Will be reset to (0,0) on next access
   * const fresh = Point.shared; // x=0, y=0
   * ```
   * @readonly
   * @returns A fresh zeroed point for temporary use
   * @see {@link Point.constructor} For creating new points
   * @see {@link PointData} For basic point interface
   */
  static get shared() {
    return Iu.x = 0, Iu.y = 0, Iu;
  }
};
const Iu = new Mn();
let Hl = class Gg {
  /**
   * Scale on the x axis.
   * @default 1
   */
  a;
  /**
   * Shear on the y axis.
   * @default 0
   */
  b;
  /**
   * Shear on the x axis.
   * @default 0
   */
  c;
  /**
   * Scale on the y axis.
   * @default 1
   */
  d;
  /**
   * Translation on the x axis.
   * @default 0
   */
  tx;
  /**
   * Translation on the y axis.
   * @default 0
   */
  ty;
  /**
   * Array representation of the matrix.
   * Only populated when `toArray()` is called.
   * @default null
   * @see {@link Matrix.toArray} For filling this array
   */
  array = null;
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(e = 1, n = 0, s = 0, r = 1, a = 0, o = 0) {
    this.a = e, this.b = n, this.c = s, this.d = r, this.tx = a, this.ty = o;
  }
  /**
   * Creates a Matrix object based on the given array.
   * Populates matrix components from a flat array in column-major order.
   *
   * > [!NOTE] Array mapping order:
   * > ```
   * > array[0] = a  (x scale)
   * > array[1] = b  (y skew)
   * > array[2] = tx (x translation)
   * > array[3] = c  (x skew)
   * > array[4] = d  (y scale)
   * > array[5] = ty (y translation)
   * > ```
   * @example
   * ```ts
   * // Create matrix from array
   * const matrix = new Matrix();
   * matrix.fromArray([
   *     2, 0,  100,  // a, b, tx
   *     0, 2,  100   // c, d, ty
   * ]);
   *
   * // Create matrix from typed array
   * const float32Array = new Float32Array([
   *     1, 0, 0,     // Scale x1, no skew
   *     0, 1, 0      // No skew, scale x1
   * ]);
   * matrix.fromArray(float32Array);
   * ```
   * @param array - The array to populate the matrix from
   * @see {@link Matrix.toArray} For converting matrix to array
   * @see {@link Matrix.set} For setting values directly
   */
  fromArray(e) {
    this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
  }
  /**
   * Sets the matrix properties directly.
   * All matrix components can be set in one call.
   * @example
   * ```ts
   * // Set to identity matrix
   * matrix.set(1, 0, 0, 1, 0, 0);
   *
   * // Set to scale matrix
   * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
   *
   * // Set to translation matrix
   * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
   * ```
   * @param a - Scale on x axis
   * @param b - Shear on y axis
   * @param c - Shear on x axis
   * @param d - Scale on y axis
   * @param tx - Translation on x axis
   * @param ty - Translation on y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.fromArray} For setting from array
   */
  set(e, n, s, r, a, o) {
    return this.a = e, this.b = n, this.c = s, this.d = r, this.tx = a, this.ty = o, this;
  }
  /**
   * Creates an array from the current Matrix object.
   *
   * > [!NOTE] The array format is:
   * > ```
   * > Non-transposed:
   * > [a, c, tx,
   * > b, d, ty,
   * > 0, 0, 1]
   * >
   * > Transposed:
   * > [a, b, 0,
   * > c, d, 0,
   * > tx,ty,1]
   * > ```
   * @example
   * ```ts
   * // Basic array conversion
   * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
   * const array = matrix.toArray();
   *
   * // Using existing array
   * const float32Array = new Float32Array(9);
   * matrix.toArray(false, float32Array);
   *
   * // Get transposed array
   * const transposed = matrix.toArray(true);
   * ```
   * @param transpose - Whether to transpose the matrix
   * @param out - Optional Float32Array to store the result
   * @returns The array containing the matrix values
   * @see {@link Matrix.fromArray} For creating matrix from array
   * @see {@link Matrix.array} For cached array storage
   */
  toArray(e, n) {
    this.array || (this.array = new Float32Array(9));
    const s = n || this.array;
    return e ? (s[0] = this.a, s[1] = this.b, s[2] = 0, s[3] = this.c, s[4] = this.d, s[5] = 0, s[6] = this.tx, s[7] = this.ty, s[8] = 1) : (s[0] = this.a, s[1] = this.c, s[2] = this.tx, s[3] = this.b, s[4] = this.d, s[5] = this.ty, s[6] = 0, s[7] = 0, s[8] = 1), s;
  }
  /**
   * Get a new position with the current transformation applied.
   *
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @example
   * ```ts
   * // Basic point transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const point = new Point(10, 20);
   * const transformed = matrix.apply(point);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.apply(point, output);
   * ```
   * @param pos - The origin point to transform
   * @param newPos - Optional point to store the result
   * @returns The transformed point
   * @see {@link Matrix.applyInverse} For inverse transformation
   * @see {@link Point} For point operations
   */
  apply(e, n) {
    n = n || new Mn();
    const s = e.x, r = e.y;
    return n.x = this.a * s + this.c * r + this.tx, n.y = this.b * s + this.d * r + this.ty, n;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   *
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @example
   * ```ts
   * // Basic inverse transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const worldPoint = new Point(150, 100);
   * const localPoint = matrix.applyInverse(worldPoint);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.applyInverse(worldPoint, output);
   *
   * // Convert mouse position to local space
   * const mousePoint = new Point(mouseX, mouseY);
   * const localMouse = matrix.applyInverse(mousePoint);
   * ```
   * @param pos - The origin point to inverse-transform
   * @param newPos - Optional point to store the result
   * @returns The inverse-transformed point
   * @see {@link Matrix.apply} For forward transformation
   * @see {@link Matrix.invert} For getting inverse matrix
   */
  applyInverse(e, n) {
    n = n || new Mn();
    const s = this.a, r = this.b, a = this.c, o = this.d, h = this.tx, c = this.ty, l = 1 / (s * o + a * -r), u = e.x, f = e.y;
    return n.x = o * l * u + -a * l * f + (c * a - h * o) * l, n.y = s * l * f + -r * l * u + (-c * s + h * r) * l, n;
  }
  /**
   * Translates the matrix on the x and y axes.
   * Adds to the position values while preserving scale, rotation and skew.
   * @example
   * ```ts
   * // Basic translation
   * const matrix = new Matrix();
   * matrix.translate(100, 50); // Move right 100, down 50
   *
   * // Chain with other transformations
   * matrix
   *     .scale(2, 2)
   *     .translate(100, 0)
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - How much to translate on the x axis
   * @param y - How much to translate on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.set} For setting position directly
   * @see {@link Matrix.setTransform} For complete transform setup
   */
  translate(e, n) {
    return this.tx += e, this.ty += n, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * Multiplies the scale values with existing matrix components.
   * @example
   * ```ts
   * // Basic scaling
   * const matrix = new Matrix();
   * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100)
   *     .scale(2, 2)     // Scales after translation
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting scale directly
   * @see {@link Matrix.append} For combining transformations
   */
  scale(e, n) {
    return this.a *= e, this.d *= n, this.c *= e, this.b *= n, this.tx *= e, this.ty *= n, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   *
   * Rotates around the origin (0,0) by the given angle in radians.
   * @example
   * ```ts
   * // Basic rotation
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100) // Move to rotation center
   *     .rotate(Math.PI)     // Rotate 180 degrees
   *     .scale(2, 2);        // Scale after rotation
   *
   * // Common angles
   * matrix.rotate(Math.PI / 2);  // 90 degrees
   * matrix.rotate(Math.PI);      // 180 degrees
   * matrix.rotate(Math.PI * 2);  // 360 degrees
   * ```
   * @remarks
   * - Rotates around origin point (0,0)
   * - Affects position if translation was set
   * - Uses counter-clockwise rotation
   * - Order of operations matters when chaining
   * @param angle - The angle in radians
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting rotation directly
   * @see {@link Matrix.append} For combining transformations
   */
  rotate(e) {
    const n = Math.cos(e), s = Math.sin(e), r = this.a, a = this.c, o = this.tx;
    return this.a = r * n - this.b * s, this.b = r * s + this.b * n, this.c = a * n - this.d * s, this.d = a * s + this.d * n, this.tx = o * n - this.ty * s, this.ty = o * s + this.ty * n, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = this * matrix
   * @example
   * ```ts
   * // Basic matrix combination
   * const matrix = new Matrix();
   * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
   * matrix.append(other);
   * ```
   * @remarks
   * - Order matters: A.append(B) !== B.append(A)
   * - Modifies current matrix
   * - Preserves transformation order
   * - Commonly used for combining transforms
   * @param matrix - The matrix to append
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.prepend} For prepending transformations
   * @see {@link Matrix.appendFrom} For appending two external matrices
   */
  append(e) {
    const n = this.a, s = this.b, r = this.c, a = this.d;
    return this.a = e.a * n + e.b * r, this.b = e.a * s + e.b * a, this.c = e.c * n + e.d * r, this.d = e.c * s + e.d * a, this.tx = e.tx * n + e.ty * r + this.tx, this.ty = e.tx * s + e.ty * a + this.ty, this;
  }
  /**
   * Appends two matrices and sets the result to this matrix.
   * Performs matrix multiplication: this = A * B
   * @example
   * ```ts
   * // Basic matrix multiplication
   * const result = new Matrix();
   * const matrixA = new Matrix().scale(2, 2);
   * const matrixB = new Matrix().rotate(Math.PI / 4);
   * result.appendFrom(matrixA, matrixB);
   * ```
   * @remarks
   * - Order matters: A * B !== B * A
   * - Creates a new transformation from two others
   * - More efficient than append() for multiple operations
   * - Does not modify input matrices
   * @param a - The first matrix to multiply
   * @param b - The second matrix to multiply
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For single matrix combination
   * @see {@link Matrix.prepend} For reverse order multiplication
   */
  appendFrom(e, n) {
    const s = e.a, r = e.b, a = e.c, o = e.d, h = e.tx, c = e.ty, l = n.a, u = n.b, f = n.c, d = n.d;
    return this.a = s * l + r * f, this.b = s * u + r * d, this.c = a * l + o * f, this.d = a * u + o * d, this.tx = h * l + c * f + n.tx, this.ty = h * u + c * d + n.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties.
   * Combines position, scale, rotation, skew and pivot in a single operation.
   * @example
   * ```ts
   * // Basic transform setup
   * const matrix = new Matrix();
   * matrix.setTransform(
   *     100, 100,    // position
   *     0, 0,        // pivot
   *     2, 2,        // scale
   *     Math.PI / 4, // rotation (45 degrees)
   *     0, 0         // skew
   * );
   * ```
   * @remarks
   * - Updates all matrix components at once
   * - More efficient than separate transform calls
   * - Uses radians for rotation and skew
   * - Pivot affects rotation center
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.decompose} For extracting transform properties
   * @see {@link TransformableObject} For transform data structure
   */
  setTransform(e, n, s, r, a, o, h, c, l) {
    return this.a = Math.cos(h + l) * a, this.b = Math.sin(h + l) * a, this.c = -Math.sin(h - c) * o, this.d = Math.cos(h - c) * o, this.tx = e - (s * this.a + r * this.c), this.ty = n - (s * this.b + r * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = matrix * this
   * @example
   * ```ts
   * // Basic matrix prepend
   * const matrix = new Matrix().scale(2, 2);
   * const other = new Matrix().translate(100, 0);
   * matrix.prepend(other); // Translation happens before scaling
   * ```
   * @remarks
   * - Order matters: A.prepend(B) !== B.prepend(A)
   * - Modifies current matrix
   * - Reverses transformation order compared to append()
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For appending transformations
   * @see {@link Matrix.appendFrom} For combining external matrices
   */
  prepend(e) {
    const n = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const s = this.a, r = this.c;
      this.a = s * e.a + this.b * e.c, this.b = s * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d;
    }
    return this.tx = n * e.a + this.ty * e.c + e.tx, this.ty = n * e.b + this.ty * e.d + e.ty, this;
  }
  /**
   * Decomposes the matrix into its individual transform components.
   * Extracts position, scale, rotation and skew values from the matrix.
   * @example
   * ```ts
   * // Basic decomposition
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * const transform = {
   *     position: new Point(),
   *     scale: new Point(),
   *     pivot: new Point(),
   *     skew: new Point(),
   *     rotation: 0
   * };
   *
   * matrix.decompose(transform);
   * console.log(transform.position); // Point(100, 100)
   * console.log(transform.rotation); // ~0.785 (PI/4)
   * console.log(transform.scale); // Point(2, 2)
   * ```
   * @remarks
   * - Handles combined transformations
   * - Accounts for pivot points
   * - Chooses between rotation/skew based on transform type
   * - Uses radians for rotation and skew
   * @param transform - The transform object to store the decomposed values
   * @returns The transform with the newly applied properties
   * @see {@link Matrix.setTransform} For composing from components
   * @see {@link TransformableObject} For transform structure
   */
  decompose(e) {
    const n = this.a, s = this.b, r = this.c, a = this.d, o = e.pivot, h = -Math.atan2(-r, a), c = Math.atan2(s, n), l = Math.abs(h + c);
    return l < 1e-5 || Math.abs(h3 - l) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = h, e.skew.y = c), e.scale.x = Math.sqrt(n * n + s * s), e.scale.y = Math.sqrt(r * r + a * a), e.position.x = this.tx + (o.x * n + o.y * r), e.position.y = this.ty + (o.x * s + o.y * a), e;
  }
  /**
   * Inverts this matrix.
   * Creates the matrix that when multiplied with this matrix results in an identity matrix.
   * @example
   * ```ts
   * // Basic matrix inversion
   * const matrix = new Matrix()
   *     .translate(100, 50)
   *     .scale(2, 2);
   *
   * matrix.invert(); // Now transforms in opposite direction
   *
   * // Verify inversion
   * const point = new Point(50, 50);
   * const transformed = matrix.apply(point);
   * const original = matrix.invert().apply(transformed);
   * // original ≈ point
   * ```
   * @remarks
   * - Modifies the current matrix
   * - Useful for reversing transformations
   * - Cannot invert matrices with zero determinant
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.applyInverse} For inverse transformations
   */
  invert() {
    const e = this.a, n = this.b, s = this.c, r = this.d, a = this.tx, o = e * r - n * s;
    return this.a = r / o, this.b = -n / o, this.c = -s / o, this.d = e / o, this.tx = (s * this.ty - r * a) / o, this.ty = -(e * this.ty - n * a) / o, this;
  }
  /**
   * Checks if this matrix is an identity matrix.
   *
   * An identity matrix has no transformations applied (default state).
   * @example
   * ```ts
   * // Check if matrix is identity
   * const matrix = new Matrix();
   * console.log(matrix.isIdentity()); // true
   *
   * // Check after transformations
   * matrix.translate(100, 0);
   * console.log(matrix.isIdentity()); // false
   *
   * // Reset and verify
   * matrix.identity();
   * console.log(matrix.isIdentity()); // true
   * ```
   * @remarks
   * - Verifies a = 1, d = 1 (no scale)
   * - Verifies b = 0, c = 0 (no skew)
   * - Verifies tx = 0, ty = 0 (no translation)
   * @returns True if matrix has no transformations
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * Sets all components to their default values: scale=1, no skew, no translation.
   * @example
   * ```ts
   * // Reset transformed matrix
   * const matrix = new Matrix()
   *     .scale(2, 2)
   *     .rotate(Math.PI / 4);
   * matrix.identity(); // Back to default state
   *
   * // Chain after reset
   * matrix
   *     .identity()
   *     .translate(100, 100)
   *     .scale(2, 2);
   *
   * // Compare with identity constant
   * const isDefault = matrix.equals(Matrix.IDENTITY);
   * ```
   * @remarks
   * - Sets a=1, d=1 (default scale)
   * - Sets b=0, c=0 (no skew)
   * - Sets tx=0, ty=0 (no translation)
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   * @see {@link Matrix.isIdentity} For checking identity state
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const e = new Gg();
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @param matrix
   * @example
   * ```ts
   * // Basic matrix cloning
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const copy = matrix.clone();
   *
   * // Clone and modify
   * const modified = matrix.clone()
   *     .scale(2, 2);
   *
   * // Compare matrices
   * console.log(matrix.equals(copy));     // true
   * console.log(matrix.equals(modified)); // false
   * ```
   * @returns A copy of this matrix. Good for chaining method calls.
   * @see {@link Matrix.copyTo} For copying to existing matrix
   * @see {@link Matrix.copyFrom} For copying from another matrix
   */
  copyTo(e) {
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix.
   * @example
   * ```ts
   * // Basic matrix copying
   * const source = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const target = new Matrix();
   * target.copyFrom(source);
   * ```
   * @param matrix - The matrix to copy from
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.clone} For creating new matrix copy
   * @see {@link Matrix.copyTo} For copying to another matrix
   */
  copyFrom(e) {
    return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
  }
  /**
   * Checks if this matrix equals another matrix.
   * Compares all components for exact equality.
   * @example
   * ```ts
   * // Basic equality check
   * const m1 = new Matrix();
   * const m2 = new Matrix();
   * console.log(m1.equals(m2)); // true
   *
   * // Compare transformed matrices
   * const transform = new Matrix()
   *     .translate(100, 100)
   * const clone = new Matrix()
   *     .scale(2, 2);
   * console.log(transform.equals(clone)); // false
   * ```
   * @param matrix - The matrix to compare to
   * @returns True if matrices are identical
   * @see {@link Matrix.copyFrom} For copying matrix values
   * @see {@link Matrix.isIdentity} For identity comparison
   */
  equals(e) {
    return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  // #endif
  /**
   * A default (identity) matrix with no transformations applied.
   *
   * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
   * @example
   * ```ts
   * // Get identity matrix reference
   * const identity = Matrix.IDENTITY;
   * console.log(identity.isIdentity()); // true
   *
   * // Compare with identity
   * const matrix = new Matrix();
   * console.log(matrix.equals(Matrix.IDENTITY)); // true
   *
   * // Create new matrix instead of modifying IDENTITY
   * const transform = new Matrix()
   *     .copyFrom(Matrix.IDENTITY)
   *     .translate(100, 100);
   * ```
   * @readonly
   * @returns A read-only identity matrix
   * @see {@link Matrix.shared} For temporary calculations
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get IDENTITY() {
    return l3.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   *
   * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempMatrix = Matrix.shared;
   * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
   * const point = tempMatrix.apply({ x: 10, y: 20 });
   *
   * // Will be reset to identity on next access
   * const fresh = Matrix.shared; // Back to identity
   * ```
   * @remarks
   * - Always returns identity matrix
   * - Safe to modify temporarily
   * - Not safe to store references
   * - Useful for one-off calculations
   * @readonly
   * @returns A fresh identity matrix for temporary use
   * @see {@link Matrix.IDENTITY} For immutable identity matrix
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get shared() {
    return c3.identity();
  }
};
const c3 = new Hl(), l3 = new Hl(), Dh = [new Mn(), new Mn(), new Mn(), new Mn()];
let _h = class Wc {
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Rectangle(0, 0, 100, 100);
   * console.log(shape.type); // 'rectangle'
   *
   * // Use in type guards
   * if (shape.type === 'rectangle') {
   *     console.log(shape.width, shape.height);
   * }
   * ```
   * @readonly
   * @default 'rectangle'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "rectangle";
  /**
   * The X coordinate of the upper-left corner of the rectangle
   * @example
   * ```ts
   * // Basic x position
   * const rect = new Rectangle();
   * rect.x = 100;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the upper-left corner of the rectangle
   * @example
   * ```ts
   * // Basic y position
   * const rect = new Rectangle();
   * rect.y = 100;
   * ```
   * @default 0
   */
  y;
  /**
   * The overall width of this rectangle
   * @example
   * ```ts
   * // Basic width setting
   * const rect = new Rectangle();
   * rect.width = 200;
   * ```
   * @default 0
   */
  width;
  /**
   * The overall height of this rectangle
   * @example
   * ```ts
   * // Basic height setting
   * const rect = new Rectangle();
   * rect.height = 150;
   * ```
   * @default 0
   */
  height;
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(e = 0, n = 0, s = 0, r = 0) {
    this.x = Number(e), this.y = Number(n), this.width = Number(s), this.height = Number(r);
  }
  /**
   * Returns the left edge (x-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get left edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.left); // 100
   *
   * // Use in alignment calculations
   * sprite.x = rect.left + padding;
   *
   * // Compare positions
   * if (point.x > rect.left) {
   *     console.log('Point is right of rectangle');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the left edge
   * @see {@link Rectangle.right} For right edge position
   * @see {@link Rectangle.x} For direct x-coordinate access
   */
  get left() {
    return this.x;
  }
  /**
   * Returns the right edge (x + width) of the rectangle.
   * @example
   * ```ts
   * // Get right edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.right); // 300
   *
   * // Align to right edge
   * sprite.x = rect.right - sprite.width;
   *
   * // Check boundaries
   * if (point.x < rect.right) {
   *     console.log('Point is inside right bound');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the right edge
   * @see {@link Rectangle.left} For left edge position
   * @see {@link Rectangle.width} For width value
   */
  get right() {
    return this.x + this.width;
  }
  /**
   * Returns the top edge (y-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get top edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.top); // 100
   *
   * // Position above rectangle
   * sprite.y = rect.top - sprite.height;
   *
   * // Check vertical position
   * if (point.y > rect.top) {
   *     console.log('Point is below top edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the top edge
   * @see {@link Rectangle.bottom} For bottom edge position
   * @see {@link Rectangle.y} For direct y-coordinate access
   */
  get top() {
    return this.y;
  }
  /**
   * Returns the bottom edge (y + height) of the rectangle.
   * @example
   * ```ts
   * // Get bottom edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.bottom); // 250
   *
   * // Stack below rectangle
   * sprite.y = rect.bottom + margin;
   *
   * // Check vertical bounds
   * if (point.y < rect.bottom) {
   *     console.log('Point is above bottom edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the bottom edge
   * @see {@link Rectangle.top} For top edge position
   * @see {@link Rectangle.height} For height value
   */
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Determines whether the Rectangle is empty (has no area).
   * @example
   * ```ts
   * // Check zero dimensions
   * const rect = new Rectangle(100, 100, 0, 50);
   * console.log(rect.isEmpty()); // true
   * ```
   * @returns True if the rectangle has no area
   * @see {@link Rectangle.width} For width value
   * @see {@link Rectangle.height} For height value
   */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /**
   * A constant empty rectangle. This is a new object every time the property is accessed.
   * @example
   * ```ts
   * // Get fresh empty rectangle
   * const empty = Rectangle.EMPTY;
   * console.log(empty.isEmpty()); // true
   * ```
   * @returns A new empty rectangle instance
   * @see {@link Rectangle.isEmpty} For empty state testing
   */
  static get EMPTY() {
    return new Wc(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Rectangle(100, 100, 200, 150);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.width *= 2;
   * modified.height += 50;
   *
   * // Verify independence
   * console.log(original.width);  // 200
   * console.log(modified.width);  // 400
   * ```
   * @returns A copy of the rectangle
   * @see {@link Rectangle.copyFrom} For copying into existing rectangle
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new Wc(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @example
   * ```ts
   * // Convert bounds to rectangle
   * const bounds = container.getBounds();
   * const rect = new Rectangle().copyFromBounds(bounds);
   * ```
   * @param bounds - The bounds to copy and convert to a rectangle
   * @returns Returns itself
   * @see {@link Bounds} For bounds object structure
   * @see {@link Rectangle.getBounds} For getting rectangle bounds
   */
  copyFromBounds(e) {
    return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new Rectangle()
   *     .copyFrom(source)
   *     .pad(10);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new Rectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isInside = rect.contains(150, 125); // true
   * // Check edge cases
   * console.log(rect.contains(100, 100)); // true (on edge)
   * console.log(rect.contains(300, 250)); // false (outside)
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   * @see {@link Rectangle.containsRect} For rectangle containment
   * @see {@link Rectangle.strokeContains} For checking stroke intersection
   */
  contains(e, n) {
    return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link Rectangle.contains} For checking fill containment
   * @see {@link Rectangle.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, s, r = 0.5) {
    const { width: a, height: o } = this;
    if (a <= 0 || o <= 0) return !1;
    const h = this.x, c = this.y, l = s * (1 - r), u = s - l, f = h - l, d = h + a + l, p = c - l, y = c + o + l, x = h + u, g = h + a - u, m = c + u, v = c + o - u;
    return e >= f && e <= d && n >= p && n <= y && !(e > x && e < g && n > m && n < v);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   *
   * Returns true only if the area of the intersection is greater than 0.
   * This means that rectangles sharing only a side are not considered intersecting.
   * @example
   * ```ts
   * // Basic intersection check
   * const rect1 = new Rectangle(0, 0, 100, 100);
   * const rect2 = new Rectangle(50, 50, 100, 100);
   * console.log(rect1.intersects(rect2)); // true
   *
   * // With transformation matrix
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // 45 degrees
   * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
   *
   * // Edge cases
   * const zeroWidth = new Rectangle(0, 0, 0, 100);
   * console.log(rect1.intersects(zeroWidth)); // false (no area)
   * ```
   * @remarks
   * - Returns true only if intersection area is > 0
   * - Rectangles sharing only a side are not intersecting
   * - Zero-area rectangles cannot intersect anything
   * - Supports optional transformation matrix
   * @param other - The Rectangle to intersect with `this`
   * @param transform - Optional transformation matrix of `other`
   * @returns True if the transformed `other` Rectangle intersects with `this`
   * @see {@link Rectangle.containsRect} For containment testing
   * @see {@link Rectangle.contains} For point testing
   */
  intersects(e, n) {
    if (!n) {
      const M = this.x < e.x ? e.x : this.x;
      if ((this.right > e.right ? e.right : this.right) <= M)
        return !1;
      const T = this.y < e.y ? e.y : this.y;
      return (this.bottom > e.bottom ? e.bottom : this.bottom) > T;
    }
    const s = this.left, r = this.right, a = this.top, o = this.bottom;
    if (r <= s || o <= a)
      return !1;
    const h = Dh[0].set(e.left, e.top), c = Dh[1].set(e.left, e.bottom), l = Dh[2].set(e.right, e.top), u = Dh[3].set(e.right, e.bottom);
    if (l.x <= h.x || c.y <= h.y)
      return !1;
    const f = Math.sign(n.a * n.d - n.b * n.c);
    if (f === 0 || (n.apply(h, h), n.apply(c, c), n.apply(l, l), n.apply(u, u), Math.max(h.x, c.x, l.x, u.x) <= s || Math.min(h.x, c.x, l.x, u.x) >= r || Math.max(h.y, c.y, l.y, u.y) <= a || Math.min(h.y, c.y, l.y, u.y) >= o))
      return !1;
    const d = f * (c.y - h.y), p = f * (h.x - c.x), y = d * s + p * a, x = d * r + p * a, g = d * s + p * o, m = d * r + p * o;
    if (Math.max(y, x, g, m) <= d * h.x + p * h.y || Math.min(y, x, g, m) >= d * u.x + p * u.y)
      return !1;
    const v = f * (h.y - l.y), w = f * (l.x - h.x), b = v * s + w * a, S = v * r + w * a, E = v * s + w * o, A = v * r + w * o;
    return !(Math.max(b, S, E, A) <= v * h.x + w * h.y || Math.min(b, S, E, A) >= v * u.x + w * u.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   *
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * // Basic padding
   * const rect = new Rectangle(100, 100, 200, 150);
   * rect.pad(10); // Adds 10px padding on all sides
   *
   * // Different horizontal and vertical padding
   * const uiRect = new Rectangle(0, 0, 100, 50);
   * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
   * ```
   * @remarks
   * - Adjusts x/y by subtracting padding
   * - Increases width/height by padding * 2
   * - Common in UI layout calculations
   * - Chainable with other methods
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   */
  pad(e = 0, n = e) {
    return this.x -= e, this.y -= n, this.width += e * 2, this.height += n * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @example
   * ```ts
   * // Basic fitting
   * const container = new Rectangle(0, 0, 100, 100);
   * const content = new Rectangle(25, 25, 200, 200);
   * content.fit(container); // Clips to container bounds
   * ```
   * @param rectangle - The rectangle to fit around
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  fit(e) {
    const n = Math.max(this.x, e.x), s = Math.min(this.x + this.width, e.x + e.width), r = Math.max(this.y, e.y), a = Math.min(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = Math.max(s - n, 0), this.y = r, this.height = Math.max(a - r, 0), this;
  }
  /**
   * Enlarges rectangle so that its corners lie on a grid defined by resolution.
   * @example
   * ```ts
   * // Basic grid alignment
   * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
   * rect.ceil(); // Aligns to whole pixels
   *
   * // Custom resolution grid
   * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
   * uiRect.ceil(0.5); // Aligns to half pixels
   *
   * // Use with precision value
   * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
   * preciseRect.ceil(1, 0.01); // Handles small decimal variations
   * ```
   * @param resolution - The grid size to align to (1 = whole pixels)
   * @param eps - Small number to prevent floating point errors
   * @returns Returns itself
   * @see {@link Rectangle.fit} For constraining to bounds
   * @see {@link Rectangle.enlarge} For growing dimensions
   */
  ceil(e = 1, n = 1e-3) {
    const s = Math.ceil((this.x + this.width - n) * e) / e, r = Math.ceil((this.y + this.height - n) * e) / e;
    return this.x = Math.floor((this.x + n) * e) / e, this.y = Math.floor((this.y + n) * e) / e, this.width = s - this.x, this.height = r - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @example
   * ```ts
   * // Basic enlargement
   * const rect = new Rectangle(50, 50, 100, 100);
   * const other = new Rectangle(0, 0, 200, 75);
   * rect.enlarge(other);
   * // rect is now: x=0, y=0, width=200, height=150
   *
   * // Use for bounding box calculation
   * const bounds = new Rectangle();
   * objects.forEach((obj) => {
   *     bounds.enlarge(obj.getBounds());
   * });
   * ```
   * @param rectangle - The rectangle to include
   * @returns Returns itself
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  enlarge(e) {
    const n = Math.min(this.x, e.x), s = Math.max(this.x + this.width, e.x + e.width), r = Math.min(this.y, e.y), a = Math.max(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = s - n, this.y = r, this.height = a - r, this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds retrieval
   * const rect = new Rectangle(100, 100, 200, 150);
   * const bounds = rect.getBounds();
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle.copyFrom} For direct copying
   * @see {@link Rectangle.clone} For creating new copy
   */
  getBounds(e) {
    return e ||= new Wc(), e.copyFrom(this), e;
  }
  /**
   * Determines whether another Rectangle is fully contained within this Rectangle.
   *
   * Rectangles that occupy the same space are considered to be containing each other.
   *
   * Rectangles without area (width or height equal to zero) can't contain anything,
   * not even other arealess rectangles.
   * @example
   * ```ts
   * // Check if one rectangle contains another
   * const container = new Rectangle(0, 0, 100, 100);
   * const inner = new Rectangle(25, 25, 50, 50);
   *
   * console.log(container.containsRect(inner)); // true
   *
   * // Check overlapping rectangles
   * const partial = new Rectangle(75, 75, 50, 50);
   * console.log(container.containsRect(partial)); // false
   *
   * // Zero-area rectangles
   * const empty = new Rectangle(0, 0, 0, 100);
   * console.log(container.containsRect(empty)); // false
   * ```
   * @param other - The Rectangle to check for containment
   * @returns True if other is fully contained within this Rectangle
   * @see {@link Rectangle.contains} For point containment
   * @see {@link Rectangle.intersects} For overlap testing
   */
  containsRect(e) {
    if (this.width <= 0 || this.height <= 0) return !1;
    const n = e.x, s = e.y, r = e.x + e.width, a = e.y + e.height;
    return n >= this.x && n < this.x + this.width && s >= this.y && s < this.y + this.height && r >= this.x && r < this.x + this.width && a >= this.y && a < this.y + this.height;
  }
  /**
   * Sets the position and dimensions of the rectangle.
   * @example
   * ```ts
   * // Basic usage
   * const rect = new Rectangle();
   * rect.set(100, 100, 200, 150);
   *
   * // Chain with other operations
   * const bounds = new Rectangle()
   *     .set(0, 0, 100, 100)
   *     .pad(10);
   * ```
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   * @returns Returns itself for method chaining
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating a new copy
   */
  set(e, n, s, r) {
    return this.x = e, this.y = n, this.width = s, this.height = r, this;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
  // #endif
}, u3 = class Ug {
  /**
   * The X coordinate of the center of this circle
   * @example
   * ```ts
   * // Basic x position
   * const circle = new Circle();
   * circle.x = 100;
   *
   * // Center circle on point
   * circle.x = point.x;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the center of this circle
   * @example
   * ```ts
   * // Basic y position
   * const circle = new Circle();
   * circle.y = 200;
   *
   * // Center circle on point
   * circle.y = point.y;
   * ```
   * @default 0
   */
  y;
  /**
   * The radius of the circle
   * @example
   * ```ts
   * // Basic radius setting
   * const circle = new Circle(100, 100);
   * circle.radius = 50;
   *
   * // Calculate area
   * const area = Math.PI * circle.radius * circle.radius;
   * ```
   * @default 0
   */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks.
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Circle(0, 0, 50);
   * console.log(shape.type); // 'circle'
   *
   * // Use in type guards
   * if (shape.type === 'circle') {
   *     console.log(shape.radius);
   * }
   * ```
   * @remarks
   * - Used for shape type checking
   * - More efficient than instanceof
   * - Read-only property
   * @readonly
   * @default 'circle'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   * @see {@link ShapePrimitive} For shape interface
   */
  type = "circle";
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(e = 0, n = 0, s = 0) {
    this.x = e, this.y = n, this.radius = s;
  }
  /**
   * Creates a clone of this Circle instance.
   * @example
   * ```ts
   * // Basic circle cloning
   * const original = new Circle(100, 100, 50);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 75;
   *
   * // Verify independence
   * console.log(original.radius); // 50
   * console.log(modified.radius); // 75
   * ```
   * @returns A copy of the Circle
   * @see {@link Circle.copyFrom} For copying into existing circle
   * @see {@link Circle.copyTo} For copying to another circle
   */
  clone() {
    return new Ug(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle.
   *
   * Uses the distance formula to determine if a point is inside the circle's radius.
   *
   * Commonly used for hit testing in PixiJS events and graphics.
   * @example
   * ```ts
   * // Basic containment check
   * const circle = new Circle(100, 100, 50);
   * const isInside = circle.contains(120, 120);
   *
   * // Check mouse position
   * const circle = new Circle(0, 0, 100);
   * container.hitArea = circle;
   * container.on('pointermove', (e) => {
   *     // only called if pointer is within circle
   * });
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   * @see {@link Circle.strokeContains} For checking stroke intersection
   * @see {@link Circle.getBounds} For getting bounding box
   */
  contains(e, n) {
    if (this.radius <= 0) return !1;
    const s = this.radius * this.radius;
    let r = this.x - e, a = this.y - n;
    return r *= r, a *= a, r + a <= s;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const circle = new Circle(100, 100, 50);
   * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this Circle's stroke
   * @see {@link Circle.contains} For checking fill containment
   * @see {@link Circle.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, s, r = 0.5) {
    if (this.radius === 0) return !1;
    const a = this.x - e, o = this.y - n, h = this.radius, c = (1 - r) * s, l = Math.sqrt(a * a + o * o);
    return l <= h + c && l > h - (s - c);
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const circle = new Circle(100, 100, 50);
   * const bounds = circle.getBounds();
   * // bounds: x=50, y=50, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * circle.getBounds(rect);
   * ```
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Circle.contains} For point containment
   */
  getBounds(e) {
    return e ||= new _h(), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
  }
  /**
   * Copies another circle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * target.copyFrom(source);
   * ```
   * @param circle - The circle to copy from
   * @returns Returns itself
   * @see {@link Circle.copyTo} For copying to another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
  }
  /**
   * Copies this circle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * source.copyTo(target);
   * ```
   * @param circle - The circle to copy to
   * @returns Returns given parameter
   * @see {@link Circle.copyFrom} For copying from another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
  // #endif
}, f3 = class Wg {
  /**
   * The X coordinate of the center of this ellipse
   * @example
   * ```ts
   * // Basic x position
   * const ellipse = new Ellipse();
   * ellipse.x = 100;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the center of this ellipse
   * @example
   * ```ts
   * // Basic y position
   * const ellipse = new Ellipse();
   * ellipse.y = 200;
   * ```
   * @default 0
   */
  y;
  /**
   * The half width of this ellipse
   * @example
   * ```ts
   * // Set half width
   * const ellipse = new Ellipse(100, 100);
   * ellipse.halfWidth = 50; // Total width will be 100
   * ```
   * @default 0
   */
  halfWidth;
  /**
   * The half height of this ellipse
   * @example
   * ```ts
   * // Set half height
   * const ellipse = new Ellipse(100, 100);
   * ellipse.halfHeight = 25; // Total height will be 50
   * ```
   * @default 0
   */
  halfHeight;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Ellipse(0, 0, 50, 25);
   * console.log(shape.type); // 'ellipse'
   *
   * // Use in type guards
   * if (shape.type === 'ellipse') {
   *     console.log(shape.halfWidth, shape.halfHeight);
   * }
   * ```
   * @readonly
   * @default 'ellipse'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "ellipse";
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(e = 0, n = 0, s = 0, r = 0) {
    this.x = e, this.y = n, this.halfWidth = s, this.halfHeight = r;
  }
  /**
   * Creates a clone of this Ellipse instance.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Ellipse(100, 100, 50, 25);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.halfWidth *= 2;
   * modified.halfHeight *= 2;
   *
   * // Verify independence
   * console.log(original.halfWidth);  // 50
   * console.log(modified.halfWidth);  // 100
   * ```
   * @returns A copy of the ellipse
   * @see {@link Ellipse.copyFrom} For copying into existing ellipse
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   */
  clone() {
    return new Wg(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse.
   * Uses normalized coordinates and the ellipse equation to determine containment.
   * @example
   * ```ts
   * // Basic containment check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isInside = ellipse.contains(120, 110);
   * ```
   * @remarks
   * - Uses ellipse equation (x²/a² + y²/b² ≤ 1)
   * - Returns false if dimensions are 0 or negative
   * - Normalized to center (0,0) for calculation
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   * @see {@link Ellipse.strokeContains} For checking stroke intersection
   * @see {@link Ellipse.getBounds} For getting containing rectangle
   */
  contains(e, n) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0)
      return !1;
    let s = (e - this.x) / this.halfWidth, r = (n - this.y) / this.halfHeight;
    return s *= s, r *= r, s + r <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @remarks
   * - Uses normalized ellipse equations
   * - Considers stroke alignment
   * - Returns false if dimensions are 0
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coords are within this ellipse's stroke
   * @see {@link Ellipse.contains} For checking fill containment
   * @see {@link Ellipse.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, s, r = 0.5) {
    const { halfWidth: a, halfHeight: o } = this;
    if (a <= 0 || o <= 0)
      return !1;
    const h = s * (1 - r), c = s - h, l = a - c, u = o - c, f = a + h, d = o + h, p = e - this.x, y = n - this.y, x = p * p / (l * l) + y * y / (u * u), g = p * p / (f * f) + y * y / (d * d);
    return x > 1 && g <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const bounds = ellipse.getBounds();
   * // bounds: x=50, y=75, width=100, height=50
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * ellipse.getBounds(rect);
   * ```
   * @remarks
   * - Creates Rectangle if none provided
   * - Top-left is (x-halfWidth, y-halfHeight)
   * - Width is halfWidth * 2
   * - Height is halfHeight * 2
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Ellipse.contains} For checking if a point is inside
   */
  getBounds(e) {
    return e ||= new _h(), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
  }
  /**
   * Copies another ellipse to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * target.copyFrom(source);
   * ```
   * @param ellipse - The ellipse to copy from
   * @returns Returns itself
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
  }
  /**
   * Copies this ellipse to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * source.copyTo(target);
   * ```
   * @param ellipse - The ellipse to copy to
   * @returns Returns given parameter
   * @see {@link Ellipse.copyFrom} For copying from another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
  // #endif
};
function d3(i, e, n, s, r, a) {
  const o = i - n, h = e - s, c = r - n, l = a - s, u = o * c + h * l, f = c * c + l * l;
  let d = -1;
  f !== 0 && (d = u / f);
  let p, y;
  d < 0 ? (p = n, y = s) : d > 1 ? (p = r, y = a) : (p = n + d * c, y = s + d * l);
  const x = i - p, g = e - y;
  return x * x + g * g;
}
let p3, y3, x3 = class Yg {
  /**
   * An array of the points of this polygon stored as a flat array of numbers.
   * @example
   * ```ts
   * // Access points directly
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]
   *
   * // Modify points
   * polygon.points[0] = 10; // Move first x coordinate
   * polygon.points[1] = 10; // Move first y coordinate
   * ```
   * @remarks
   * - Stored as [x1, y1, x2, y2, ...]
   * - Each pair represents a vertex
   * - Length is always even
   * - Can be modified directly
   */
  points;
  /**
   * Indicates if the polygon path is closed.
   * @example
   * ```ts
   * // Create open polygon
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * polygon.closePath = false;
   *
   * // Check path state
   * if (polygon.closePath) {
   *     // Last point connects to first
   * }
   * ```
   * @remarks
   * - True by default
   * - False after moveTo
   * - True after closePath
   * @default true
   */
  closePath;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(shape.type); // 'polygon'
   *
   * // Use in type guards
   * if (shape.type === 'polygon') {
   *     // TypeScript knows this is a Polygon
   *     console.log(shape.points.length);
   * }
   * ```
   * @readonly
   * @default 'polygon'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "polygon";
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...e) {
    let n = Array.isArray(e[0]) ? e[0] : e;
    if (typeof n[0] != "number") {
      const s = [];
      for (let r = 0, a = n.length; r < a; r++)
        s.push(n[r].x, n[r].y);
      n = s;
    }
    this.points = n, this.closePath = !0;
  }
  /**
   * Determines whether the polygon's points are arranged in a clockwise direction.
   * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
   *
   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
   *
   * The formula sums up the cross products of adjacent vertices:
   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
   * The final sum divided by 2 gives the signed area - positive for clockwise.
   * @example
   * ```ts
   * // Check polygon winding
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.isClockwise()); // Check direction
   *
   * // Use in path construction
   * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
   * if (hole.isClockwise() === shape.isClockwise()) {
   *     hole.points.reverse(); // Reverse for proper hole winding
   * }
   * ```
   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
   */
  isClockwise() {
    let e = 0;
    const n = this.points, s = n.length;
    for (let r = 0; r < s; r += 2) {
      const a = n[r], o = n[r + 1], h = n[(r + 2) % s], c = n[(r + 3) % s];
      e += (h - a) * (c + o);
    }
    return e < 0;
  }
  /**
   * Checks if this polygon completely contains another polygon.
   * Used for detecting holes in shapes, like when parsing SVG paths.
   * @example
   * ```ts
   * // Basic containment check
   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
   *
   * outerSquare.containsPolygon(innerSquare); // Returns true
   * innerSquare.containsPolygon(outerSquare); // Returns false
   * ```
   * @remarks
   * - Uses bounds check for quick rejection
   * - Tests all points for containment
   * @param polygon - The polygon to test for containment
   * @returns True if this polygon completely contains the other polygon
   * @see {@link Polygon.contains} For single point testing
   * @see {@link Polygon.getBounds} For bounds calculation
   */
  containsPolygon(e) {
    const n = this.getBounds(p3), s = e.getBounds(y3);
    if (!n.containsRect(s))
      return !1;
    const r = e.points;
    for (let a = 0; a < r.length; a += 2) {
      const o = r[a], h = r[a + 1];
      if (!this.contains(o, h))
        return !1;
    }
    return !0;
  }
  /**
   * Creates a clone of this polygon.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Polygon([0, 0, 100, 0, 50, 100]);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.points[0] = 10; // Modify first x coordinate
   * ```
   * @returns A copy of the polygon
   * @see {@link Polygon.copyFrom} For copying into existing polygon
   * @see {@link Polygon.copyTo} For copying to another polygon
   */
  clone() {
    const e = this.points.slice(), n = new Yg(e);
    return n.closePath = this.closePath, n;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * Uses raycasting algorithm for point-in-polygon testing.
   * @example
   * ```ts
   * // Basic containment check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isInside = polygon.contains(25, 25); // true
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this polygon
   * @see {@link Polygon.strokeContains} For checking stroke intersection
   * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
   */
  contains(e, n) {
    let s = !1;
    const r = this.points.length / 2;
    for (let a = 0, o = r - 1; a < r; o = a++) {
      const h = this.points[a * 2], c = this.points[a * 2 + 1], l = this.points[o * 2], u = this.points[o * 2 + 1];
      c > n != u > n && e < (l - h) * ((n - c) / (u - c)) + h && (s = !s);
    }
    return s;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
   * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
   * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this polygon's stroke
   * @see {@link Polygon.contains} For checking fill containment
   * @see {@link Polygon.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, s, r = 0.5) {
    const a = s * s, o = a * (1 - r), h = a - o, { points: c } = this, l = c.length - (this.closePath ? 0 : 2);
    for (let u = 0; u < l; u += 2) {
      const f = c[u], d = c[u + 1], p = c[(u + 2) % c.length], y = c[(u + 3) % c.length], x = d3(e, n, f, d, p, y), g = Math.sign((p - f) * (n - d) - (y - d) * (e - f));
      if (x <= (g < 0 ? h : o))
        return !0;
    }
    return !1;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const bounds = polygon.getBounds();
   * // bounds: x=0, y=0, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * polygon.getBounds(rect);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Polygon.contains} For checking if a point is inside
   */
  getBounds(e) {
    e ||= new _h();
    const n = this.points;
    let s = 1 / 0, r = -1 / 0, a = 1 / 0, o = -1 / 0;
    for (let h = 0, c = n.length; h < c; h += 2) {
      const l = n[h], u = n[h + 1];
      s = l < s ? l : s, r = l > r ? l : r, a = u < a ? u : a, o = u > o ? u : o;
    }
    return e.x = s, e.width = r - s, e.y = a, e.height = o - a, e;
  }
  /**
   * Copies another polygon to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * target.copyFrom(source);
   * ```
   * @param polygon - The polygon to copy from
   * @returns Returns itself
   * @see {@link Polygon.copyTo} For copying to another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyFrom(e) {
    return this.points = e.points.slice(), this.closePath = e.closePath, this;
  }
  /**
   * Copies this polygon to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * source.copyTo(target);
   * ```
   * @param polygon - The polygon to copy to
   * @returns Returns given parameter
   * @see {@link Polygon.copyFrom} For copying from another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, n) => `${e}, ${n}`, "")}]`;
  }
  // #endif
  /**
   * Get the last X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastX); // 300
   * ```
   * @readonly
   * @returns The x-coordinate of the last vertex
   * @see {@link Polygon.lastY} For last Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastY); // 400
   * ```
   * @readonly
   * @returns The y-coordinate of the last vertex
   * @see {@link Polygon.lastX} For last X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the last X coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
   */
  get x() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
   */
  get y() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.x); // 0
   * ```
   * @readonly
   * @returns The x-coordinate of the first vertex
   * @see {@link Polygon.startY} For first Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startX() {
    return this.points[0];
  }
  /**
   * Get the first Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.y); // 0
   * ```
   * @readonly
   * @returns The y-coordinate of the first vertex
   * @see {@link Polygon.startX} For first X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startY() {
    return this.points[1];
  }
};
const qh = (i, e, n, s, r, a, o) => {
  const h = i - n, c = e - s, l = Math.sqrt(h * h + c * c);
  return l >= r - a && l <= r + o;
};
let g3 = class jg {
  /**
   * The X coordinate of the upper-left corner of the rounded rectangle
   * @example
   * ```ts
   * // Basic x position
   * const rect = new RoundedRectangle();
   * rect.x = 100;
   * ```
   * @default 0
   */
  x;
  /**
   * The Y coordinate of the upper-left corner of the rounded rectangle
   * @example
   * ```ts
   * // Basic y position
   * const rect = new RoundedRectangle();
   * rect.y = 100;
   * ```
   * @default 0
   */
  y;
  /**
   * The overall width of this rounded rectangle
   * @example
   * ```ts
   * // Basic width setting
   * const rect = new RoundedRectangle();
   * rect.width = 200; // Total width will be 200
   * ```
   * @default 0
   */
  width;
  /**
   * The overall height of this rounded rectangle
   * @example
   * ```ts
   * // Basic height setting
   * const rect = new RoundedRectangle();
   * rect.height = 150; // Total height will be 150
   * ```
   * @default 0
   */
  height;
  /**
   * Controls the radius of the rounded corners
   * @example
   * ```ts
   * // Basic radius setting
   * const rect = new RoundedRectangle(0, 0, 200, 150);
   * rect.radius = 20;
   *
   * // Clamp to maximum safe radius
   * rect.radius = Math.min(rect.width, rect.height) / 2;
   *
   * // Create pill shape
   * rect.radius = rect.height / 2;
   * ```
   * @remarks
   * - Automatically clamped to half of smallest dimension
   * - Common values: 0-20 for UI elements
   * - Higher values create more rounded corners
   * @default 20
   */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @example
   * ```ts
   * // Check shape type
   * const shape = new RoundedRectangle(0, 0, 100, 100, 20);
   * console.log(shape.type); // 'roundedRectangle'
   *
   * // Use in type guards
   * if (shape.type === 'roundedRectangle') {
   *     console.log(shape.radius);
   * }
   * ```
   * @readonly
   * @default 'roundedRectangle'
   * @see {@link SHAPE_PRIMITIVE} For all shape types
   */
  type = "roundedRectangle";
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(e = 0, n = 0, s = 0, r = 0, a = 20) {
    this.x = e, this.y = n, this.width = s, this.height = r, this.radius = a;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds calculation
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const bounds = rect.getBounds();
   * // bounds: x=100, y=100, width=200, height=150
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @remarks
   * - Rectangle matches outer dimensions
   * - Ignores corner radius
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link RoundedRectangle.contains} For checking if a point is inside
   */
  getBounds(e) {
    return e ||= new _h(), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new RoundedRectangle(100, 100, 200, 150, 20);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 30;
   * modified.width *= 2;
   *
   * // Verify independence
   * console.log(original.radius);  // 20
   * console.log(modified.radius);  // 30
   * ```
   * @returns A copy of the rounded rectangle
   * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new jg(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new RoundedRectangle()
   *     .copyFrom(source)
   *     .getBounds(rect);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new RoundedRectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isInside = rect.contains(150, 125); // true
   * // Check corner radius
   * const corner = rect.contains(100, 100); // false if within corner curve
   * ```
   * @remarks
   * - Returns false if width/height is 0 or negative
   * - Handles rounded corners with radius check
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rounded Rectangle
   * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
   * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
   */
  contains(e, n) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (e >= this.x && e <= this.x + this.width && n >= this.y && n <= this.y + this.height) {
      const s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (n >= this.y + s && n <= this.y + this.height - s || e >= this.x + s && e <= this.x + this.width - s)
        return !0;
      let r = e - (this.x + s), a = n - (this.y + s);
      const o = s * s;
      if (r * r + a * a <= o || (r = e - (this.x + this.width - s), r * r + a * a <= o) || (a = n - (this.y + this.height - s), r * r + a * a <= o) || (r = e - (this.x + s), r * r + a * a <= o))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link RoundedRectangle.contains} For checking fill containment
   * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
   */
  strokeContains(e, n, s, r = 0.5) {
    const { x: a, y: o, width: h, height: c, radius: l } = this, u = s * (1 - r), f = s - u, d = a + l, p = o + l, y = h - l * 2, x = c - l * 2, g = a + h, m = o + c;
    return (e >= a - u && e <= a + f || e >= g - f && e <= g + u) && n >= p && n <= p + x || (n >= o - u && n <= o + f || n >= m - f && n <= m + u) && e >= d && e <= d + y ? !0 : (
      // Top-left
      e < d && n < p && qh(
        e,
        n,
        d,
        p,
        l,
        f,
        u
      ) || e > g - l && n < p && qh(
        e,
        n,
        g - l,
        p,
        l,
        f,
        u
      ) || e > g - l && n > m - l && qh(
        e,
        n,
        g - l,
        m - l,
        l,
        f,
        u
      ) || e < d && n > m - l && qh(
        e,
        n,
        d,
        m - l,
        l,
        f,
        u
      )
    );
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
  // #endif
};
const m3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: u3,
  Ellipse: f3,
  Polygon: x3,
  Rectangle: _h,
  RoundedRectangle: g3
}, Symbol.toStringTag, { value: "Module" }));
let Hg = class Xg {
  /** @ignore */
  _x;
  /** @ignore */
  _y;
  /** This object used to call the `onUpdate` callback when the point changes. */
  _observer;
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e, n, s) {
    this._x = n || 0, this._y = s || 0, this._observer = e;
  }
  /**
   * Creates a clone of this point.
   * @example
   * ```ts
   * // Basic cloning
   * const point = new ObservablePoint(observer, 100, 200);
   * const copy = point.clone();
   *
   * // Clone with new observer
   * const newObserver = {
   *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
   * };
   * const watched = point.clone(newObserver);
   *
   * // Verify independence
   * watched.set(300, 400); // Only triggers new observer
   * ```
   * @param observer - Optional observer to pass to the new observable point
   * @returns A copy of this observable point
   * @see {@link ObservablePoint.copyFrom} For copying into existing point
   * @see {@link Observer} For observer interface details
   */
  clone(e) {
    return new Xg(e ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new ObservablePoint(observer);
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.equals} For comparing positions
   */
  set(e = 0, n = e) {
    return (this._x !== e || this._y !== n) && (this._x = e, this._y = n, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(observer, 100, 200);
   * const target = new ObservablePoint();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new ObservablePoint()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyTo} For copying to another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyFrom(e) {
    return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(100, 200);
   * const target = new ObservablePoint();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyTo(e) {
    return e.set(this._x, this._y), e;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new ObservablePoint(100, 200);
   * const p2 = new ObservablePoint(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new ObservablePoint(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link ObservablePoint.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(e) {
    return e.x === this._x && e.y === this._y;
  }
  // #if _DEBUG
  toString() {
    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
  }
  // #endif
  /**
   * Position of the observable point on the x axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic x position
   * const point = new ObservablePoint(observer);
   * point.x = 100; // Triggers observer
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x !== e && (this._x = e, this._observer._onUpdate(this));
  }
  /**
   * Position of the observable point on the y axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic y position
   * const point = new ObservablePoint(observer);
   * point.y = 200; // Triggers observer
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y !== e && (this._y = e, this._observer._onUpdate(this));
  }
};
function v3(i, e, n, s, r, a, o, h) {
  const c = o - n, l = h - s, u = r - n, f = a - s, d = i - n, p = e - s, y = c * c + l * l, x = c * u + l * f, g = c * d + l * p, m = u * u + f * f, v = u * d + f * p, w = 1 / (y * m - x * x), b = (m * g - x * v) * w, S = (y * v - x * g) * w;
  return b >= 0 && S >= 0 && b + S < 1;
}
const w3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ObservablePoint: Hg,
  Point: Mn,
  pointInTriangle: v3
}, Symbol.toStringTag, { value: "Module" }));
let Ue = class Zg {
  x;
  y;
  constructor(e, n) {
    this.x = e || 0, this.y = n || 0;
  }
  /**
   * Copy from another point
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Clone a point
   */
  clone() {
    return new Zg(this.x, this.y);
  }
  /**
   * Set x and y
   */
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  /**
   * If equal to another point
   */
  equal(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Add another point
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scale(e) {
    this.x *= e, this.y *= e;
  }
  scaleAndAdd(e, n) {
    this.x += e.x * n, this.y += e.y * n;
  }
  /**
   * Sub another point
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Dot product with other point
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Get length of point
   */
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Get squared length
   */
  lenSquare() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Normalize
   */
  normalize() {
    const e = this.len();
    return this.x /= e, this.y /= e, this;
  }
  /**
   * Distance to another point
   */
  distance(e) {
    const n = this.x - e.x, s = this.y - e.y;
    return Math.sqrt(n * n + s * s);
  }
  /**
   * Square distance to another point
   */
  distanceSquare(e) {
    const n = this.x - e.x, s = this.y - e.y;
    return n * n + s * s;
  }
  /**
   * Negate
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Apply a transform matrix array.
   */
  transform(e) {
    if (!e)
      return;
    const n = this.x, s = this.y;
    return this.x = e[0] * n + e[2] * s + e[4], this.y = e[1] * n + e[3] * s + e[5], this;
  }
  toArray(e) {
    return e[0] = this.x, e[1] = this.y, e;
  }
  fromArray(e) {
    this.x = e[0], this.y = e[1];
  }
  static set(e, n, s) {
    e.x = n, e.y = s;
  }
  static copy(e, n) {
    e.x = n.x, e.y = n.y;
  }
  static len(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }
  static lenSquare(e) {
    return e.x * e.x + e.y * e.y;
  }
  static dot(e, n) {
    return e.x * n.x + e.y * n.y;
  }
  static add(e, n, s) {
    e.x = n.x + s.x, e.y = n.y + s.y;
  }
  static sub(e, n, s) {
    e.x = n.x - s.x, e.y = n.y - s.y;
  }
  static scale(e, n, s) {
    e.x = n.x * s, e.y = n.y * s;
  }
  static scaleAndAdd(e, n, s, r) {
    e.x = n.x + s.x * r, e.y = n.y + s.y * r;
  }
  static lerp(e, n, s, r) {
    const a = 1 - r;
    e.x = a * n.x + r * s.x, e.y = a * n.y + r * s.y;
  }
};
class Uo {
  currentID;
  dirtyID;
  _x;
  _y;
  _width;
  _height;
  _hull;
  /**
   * @param [x=0] - The X coordinate of the upper-left corner of the rectangle
   * @param [y=0] - The Y coordinate of the upper-left corner of the rectangle
   * @param [width=0] - The overall width of this rectangle
   * @param [height=0] - The overall height of this rectangle
   */
  constructor(e = 0, n = 0, s = 0, r = 0) {
    this._x = Number(e), this._y = Number(n), this._width = Number(s), this._height = Number(r), this._hull = [new Ue(), new Ue(), new Ue(), new Ue()], this.currentID = -1, this.dirtyID = 0;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this.dirtyID++;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this.dirtyID++;
  }
  get width() {
    return this._width;
  }
  set width(e) {
    this._width = e, this.dirtyID++;
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this._height = e, this.dirtyID++;
  }
  get hull() {
    return this.isDirty() && this.update(), this._hull;
  }
  get topLeft() {
    return this.isDirty() && this.update(), this._hull[0];
  }
  get topRight() {
    return this.isDirty() && this.update(), this._hull[1];
  }
  get bottomRight() {
    return this.isDirty() && this.update(), this._hull[2];
  }
  get bottomLeft() {
    return this.isDirty() && this.update(), this._hull[3];
  }
  isDirty() {
    return this.currentID !== this.dirtyID;
  }
  update() {
    const [e, n, s, r] = this._hull;
    e.set(this._x, this._y), n.set(this._x + this._width, this._y), s.set(this._x + this._width, this._y + this._height), r.set(this._x, this._y + this._height);
  }
  /**
   * returns the left edge of the rectangle
   *
   * @member {number}
   */
  get left() {
    return this.x;
  }
  /**
   * returns the right edge of the rectangle
   */
  get right() {
    return this.x + this.width;
  }
  /**
   * returns the top edge of the rectangle
   */
  get top() {
    return this.y;
  }
  /**
   * returns the bottom edge of the rectangle
   */
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Creates a clone of this Rectangle
   *
   * @return A copy of this AxisAlignedBounds.
   */
  clone() {
    return new Uo(this.x, this.y, this.width, this.height);
  }
  /**
   * Copies another rectangle to this one.
   *
   * @param rectangle - The rectangle to copy from.
   * @return Returns itself.
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   *
   * @param rectangle - The rectangle to copy to.
   * @return Returns given parameter.
   */
  copyTo(e) {
    return e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   *
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @return Whether the x/y coordinates are within this Rectangle
   */
  contains(e, n) {
    return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height;
  }
  /**
   * Checks whether the given {@code bounds} are equal to this.
   *
   * @param bounds
   */
  equals(e) {
    return e ? e.x === this.x && e.y === this.y && e.width === this.width && e.height === this.height : !1;
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   *
   * @param [paddingX=0] - The horizontal padding amount.
   * @param [paddingY=0] - The vertical padding amount.
   * @return Returns itself.
   */
  pad(e = 0, n = e) {
    return this.x -= e, this.y -= n, this.width += e * 2, this.height += n * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   *
   * @param rectangle - The rectangle to fit.
   * @return Returns itself.
   */
  fit(e) {
    const n = Math.max(this.x, e.x), s = Math.min(this.x + this.width, e.x + e.width), r = Math.max(this.y, e.y), a = Math.min(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = Math.max(s - n, 0), this.y = r, this.height = Math.max(a - r, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   *
   * @param [resolution=1] - resolution
   * @param [eps=0.001] - precision
   * @return Returns itself.
   */
  ceil(e = 1, n = 1e-3) {
    const s = Math.ceil((this.x + this.width - n) * e) / e, r = Math.ceil((this.y + this.height - n) * e) / e;
    return this.x = Math.floor((this.x + n) * e) / e, this.y = Math.floor((this.y + n) * e) / e, this.width = s - this.x, this.height = r - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   *
   * @param rectangle - The rectangle to include.
   * @return Returns itself.
   */
  enlarge(e) {
    const n = Math.min(this.x, e.x), s = Math.max(this.x + this.width, e.x + e.width), r = Math.min(this.y, e.y), a = Math.max(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = s - n, this.y = r, this.height = a - r, this;
  }
}
const ay = new Mn();
class M3 {
  innerBounds;
  currentID;
  dirtyID;
  _rotation;
  _center;
  _hull;
  _matrix;
  constructor(e = 0, n = 0, s = 0, r = 0, a = 0) {
    e instanceof Uo && (a = n || 0, n = e.y, s = e.width, r = e.height, e = e.x), this.innerBounds = new Uo(e, n, s, r), this._rotation = a, this._center = new Hg(this), this._hull = [new Mn(), new Mn(), new Mn(), new Mn()], this._matrix = new Hl(), this.currentID = -1, this.dirtyID = 0;
  }
  /**
   * The angle, in radians, by which this bounding box is tilted.
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation = e, this.dirtyID++;
  }
  /**
   * The center of this bounding box.
   *
   * The center of this and {@code this.innerBounds} will always coincide.
   */
  get center() {
    return this.isDirty() && this.update(), this._center;
  }
  set center(e) {
    this.center.copyFrom(e);
  }
  /**
   * The four-corners of this bounding, in clockwise order starting from the top-left.
   *
   * @readonly
   */
  get hull() {
    return this.isDirty() && this.update(), this._hull;
  }
  /**
   * The top-left corner of this bounding box. The returned instance should not be modified directly.
   *
   * @readonly
   */
  get topLeft() {
    return this.isDirty() && this.update(), this._hull[0];
  }
  /**
   * The top-right corner of this bounding box. The returned instance should not be modified directly.
   *
   * @readonly
   */
  get topRight() {
    return this.isDirty() && this.update(), this._hull[1];
  }
  /**
   * The bottom-right corner of this bounding box. The returned instance should not be modified directly.
   */
  get bottomRight() {
    return this.isDirty() && this.update(), this._hull[2];
  }
  /**
   * The bottom-left corner of this bounding box. The returned instance should not be modified directly.
   */
  get bottomLeft() {
    return this.isDirty() && this.update(), this._hull[3];
  }
  /**
   * Checks whether the given {@code bounds} are equal to this.
   *
   * @param bounds
   */
  equals(e) {
    return e ? this.innerBounds.equals(e.innerBounds) && this.rotation === e.rotation : !1;
  }
  /**
   * Whether this bounding box contains the given point
   *
   * @param point
   */
  contains(e, n) {
    typeof e == "number" && (e = ay.set(e, n));
    const s = this._matrix.applyInverse(e, ay);
    return this.innerBounds.contains(s.x, s.y);
  }
  /**
   * Copies {@code bounds} into this instance.
   *
   * @param bounds
   */
  copyFrom(e) {
    return this.innerBounds.copyFrom(e.innerBounds), this.rotation = e.rotation, this.dirtyID++, this;
  }
  /**
   * Whether any internal state needs to be recalculated.
   */
  isDirty() {
    return this.currentID !== this.dirtyID + this.innerBounds.dirtyID;
  }
  /**
   * This will recalculate the center, orientation matrix, and the hull vertices. It should be called only if
   * {@code this.isDirty} returns true.
   */
  update() {
    const e = this.innerBounds, n = this._rotation, s = this._center, [r, a, o, h] = this._hull, c = this._matrix;
    s._x = e.x + e.width / 2, s._y = e.y + e.height / 2, c.identity().translate(-s.x, -s.y).rotate(n).translate(s.x, s.y), c.apply(e.topLeft, r), c.apply(e.topRight, a), c.apply(e.bottomRight, o), c.apply(e.bottomLeft, h), this.currentID = this.dirtyID + this.innerBounds.dirtyID;
  }
  _onUpdate() {
    this.updateCenter();
  }
  /**
   * This will translate {@link OrientedBounds#innerBounds} after {@link OrientedBounds#center} is
   * changed to ensure consistency.
   */
  updateCenter() {
    const e = this.center, n = this.innerBounds;
    n.x = e.x - n.width / 2, n.y = e.y - n.height / 2;
  }
}
const b3 = (i, e) => i[0] * e[0] + i[1] * e[1], _3 = (i, e) => i[0] * e[1] - i[1] * e[0], oy = (i, e) => Math.atan2(_3(i, e), b3(i, e));
function Jg(i, e, n, s, r, a, o) {
  let h = Math.PI * 2;
  o === 0 && (o = 1e-6), o === h && (o = h - 1e-6);
  let c = Math.cos(r), l = Math.sin(r), u = c * n * Math.cos(a) - l * s * Math.sin(a) + i, f = l * n * Math.cos(a) + c * s * Math.sin(a) + e, d = c * n * Math.cos(a + o) - l * s * Math.sin(a + o) + i, p = l * n * Math.cos(a + o) + c * s * Math.sin(a + o) + e, y = Math.abs(o) > Math.PI ? 1 : 0, x = o > 0 ? 1 : 0;
  return {
    x1: u,
    y1: f,
    x2: d,
    y2: p,
    fa: y,
    //是大弧标志，如果选择跨度小于或等于 180 度的弧，则为 0，如果选择跨度大于 180 度的弧，则为 1。
    fs: x
    //是扫描标志，如果连接中心和圆弧的线扫描的角度减小，则为 0，如果扫描的角度增加，则为 1。
  };
}
function Qg(i, e, n, s, r, a, o, h, c) {
  let l = Math.cos(c), u = Math.sin(c), f = l * (i - n) / 2 + u * (e - s) / 2, d = -u * (i - n) / 2 + l * (e - s) / 2, p = f * f / (o * o) + d * d / (h * h);
  p > 1 && (p = Math.sqrt(p), o *= p, h *= p);
  let y = r !== a ? 1 : -1, x = (o * o * h * h - o * o * d * d - h * h * f * f) / (o * o * d * d + h * h * f * f);
  x < 0 ? x = 0 : x = Math.sqrt(x);
  let g = y * x * (o * d / h), m = y * x * (-h * f / o), v = l * g - u * m + (i + n) / 2, w = u * g + l * m + (e + s) / 2, b = oy([1, 0], [(f - g) / o, (d - m) / h]), S = oy([(f - g) / o, (d - m) / h], [(-f - g) / o, (-d - m) / h]);
  !a && S > 0 ? S -= Math.PI * 2 : a && S < 0 && (S += Math.PI * 2);
  let E = b + S;
  return {
    rx: o,
    ry: h,
    cx: v,
    cy: w,
    theta1: b,
    // 是拉伸和旋转操作之前椭圆弧的起始角度。
    theta2: E,
    // 是拉伸和旋转操作之前椭圆弧的终止角度。
    dtheta: S
    // 是这两个角度之间的差值。
  };
}
function Kg(i, e, n, s, r, a) {
  const o = Math.cos(a) * n, h = Math.sin(a) * s, c = Math.cos(r), l = Math.sin(r);
  return {
    x: i + c * o - l * h,
    y: e + l * o + c * h
  };
}
function od(i, e, n, s, r, a, o) {
  const h = o - a, c = 4 / 3 * Math.tan(h / 4), l = N.fromRotation(a), u = N.fromRotation(o), f = N.fromPoint(l), d = N.fromPoint(u);
  return f.translate(-c * l.y, c * l.x), d.translate(c * u.y, -c * u.x), l.scale(n, s).rotate(r).translate(i, e), f.scale(n, s).rotate(r).translate(i, e), d.scale(n, s).rotate(r).translate(i, e), u.scale(n, s).rotate(r).translate(i, e), [l.x, l.y, f.x, f.y, d.x, d.y, u.x, u.y];
}
function Xl(i, e, n, s, r, a, o, h, c, l) {
  const { cx: u, cy: f, theta1: d, dtheta: p, rx: y, ry: x } = Qg(i, e, n, s, h, c, r, a, o), g = Math.ceil(Math.abs(p / (Math.PI / 2))), m = p / g, v = [];
  let w = d;
  for (let b = 0; b < g; b++) {
    const S = w + m;
    let [E, A, M, _, T, C, P, R] = od(u, f, y, x, o, w, S);
    l?.(E, A, M, _, T, C, P, R, b), w = S, v.push(E, A, M, _, T, C, P, R);
  }
  return v;
}
const tm = Math.PI, S3 = Math.PI * 2, T3 = Math.PI * 0.5, E3 = 4 / 3 * (Math.sqrt(2) - 1);
function z3(i) {
  return 4 / 3 * Math.tan(i / 4);
}
function C3(i) {
  return Math.ceil(Math.abs(i) / tm);
}
function A3(i) {
  for (var e = 0; e < i.length; e++)
    if (i[e] !== void 0 && !Number.isFinite(i[e]))
      return !1;
  return !0;
}
function P3(i, e, n = 1e-5) {
  return Math.abs(i - e) <= n;
}
function I3(i) {
  return i * (180 / Math.PI);
}
function R3(i) {
  return i * (Math.PI / 180);
}
function O3(i) {
  return Math.sqrt(i);
}
function k3(i, e) {
  return Math.pow(i, e);
}
function L3(i) {
  return Math.abs(i);
}
function F3(i, e) {
  return Math.min(i, e);
}
function N3(i, e) {
  return Math.max(i, e);
}
function B3(i, e) {
  return Math.random() * (e - i) + i;
}
function D3(i, e, n = 1e-4) {
  return (i(e + n) - i(e - n)) / (2 * n);
}
function Gf(i) {
  if (i < 0) return -1;
  let e = 1;
  for (let n = 2; n <= i; n++)
    e *= n;
  return e;
}
function em(i, e) {
  if (e > i) return 0;
  let n = 1;
  for (let s = 1; s <= e; s++)
    n *= (i - s + 1) / s;
  return n;
}
function q3(i, e) {
  if (e > i) return 0;
  let n = 1;
  for (let s = 1; s <= e; s++)
    n *= i - s + 1;
  return n;
}
function $3(i, e, n, s, r) {
  return (i - e) * (r - s) / (n - e) + s;
}
function Je(i, e, n) {
  return Math.min(Math.max(i, e), n);
}
function V3(i, e, n) {
  return i * (1 - n) + e * n;
}
function G3(i, e, n) {
  return (n - i) / (e - i);
}
function U3(i, e, n) {
  const s = Je((n - i) / (e - i), 0, 1);
  return s * s * (3 - 2 * s);
}
function W3(i, e, n) {
  const s = Je((n - i) / (e - i), 0, 1);
  return s < 0.5 ? 4 * s * s * s : (s - 1) * (2 * s - 2) * (2 * s - 2) + 1;
}
function Y3(i, e, n) {
  const s = Je((n - i) / (e - i), 0, 1);
  return s * s * s;
}
function j3(i, e, n) {
  const s = Je((n - i) / (e - i), 0, 1);
  return (s - 1) * (2 * s - 2) * (2 * s - 2) + 1;
}
function H3(i) {
  return (e) => class extends e {
    constructor(...n) {
      super(...n), Object.assign(this, i);
    }
  };
}
const X3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BEZIER_CIRCLE_GOLDEN_RATIO: E3,
  PI: tm,
  PI2: S3,
  PI_2: T3,
  abs: L3,
  allAreFinite: A3,
  calcArcGoldenRatio: z3,
  calcArcSteps: C3,
  clamp: Je,
  createMixin: H3,
  degreesToRadians: R3,
  derivative: D3,
  easeIn: Y3,
  easeInOut: W3,
  easeOut: j3,
  equalsEpsilon: P3,
  factorial: Gf,
  inverseLerp: G3,
  lerp: V3,
  map: $3,
  max: N3,
  min: F3,
  nCr: em,
  nPr: q3,
  pow: k3,
  radiansToDegrees: I3,
  random: B3,
  smoothstep: U3,
  sqrt: O3
}, Symbol.toStringTag, { value: "Module" })), ct = 1e-6, Z3 = "zyx", hy = new Float32Array([
  1,
  0,
  0,
  1
]);
class Ae extends Float32Array {
  /**
   * The number of bytes in a {@link Mat2}.
   */
  static BYTE_LENGTH = 4 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 4:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 4);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n
        ]) : super(n, 0, 4);
        break;
      default:
        super(hy);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat2.str(this);`
   */
  get str() {
    return Ae.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat2} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat2.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(hy), this;
  }
  /**
   * Multiplies this {@link Mat2} against another one
   * Equivalent to `Mat2.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return Ae.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat2.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Transpose this {@link Mat2}
   * Equivalent to `Mat2.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return Ae.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat2}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return Ae.invert(this, this);
  }
  /**
   * Scales this {@link Mat2} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat2.scale(this, this, v);`
   *
   * @param v - The {@link Vec2} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return Ae.scale(this, this, e);
  }
  /**
   * Rotates this {@link Mat2} by the given angle around the given axis
   * Equivalent to `Mat2.rotate(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  rotate(e) {
    return Ae.rotate(this, this, e);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat2}
   * @category Static
   *
   * @returns A new {@link Mat2}
   */
  static create() {
    return new Ae();
  }
  /**
   * Creates a new {@link Mat2} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat2}
   */
  static clone(e) {
    return new Ae(e);
  }
  /**
   * Copy the values from one {@link Mat2} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Create a new {@link Mat2} with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat2}
   */
  static fromValues(...e) {
    return new Ae(...e);
  }
  /**
   * Set the components of a {@link Mat2} to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set a {@link Mat2} to the identity matrix
   * @category Static
   *
   * @param out - The receiving matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, n) {
    if (e === n) {
      let s = n[1];
      e[1] = n[2], e[2] = s;
    } else
      e[0] = n[0], e[1] = n[2], e[2] = n[1], e[3] = n[3];
    return e;
  }
  /**
   * Inverts a {@link Mat2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3];
    let h = s * o - a * r;
    return h ? (h = 1 / h, e[0] = o * h, e[1] = -r * h, e[2] = -a * h, e[3] = s * h, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, n) {
    const s = n[0];
    return e[0] = n[3], e[1] = -n[1], e[2] = -n[2], e[3] = s, e;
  }
  /**
   * Calculates the determinant of a {@link Mat2}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    return e[0] * e[3] - e[2] * e[1];
  }
  /**
   * Adds two {@link Mat2}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e[2] = n[2] + s[2], e[3] = n[3] + s[3], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, s) {
    return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e[2] = n[2] - s[2], e[3] = n[3] - s[3], e;
  }
  /**
   * Alias for {@link Mat2.subtract}
   * @category Static
   */
  static sub(e, n, s) {
    return e;
  }
  /**
   * Multiplies two {@link Mat2}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = s[0], l = s[1], u = s[2], f = s[3];
    return e[0] = r * c + o * l, e[1] = a * c + h * l, e[2] = r * u + o * f, e[3] = a * u + h * f, e;
  }
  /**
   * Alias for {@link Mat2.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return e;
  }
  /**
   * Rotates a {@link Mat2} by the given angle
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotate(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = Math.sin(s), l = Math.cos(s);
    return e[0] = r * l + o * c, e[1] = a * l + h * c, e[2] = r * -c + o * l, e[3] = a * -c + h * l, e;
  }
  /**
   * Scales the {@link Mat2} by the dimensions in the given {@link Vec2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec2} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = s[0], l = s[1];
    return e[0] = r * c, e[1] = a * c, e[2] = o * l, e[3] = h * l, e;
  }
  /**
   * Creates a {@link Mat2} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   * @category Static
   *
   * @param out - {@link Mat2} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromRotation(e, n) {
    const s = Math.sin(n), r = Math.cos(n);
    return e[0] = r, e[1] = s, e[2] = -s, e[3] = r, e;
  }
  /**
   * Creates a {@link Mat2} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat2} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = n[1], e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat2}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3]);
  }
  /**
   * Multiply each element of a {@link Mat2} by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e;
  }
  /**
   * Adds two {@link Mat2}'s after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, s, r) {
    return e[0] = n[0] + s[0] * r, e[1] = n[1] + s[1] * r, e[2] = n[2] + s[2] * r, e[3] = n[3] + s[3] * r, e;
  }
  /**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @category Static
   *
   * @param L - the lower triangular matrix
   * @param D - the diagonal matrix
   * @param U - the upper triangular matrix
   * @param a - the input matrix to factorize
   */
  static LDU(e, n, s, r) {
    return e[2] = r[2] / r[0], s[0] = r[0], s[1] = r[1], s[3] = r[3] - e[2] * s[1], [e, n, s];
  }
  /**
   * Returns whether or not two {@link Mat2}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3];
  }
  /**
   * Returns whether or not two {@link Mat2}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = e[2], o = e[3], h = n[0], c = n[1], l = n[2], u = n[3];
    return Math.abs(s - h) <= ct * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(r - c) <= ct * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(a - l) <= ct * Math.max(1, Math.abs(a), Math.abs(l)) && Math.abs(o - u) <= ct * Math.max(1, Math.abs(o), Math.abs(u));
  }
  /**
   * Returns a string representation of a {@link Mat2}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat2(${e.join(", ")})`;
  }
}
Ae.prototype.mul = Ae.prototype.multiply;
Ae.mul = Ae.multiply;
Ae.sub = Ae.subtract;
const ma = Ae, cy = new Float32Array([
  1,
  0,
  0,
  1,
  0,
  0
]);
class He extends Float32Array {
  /**
   * The number of bytes in a {@link Mat2d}.
   */
  static BYTE_LENGTH = 6 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 6:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 6);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n,
          n,
          n
        ]) : super(n, 0, 6);
        break;
      default:
        super(cy);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat2d.str(this);`
   */
  get str() {
    return He.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Mat2d} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat2d.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(cy), this;
  }
  /**
   * Multiplies this {@link Mat2d} against another one
   * Equivalent to `Mat2d.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return He.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat2d.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Translate this {@link Mat2d} by the given vector
   * Equivalent to `Mat2d.translate(this, this, v);`
   *
   * @param v - The {@link Vec2} to translate by
   * @returns `this`
   */
  translate(e) {
    return He.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat2d} by the given angle around the given axis
   * Equivalent to `Mat2d.rotate(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  rotate(e) {
    return He.rotate(this, this, e);
  }
  /**
   * Scales this {@link Mat2d} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat2d.scale(this, this, v);`
   *
   * @param v - The {@link Vec2} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return He.scale(this, this, e);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat2d}
   * @category Static
   *
   * @returns A new {@link Mat2d}
   */
  static create() {
    return new He();
  }
  /**
   * Creates a new {@link Mat2d} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat2d}
   */
  static clone(e) {
    return new He(e);
  }
  /**
   * Copy the values from one {@link Mat2d} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e;
  }
  /**
   * Create a new {@link Mat2d} with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat2d}
   */
  static fromValues(...e) {
    return new He(...e);
  }
  /**
   * Set the components of a {@link Mat2d} to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e;
  }
  /**
   * Set a {@link Mat2d} to the identity matrix
   * @category Static
   *
   * @param out - The receiving matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
  }
  /**
   * Inverts a {@link Mat2d}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = n[4], c = n[5];
    let l = s * o - r * a;
    return l ? (l = 1 / l, e[0] = o * l, e[1] = -r * l, e[2] = -a * l, e[3] = s * l, e[4] = (a * c - o * h) * l, e[5] = (r * h - s * c) * l, e) : null;
  }
  /**
   * Calculates the determinant of a {@link Mat2d}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    return e[0] * e[3] - e[1] * e[2];
  }
  /**
   * Adds two {@link Mat2d}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e[2] = n[2] + s[2], e[3] = n[3] + s[3], e[4] = n[4] + s[4], e[5] = n[5] + s[5], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, s) {
    return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e[2] = n[2] - s[2], e[3] = n[3] - s[3], e[4] = n[4] - s[4], e[5] = n[5] - s[5], e;
  }
  /**
   * Alias for {@link Mat2d.subtract}
   * @category Static
   */
  static sub(e, n, s) {
    return e;
  }
  /**
   * Multiplies two {@link Mat2d}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = s[0], f = s[1], d = s[2], p = s[3], y = s[4], x = s[5];
    return e[0] = r * u + o * f, e[1] = a * u + h * f, e[2] = r * d + o * p, e[3] = a * d + h * p, e[4] = r * y + o * x + c, e[5] = a * y + h * x + l, e;
  }
  /**
   * Alias for {@link Mat2d.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return e;
  }
  /**
   * Translate a {@link Mat2d} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = s[0], f = s[1];
    return e[0] = r, e[1] = a, e[2] = o, e[3] = h, e[4] = r * u + o * f + c, e[5] = a * u + h * f + l, e;
  }
  /**
   * Rotates a {@link Mat2d} by the given angle
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotate(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = Math.sin(s), f = Math.cos(s);
    return e[0] = r * f + o * u, e[1] = a * f + h * u, e[2] = r * -u + o * f, e[3] = a * -u + h * f, e[4] = c, e[5] = l, e;
  }
  /**
   * Scales the {@link Mat2d} by the dimensions in the given {@link Vec2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec2} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = s[0], f = s[1];
    return e[0] = r * u, e[1] = a * u, e[2] = o * f, e[3] = h * f, e[4] = c, e[5] = l, e;
  }
  // TODO: Got to fromRotation
  /**
   * Creates a {@link Mat2d} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     Mat2d.identity(dest);
   *     Mat2d.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat2d} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = n[0], e[5] = n[1], e;
  }
  /**
   * Creates a {@link Mat2d} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     Mat2d.identity(dest);
   *     Mat2d.rotate(dest, dest, rad);
   * @category Static
   *
   * @param out - {@link Mat2d} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromRotation(e, n) {
    const s = Math.sin(n), r = Math.cos(n);
    return e[0] = r, e[1] = s, e[2] = -s, e[3] = r, e[4] = 0, e[5] = 0, e;
  }
  /**
   * Creates a {@link Mat2d} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     Mat2d.identity(dest);
   *     Mat2d.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat2d} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = n[1], e[4] = 0, e[5] = 0, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat2d}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + 1);
  }
  /**
   * Multiply each element of a {@link Mat2d} by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e[4] = n[4] * s, e[5] = n[5] * s, e;
  }
  /**
   * Adds two {@link Mat2d}'s after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, s, r) {
    return e[0] = n[0] + s[0] * r, e[1] = n[1] + s[1] * r, e[2] = n[2] + s[2] * r, e[3] = n[3] + s[3] * r, e[4] = n[4] + s[4] * r, e[5] = n[5] + s[5] * r, e;
  }
  /**
   * Returns whether or not two {@link Mat2d}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5];
  }
  /**
   * Returns whether or not two {@link Mat2d}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = e[2], o = e[3], h = e[4], c = e[5], l = n[0], u = n[1], f = n[2], d = n[3], p = n[4], y = n[5];
    return Math.abs(s - l) <= ct * Math.max(1, Math.abs(s), Math.abs(l)) && Math.abs(r - u) <= ct * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(a - f) <= ct * Math.max(1, Math.abs(a), Math.abs(f)) && Math.abs(o - d) <= ct * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(h - p) <= ct * Math.max(1, Math.abs(h), Math.abs(p)) && Math.abs(c - y) <= ct * Math.max(1, Math.abs(c), Math.abs(y));
  }
  /**
   * Returns a string representation of a {@link Mat2d}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat2d(${e.join(", ")})`;
  }
}
He.mul = He.multiply;
He.sub = He.subtract;
const os = He, ly = new Float32Array([
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1
]);
class pe extends Float32Array {
  /**
   * The number of bytes in a {@link Mat3}.
   */
  static BYTE_LENGTH = 9 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat3}.
   */
  constructor(...e) {
    switch (e.length) {
      case 9:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 9);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n
        ]) : super(n, 0, 9);
        break;
      default:
        super(ly);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat3.str(this);`
   */
  get str() {
    return pe.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat3} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat3.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(ly), this;
  }
  /**
   * Multiplies this {@link Mat3} against another one
   * Equivalent to `Mat3.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return pe.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat3.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Transpose this {@link Mat3}
   * Equivalent to `Mat3.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return pe.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat3}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return pe.invert(this, this);
  }
  /**
   * Translate this {@link Mat3} by the given vector
   * Equivalent to `Mat3.translate(this, this, v);`
   *
   * @param v - The {@link Vec2} to translate by
   * @returns `this`
   */
  translate(e) {
    return pe.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat3} by the given angle around the given axis
   * Equivalent to `Mat3.rotate(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  rotate(e) {
    return pe.rotate(this, this, e);
  }
  /**
   * Scales this {@link Mat3} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat3.scale(this, this, v);`
   *
   * @param v - The {@link Vec2} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return pe.scale(this, this, e);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat3}
   * @category Static
   *
   * @returns A new {@link Mat3}
   */
  static create() {
    return new pe();
  }
  /**
   * Creates a new {@link Mat3} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat3}
   */
  static clone(e) {
    return new pe(e);
  }
  /**
   * Copy the values from one {@link Mat3} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e;
  }
  /**
   * Create a new {@link Mat3} with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat3}
   */
  static fromValues(...e) {
    return new pe(...e);
  }
  /**
   * Set the components of a {@link Mat3} to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e;
  }
  /**
   * Set a {@link Mat3} to the identity matrix
   * @category Static
   *
   * @param out - The receiving matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat3}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, n) {
    if (e === n) {
      const s = n[1], r = n[2], a = n[5];
      e[1] = n[3], e[2] = n[6], e[3] = s, e[5] = n[7], e[6] = r, e[7] = a;
    } else
      e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8];
    return e;
  }
  /**
   * Inverts a {@link Mat3}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8], d = f * h - c * u, p = -f * o + c * l, y = u * o - h * l;
    let x = s * d + r * p + a * y;
    return x ? (x = 1 / x, e[0] = d * x, e[1] = (-f * r + a * u) * x, e[2] = (c * r - a * h) * x, e[3] = p * x, e[4] = (f * s - a * l) * x, e[5] = (-c * s + a * o) * x, e[6] = y * x, e[7] = (-u * s + r * l) * x, e[8] = (h * s - r * o) * x, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat3}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8];
    return e[0] = h * f - c * u, e[1] = a * u - r * f, e[2] = r * c - a * h, e[3] = c * l - o * f, e[4] = s * f - a * l, e[5] = a * o - s * c, e[6] = o * u - h * l, e[7] = r * l - s * u, e[8] = s * h - r * o, e;
  }
  /**
   * Calculates the determinant of a {@link Mat3}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    const n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8];
    return n * (u * o - h * l) + s * (-u * a + h * c) + r * (l * a - o * c);
  }
  /**
   * Adds two {@link Mat3}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e[2] = n[2] + s[2], e[3] = n[3] + s[3], e[4] = n[4] + s[4], e[5] = n[5] + s[5], e[6] = n[6] + s[6], e[7] = n[7] + s[7], e[8] = n[8] + s[8], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, s) {
    return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e[2] = n[2] - s[2], e[3] = n[3] - s[3], e[4] = n[4] - s[4], e[5] = n[5] - s[5], e[6] = n[6] - s[6], e[7] = n[7] - s[7], e[8] = n[8] - s[8], e;
  }
  /**
   * Alias for {@link Mat3.subtract}
   * @category Static
   */
  static sub(e, n, s) {
    return e;
  }
  /**
   * Multiplies two {@link Mat3}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8];
    let p = s[0], y = s[1], x = s[2];
    return e[0] = p * r + y * h + x * u, e[1] = p * a + y * c + x * f, e[2] = p * o + y * l + x * d, p = s[3], y = s[4], x = s[5], e[3] = p * r + y * h + x * u, e[4] = p * a + y * c + x * f, e[5] = p * o + y * l + x * d, p = s[6], y = s[7], x = s[8], e[6] = p * r + y * h + x * u, e[7] = p * a + y * c + x * f, e[8] = p * o + y * l + x * d, e;
  }
  /**
   * Alias for {@link Mat3.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return e;
  }
  /**
   * Translate a {@link Mat3} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8], p = s[0], y = s[1];
    return e[0] = r, e[1] = a, e[2] = o, e[3] = h, e[4] = c, e[5] = l, e[6] = p * r + y * h + u, e[7] = p * a + y * c + f, e[8] = p * o + y * l + d, e;
  }
  /**
   * Rotates a {@link Mat3} by the given angle
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotate(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8], p = Math.sin(s), y = Math.cos(s);
    return e[0] = y * r + p * h, e[1] = y * a + p * c, e[2] = y * o + p * l, e[3] = y * h - p * r, e[4] = y * c - p * a, e[5] = y * l - p * o, e[6] = u, e[7] = f, e[8] = d, e;
  }
  /**
   * Scales the {@link Mat3} by the dimensions in the given {@link Vec2}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec2} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, s) {
    const r = s[0], a = s[1];
    return e[0] = r * n[0], e[1] = r * n[1], e[2] = r * n[2], e[3] = a * n[3], e[4] = a * n[4], e[5] = a * n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e;
  }
  /**
   * Creates a {@link Mat3} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat3} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = n[0], e[7] = n[1], e[8] = 1, e;
  }
  /**
   * Creates a {@link Mat3} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   * @category Static
   *
   * @param out - {@link Mat3} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromRotation(e, n) {
    const s = Math.sin(n), r = Math.cos(n);
    return e[0] = r, e[1] = s, e[2] = 0, e[3] = -s, e[4] = r, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
  }
  /**
   * Creates a {@link Mat3} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat3} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = n[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
  }
  /**
   * Copies the upper-left 3x3 values of a {@link Mat2d} into the given
   * {@link Mat3}.
   * @category Static
   *
   * @param out - the receiving 3x3 matrix
   * @param a - the source 2x3 matrix
   * @returns `out`
   */
  static fromMat2d(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = 0, e[3] = n[2], e[4] = n[3], e[5] = 0, e[6] = n[4], e[7] = n[5], e[8] = 1, e;
  }
  /**
   * Calculates a {@link Mat3} from the given quaternion
   *
   * @param out - {@link Mat3} receiving operation result
   * @param q - {@link Quat} to create matrix from
   * @returns `out`
   */
  static fromQuat(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = s + s, c = r + r, l = a + a, u = s * h, f = r * h, d = r * c, p = a * h, y = a * c, x = a * l, g = o * h, m = o * c, v = o * l;
    return e[0] = 1 - d - x, e[3] = f - v, e[6] = p + m, e[1] = f + v, e[4] = 1 - u - x, e[7] = y - g, e[2] = p - m, e[5] = y + g, e[8] = 1 - u - d, e;
  }
  /**
   * Copies the upper-left 3x3 values of a {@link Mat4} into the given
   * {@link Mat3}.
   * @category Static
   *
   * @param out - the receiving 3x3 matrix
   * @param a - the source 4x4 matrix
   * @returns `out`
   */
  static fromMat4(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[4], e[4] = n[5], e[5] = n[6], e[6] = n[8], e[7] = n[9], e[8] = n[10], e;
  }
  /**
   * Calculates a {@link Mat3} normal matrix (adjoint) from the upper 3x3 of a {@link Mat4}.
   * See https://www.shadertoy.com/view/3s33zj for details.
   * @category Static
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
   * @returns `out` or `null` if the matrix is not invertable
   */
  static normalFromMat4(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[4], h = n[5], c = n[6], l = n[8], u = n[9], f = n[10];
    return e[0] = h * f - c * u, e[1] = a * u - r * f, e[2] = r * c - a * h, e[3] = c * l - o * f, e[4] = s * f - a * l, e[5] = a * o - s * c, e[6] = o * u - h * l, e[7] = r * l - s * u, e[8] = s * h - r * o, e;
  }
  /**
   * Alias for {@link Mat3.adjointFromMat4}
   * @category Static
   * @deprecated Use {@link Mat3.normalFromMat4}
   */
  static normalFromMat4Fast(e, n) {
    return e;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   * @category Static
   *
   * @param out mat3 frustum matrix will be written into
   * @param width Width of your gl context
   * @param height Height of gl context
   * @returns `out`
   */
  static projection(e, n, s) {
    return e[0] = 2 / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / s, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat3}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(
      e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8]
    );
  }
  /**
   * Multiply each element of a {@link Mat3} by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = n[7] * s, e[8] = n[8] * s, e;
  }
  /**
   * Adds two {@link Mat3}'s after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, s, r) {
    return e[0] = n[0] + s[0] * r, e[1] = n[1] + s[1] * r, e[2] = n[2] + s[2] * r, e[3] = n[3] + s[3] * r, e[4] = n[4] + s[4] * r, e[5] = n[5] + s[5] * r, e[6] = n[6] + s[6] * r, e[7] = n[7] + s[7] * r, e[8] = n[8] + s[8] * r, e;
  }
  /**
   * Returns whether or not two {@link Mat3}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5] && e[6] === n[6] && e[7] === n[7] && e[8] === n[8];
  }
  /**
   * Returns whether or not two {@link Mat3}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = e[2], o = e[3], h = e[4], c = e[5], l = e[6], u = e[7], f = e[8], d = n[0], p = n[1], y = n[2], x = n[3], g = n[4], m = n[5], v = n[6], w = n[7], b = n[8];
    return Math.abs(s - d) <= ct * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(r - p) <= ct * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(a - y) <= ct * Math.max(1, Math.abs(a), Math.abs(y)) && Math.abs(o - x) <= ct * Math.max(1, Math.abs(o), Math.abs(x)) && Math.abs(h - g) <= ct * Math.max(1, Math.abs(h), Math.abs(g)) && Math.abs(c - m) <= ct * Math.max(1, Math.abs(c), Math.abs(m)) && Math.abs(l - v) <= ct * Math.max(1, Math.abs(l), Math.abs(v)) && Math.abs(u - w) <= ct * Math.max(1, Math.abs(u), Math.abs(w)) && Math.abs(f - b) <= ct * Math.max(1, Math.abs(f), Math.abs(b));
  }
  /**
   * Returns a string representation of a {@link Mat3}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat3(${e.join(", ")})`;
  }
}
pe.prototype.mul = pe.prototype.multiply;
pe.mul = pe.multiply;
pe.sub = pe.subtract;
pe.normalFromMat4Fast = pe.normalFromMat4;
const nm = pe, uy = new Float32Array([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]);
class kt extends Float32Array {
  /**
   * The number of bytes in a {@link Mat4}.
   */
  static BYTE_LENGTH = 16 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat4}.
   */
  constructor(...e) {
    switch (e.length) {
      case 16:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 16);
        break;
      case 1:
        const n = e[0];
        typeof n == "number" ? super([
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n,
          n
        ]) : super(n, 0, 16);
        break;
      default:
        super(uy);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat4.str(this);`
   */
  get str() {
    return kt.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat4} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat4.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(uy), this;
  }
  /**
   * Multiplies this {@link Mat4} against another one
   * Equivalent to `Mat4.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return kt.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat4.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Transpose this {@link Mat4}
   * Equivalent to `Mat4.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return kt.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat4}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return kt.invert(this, this);
  }
  /**
   * Translate this {@link Mat4} by the given vector
   * Equivalent to `Mat4.translate(this, this, v);`
   *
   * @param v - The {@link Vec3} to translate by
   * @returns `this`
   */
  translate(e) {
    return kt.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the given axis
   * Equivalent to `Mat4.rotate(this, this, rad, axis);`
   *
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  rotate(e, n) {
    return kt.rotate(this, this, e, n);
  }
  /**
   * Scales this {@link Mat4} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat4.scale(this, this, v);`
   *
   * @param v - The {@link Vec3} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return kt.scale(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the X axis
   * Equivalent to `Mat4.rotateX(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateX(e) {
    return kt.rotateX(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Y axis
   * Equivalent to `Mat4.rotateY(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateY(e) {
    return kt.rotateY(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Z axis
   * Equivalent to `Mat4.rotateZ(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateZ(e) {
    return kt.rotateZ(this, this, e);
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveNO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveNO(e, n, s, r) {
    return kt.perspectiveNO(this, e, n, s, r);
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveZO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveZO(e, n, s, r) {
    return kt.perspectiveZO(this, e, n, s, r);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Equivalent to `Mat4.orthoNO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoNO(e, n, s, r, a, o) {
    return kt.orthoNO(this, e, n, s, r, a, o);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Equivalent to `Mat4.orthoZO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoZO(e, n, s, r, a, o) {
    return kt.orthoZO(this, e, n, s, r, a, o);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat4}
   * @category Static
   *
   * @returns A new {@link Mat4}
   */
  static create() {
    return new kt();
  }
  /**
   * Creates a new {@link Mat4} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat4}
   */
  static clone(e) {
    return new kt(e);
  }
  /**
   * Copy the values from one {@link Mat4} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e;
  }
  /**
   * Create a new mat4 with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat4}
   */
  static fromValues(...e) {
    return new kt(...e);
  }
  /**
   * Set the components of a mat4 to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e;
  }
  /**
   * Set a {@link Mat4} to the identity matrix
   * @category Static
   *
   * @param out - The receiving Matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, n) {
    if (e === n) {
      const s = n[1], r = n[2], a = n[3], o = n[6], h = n[7], c = n[11];
      e[1] = n[4], e[2] = n[8], e[3] = n[12], e[4] = s, e[6] = n[9], e[7] = n[13], e[8] = r, e[9] = o, e[11] = n[14], e[12] = a, e[13] = h, e[14] = c;
    } else
      e[0] = n[0], e[1] = n[4], e[2] = n[8], e[3] = n[12], e[4] = n[1], e[5] = n[5], e[6] = n[9], e[7] = n[13], e[8] = n[2], e[9] = n[6], e[10] = n[10], e[11] = n[14], e[12] = n[3], e[13] = n[7], e[14] = n[11], e[15] = n[15];
    return e;
  }
  /**
   * Inverts a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out` or `null` if the matrix is not invertable
   */
  static invert(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8], d = n[9], p = n[10], y = n[11], x = n[12], g = n[13], m = n[14], v = n[15], w = s * c - r * h, b = s * l - a * h, S = s * u - o * h, E = r * l - a * c, A = r * u - o * c, M = a * u - o * l, _ = f * g - d * x, T = f * m - p * x, C = f * v - y * x, P = d * m - p * g, R = d * v - y * g, k = p * v - y * m;
    let I = w * k - b * R + S * P + E * C - A * T + M * _;
    return I ? (I = 1 / I, e[0] = (c * k - l * R + u * P) * I, e[1] = (a * R - r * k - o * P) * I, e[2] = (g * M - m * A + v * E) * I, e[3] = (p * A - d * M - y * E) * I, e[4] = (l * C - h * k - u * T) * I, e[5] = (s * k - a * C + o * T) * I, e[6] = (m * S - x * M - v * b) * I, e[7] = (f * M - p * S + y * b) * I, e[8] = (h * R - c * C + u * _) * I, e[9] = (r * C - s * R - o * _) * I, e[10] = (x * A - g * S + v * w) * I, e[11] = (d * S - f * A - y * w) * I, e[12] = (c * T - h * P - l * _) * I, e[13] = (s * P - r * T + a * _) * I, e[14] = (g * b - x * E - m * w) * I, e[15] = (f * E - d * b + p * w) * I, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = n[4], c = n[5], l = n[6], u = n[7], f = n[8], d = n[9], p = n[10], y = n[11], x = n[12], g = n[13], m = n[14], v = n[15], w = s * c - r * h, b = s * l - a * h, S = s * u - o * h, E = r * l - a * c, A = r * u - o * c, M = a * u - o * l, _ = f * g - d * x, T = f * m - p * x, C = f * v - y * x, P = d * m - p * g, R = d * v - y * g, k = p * v - y * m;
    return e[0] = c * k - l * R + u * P, e[1] = a * R - r * k - o * P, e[2] = g * M - m * A + v * E, e[3] = p * A - d * M - y * E, e[4] = l * C - h * k - u * T, e[5] = s * k - a * C + o * T, e[6] = m * S - x * M - v * b, e[7] = f * M - p * S + y * b, e[8] = h * R - c * C + u * _, e[9] = r * C - s * R - o * _, e[10] = x * A - g * S + v * w, e[11] = d * S - f * A - y * w, e[12] = c * T - h * P - l * _, e[13] = s * P - r * T + a * _, e[14] = g * b - x * E - m * w, e[15] = f * E - d * b + p * w, e;
  }
  /**
   * Calculates the determinant of a {@link Mat4}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    const n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = e[9], d = e[10], p = e[11], y = e[12], x = e[13], g = e[14], m = e[15], v = n * h - s * o, w = n * c - r * o, b = s * c - r * h, S = u * x - f * y, E = u * g - d * y, A = f * g - d * x, M = n * A - s * E + r * S, _ = o * A - h * E + c * S, T = u * b - f * w + d * v, C = y * b - x * w + g * v;
    return l * M - a * _ + m * T - p * C;
  }
  /**
   * Multiplies two {@link Mat4}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8], p = n[9], y = n[10], x = n[11], g = n[12], m = n[13], v = n[14], w = n[15];
    let b = s[0], S = s[1], E = s[2], A = s[3];
    return e[0] = b * r + S * c + E * d + A * g, e[1] = b * a + S * l + E * p + A * m, e[2] = b * o + S * u + E * y + A * v, e[3] = b * h + S * f + E * x + A * w, b = s[4], S = s[5], E = s[6], A = s[7], e[4] = b * r + S * c + E * d + A * g, e[5] = b * a + S * l + E * p + A * m, e[6] = b * o + S * u + E * y + A * v, e[7] = b * h + S * f + E * x + A * w, b = s[8], S = s[9], E = s[10], A = s[11], e[8] = b * r + S * c + E * d + A * g, e[9] = b * a + S * l + E * p + A * m, e[10] = b * o + S * u + E * y + A * v, e[11] = b * h + S * f + E * x + A * w, b = s[12], S = s[13], E = s[14], A = s[15], e[12] = b * r + S * c + E * d + A * g, e[13] = b * a + S * l + E * p + A * m, e[14] = b * o + S * u + E * y + A * v, e[15] = b * h + S * f + E * x + A * w, e;
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return e;
  }
  /**
   * Translate a {@link Mat4} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, s) {
    const r = s[0], a = s[1], o = s[2];
    if (n === e)
      e[12] = n[0] * r + n[4] * a + n[8] * o + n[12], e[13] = n[1] * r + n[5] * a + n[9] * o + n[13], e[14] = n[2] * r + n[6] * a + n[10] * o + n[14], e[15] = n[3] * r + n[7] * a + n[11] * o + n[15];
    else {
      const h = n[0], c = n[1], l = n[2], u = n[3], f = n[4], d = n[5], p = n[6], y = n[7], x = n[8], g = n[9], m = n[10], v = n[11];
      e[0] = h, e[1] = c, e[2] = l, e[3] = u, e[4] = f, e[5] = d, e[6] = p, e[7] = y, e[8] = x, e[9] = g, e[10] = m, e[11] = v, e[12] = h * r + f * a + x * o + n[12], e[13] = c * r + d * a + g * o + n[13], e[14] = l * r + p * a + m * o + n[14], e[15] = u * r + y * a + v * o + n[15];
    }
    return e;
  }
  /**
   * Scales the {@link Mat4} by the dimensions in the given {@link Vec3} not using vectorization
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec3} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, n, s) {
    const r = s[0], a = s[1], o = s[2];
    return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = n[3] * r, e[4] = n[4] * a, e[5] = n[5] * a, e[6] = n[6] * a, e[7] = n[7] * a, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = n[11] * o, e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e;
  }
  /**
   * Rotates a {@link Mat4} by the given angle around the given axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if axis has a length of 0
   */
  static rotate(e, n, s, r) {
    let a = r[0], o = r[1], h = r[2], c = Math.sqrt(a * a + o * o + h * h);
    if (c < ct)
      return null;
    c = 1 / c, a *= c, o *= c, h *= c;
    const l = Math.sin(s), u = Math.cos(s), f = 1 - u, d = n[0], p = n[1], y = n[2], x = n[3], g = n[4], m = n[5], v = n[6], w = n[7], b = n[8], S = n[9], E = n[10], A = n[11], M = a * a * f + u, _ = o * a * f + h * l, T = h * a * f - o * l, C = a * o * f - h * l, P = o * o * f + u, R = h * o * f + a * l, k = a * h * f + o * l, I = o * h * f - a * l, L = h * h * f + u;
    return e[0] = d * M + g * _ + b * T, e[1] = p * M + m * _ + S * T, e[2] = y * M + v * _ + E * T, e[3] = x * M + w * _ + A * T, e[4] = d * C + g * P + b * R, e[5] = p * C + m * P + S * R, e[6] = y * C + v * P + E * R, e[7] = x * C + w * P + A * R, e[8] = d * k + g * I + b * L, e[9] = p * k + m * I + S * L, e[10] = y * k + v * I + E * L, e[11] = x * k + w * I + A * L, n !== e && (e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateX(e, n, s) {
    let r = Math.sin(s), a = Math.cos(s), o = n[4], h = n[5], c = n[6], l = n[7], u = n[8], f = n[9], d = n[10], p = n[11];
    return n !== e && (e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e[4] = o * a + u * r, e[5] = h * a + f * r, e[6] = c * a + d * r, e[7] = l * a + p * r, e[8] = u * a - o * r, e[9] = f * a - h * r, e[10] = d * a - c * r, e[11] = p * a - l * r, e;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateY(e, n, s) {
    let r = Math.sin(s), a = Math.cos(s), o = n[0], h = n[1], c = n[2], l = n[3], u = n[8], f = n[9], d = n[10], p = n[11];
    return n !== e && (e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e[0] = o * a - u * r, e[1] = h * a - f * r, e[2] = c * a - d * r, e[3] = l * a - p * r, e[8] = o * r + u * a, e[9] = h * r + f * a, e[10] = c * r + d * a, e[11] = l * r + p * a, e;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateZ(e, n, s) {
    let r = Math.sin(s), a = Math.cos(s), o = n[0], h = n[1], c = n[2], l = n[3], u = n[4], f = n[5], d = n[6], p = n[7];
    return n !== e && (e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e[0] = o * a + u * r, e[1] = h * a + f * r, e[2] = c * a + d * r, e[3] = l * a + p * r, e[4] = u * a - o * r, e[5] = f * a - h * r, e[6] = d * a - c * r, e[7] = p * a - l * r, e;
  }
  /**
   * Creates a {@link Mat4} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, n) {
    return e[0] = n[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = n[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out` or `null` if `axis` has a length of 0
   */
  static fromRotation(e, n, s) {
    let r = s[0], a = s[1], o = s[2], h = Math.sqrt(r * r + a * a + o * o);
    if (h < ct)
      return null;
    h = 1 / h, r *= h, a *= h, o *= h;
    const c = Math.sin(n), l = Math.cos(n), u = 1 - l;
    return e[0] = r * r * u + l, e[1] = a * r * u + o * c, e[2] = o * r * u - a * c, e[3] = 0, e[4] = r * a * u - o * c, e[5] = a * a * u + l, e[6] = o * a * u + r * c, e[7] = 0, e[8] = r * o * u + a * c, e[9] = a * o * u - r * c, e[10] = o * o * u + l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromXRotation(e, n) {
    let s = Math.sin(n), r = Math.cos(n);
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = s, e[7] = 0, e[8] = 0, e[9] = -s, e[10] = r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromYRotation(e, n) {
    let s = Math.sin(n), r = Math.cos(n);
    return e[0] = r, e[1] = 0, e[2] = -s, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = s, e[9] = 0, e[10] = r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromZRotation(e, n) {
    const s = Math.sin(n), r = Math.cos(n);
    return e[0] = r, e[1] = s, e[2] = 0, e[3] = 0, e[4] = -s, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @returns `out`
   */
  static fromRotationTranslation(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = r + r, l = a + a, u = o + o, f = r * c, d = r * l, p = r * u, y = a * l, x = a * u, g = o * u, m = h * c, v = h * l, w = h * u;
    return e[0] = 1 - (y + g), e[1] = d + w, e[2] = p - v, e[3] = 0, e[4] = d - w, e[5] = 1 - (f + g), e[6] = x + m, e[7] = 0, e[8] = p + v, e[9] = x - m, e[10] = 1 - (f + y), e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e;
  }
  /**
   * Sets a {@link Mat4} from a {@link Quat2}.
   * @category Static
   *
   * @param out - Matrix
   * @param a - Dual Quaternion
   * @returns `out`
   */
  static fromQuat2(e, n) {
    const s = -n[0], r = -n[1], a = -n[2], o = n[3], h = n[4], c = n[5], l = n[6], u = n[7];
    let f = s * s + r * r + a * a + o * o;
    return f > 0 ? (qn[0] = (h * o + u * s + c * a - l * r) * 2 / f, qn[1] = (c * o + u * r + l * s - h * a) * 2 / f, qn[2] = (l * o + u * a + h * r - c * s) * 2 / f) : (qn[0] = (h * o + u * s + c * a - l * r) * 2, qn[1] = (c * o + u * r + l * s - h * a) * 2, qn[2] = (l * o + u * a + h * r - c * s) * 2), kt.fromRotationTranslation(e, n, qn), e;
  }
  /**
   * Calculates a {@link Mat4} normal matrix (adjoint) from a {@link Mat4}
   * See https://www.shadertoy.com/view/3s33zj for details.
   * @category Static
   *
   * @param out - Matrix receiving operation result
   * @param a - Mat4 to derive the normal matrix from
   * @returns `out`
   */
  static normalFromMat4(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[4], h = n[5], c = n[6], l = n[8], u = n[9], f = n[10];
    return e[0] = h * f - c * u, e[1] = a * u - r * f, e[2] = r * c - a * h, e[3] = 0, e[4] = c * l - o * f, e[5] = s * f - a * l, e[6] = a * o - s * c, e[7] = 0, e[8] = o * u - h * l, e[9] = r * l - s * u, e[10] = s * h - r * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Alias for {@link Mat4.adjointFromMat4}
   * @category Static
   * @deprecated Use {@link Mat4.normalFromMat4}
   */
  static normalFromMat4Fast(e, n) {
    return e;
  }
  /**
   * Returns the translation vector component of a transformation
   * matrix. If a matrix is built with fromRotationTranslation,
   * the returned vector will be the same as the translation vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getTranslation(e, n) {
    return e[0] = n[12], e[1] = n[13], e[2] = n[14], e;
  }
  /**
   * Returns the scaling factor component of a transformation
   * matrix. If a matrix is built with fromRotationTranslationScale
   * with a normalized Quaternion parameter, the returned vector will be
   * the same as the scaling vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getScaling(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[4], h = n[5], c = n[6], l = n[8], u = n[9], f = n[10];
    return e[0] = Math.sqrt(s * s + r * r + a * a), e[1] = Math.sqrt(o * o + h * h + c * c), e[2] = Math.sqrt(l * l + u * u + f * f), e;
  }
  /**
   * Returns a quaternion representing the rotational component
   * of a transformation matrix. If a matrix is built with
   * fromRotationTranslation, the returned quaternion will be the
   * same as the quaternion originally supplied.
   * @category Static
   *
   * @param out - Quaternion to receive the rotation component
   * @param mat - Matrix to be decomposed (input)
   * @return `out`
   */
  static getRotation(e, n) {
    kt.getScaling(qn, n);
    const s = 1 / qn[0], r = 1 / qn[1], a = 1 / qn[2], o = n[0] * s, h = n[1] * r, c = n[2] * a, l = n[4] * s, u = n[5] * r, f = n[6] * a, d = n[8] * s, p = n[9] * r, y = n[10] * a, x = o + u + y;
    let g = 0;
    return x > 0 ? (g = Math.sqrt(x + 1) * 2, e[3] = 0.25 * g, e[0] = (f - p) / g, e[1] = (d - c) / g, e[2] = (h - l) / g) : o > u && o > y ? (g = Math.sqrt(1 + o - u - y) * 2, e[3] = (f - p) / g, e[0] = 0.25 * g, e[1] = (h + l) / g, e[2] = (d + c) / g) : u > y ? (g = Math.sqrt(1 + u - o - y) * 2, e[3] = (d - c) / g, e[0] = (h + l) / g, e[1] = 0.25 * g, e[2] = (f + p) / g) : (g = Math.sqrt(1 + y - o - u) * 2, e[3] = (h - l) / g, e[0] = (d + c) / g, e[1] = (f + p) / g, e[2] = 0.25 * g), e;
  }
  /**
   * Decomposes a transformation matrix into its rotation, translation
   * and scale components. Returns only the rotation component
   * @category Static
   *
   * @param out_r - Quaternion to receive the rotation component
   * @param out_t - Vector to receive the translation vector
   * @param out_s - Vector to receive the scaling factor
   * @param mat - Matrix to be decomposed (input)
   * @returns `out_r`
   */
  static decompose(e, n, s, r) {
    n[0] = r[12], n[1] = r[13], n[2] = r[14];
    const a = r[0], o = r[1], h = r[2], c = r[4], l = r[5], u = r[6], f = r[8], d = r[9], p = r[10];
    s[0] = Math.sqrt(a * a + o * o + h * h), s[1] = Math.sqrt(c * c + l * l + u * u), s[2] = Math.sqrt(f * f + d * d + p * p);
    const y = 1 / s[0], x = 1 / s[1], g = 1 / s[2], m = a * y, v = o * x, w = h * g, b = c * y, S = l * x, E = u * g, A = f * y, M = d * x, _ = p * g, T = m + S + _;
    let C = 0;
    return T > 0 ? (C = Math.sqrt(T + 1) * 2, e[3] = 0.25 * C, e[0] = (E - M) / C, e[1] = (A - w) / C, e[2] = (v - b) / C) : m > S && m > _ ? (C = Math.sqrt(1 + m - S - _) * 2, e[3] = (E - M) / C, e[0] = 0.25 * C, e[1] = (v + b) / C, e[2] = (A + w) / C) : S > _ ? (C = Math.sqrt(1 + S - m - _) * 2, e[3] = (A - w) / C, e[0] = (v + b) / C, e[1] = 0.25 * C, e[2] = (E + M) / C) : (C = Math.sqrt(1 + _ - m - S) * 2, e[3] = (v - b) / C, e[0] = (A + w) / C, e[1] = (E + M) / C, e[2] = 0.25 * C), e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @returns `out`
   */
  static fromRotationTranslationScale(e, n, s, r) {
    const a = n[0], o = n[1], h = n[2], c = n[3], l = a + a, u = o + o, f = h + h, d = a * l, p = a * u, y = a * f, x = o * u, g = o * f, m = h * f, v = c * l, w = c * u, b = c * f, S = r[0], E = r[1], A = r[2];
    return e[0] = (1 - (x + m)) * S, e[1] = (p + b) * S, e[2] = (y - w) * S, e[3] = 0, e[4] = (p - b) * E, e[5] = (1 - (d + m)) * E, e[6] = (g + v) * E, e[7] = 0, e[8] = (y + w) * A, e[9] = (g - v) * A, e[10] = (1 - (d + x)) * A, e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @param o - The origin vector around which to scale and rotate
   * @returns `out`
   */
  static fromRotationTranslationScaleOrigin(e, n, s, r, a) {
    const o = n[0], h = n[1], c = n[2], l = n[3], u = o + o, f = h + h, d = c + c, p = o * u, y = o * f, x = o * d, g = h * f, m = h * d, v = c * d, w = l * u, b = l * f, S = l * d, E = r[0], A = r[1], M = r[2], _ = a[0], T = a[1], C = a[2], P = (1 - (g + v)) * E, R = (y + S) * E, k = (x - b) * E, I = (y - S) * A, L = (1 - (p + v)) * A, F = (m + w) * A, B = (x + b) * M, V = (m - w) * M, J = (1 - (p + g)) * M;
    return e[0] = P, e[1] = R, e[2] = k, e[3] = 0, e[4] = I, e[5] = L, e[6] = F, e[7] = 0, e[8] = B, e[9] = V, e[10] = J, e[11] = 0, e[12] = s[0] + _ - (P * _ + I * T + B * C), e[13] = s[1] + T - (R * _ + L * T + V * C), e[14] = s[2] + C - (k * _ + F * T + J * C), e[15] = 1, e;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Quaternion to create matrix from
   * @returns `out`
   */
  static fromQuat(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = s + s, c = r + r, l = a + a, u = s * h, f = r * h, d = r * c, p = a * h, y = a * c, x = a * l, g = o * h, m = o * c, v = o * l;
    return e[0] = 1 - d - x, e[1] = f + v, e[2] = p - m, e[3] = 0, e[4] = f - v, e[5] = 1 - u - x, e[6] = y + g, e[7] = 0, e[8] = p + m, e[9] = y - g, e[10] = 1 - u - d, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far -  Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumNO(e, n, s, r, a, o, h = 1 / 0) {
    const c = 1 / (s - n), l = 1 / (a - r);
    if (e[0] = o * 2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = o * 2 * l, e[6] = 0, e[7] = 0, e[8] = (s + n) * c, e[9] = (a + r) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, h != null && h !== 1 / 0) {
      const u = 1 / (o - h);
      e[10] = (h + o) * u, e[14] = 2 * h * o * u;
    } else
      e[10] = -1, e[14] = -2 * o;
    return e;
  }
  /**
   * Alias for {@link Mat4.frustumNO}
   * @category Static
   * @deprecated Use {@link Mat4.frustumNO} or {@link Mat4.frustumZO} explicitly
   */
  static frustum(e, n, s, r, a, o, h = 1 / 0) {
    return e;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static frustumZO(e, n, s, r, a, o, h = 1 / 0) {
    const c = 1 / (s - n), l = 1 / (a - r);
    if (e[0] = o * 2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = o * 2 * l, e[6] = 0, e[7] = 0, e[8] = (s + n) * c, e[9] = (a + r) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, h != null && h !== 1 / 0) {
      const u = 1 / (o - h);
      e[10] = h * u, e[14] = h * o * u;
    } else
      e[10] = -1, e[14] = -o;
    return e;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveNO(e, n, s, r, a = 1 / 0) {
    const o = 1 / Math.tan(n / 2);
    if (e[0] = o / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = o, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, a != null && a !== 1 / 0) {
      const h = 1 / (r - a);
      e[10] = (a + r) * h, e[14] = 2 * a * r * h;
    } else
      e[10] = -1, e[14] = -2 * r;
    return e;
  }
  /**
   * Alias for {@link Mat4.perspectiveNO}
   * @category Static
   * @deprecated Use {@link Mat4.perspectiveNO} or {@link Mat4.perspectiveZO} explicitly
   */
  static perspective(e, n, s, r, a = 1 / 0) {
    return e;
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveZO(e, n, s, r, a = 1 / 0) {
    const o = 1 / Math.tan(n / 2);
    if (e[0] = o / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = o, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, a != null && a !== 1 / 0) {
      const h = 1 / (r - a);
      e[10] = a * h, e[14] = a * r * h;
    } else
      e[10] = -1, e[14] = -r;
    return e;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fov - Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   * @deprecated
   */
  static perspectiveFromFieldOfView(e, n, s, r) {
    const a = Math.tan(n.upDegrees * Math.PI / 180), o = Math.tan(n.downDegrees * Math.PI / 180), h = Math.tan(n.leftDegrees * Math.PI / 180), c = Math.tan(n.rightDegrees * Math.PI / 180), l = 2 / (h + c), u = 2 / (a + o);
    return e[0] = l, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = u, e[6] = 0, e[7] = 0, e[8] = -((h - c) * l * 0.5), e[9] = (a - o) * u * 0.5, e[10] = r / (s - r), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = r * s / (s - r), e[15] = 0, e;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoNO(e, n, s, r, a, o, h) {
    const c = 1 / (n - s), l = 1 / (r - a), u = 1 / (o - h);
    return e[0] = -2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (n + s) * c, e[13] = (a + r) * l, e[14] = (h + o) * u, e[15] = 1, e;
  }
  /**
   * Alias for {@link Mat4.orthoNO}
   * @category Static
   * @deprecated Use {@link Mat4.orthoNO} or {@link Mat4.orthoZO} explicitly
   */
  static ortho(e, n, s, r, a, o, h) {
    return e;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoZO(e, n, s, r, a, o, h) {
    const c = 1 / (n - s), l = 1 / (r - a), u = 1 / (o - h);
    return e[0] = -2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = u, e[11] = 0, e[12] = (n + s) * c, e[13] = (a + r) * l, e[14] = o * u, e[15] = 1, e;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param center - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static lookAt(e, n, s, r) {
    const a = n[0], o = n[1], h = n[2], c = r[0], l = r[1], u = r[2], f = s[0], d = s[1], p = s[2];
    if (Math.abs(a - f) < ct && Math.abs(o - d) < ct && Math.abs(h - p) < ct)
      return kt.identity(e);
    let y = a - f, x = o - d, g = h - p, m = 1 / Math.sqrt(y * y + x * x + g * g);
    y *= m, x *= m, g *= m;
    let v = l * g - u * x, w = u * y - c * g, b = c * x - l * y;
    m = Math.sqrt(v * v + w * w + b * b), m ? (m = 1 / m, v *= m, w *= m, b *= m) : (v = 0, w = 0, b = 0);
    let S = x * b - g * w, E = g * v - y * b, A = y * w - x * v;
    return m = Math.sqrt(S * S + E * E + A * A), m ? (m = 1 / m, S *= m, E *= m, A *= m) : (S = 0, E = 0, A = 0), e[0] = v, e[1] = S, e[2] = y, e[3] = 0, e[4] = w, e[5] = E, e[6] = x, e[7] = 0, e[8] = b, e[9] = A, e[10] = g, e[11] = 0, e[12] = -(v * a + w * o + b * h), e[13] = -(S * a + E * o + A * h), e[14] = -(y * a + x * o + g * h), e[15] = 1, e;
  }
  /**
   * Generates a matrix that makes something look at something else.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param target - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static targetTo(e, n, s, r) {
    const a = n[0], o = n[1], h = n[2], c = r[0], l = r[1], u = r[2];
    let f = a - s[0], d = o - s[1], p = h - s[2], y = f * f + d * d + p * p;
    y > 0 && (y = 1 / Math.sqrt(y), f *= y, d *= y, p *= y);
    let x = l * p - u * d, g = u * f - c * p, m = c * d - l * f;
    return y = x * x + g * g + m * m, y > 0 && (y = 1 / Math.sqrt(y), x *= y, g *= y, m *= y), e[0] = x, e[1] = g, e[2] = m, e[3] = 0, e[4] = d * m - p * g, e[5] = p * x - f * m, e[6] = f * g - d * x, e[7] = 0, e[8] = f, e[9] = d, e[10] = p, e[11] = 0, e[12] = a, e[13] = o, e[14] = h, e[15] = 1, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat4}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(
      e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8] + e[9] * e[9] + e[10] * e[10] + e[11] * e[11] + e[12] * e[12] + e[13] * e[13] + e[14] * e[14] + e[15] * e[15]
    );
  }
  /**
   * Adds two {@link Mat4}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e[2] = n[2] + s[2], e[3] = n[3] + s[3], e[4] = n[4] + s[4], e[5] = n[5] + s[5], e[6] = n[6] + s[6], e[7] = n[7] + s[7], e[8] = n[8] + s[8], e[9] = n[9] + s[9], e[10] = n[10] + s[10], e[11] = n[11] + s[11], e[12] = n[12] + s[12], e[13] = n[13] + s[13], e[14] = n[14] + s[14], e[15] = n[15] + s[15], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, s) {
    return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e[2] = n[2] - s[2], e[3] = n[3] - s[3], e[4] = n[4] - s[4], e[5] = n[5] - s[5], e[6] = n[6] - s[6], e[7] = n[7] - s[7], e[8] = n[8] - s[8], e[9] = n[9] - s[9], e[10] = n[10] - s[10], e[11] = n[11] - s[11], e[12] = n[12] - s[12], e[13] = n[13] - s[13], e[14] = n[14] - s[14], e[15] = n[15] - s[15], e;
  }
  /**
   * Alias for {@link Mat4.subtract}
   * @category Static
   */
  static sub(e, n, s) {
    return e;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = n[7] * s, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = n[11] * s, e[12] = n[12] * s, e[13] = n[13] * s, e[14] = n[14] * s, e[15] = n[15] * s, e;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, n, s, r) {
    return e[0] = n[0] + s[0] * r, e[1] = n[1] + s[1] * r, e[2] = n[2] + s[2] * r, e[3] = n[3] + s[3] * r, e[4] = n[4] + s[4] * r, e[5] = n[5] + s[5] * r, e[6] = n[6] + s[6] * r, e[7] = n[7] + s[7] * r, e[8] = n[8] + s[8] * r, e[9] = n[9] + s[9] * r, e[10] = n[10] + s[10] * r, e[11] = n[11] + s[11] * r, e[12] = n[12] + s[12] * r, e[13] = n[13] + s[13] * r, e[14] = n[14] + s[14] * r, e[15] = n[15] + s[15] * r, e;
  }
  /**
   * Returns whether or not two {@link Mat4}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5] && e[6] === n[6] && e[7] === n[7] && e[8] === n[8] && e[9] === n[9] && e[10] === n[10] && e[11] === n[11] && e[12] === n[12] && e[13] === n[13] && e[14] === n[14] && e[15] === n[15];
  }
  /**
   * Returns whether or not two {@link Mat4}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = e[2], o = e[3], h = e[4], c = e[5], l = e[6], u = e[7], f = e[8], d = e[9], p = e[10], y = e[11], x = e[12], g = e[13], m = e[14], v = e[15], w = n[0], b = n[1], S = n[2], E = n[3], A = n[4], M = n[5], _ = n[6], T = n[7], C = n[8], P = n[9], R = n[10], k = n[11], I = n[12], L = n[13], F = n[14], B = n[15];
    return Math.abs(s - w) <= ct * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(r - b) <= ct * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(a - S) <= ct * Math.max(1, Math.abs(a), Math.abs(S)) && Math.abs(o - E) <= ct * Math.max(1, Math.abs(o), Math.abs(E)) && Math.abs(h - A) <= ct * Math.max(1, Math.abs(h), Math.abs(A)) && Math.abs(c - M) <= ct * Math.max(1, Math.abs(c), Math.abs(M)) && Math.abs(l - _) <= ct * Math.max(1, Math.abs(l), Math.abs(_)) && Math.abs(u - T) <= ct * Math.max(1, Math.abs(u), Math.abs(T)) && Math.abs(f - C) <= ct * Math.max(1, Math.abs(f), Math.abs(C)) && Math.abs(d - P) <= ct * Math.max(1, Math.abs(d), Math.abs(P)) && Math.abs(p - R) <= ct * Math.max(1, Math.abs(p), Math.abs(R)) && Math.abs(y - k) <= ct * Math.max(1, Math.abs(y), Math.abs(k)) && Math.abs(x - I) <= ct * Math.max(1, Math.abs(x), Math.abs(I)) && Math.abs(g - L) <= ct * Math.max(1, Math.abs(g), Math.abs(L)) && Math.abs(m - F) <= ct * Math.max(1, Math.abs(m), Math.abs(F)) && Math.abs(v - B) <= ct * Math.max(1, Math.abs(v), Math.abs(B));
  }
  /**
   * Returns a string representation of a {@link Mat4}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat4(${e.join(", ")})`;
  }
}
const qn = new Float32Array(3);
kt.prototype.mul = kt.prototype.multiply;
kt.sub = kt.subtract;
kt.mul = kt.multiply;
kt.frustum = kt.frustumNO;
kt.perspective = kt.perspectiveNO;
kt.ortho = kt.orthoNO;
kt.normalFromMat4Fast = kt.normalFromMat4;
const im = kt;
class vt extends Float32Array {
  /**
  * The number of bytes in a {@link Vec3}.
  */
  static BYTE_LENGTH = 3 * Float32Array.BYTES_PER_ELEMENT;
  /**
  * Create a {@link Vec3}.
  */
  constructor(...e) {
    switch (e.length) {
      case 3:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 3);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n]) : super(n, 0, 3);
        break;
      }
      default:
        super(3);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color components
   */
  get b() {
    return this[2];
  }
  set b(e) {
    this[2] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec3.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    const e = this[0], n = this[1], s = this[2];
    return Math.sqrt(e * e + n * n + s * s);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec3.squaredMagnitude(this);`
   */
  get squaredMagnitude() {
    const e = this[0], n = this[1], s = this[2];
    return e * e + n * n + s * s;
  }
  /**
   * Alias for {@link Vec3.squaredMagnitude}
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec3.str(this);`
   */
  get str() {
    return vt.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec3} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Adds a {@link Vec3} to `this`.
   * Equivalent to `Vec3.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this[2] += e[2], this;
  }
  /**
   * Subtracts a {@link Vec3} from `this`.
   * Equivalent to `Vec3.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this[2] -= e[2], this;
  }
  /**
   * Alias for {@link Vec3.subtract}
   */
  sub(e) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec3}.
   * Equivalent to `Vec3.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this[2] *= e[2], this;
  }
  /**
   * Alias for {@link Vec3.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec3}.
   * Equivalent to `Vec3.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this[2] /= e[2], this;
  }
  /**
   * Alias for {@link Vec3.divide}
   */
  div(e) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec3.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec3.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, n) {
    return this[0] += e[0] * n, this[1] += e[1] * n, this[2] += e[2] * n, this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return vt.distance(this, e);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  dist(e) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return vt.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  sqrDist(e) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec3.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this[2] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec3.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this[2] = 1 / this[2], this;
  }
  /**
   * Sets each component of `this` to it's absolute value.
   * Equivalent to `Vec3.abs(this, this);`
   *
   * @returns `this`
   */
  abs() {
    return this[0] = Math.abs(this[0]), this[1] = Math.abs(this[1]), this[2] = Math.abs(this[2]), this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec3}.
   * Equivalent to `Vec3.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1] + this[2] * e[2];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec3.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return vt.normalize(this, this);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, empty vec3
   * @category Static
   *
   * @returns a new 3D vector
   */
  static create() {
    return new vt();
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 3D vector
   */
  static clone(e) {
    return new vt(e);
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec3}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(e) {
    let n = e[0], s = e[1], r = e[2];
    return Math.sqrt(n * n + s * s + r * r);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Creates a new vec3 initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns a new 3D vector
   */
  static fromValues(e, n, s) {
    return new vt(e, n, s);
  }
  /**
   * Copy the values from one vec3 to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e;
  }
  /**
   * Set the components of a vec3 to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns `out`
   */
  static set(e, n, s, r) {
    return e[0] = n, e[1] = s, e[2] = r, e;
  }
  /**
   * Adds two {@link Vec3}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e[2] = n[2] + s[2], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, s) {
    return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e[2] = n[2] - s[2], e;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Static
   */
  static sub(e, n, s) {
    return [0, 0, 0];
  }
  /**
   * Multiplies two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    return e[0] = n[0] * s[0], e[1] = n[1] * s[1], e[2] = n[2] * s[2], e;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return [0, 0, 0];
  }
  /**
   * Divides two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(e, n, s) {
    return e[0] = n[0] / s[0], e[1] = n[1] / s[1], e[2] = n[2] / s[2], e;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Static
   */
  static div(e, n, s) {
    return [0, 0, 0];
  }
  /**
   * Math.ceil the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(e, n) {
    return e[0] = Math.ceil(n[0]), e[1] = Math.ceil(n[1]), e[2] = Math.ceil(n[2]), e;
  }
  /**
   * Math.floor the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(e, n) {
    return e[0] = Math.floor(n[0]), e[1] = Math.floor(n[1]), e[2] = Math.floor(n[2]), e;
  }
  /**
   * Returns the minimum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(e, n, s) {
    return e[0] = Math.min(n[0], s[0]), e[1] = Math.min(n[1], s[1]), e[2] = Math.min(n[2], s[2]), e;
  }
  /**
   * Returns the maximum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(e, n, s) {
    return e[0] = Math.max(n[0], s[0]), e[1] = Math.max(n[1], s[1]), e[2] = Math.max(n[2], s[2]), e;
  }
  /**
   * symmetric round the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  /*static round(out: Vec3Like, a: Readonly<Vec3Like>): Vec3Like {
    out[0] = glMatrix.round(a[0]);
    out[1] = glMatrix.round(a[1]);
    out[2] = glMatrix.round(a[2]);
    return out;
  }*/
  /**
   * Scales a vec3 by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, n, s, r) {
    return e[0] = n[0] + s[0] * r, e[1] = n[1] + s[1] * r, e[2] = n[2] + s[2] * r, e;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(e, n) {
    const s = n[0] - e[0], r = n[1] - e[1], a = n[2] - e[2];
    return Math.sqrt(s * s + r * r + a * a);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  static dist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(e, n) {
    const s = n[0] - e[0], r = n[1] - e[1], a = n[2] - e[2];
    return s * s + r * r + a * a;
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  static sqrDist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared length of a vec3
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    const n = e[0], s = e[1], r = e[2];
    return n * n + s * s + r * r;
  }
  /**
   * Alias for {@link Vec3.squaredLength}
   */
  static sqrLen(e, n) {
    return 0;
  }
  /**
   * Negates the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e;
  }
  /**
   * Returns the inverse of the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(e, n) {
    return e[0] = 1 / n[0], e[1] = 1 / n[1], e[2] = 1 / n[2], e;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec3}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(e, n) {
    return e[0] = Math.abs(n[0]), e[1] = Math.abs(n[1]), e[2] = Math.abs(n[2]), e;
  }
  /**
   * Normalize a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    const s = n[0], r = n[1], a = n[2];
    let o = s * s + r * r + a * a;
    return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = n[0] * o, e[1] = n[1] * o, e[2] = n[2] * o, e;
  }
  /**
   * Calculates the dot product of two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2];
  }
  /**
   * Computes the cross product of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static cross(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = s[0], c = s[1], l = s[2];
    return e[0] = a * l - o * c, e[1] = o * h - r * l, e[2] = r * c - a * h, e;
  }
  /**
   * Performs a linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, s, r) {
    const a = n[0], o = n[1], h = n[2];
    return e[0] = a + r * (s[0] - a), e[1] = o + r * (s[1] - o), e[2] = h + r * (s[2] - h), e;
  }
  /**
   * Performs a spherical linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(e, n, s, r) {
    const a = Math.acos(Math.min(Math.max(vt.dot(n, s), -1), 1)), o = Math.sin(a), h = Math.sin((1 - r) * a) / o, c = Math.sin(r * a) / o;
    return e[0] = h * n[0] + c * s[0], e[1] = h * n[1] + c * s[1], e[2] = h * n[2] + c * s[2], e;
  }
  /**
   * Performs a hermite interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static hermite(e, n, s, r, a, o) {
    const h = o * o, c = h * (2 * o - 3) + 1, l = h * (o - 2) + o, u = h * (o - 1), f = h * (3 - 2 * o);
    return e[0] = n[0] * c + s[0] * l + r[0] * u + a[0] * f, e[1] = n[1] * c + s[1] * l + r[1] * u + a[1] * f, e[2] = n[2] * c + s[2] * l + r[2] * u + a[2] * f, e;
  }
  /**
   * Performs a bezier interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static bezier(e, n, s, r, a, o) {
    const h = 1 - o, c = h * h, l = o * o, u = c * h, f = 3 * o * c, d = 3 * l * h, p = l * o;
    return e[0] = n[0] * u + s[0] * f + r[0] * d + a[0] * p, e[1] = n[1] * u + s[1] * f + r[1] * d + a[1] * p, e[2] = n[2] * u + s[2] * f + r[2] * d + a[2] * p, e;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
   * @returns `out`
   */
  /*static random(out: Vec3Like, scale) {
      scale = scale === undefined ? 1.0 : scale;
  
      let r = glMatrix.RANDOM() * 2.0 * Math.PI;
      let z = glMatrix.RANDOM() * 2.0 - 1.0;
      let zScale = Math.sqrt(1.0 - z * z) * scale;
  
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale;
      return out;
    }*/
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = s[3] * r + s[7] * a + s[11] * o + s[15] || 1;
    return e[0] = (s[0] * r + s[4] * a + s[8] * o + s[12]) / h, e[1] = (s[1] * r + s[5] * a + s[9] * o + s[13]) / h, e[2] = (s[2] * r + s[6] * a + s[10] * o + s[14]) / h, e;
  }
  /**
   * Transforms the vec3 with a mat3.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - the 3x3 matrix to transform with
   * @returns `out`
   */
  static transformMat3(e, n, s) {
    let r = n[0], a = n[1], o = n[2];
    return e[0] = r * s[0] + a * s[3] + o * s[6], e[1] = r * s[1] + a * s[4] + o * s[7], e[2] = r * s[2] + a * s[5] + o * s[8], e;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(e, n, s) {
    const r = s[0], a = s[1], o = s[2], h = s[3] * 2, c = n[0], l = n[1], u = n[2], f = a * u - o * l, d = o * c - r * u, p = r * l - a * c, y = (a * p - o * d) * 2, x = (o * f - r * p) * 2, g = (r * d - a * f) * 2;
    return e[0] = c + f * h + y, e[1] = l + d * h + x, e[2] = u + p * h + g, e;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateX(e, n, s, r) {
    const a = s[1], o = s[2], h = n[1] - a, c = n[2] - o;
    return e[0] = n[0], e[1] = h * Math.cos(r) - c * Math.sin(r) + a, e[2] = h * Math.sin(r) + c * Math.cos(r) + o, e;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateY(e, n, s, r) {
    const a = s[0], o = s[2], h = n[0] - a, c = n[2] - o;
    return e[0] = c * Math.sin(r) + h * Math.cos(r) + a, e[1] = n[1], e[2] = c * Math.cos(r) - h * Math.sin(r) + o, e;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateZ(e, n, s, r) {
    const a = s[0], o = s[1], h = n[0] - a, c = n[1] - o;
    return e[0] = h * Math.cos(r) - c * Math.sin(r) + a, e[1] = h * Math.sin(r) + c * Math.cos(r) + o, e[2] = s[2], e;
  }
  /**
   * Get the angle between two 3D vectors
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(e, n) {
    const s = e[0], r = e[1], a = e[2], o = n[0], h = n[1], c = n[2], l = Math.sqrt((s * s + r * r + a * a) * (o * o + h * h + c * c)), u = l && vt.dot(e, n) / l;
    return Math.acos(Math.min(Math.max(u, -1), 1));
  }
  /**
   * Set the components of a vec3 to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e;
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Vec3(${e.join(", ")})`;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = e[2], o = n[0], h = n[1], c = n[2];
    return Math.abs(s - o) <= ct * Math.max(1, Math.abs(s), Math.abs(o)) && Math.abs(r - h) <= ct * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(a - c) <= ct * Math.max(1, Math.abs(a), Math.abs(c));
  }
}
vt.prototype.sub = vt.prototype.subtract;
vt.prototype.mul = vt.prototype.multiply;
vt.prototype.div = vt.prototype.divide;
vt.prototype.dist = vt.prototype.distance;
vt.prototype.sqrDist = vt.prototype.squaredDistance;
vt.sub = vt.subtract;
vt.mul = vt.multiply;
vt.div = vt.divide;
vt.dist = vt.distance;
vt.sqrDist = vt.squaredDistance;
vt.sqrLen = vt.squaredLength;
vt.mag = vt.magnitude;
vt.length = vt.magnitude;
vt.len = vt.magnitude;
const Fi = vt;
class gt extends Float32Array {
  /**
   * The number of bytes in a {@link Vec4}.
   */
  static BYTE_LENGTH = 4 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Vec4}.
   */
  constructor(...e) {
    switch (e.length) {
      case 4:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 4);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n, n]) : super(n, 0, 4);
        break;
      }
      default:
        super(4);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  /**
   * The w component of the vector. Equivalent to `this[3];`
   * @category Vector components
   */
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color components
   */
  get b() {
    return this[2];
  }
  set b(e) {
    this[2] = e;
  }
  /**
   * The a component of the vector. Equivalent to `this[3];`
   * @category Color components
   */
  get a() {
    return this[3];
  }
  set a(e) {
    this[3] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec4.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    const e = this[0], n = this[1], s = this[2], r = this[3];
    return Math.sqrt(e * e + n * n + s * s + r * r);
  }
  /**
   * Alias for {@link Vec4.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec4.str(this);`
   */
  get str() {
    return gt.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec4} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return super.set(e), this;
  }
  /**
   * Adds a {@link Vec4} to `this`.
   * Equivalent to `Vec4.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this[2] += e[2], this[3] += e[3], this;
  }
  /**
   * Subtracts a {@link Vec4} from `this`.
   * Equivalent to `Vec4.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this[2] -= e[2], this[3] -= e[3], this;
  }
  /**
   * Alias for {@link Vec4.subtract}
   */
  sub(e) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec4}.
   * Equivalent to `Vec4.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this[2] *= e[2], this[3] *= e[3], this;
  }
  /**
   * Alias for {@link Vec4.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec4}.
   * Equivalent to `Vec4.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this[2] /= e[2], this[3] /= e[3], this;
  }
  /**
   * Alias for {@link Vec4.divide}
   */
  div(e) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec4.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this[3] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec4.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, n) {
    return this[0] += e[0] * n, this[1] += e[1] * n, this[2] += e[2] * n, this[3] += e[3] * n, this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec4} and `this`.
   * Equivalent to `Vec4.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return gt.distance(this, e);
  }
  /**
   * Alias for {@link Vec4.distance}
   */
  dist(e) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec4} and `this`.
   * Equivalent to `Vec4.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return gt.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec4.squaredDistance}
   */
  sqrDist(e) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec4.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this[2] *= -1, this[3] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec4.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this[2] = 1 / this[2], this[3] = 1 / this[3], this;
  }
  /**
   * Sets each component of `this` to it's absolute value.
   * Equivalent to `Vec4.abs(this, this);`
   *
   * @returns `this`
   */
  abs() {
    return this[0] = Math.abs(this[0]), this[1] = Math.abs(this[1]), this[2] = Math.abs(this[2]), this[3] = Math.abs(this[3]), this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec4}.
   * Equivalent to `Vec4.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1] + this[2] * e[2] + this[3] * e[3];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec4.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return gt.normalize(this, this);
  }
  //===================
  // Static methods
  //===================
  /**
   * Creates a new, empty {@link Vec4}
   * @category Static
   *
   * @returns a new 4D vector
   */
  static create() {
    return new gt();
  }
  /**
   * Creates a new {@link Vec4} initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 4D vector
   */
  static clone(e) {
    return new gt(e);
  }
  /**
   * Creates a new {@link Vec4} initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns a new 4D vector
   */
  static fromValues(e, n, s, r) {
    return new gt(e, n, s, r);
  }
  /**
   * Copy the values from one {@link Vec4} to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set the components of a {@link Vec4} to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns `out`
   */
  static set(e, n, s, r, a) {
    return e[0] = n, e[1] = s, e[2] = r, e[3] = a, e;
  }
  /**
   * Adds two {@link Vec4}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e[2] = n[2] + s[2], e[3] = n[3] + s[3], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, n, s) {
    return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e[2] = n[2] - s[2], e[3] = n[3] - s[3], e;
  }
  /**
   * Alias for {@link Vec4.subtract}
   * @category Static
   */
  static sub(e, n, s) {
    return e;
  }
  /**
   * Multiplies two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    return e[0] = n[0] * s[0], e[1] = n[1] * s[1], e[2] = n[2] * s[2], e[3] = n[3] * s[3], e;
  }
  /**
   * Alias for {@link Vec4.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return e;
  }
  /**
   * Divides two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(e, n, s) {
    return e[0] = n[0] / s[0], e[1] = n[1] / s[1], e[2] = n[2] / s[2], e[3] = n[3] / s[3], e;
  }
  /**
   * Alias for {@link Vec4.divide}
   * @category Static
   */
  static div(e, n, s) {
    return e;
  }
  /**
   * Math.ceil the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(e, n) {
    return e[0] = Math.ceil(n[0]), e[1] = Math.ceil(n[1]), e[2] = Math.ceil(n[2]), e[3] = Math.ceil(n[3]), e;
  }
  /**
   * Math.floor the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(e, n) {
    return e[0] = Math.floor(n[0]), e[1] = Math.floor(n[1]), e[2] = Math.floor(n[2]), e[3] = Math.floor(n[3]), e;
  }
  /**
   * Returns the minimum of two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(e, n, s) {
    return e[0] = Math.min(n[0], s[0]), e[1] = Math.min(n[1], s[1]), e[2] = Math.min(n[2], s[2]), e[3] = Math.min(n[3], s[3]), e;
  }
  /**
   * Returns the maximum of two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(e, n, s) {
    return e[0] = Math.max(n[0], s[0]), e[1] = Math.max(n[1], s[1]), e[2] = Math.max(n[2], s[2]), e[3] = Math.max(n[3], s[3]), e;
  }
  /**
   * Math.round the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  static round(e, n) {
    return e[0] = Math.round(n[0]), e[1] = Math.round(n[1]), e[2] = Math.round(n[2]), e[3] = Math.round(n[3]), e;
  }
  /**
   * Scales a {@link Vec4} by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e;
  }
  /**
   * Adds two {@link Vec4}'s after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, n, s, r) {
    return e[0] = n[0] + s[0] * r, e[1] = n[1] + s[1] * r, e[2] = n[2] + s[2] * r, e[3] = n[3] + s[3] * r, e;
  }
  /**
   * Calculates the euclidian distance between two {@link Vec4}'s
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(e, n) {
    const s = n[0] - e[0], r = n[1] - e[1], a = n[2] - e[2], o = n[3] - e[3];
    return Math.hypot(s, r, a, o);
  }
  /**
   * Alias for {@link Vec4.distance}
   * @category Static
   */
  static dist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two {@link Vec4}'s
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(e, n) {
    const s = n[0] - e[0], r = n[1] - e[1], a = n[2] - e[2], o = n[3] - e[3];
    return s * s + r * r + a * a + o * o;
  }
  /**
   * Alias for {@link Vec4.squaredDistance}
   * @category Static
   */
  static sqrDist(e, n) {
    return 0;
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec4}
   * @category Static
   *
   * @param a - vector to calculate length of
   * @returns length of `a`
   */
  static magnitude(e) {
    const n = e[0], s = e[1], r = e[2], a = e[3];
    return Math.sqrt(n * n + s * s + r * r + a * a);
  }
  /**
   * Alias for {@link Vec4.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec4.magnitude}
   * @category Static
   * @deprecated Use {@link Vec4.magnitude} to avoid conflicts with builtin `length` methods/attribs
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec4.magnitude}
   * @category Static
   * @deprecated Use {@link Vec4.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Vec4}
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    const n = e[0], s = e[1], r = e[2], a = e[3];
    return n * n + s * s + r * r + a * a;
  }
  /**
   * Alias for {@link Vec4.squaredLength}
   * @category Static
   */
  static sqrLen(e) {
    return 0;
  }
  /**
   * Negates the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e[3] = -n[3], e;
  }
  /**
   * Returns the inverse of the components of a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(e, n) {
    return e[0] = 1 / n[0], e[1] = 1 / n[1], e[2] = 1 / n[2], e[3] = 1 / n[3], e;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec4}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(e, n) {
    return e[0] = Math.abs(n[0]), e[1] = Math.abs(n[1]), e[2] = Math.abs(n[2]), e[3] = Math.abs(n[3]), e;
  }
  /**
   * Normalize a {@link Vec4}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3];
    let h = s * s + r * r + a * a + o * o;
    return h > 0 && (h = 1 / Math.sqrt(h)), e[0] = s * h, e[1] = r * h, e[2] = a * h, e[3] = o * h, e;
  }
  /**
   * Calculates the dot product of two {@link Vec4}'s
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2] + e[3] * n[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   * @category Static
   *
   * @param out the receiving vector
   * @param u - the first vector
   * @param v - the second vector
   * @param w - the third vector
   * @returns result
   */
  static cross(e, n, s, r) {
    const a = s[0] * r[1] - s[1] * r[0], o = s[0] * r[2] - s[2] * r[0], h = s[0] * r[3] - s[3] * r[0], c = s[1] * r[2] - s[2] * r[1], l = s[1] * r[3] - s[3] * r[1], u = s[2] * r[3] - s[3] * r[2], f = n[0], d = n[1], p = n[2], y = n[3];
    return e[0] = d * u - p * l + y * c, e[1] = -(f * u) + p * h - y * o, e[2] = f * l - d * h + y * a, e[3] = -(f * c) + d * o - p * a, e;
  }
  /**
   * Performs a linear interpolation between two {@link Vec4}'s
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, s, r) {
    const a = n[0], o = n[1], h = n[2], c = n[3];
    return e[0] = a + r * (s[0] - a), e[1] = o + r * (s[1] - o), e[2] = h + r * (s[2] - h), e[3] = c + r * (s[3] - c), e;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param [scale] - Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns `out`
   */
  /*static random(out: Vec4Like, scale): Vec4Like {
      scale = scale || 1.0;
  
      // Marsaglia, George. Choosing a Point from the Surface of a
      // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
      // http://projecteuclid.org/euclid.aoms/1177692644;
      var v1, v2, v3, v4;
      var s1, s2;
      do {
        v1 = glMatrix.RANDOM() * 2 - 1;
        v2 = glMatrix.RANDOM() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
      } while (s1 >= 1);
      do {
        v3 = glMatrix.RANDOM() * 2 - 1;
        v4 = glMatrix.RANDOM() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
      } while (s2 >= 1);
  
      var d = Math.sqrt((1 - s1) / s2);
      out[0] = scale * v1;
      out[1] = scale * v2;
      out[2] = scale * v3 * d;
      out[3] = scale * v4 * d;
      return out;
    }*/
  /**
   * Transforms the {@link Vec4} with a {@link Mat4}.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3];
    return e[0] = s[0] * r + s[4] * a + s[8] * o + s[12] * h, e[1] = s[1] * r + s[5] * a + s[9] * o + s[13] * h, e[2] = s[2] * r + s[6] * a + s[10] * o + s[14] * h, e[3] = s[3] * r + s[7] * a + s[11] * o + s[15] * h, e;
  }
  /**
   * Transforms the {@link Vec4} with a {@link Quat}
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = s[0], c = s[1], l = s[2], u = s[3], f = u * r + c * o - l * a, d = u * a + l * r - h * o, p = u * o + h * a - c * r, y = -h * r - c * a - l * o;
    return e[0] = f * u + y * -h + d * -l - p * -c, e[1] = d * u + y * -c + p * -h - f * -l, e[2] = p * u + y * -l + f * -c - d * -h, e[3] = n[3], e;
  }
  /**
   * Set the components of a {@link Vec4} to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;
  }
  /**
   * Returns a string representation of a {@link Vec4}
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Vec4(${e.join(", ")})`;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = e[2], o = e[3], h = n[0], c = n[1], l = n[2], u = n[3];
    return Math.abs(s - h) <= ct * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(r - c) <= ct * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(a - l) <= ct * Math.max(1, Math.abs(a), Math.abs(l)) && Math.abs(o - u) <= ct * Math.max(1, Math.abs(o), Math.abs(u));
  }
}
gt.prototype.sub = gt.prototype.subtract;
gt.prototype.mul = gt.prototype.multiply;
gt.prototype.div = gt.prototype.divide;
gt.prototype.dist = gt.prototype.distance;
gt.prototype.sqrDist = gt.prototype.squaredDistance;
gt.sub = gt.subtract;
gt.mul = gt.multiply;
gt.div = gt.divide;
gt.dist = gt.distance;
gt.sqrDist = gt.squaredDistance;
gt.sqrLen = gt.squaredLength;
gt.mag = gt.magnitude;
gt.length = gt.magnitude;
gt.len = gt.magnitude;
const Zs = gt;
class yt extends Float32Array {
  /**
   * The number of bytes in a {@link Quat}.
   */
  static BYTE_LENGTH = 4 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Quat}.
   */
  constructor(...e) {
    switch (e.length) {
      case 4:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 4);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n, n]) : super(n, 0, 4);
        break;
      }
      default:
        super(4), this[3] = 1;
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the quaternion. Equivalent to `this[0];`
   * @category Quaternion components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the quaternion. Equivalent to `this[1];`
   * @category Quaternion components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the quaternion. Equivalent to `this[2];`
   * @category Quaternion components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  /**
   * The w component of the quaternion. Equivalent to `this[3];`
   * @category Quaternion components
   */
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Quat.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    const e = this[0], n = this[1], s = this[2], r = this[3];
    return Math.sqrt(e * e + n * n + s * s + r * r);
  }
  /**
   * Alias for {@link Quat.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Quat.str(this);`
   */
  get str() {
    return yt.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Quat} into `this`.
   *
   * @param a the source quaternion
   * @returns `this`
   */
  copy(e) {
    return super.set(e), this;
  }
  /**
   * Set `this` to the identity quaternion
   * Equivalent to Quat.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this[0] = 0, this[1] = 0, this[2] = 0, this[3] = 1, this;
  }
  /**
   * Multiplies `this` by a {@link Quat}.
   * Equivalent to `Quat.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return yt.multiply(this, this, e);
  }
  /**
   * Alias for {@link Quat.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Rotates `this` by the given angle about the X axis
   * Equivalent to `Quat.rotateX(this, this, rad);`
   *
   * @param rad - angle (in radians) to rotate
   * @returns `this`
   */
  rotateX(e) {
    return yt.rotateX(this, this, e);
  }
  /**
   * Rotates `this` by the given angle about the Y axis
   * Equivalent to `Quat.rotateY(this, this, rad);`
   *
   * @param rad - angle (in radians) to rotate
   * @returns `this`
   */
  rotateY(e) {
    return yt.rotateY(this, this, e);
  }
  /**
   * Rotates `this` by the given angle about the Z axis
   * Equivalent to `Quat.rotateZ(this, this, rad);`
   *
   * @param rad - angle (in radians) to rotate
   * @returns `this`
   */
  rotateZ(e) {
    return yt.rotateZ(this, this, e);
  }
  /**
   * Inverts `this`
   * Equivalent to `Quat.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return yt.invert(this, this);
  }
  /**
   * Scales `this` by a scalar number
   * Equivalent to `Quat.scale(this, this, scale);`
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this[3] *= e, this;
  }
  /**
   * Calculates the dot product of `this` and another {@link Quat}
   * Equivalent to `Quat.dot(this, b);`
   *
   * @param b - the second operand
   * @returns dot product of `this` and b
   */
  dot(e) {
    return yt.dot(this, e);
  }
  //===================
  // Static methods
  //===================
  /**
   * Creates a new identity quat
   * @category Static
   *
   * @returns a new quaternion
   */
  static create() {
    return new yt();
  }
  /**
   * Set a quat to the identity quaternion
   * @category Static
   *
   * @param out - the receiving quaternion
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param axis - the axis around which to rotate
   * @param rad - the angle in radians
   * @returns `out`
   **/
  static setAxisAngle(e, n, s) {
    s = s * 0.5;
    const r = Math.sin(s);
    return e[0] = r * n[0], e[1] = r * n[1], e[2] = r * n[2], e[3] = Math.cos(s), e;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @category Static
   *
   * @param out_axis - Vector receiving the axis of rotation
   * @param q - Quaternion to be decomposed
   * @return Angle, in radians, of the rotation
   */
  static getAxisAngle(e, n) {
    const s = Math.acos(n[3]) * 2, r = Math.sin(s / 2);
    return r > ct ? (e[0] = n[0] / r, e[1] = n[1] / r, e[2] = n[2] / r) : (e[0] = 1, e[1] = 0, e[2] = 0), s;
  }
  /**
   * Gets the angular distance between two unit quaternions
   * @category Static
   *
   * @param  {ReadonlyQuat} a     Origin unit quaternion
   * @param  {ReadonlyQuat} b     Destination unit quaternion
   * @return {Number}     Angle, in radians, between the two quaternions
   */
  static getAngle(e, n) {
    const s = yt.dot(e, n);
    return Math.acos(2 * s * s - 1);
  }
  /**
   * Multiplies two quat's
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = s[0], l = s[1], u = s[2], f = s[3];
    return e[0] = r * f + h * c + a * u - o * l, e[1] = a * f + h * l + o * c - r * u, e[2] = o * f + h * u + r * l - a * c, e[3] = h * f - r * c - a * l - o * u, e;
  }
  /**
   * Rotates a quaternion by the given angle about the X axis
   * @category Static
   *
   * @param out - quat receiving operation result
   * @param a - quat to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateX(e, n, s) {
    s *= 0.5;
    const r = n[0], a = n[1], o = n[2], h = n[3], c = Math.sin(s), l = Math.cos(s);
    return e[0] = r * l + h * c, e[1] = a * l + o * c, e[2] = o * l - a * c, e[3] = h * l - r * c, e;
  }
  /**
   * Rotates a quaternion by the given angle about the Y axis
   * @category Static
   *
   * @param out - quat receiving operation result
   * @param a - quat to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateY(e, n, s) {
    s *= 0.5;
    const r = n[0], a = n[1], o = n[2], h = n[3], c = Math.sin(s), l = Math.cos(s);
    return e[0] = r * l - o * c, e[1] = a * l + h * c, e[2] = o * l + r * c, e[3] = h * l - a * c, e;
  }
  /**
   * Rotates a quaternion by the given angle about the Z axis
   * @category Static
   *
   * @param out - quat receiving operation result
   * @param a - quat to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateZ(e, n, s) {
    s *= 0.5;
    const r = n[0], a = n[1], o = n[2], h = n[3], c = Math.sin(s), l = Math.cos(s);
    return e[0] = r * l + a * c, e[1] = a * l - r * c, e[2] = o * l + h * c, e[3] = h * l - o * c, e;
  }
  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate W component of
   * @returns `out`
   */
  static calculateW(e, n) {
    const s = n[0], r = n[1], a = n[2];
    return e[0] = s, e[1] = r, e[2] = a, e[3] = Math.sqrt(Math.abs(1 - s * s - r * r - a * a)), e;
  }
  /**
   * Calculate the exponential of a unit quaternion.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate the exponential of
   * @returns `out`
   */
  static exp(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = Math.sqrt(s * s + r * r + a * a), c = Math.exp(o), l = h > 0 ? c * Math.sin(h) / h : 0;
    return e[0] = s * l, e[1] = r * l, e[2] = a * l, e[3] = c * Math.cos(h), e;
  }
  /**
   * Calculate the natural logarithm of a unit quaternion.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate the exponential of
   * @returns `out`
   */
  static ln(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = Math.sqrt(s * s + r * r + a * a), c = h > 0 ? Math.atan2(h, o) / h : 0;
    return e[0] = s * c, e[1] = r * c, e[2] = a * c, e[3] = 0.5 * Math.log(s * s + r * r + a * a + o * o), e;
  }
  /**
   * Calculate the scalar power of a unit quaternion.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate the exponential of
   * @param b - amount to scale the quaternion by
   * @returns `out`
   */
  static pow(e, n, s) {
    return yt.ln(e, n), yt.scale(e, e, s), yt.exp(e, e), e;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(e, n, s, r) {
    const a = n[0], o = n[1], h = n[2], c = n[3];
    let l = s[0], u = s[1], f = s[2], d = s[3], p, y, x = a * l + o * u + h * f + c * d;
    if (x < 0 && (x = -x, l = -l, u = -u, f = -f, d = -d), 1 - x > ct) {
      const g = Math.acos(x), m = Math.sin(g);
      p = Math.sin((1 - r) * g) / m, y = Math.sin(r * g) / m;
    } else
      p = 1 - r, y = r;
    return e[0] = p * a + y * l, e[1] = p * o + y * u, e[2] = p * h + y * f, e[3] = p * c + y * d, e;
  }
  /**
   * Generates a random unit quaternion
   * @category Static
   *
   * @param out - the receiving quaternion
   * @returns `out`
   */
  /*static random(out: QuatLike): QuatLike {
      // Implementation of http://planning.cs.uiuc.edu/node198.html
      // TODO: Calling random 3 times is probably not the fastest solution
      let u1 = glMatrix.RANDOM();
      let u2 = glMatrix.RANDOM();
      let u3 = glMatrix.RANDOM();
  
      let sqrt1MinusU1 = Math.sqrt(1 - u1);
      let sqrtU1 = Math.sqrt(u1);
  
      out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
      out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
      out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
      out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
      return out;
    }*/
  /**
   * Calculates the inverse of a quat
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate inverse of
   * @returns `out`
   */
  static invert(e, n) {
    const s = n[0], r = n[1], a = n[2], o = n[3], h = s * s + r * r + a * a + o * o, c = h ? 1 / h : 0;
    return e[0] = -s * c, e[1] = -r * c, e[2] = -a * c, e[3] = o * c, e;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quat to calculate conjugate of
   * @returns `out`
   */
  static conjugate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e[3] = n[3], e;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param m - rotation matrix
   * @returns `out`
   */
  static fromMat3(e, n) {
    const s = n[0] + n[4] + n[8];
    let r;
    if (s > 0)
      r = Math.sqrt(s + 1), e[3] = 0.5 * r, r = 0.5 / r, e[0] = (n[5] - n[7]) * r, e[1] = (n[6] - n[2]) * r, e[2] = (n[1] - n[3]) * r;
    else {
      let a = 0;
      n[4] > n[0] && (a = 1), n[8] > n[a * 3 + a] && (a = 2);
      let o = (a + 1) % 3, h = (a + 2) % 3;
      r = Math.sqrt(n[a * 3 + a] - n[o * 3 + o] - n[h * 3 + h] + 1), e[a] = 0.5 * r, r = 0.5 / r, e[3] = (n[o * 3 + h] - n[h * 3 + o]) * r, e[o] = (n[o * 3 + a] + n[a * 3 + o]) * r, e[h] = (n[h * 3 + a] + n[a * 3 + h]) * r;
    }
    return e;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param x - Angle to rotate around X axis in degrees.
   * @param y - Angle to rotate around Y axis in degrees.
   * @param z - Angle to rotate around Z axis in degrees.
   * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order - Intrinsic order for conversion, default is zyx.
   * @returns `out`
   */
  static fromEuler(e, n, s, r, a = Z3) {
    let o = 0.5 * Math.PI / 180;
    n *= o, s *= o, r *= o;
    let h = Math.sin(n), c = Math.cos(n), l = Math.sin(s), u = Math.cos(s), f = Math.sin(r), d = Math.cos(r);
    switch (a) {
      case "xyz":
        e[0] = h * u * d + c * l * f, e[1] = c * l * d - h * u * f, e[2] = c * u * f + h * l * d, e[3] = c * u * d - h * l * f;
        break;
      case "xzy":
        e[0] = h * u * d - c * l * f, e[1] = c * l * d - h * u * f, e[2] = c * u * f + h * l * d, e[3] = c * u * d + h * l * f;
        break;
      case "yxz":
        e[0] = h * u * d + c * l * f, e[1] = c * l * d - h * u * f, e[2] = c * u * f - h * l * d, e[3] = c * u * d + h * l * f;
        break;
      case "yzx":
        e[0] = h * u * d + c * l * f, e[1] = c * l * d + h * u * f, e[2] = c * u * f - h * l * d, e[3] = c * u * d - h * l * f;
        break;
      case "zxy":
        e[0] = h * u * d - c * l * f, e[1] = c * l * d + h * u * f, e[2] = c * u * f + h * l * d, e[3] = c * u * d - h * l * f;
        break;
      case "zyx":
        e[0] = h * u * d - c * l * f, e[1] = c * l * d + h * u * f, e[2] = c * u * f - h * l * d, e[3] = c * u * d + h * l * f;
        break;
      default:
        throw new Error("Unknown angle order " + a);
    }
    return e;
  }
  /**
   * Returns a string representation of a quatenion
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Quat(${e.join(", ")})`;
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   * @category Static
   *
   * @param a - quaternion to clone
   * @returns a new quaternion
   */
  static clone(e) {
    return new yt(e);
  }
  /**
   * Creates a new quat initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns a new quaternion
   */
  static fromValues(e, n, s, r) {
    return new yt(e, n, s, r);
  }
  /**
   * Copy the values from one quat to another
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the source quaternion
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set the components of a {@link Quat} to the given values
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @param w - W component
   * @returns `out`
   */
  static set(e, n, s, r, a) {
    return e;
  }
  /**
   * Adds two {@link Quat}'s
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e;
  }
  /**
   * Alias for {@link Quat.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return e;
  }
  /**
   * Scales a quat by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param b - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e;
  }
  /**
   * Calculates the dot product of two quat's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2] + e[3] * n[3];
  }
  /**
   * Performs a linear interpolation between two quat's
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, s, r) {
    return e;
  }
  /**
   * Calculates the magnitude (length) of a {@link Quat}
   * @category Static
   *
   * @param a - quaternion to calculate length of
   * @returns length of `a`
   */
  static magnitude(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.magnitude}
   * @category Static
   * @deprecated Use {@link Quat.magnitude} to avoid conflicts with builtin `length` methods/attribs
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.magnitude}
   * @category Static
   * @deprecated Use {@link Quat.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Quat}
   * @category Static
   *
   * @param a - quaternion to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat.squaredLength}
   * @category Static
   */
  static sqrLen(e) {
    return 0;
  }
  /**
   * Normalize a {@link Quat}
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - quaternion to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    return e;
  }
  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first quaternion.
   * @param b - The second quaternion.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return !1;
  }
  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, n) {
    return !1;
  }
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   * @category Static
   *
   * @param out - the receiving quaternion.
   * @param a - the initial vector
   * @param b - the destination vector
   * @returns `out`
   */
  static rotationTo(e, n, s) {
    let r = vt.dot(n, s);
    return r < -0.999999 ? (vt.cross(oi, J3, n), vt.mag(oi) < 1e-6 && vt.cross(oi, Q3, n), vt.normalize(oi, oi), yt.setAxisAngle(e, oi, Math.PI), e) : r > 0.999999 ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (vt.cross(oi, n, s), e[0] = oi[0], e[1] = oi[1], e[2] = oi[2], e[3] = 1 + r, yt.normalize(e, e));
  }
  /**
   * Performs a spherical linear interpolation with two control points
   * @category Static
   *
   * @param out - the receiving quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static sqlerp(e, n, s, r, a, o) {
    return yt.slerp(fy, n, a, o), yt.slerp(dy, s, r, o), yt.slerp(e, fy, dy, 2 * o * (1 - o)), e;
  }
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   * @category Static
   *
   * @param out - The receiving quaternion
   * @param view - the vector representing the viewing direction
   * @param right - the vector representing the local "right" direction
   * @param up - the vector representing the local "up" direction
   * @returns `out`
   */
  static setAxes(e, n, s, r) {
    return ai[0] = s[0], ai[3] = s[1], ai[6] = s[2], ai[1] = r[0], ai[4] = r[1], ai[7] = r[2], ai[2] = -n[0], ai[5] = -n[1], ai[8] = -n[2], yt.normalize(e, yt.fromMat3(e, ai));
  }
}
const fy = new Float32Array(4), dy = new Float32Array(4), ai = new Float32Array(9), oi = new Float32Array(3), J3 = new Float32Array([1, 0, 0]), Q3 = new Float32Array([0, 1, 0]);
yt.set = gt.set;
yt.add = gt.add;
yt.lerp = gt.lerp;
yt.normalize = gt.normalize;
yt.squaredLength = gt.squaredLength;
yt.sqrLen = gt.squaredLength;
yt.exactEquals = gt.exactEquals;
yt.equals = gt.equals;
yt.magnitude = gt.magnitude;
yt.prototype.mul = yt.prototype.multiply;
yt.mul = yt.multiply;
yt.mag = yt.magnitude;
yt.length = yt.magnitude;
yt.len = yt.magnitude;
const K3 = yt;
class ye extends Float32Array {
  /**
   * The number of bytes in a {@link Quat}.
   */
  static BYTE_LENGTH = 8 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Quat2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 8:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 8);
        break;
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n, n, n, n, n, n, n]) : super(n, 0, 8);
        break;
      }
      default:
        super(8), this[3] = 1;
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Quat2.str(this);`
   */
  get str() {
    return ye.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Quat2} into `this`.
   *
   * @param a the source dual quaternion
   * @returns `this`
   */
  copy(e) {
    return super.set(e), this;
  }
  //===================
  // Static methods
  //===================
  /**
   * Creates a new identity {@link Quat2}
   * @category Static
   *
   * @returns a new dual quaternion [real -> rotation, dual -> translation]
   */
  static create() {
    return new ye();
  }
  /**
   * Creates a {@link Quat2} quat initialized with values from an existing quaternion
   * @category Static
   *
   * @param a - dual quaternion to clone
   * @returns a new dual quaternion
   */
  static clone(e) {
    return new ye(e);
  }
  /**
   * Creates a new {@link Quat2}  initialized with the given values
   * @category Static
   *
   * @param x1 - 1st X component
   * @param y1 - 1st Y component
   * @param z1 - 1st Z component
   * @param w1 - 1st W component
   * @param x2 - 2nd X component
   * @param y2 - 2nd Y component
   * @param z2 - 2nd Z component
   * @param w2 - 2nd W component
   * @returns a new dual quaternion
   */
  static fromValues(e, n, s, r, a, o, h, c) {
    return new ye(e, n, s, r, a, o, h, c);
  }
  /**
   * Creates a new {@link Quat2} from the given values (quat and translation)
   * @category Static
   *
   * @param x1 - X component (rotation)
   * @param y1 - Y component (rotation)
   * @param z1 - Z component (rotation)
   * @param w1 - W component (rotation)
   * @param x2 - X component (translation)
   * @param y2 - Y component (translation)
   * @param z2 - Z component (translation)
   * @returns a new dual quaternion
   */
  static fromRotationTranslationValues(e, n, s, r, a, o, h) {
    const c = a * 0.5, l = o * 0.5, u = h * 0.5;
    return new ye(
      e,
      n,
      s,
      r,
      c * r + l * s - u * n,
      l * r + u * e - c * s,
      u * r + c * n - l * e,
      -c * e - l * n - u * s
    );
  }
  /**
   * Sets a {@link Quat2} from a quaternion and a translation
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param q - a normalized quaternion
   * @param t - translation vector
   * @returns `out`
   */
  static fromRotationTranslation(e, n, s) {
    const r = s[0] * 0.5, a = s[1] * 0.5, o = s[2] * 0.5, h = n[0], c = n[1], l = n[2], u = n[3];
    return e[0] = h, e[1] = c, e[2] = l, e[3] = u, e[4] = r * u + a * l - o * c, e[5] = a * u + o * h - r * l, e[6] = o * u + r * c - a * h, e[7] = -r * h - a * c - o * l, e;
  }
  /**
   * Sets a {@link Quat2} from a translation
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param t - translation vector
   * @returns `out`
   */
  static fromTranslation(e, n) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = n[0] * 0.5, e[5] = n[1] * 0.5, e[6] = n[2] * 0.5, e[7] = 0, e;
  }
  /**
   * Sets a {@link Quat2} from a quaternion
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param q - a normalized quaternion
   * @returns `out`
   */
  static fromRotation(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e;
  }
  /**
   * Sets a {@link Quat2} from a quaternion
   * @category Static
   *
   * @param out - dual quaternion receiving operation result
   * @param a - the matrix
   * @returns `out`
   */
  static fromMat4(e, n) {
    return kt.getRotation(py, n), kt.getTranslation(yy, n), ye.fromRotationTranslation(e, py, yy);
  }
  /**
   * Copy the values from one {@link Quat2} to another
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the source dual quaternion
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e;
  }
  /**
   * Set a {@link Quat2} to the identity dual quaternion
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e;
  }
  /**
   * Set the components of a {@link Quat2} to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x1 - 1st X component
   * @param y1 - 1st Y component
   * @param z1 - 1st Z component
   * @param w1 - 1st W component
   * @param x2 - 2nd X component
   * @param y2 - 2nd Y component
   * @param z2 - 2nd Z component
   * @param w2 - 2nd W component
   * @returns `out`
   */
  static set(e, n, s, r, a, o, h, c, l) {
    return e[0] = n, e[1] = s, e[2] = r, e[3] = a, e[4] = o, e[5] = h, e[6] = c, e[7] = l, e;
  }
  /**
   * Gets the real part of a dual quat
   * @category Static
   *
   * @param out - real part
   * @param a - Dual Quaternion
   * @return `out`
   */
  static getReal(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Gets the dual part of a dual quat
   * @category Static
   *
   * @param out - dual part
   * @param a - Dual Quaternion
   * @return `out`
   */
  static getDual(e, n) {
    return e[0] = n[4], e[1] = n[5], e[2] = n[6], e[3] = n[7], e;
  }
  /**
   * Set the real component of a {@link Quat2} to the given quaternion
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - a quaternion representing the real part
   * @return `out`
   */
  static setReal(e, n) {
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e;
  }
  /**
   * Set the dual component of a {@link Quat2} to the given quaternion
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - a quaternion representing the dual part
   * @return `out`
   */
  static setDual(e, n) {
    return e[4] = n[0], e[5] = n[1], e[6] = n[2], e[7] = n[3], e;
  }
  /**
   * Gets the translation of a normalized {@link Quat2}
   * @category Static
   *
   * @param out - the receiving translation vector
   * @param a - Dual Quaternion to be decomposed
   * @return `out`
   */
  static getTranslation(e, n) {
    const s = n[4], r = n[5], a = n[6], o = n[7], h = -n[0], c = -n[1], l = -n[2], u = n[3];
    return e[0] = (s * u + o * h + r * l - a * c) * 2, e[1] = (r * u + o * c + a * h - s * l) * 2, e[2] = (a * u + o * l + s * c - r * h) * 2, e;
  }
  /**
   * Translates a {@link Quat2} by the given vector
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = s[0] * 0.5, l = s[1] * 0.5, u = s[2] * 0.5, f = n[4], d = n[5], p = n[6], y = n[7];
    return e[0] = r, e[1] = a, e[2] = o, e[3] = h, e[4] = h * c + a * u - o * l + f, e[5] = h * l + o * c - r * u + d, e[6] = h * u + r * l - a * c + p, e[7] = -r * c - a * l - o * u + y, e;
  }
  /**
   * Rotates a {@link Quat2} around the X axis
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateX(e, n, s) {
    let r = -n[0], a = -n[1], o = -n[2], h = n[3];
    const c = n[4], l = n[5], u = n[6], f = n[7], d = c * h + f * r + l * o - u * a, p = l * h + f * a + u * r - c * o, y = u * h + f * o + c * a - l * r, x = f * h - c * r - l * a - u * o;
    return yt.rotateX(e, n, s), r = e[0], a = e[1], o = e[2], h = e[3], e[4] = d * h + x * r + p * o - y * a, e[5] = p * h + x * a + y * r - d * o, e[6] = y * h + x * o + d * a - p * r, e[7] = x * h - d * r - p * a - y * o, e;
  }
  /**
   * Rotates a {@link Quat2} around the Y axis
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateY(e, n, s) {
    let r = -n[0], a = -n[1], o = -n[2], h = n[3];
    const c = n[4], l = n[5], u = n[6], f = n[7], d = c * h + f * r + l * o - u * a, p = l * h + f * a + u * r - c * o, y = u * h + f * o + c * a - l * r, x = f * h - c * r - l * a - u * o;
    return yt.rotateY(e, n, s), r = e[0], a = e[1], o = e[2], h = e[3], e[4] = d * h + x * r + p * o - y * a, e[5] = p * h + x * a + y * r - d * o, e[6] = y * h + x * o + d * a - p * r, e[7] = x * h - d * r - p * a - y * o, e;
  }
  /**
   * Rotates a {@link Quat2} around the Z axis
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param rad - angle (in radians) to rotate
   * @returns `out`
   */
  static rotateZ(e, n, s) {
    let r = -n[0], a = -n[1], o = -n[2], h = n[3];
    const c = n[4], l = n[5], u = n[6], f = n[7], d = c * h + f * r + l * o - u * a, p = l * h + f * a + u * r - c * o, y = u * h + f * o + c * a - l * r, x = f * h - c * r - l * a - u * o;
    return yt.rotateZ(e, n, s), r = e[0], a = e[1], o = e[2], h = e[3], e[4] = d * h + x * r + p * o - y * a, e[5] = p * h + x * a + y * r - d * o, e[6] = y * h + x * o + d * a - p * r, e[7] = x * h - d * r - p * a - y * o, e;
  }
  /**
   * Rotates a {@link Quat2} by a given quaternion (a * q)
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param q - quaternion to rotate by
   * @returns `out`
   */
  static rotateByQuatAppend(e, n, s) {
    const r = s[0], a = s[1], o = s[2], h = s[3];
    let c = n[0], l = n[1], u = n[2], f = n[3];
    return e[0] = c * h + f * r + l * o - u * a, e[1] = l * h + f * a + u * r - c * o, e[2] = u * h + f * o + c * a - l * r, e[3] = f * h - c * r - l * a - u * o, c = n[4], l = n[5], u = n[6], f = n[7], e[4] = c * h + f * r + l * o - u * a, e[5] = l * h + f * a + u * r - c * o, e[6] = u * h + f * o + c * a - l * r, e[7] = f * h - c * r - l * a - u * o, e;
  }
  /**
   * Rotates a {@link Quat2} by a given quaternion (q * a)
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param q - quaternion to rotate by
   * @param a - the dual quaternion to rotate
   * @returns `out`
   */
  static rotateByQuatPrepend(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3];
    let c = s[0], l = s[1], u = s[2], f = s[3];
    return e[0] = r * f + h * c + a * u - o * l, e[1] = a * f + h * l + o * c - r * u, e[2] = o * f + h * u + r * l - a * c, e[3] = h * f - r * c - a * l - o * u, c = s[4], l = s[5], u = s[6], f = s[7], e[4] = r * f + h * c + a * u - o * l, e[5] = a * f + h * l + o * c - r * u, e[6] = o * f + h * u + r * l - a * c, e[7] = h * f - r * c - a * l - o * u, e;
  }
  /**
   * Rotates a {@link Quat2} around a given axis. Does the normalization automatically
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the dual quaternion to rotate
   * @param axis - the axis to rotate around
   * @param rad - how far the rotation should be
   * @returns `out`
   */
  static rotateAroundAxis(e, n, s, r) {
    if (Math.abs(r) < ct)
      return ye.copy(e, n);
    const a = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
    r = r * 0.5;
    const o = Math.sin(r), h = o * s[0] / a, c = o * s[1] / a, l = o * s[2] / a, u = Math.cos(r), f = n[0], d = n[1], p = n[2], y = n[3];
    e[0] = f * u + y * h + d * l - p * c, e[1] = d * u + y * c + p * h - f * l, e[2] = p * u + y * l + f * c - d * h, e[3] = y * u - f * h - d * c - p * l;
    const x = n[4], g = n[5], m = n[6], v = n[7];
    return e[4] = x * u + v * h + g * l - m * c, e[5] = g * u + v * c + m * h - x * l, e[6] = m * u + v * l + x * c - g * h, e[7] = v * u - x * h - g * c - m * l, e;
  }
  /**
   * Adds two {@link Quat2}s
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e[2] = n[2] + s[2], e[3] = n[3] + s[3], e[4] = n[4] + s[4], e[5] = n[5] + s[5], e[6] = n[6] + s[6], e[7] = n[7] + s[7], e;
  }
  /**
   * Multiplies two {@link Quat2}s
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - the first operand
   * @param b - the second operand
   * @returns {quat2} out
   */
  static multiply(e, n, s) {
    const r = n[0], a = n[1], o = n[2], h = n[3], c = s[4], l = s[5], u = s[6], f = s[7], d = n[4], p = n[5], y = n[6], x = n[7], g = s[0], m = s[1], v = s[2], w = s[3];
    return e[0] = r * w + h * g + a * v - o * m, e[1] = a * w + h * m + o * g - r * v, e[2] = o * w + h * v + r * m - a * g, e[3] = h * w - r * g - a * m - o * v, e[4] = r * f + h * c + a * u - o * l + d * w + x * g + p * v - y * m, e[5] = a * f + h * l + o * c - r * u + p * w + x * m + y * g - d * v, e[6] = o * f + h * u + r * l - a * c + y * w + x * v + d * m - p * g, e[7] = h * f - r * c - a * l - o * u + x * w - d * g - p * m - y * v, e;
  }
  /**
   * Alias for {@link Quat2.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return e;
  }
  /**
   * Scales a {@link Quat2} by a scalar value
   * @category Static
   *
   * @param out - the receiving dual quaterion
   * @param a - the dual quaternion to scale
   * @param b - scalar value to scale the dual quaterion by
   * @returns `out`
   */
  static scale(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e[2] = n[2] * s, e[3] = n[3] * s, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = n[7] * s, e;
  }
  /**
   * Calculates the dot product of two {@link Quat2}s (The dot product of the real parts)
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, n) {
    return 0;
  }
  /**
   * Performs a linear interpolation between two {@link Quat2}s
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when `t = 0.5`)
   * @category Static
   *
   * @param out - the receiving dual quat
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, s, r) {
    const a = 1 - r;
    return ye.dot(n, s) < 0 && (r = -r), e[0] = n[0] * a + s[0] * r, e[1] = n[1] * a + s[1] * r, e[2] = n[2] * a + s[2] * r, e[3] = n[3] * a + s[3] * r, e[4] = n[4] * a + s[4] * r, e[5] = n[5] * a + s[5] * r, e[6] = n[6] * a + s[6] * r, e[7] = n[7] * a + s[7] * r, e;
  }
  /**
   * Calculates the inverse of a {@link Quat2}. If they are normalized, conjugate is cheaper
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - dual quat to calculate inverse of
   * @returns `out`
   */
  static invert(e, n) {
    const s = ye.squaredLength(n);
    return e[0] = -n[0] / s, e[1] = -n[1] / s, e[2] = -n[2] / s, e[3] = n[3] / s, e[4] = -n[4] / s, e[5] = -n[5] / s, e[6] = -n[6] / s, e[7] = n[7] / s, e;
  }
  /**
   * Calculates the conjugate of a {@link Quat2}
   * If the dual quaternion is normalized, this function is faster than {@link Quat2.invert} and produces the same result.
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - dual quaternion to calculate conjugate of
   * @returns `out`
   */
  static conjugate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e[2] = -n[2], e[3] = n[3], e[4] = -n[4], e[5] = -n[5], e[6] = -n[6], e[7] = n[7], e;
  }
  /**
   * Calculates the magnitude (length) of a {@link Quat2}
   * @category Static
   *
   * @param a - dual quaternion to calculate length of
   * @returns length of `a`
   */
  static magnitude(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.magnitude}
   * @category Static
   * @deprecated Use {@link Quat2.magnitude} to avoid conflicts with builtin `length` methods/attribs
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.magnitude}
   * @category Static
   * @deprecated Use {@link Quat2.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Quat2}
   * @category Static
   *
   * @param a - dual quaternion to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    return 0;
  }
  /**
   * Alias for {@link Quat2.squaredLength}
   * @category Static
   */
  static sqrLen(e) {
    return 0;
  }
  /**
   * Normalize a {@link Quat2}
   * @category Static
   *
   * @param out - the receiving dual quaternion
   * @param a - dual quaternion to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    let s = ye.squaredLength(n);
    if (s > 0) {
      s = Math.sqrt(s);
      const r = n[0] / s, a = n[1] / s, o = n[2] / s, h = n[3] / s, c = n[4], l = n[5], u = n[6], f = n[7], d = r * c + a * l + o * u + h * f;
      e[0] = r, e[1] = a, e[2] = o, e[3] = h, e[4] = (c - r * d) / s, e[5] = (l - a * d) / s, e[6] = (u - o * d) / s, e[7] = (f - h * d) / s;
    }
    return e;
  }
  /**
   * Returns a string representation of a {@link Quat2}
   * @category Static
   *
   * @param a - dual quaternion to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Quat2(${e.join(", ")})`;
  }
  /**
   * Returns whether or not the {@link Quat2}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first dual quaternion.
   * @param b - The second dual quaternion.
   * @returns True if the dual quaternions are equal, false otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3] && e[4] === n[4] && e[5] === n[5] && e[6] === n[6] && e[7] === n[7];
  }
  /**
   * Returns whether or not the {@link Quat2}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first dual quaternion.
   * @param b - The second dual quaternion.
   * @returns True if the dual quaternions are equal, false otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = e[2], o = e[3], h = e[4], c = e[5], l = e[6], u = e[7], f = n[0], d = n[1], p = n[2], y = n[3], x = n[4], g = n[5], m = n[6], v = n[7];
    return Math.abs(s - f) <= ct * Math.max(1, Math.abs(s), Math.abs(f)) && Math.abs(r - d) <= ct * Math.max(1, Math.abs(r), Math.abs(d)) && Math.abs(a - p) <= ct * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(o - y) <= ct * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(h - x) <= ct * Math.max(1, Math.abs(h), Math.abs(x)) && Math.abs(c - g) <= ct * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(l - m) <= ct * Math.max(1, Math.abs(l), Math.abs(m)) && Math.abs(u - v) <= ct * Math.max(1, Math.abs(u), Math.abs(v));
  }
}
const py = new Float32Array(4), yy = new Float32Array(3);
ye.dot = yt.dot;
ye.squaredLength = yt.squaredLength;
ye.sqrLen = yt.squaredLength;
ye.mag = yt.magnitude;
ye.length = yt.magnitude;
ye.len = yt.magnitude;
ye.mul = ye.multiply;
const tS = ye;
class It extends Float32Array {
  /**
   * The number of bytes in a {@link Vec2}.
   */
  static BYTE_LENGTH = 2 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Vec2}.
   */
  constructor(...e) {
    switch (e.length) {
      case 2: {
        const n = e[0];
        typeof n == "number" ? super([n, e[1]]) : super(n, e[1], 2);
        break;
      }
      case 1: {
        const n = e[0];
        typeof n == "number" ? super([n, n]) : super(n, 0, 2);
        break;
      }
      default:
        super(2);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec2.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * TypedArrays to mean the number of elements in the array.
   */
  get magnitude() {
    return Math.hypot(this[0], this[1]);
  }
  /**
   * Alias for {@link Vec2.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec2.squaredMagnitude(this);`
   */
  get squaredMagnitude() {
    const e = this[0], n = this[1];
    return e * e + n * n;
  }
  /**
   * Alias for {@link Vec2.squaredMagnitude}
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec2.str(this);`
   */
  get str() {
    return It.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec2} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  // Instead of zero(), use a.fill(0) for instances;
  /**
   * Adds a {@link Vec2} to `this`.
   * Equivalent to `Vec2.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this;
  }
  /**
   * Subtracts a {@link Vec2} from `this`.
   * Equivalent to `Vec2.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this;
  }
  /**
   * Alias for {@link Vec2.subtract}
   */
  sub(e) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec2}.
   * Equivalent to `Vec2.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this;
  }
  /**
   * Alias for {@link Vec2.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec2}.
   * Equivalent to `Vec2.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns {Vec2} `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this;
  }
  /**
   * Alias for {@link Vec2.divide}
   */
  div(e) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec2.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec2.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, n) {
    return this[0] += e[0] * n, this[1] += e[1] * n, this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec2} and `this`.
   * Equivalent to `Vec2.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return It.distance(this, e);
  }
  /**
   * Alias for {@link Vec2.distance}
   */
  dist(e) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec2} and `this`.
   * Equivalent to `Vec2.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return It.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec2.squaredDistance}
   */
  sqrDist(e) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec2.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec2.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this;
  }
  /**
   * Sets each component of `this` to it's absolute value.
   * Equivalent to `Vec2.abs(this, this);`
   *
   * @returns `this`
   */
  abs() {
    return this[0] = Math.abs(this[0]), this[1] = Math.abs(this[1]), this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec2}.
   * Equivalent to `Vec2.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec2.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return It.normalize(this, this);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, empty {@link Vec2}
   * @category Static
   *
   * @returns A new 2D vector
   */
  static create() {
    return new It();
  }
  /**
   * Creates a new {@link Vec2} initialized with values from an existing vector
   * @category Static
   *
   * @param a - Vector to clone
   * @returns A new 2D vector
   */
  static clone(e) {
    return new It(e);
  }
  /**
   * Creates a new {@link Vec2} initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @returns A new 2D vector
   */
  static fromValues(e, n) {
    return new It(e, n);
  }
  /**
   * Copy the values from one {@link Vec2} to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - The source vector
   * @returns `out`
   */
  static copy(e, n) {
    return e[0] = n[0], e[1] = n[1], e;
  }
  /**
   * Set the components of a {@link Vec2} to the given values
   * @category Static
   *
   * @param out - The receiving vector
   * @param x - X component
   * @param y - Y component
   * @returns `out`
   */
  static set(e, n, s) {
    return e[0] = n, e[1] = s, e;
  }
  /**
   * Adds two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, n, s) {
    return e[0] = n[0] + s[0], e[1] = n[1] + s[1], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static subtract(e, n, s) {
    return e[0] = n[0] - s[0], e[1] = n[1] - s[1], e;
  }
  /**
   * Alias for {@link Vec2.subtract}
   * @category Static
   */
  static sub(e, n, s) {
    return [0, 0];
  }
  /**
   * Multiplies two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, n, s) {
    return e[0] = n[0] * s[0], e[1] = n[1] * s[1], e;
  }
  /**
   * Alias for {@link Vec2.multiply}
   * @category Static
   */
  static mul(e, n, s) {
    return [0, 0];
  }
  /**
   * Divides two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static divide(e, n, s) {
    return e[0] = n[0] / s[0], e[1] = n[1] / s[1], e;
  }
  /**
   * Alias for {@link Vec2.divide}
   * @category Static
   */
  static div(e, n, s) {
    return [0, 0];
  }
  /**
   * Math.ceil the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to ceil
   * @returns `out`
   */
  static ceil(e, n) {
    return e[0] = Math.ceil(n[0]), e[1] = Math.ceil(n[1]), e;
  }
  /**
   * Math.floor the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to floor
   * @returns `out`
   */
  static floor(e, n) {
    return e[0] = Math.floor(n[0]), e[1] = Math.floor(n[1]), e;
  }
  /**
   * Returns the minimum of two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static min(e, n, s) {
    return e[0] = Math.min(n[0], s[0]), e[1] = Math.min(n[1], s[1]), e;
  }
  /**
   * Returns the maximum of two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static max(e, n, s) {
    return e[0] = Math.max(n[0], s[0]), e[1] = Math.max(n[1], s[1]), e;
  }
  /**
   * Math.round the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to round
   * @returns `out`
   */
  static round(e, n) {
    return e[0] = Math.round(n[0]), e[1] = Math.round(n[1]), e;
  }
  /**
   * Scales a {@link Vec2} by a scalar number
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The vector to scale
   * @param b - Amount to scale the vector by
   * @returns `out`
   */
  static scale(e, n, s) {
    return e[0] = n[0] * s, e[1] = n[1] * s, e;
  }
  /**
   * Adds two Vec2's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @param scale - The amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, n, s, r) {
    return e[0] = n[0] + s[0] * r, e[1] = n[1] + s[1] * r, e;
  }
  /**
   * Calculates the euclidian distance between two {@link Vec2}s
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns distance between `a` and `b`
   */
  static distance(e, n) {
    return Math.hypot(n[0] - e[0], n[1] - e[1]);
  }
  /**
   * Alias for {@link Vec2.distance}
   * @category Static
   */
  static dist(e, n) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two {@link Vec2}s
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns Squared distance between `a` and `b`
   */
  static squaredDistance(e, n) {
    const s = n[0] - e[0], r = n[1] - e[1];
    return s * s + r * r;
  }
  /**
   * Alias for {@link Vec2.distance}
   * @category Static
   */
  static sqrDist(e, n) {
    return 0;
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec2}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(e) {
    let n = e[0], s = e[1];
    return Math.sqrt(n * n + s * s);
  }
  /**
   * Alias for {@link Vec2.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec2.magnitude}
   * @category Static
   * @deprecated Use {@link Vec2.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec2.magnitude}
   * @category Static
   * @deprecated Use {@link Vec2.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Calculates the squared length of a {@link Vec2}
   * @category Static
   *
   * @param a - Vector to calculate squared length of
   * @returns Squared length of a
   */
  static squaredLength(e) {
    const n = e[0], s = e[1];
    return n * n + s * s;
  }
  /**
   * Alias for {@link Vec2.squaredLength}
   */
  static sqrLen(e, n) {
    return 0;
  }
  /**
   * Negates the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to negate
   * @returns `out`
   */
  static negate(e, n) {
    return e[0] = -n[0], e[1] = -n[1], e;
  }
  /**
   * Returns the inverse of the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to invert
   * @returns `out`
   */
  static inverse(e, n) {
    return e[0] = 1 / n[0], e[1] = 1 / n[1], e;
  }
  /**
   * Returns the absolute value of the components of a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to compute the absolute values of
   * @returns `out`
   */
  static abs(e, n) {
    return e[0] = Math.abs(n[0]), e[1] = Math.abs(n[1]), e;
  }
  /**
   * Normalize a {@link Vec2}
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - Vector to normalize
   * @returns `out`
   */
  static normalize(e, n) {
    const s = n[0], r = n[1];
    let a = s * s + r * r;
    return a > 0 && (a = 1 / Math.sqrt(a)), e[0] = n[0] * a, e[1] = n[1] * a, e;
  }
  /**
   * Calculates the dot product of two {@link Vec2}s
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns Dot product of `a` and `b`
   */
  static dot(e, n) {
    return e[0] * n[0] + e[1] * n[1];
  }
  /**
   * Computes the cross product of two {@link Vec2}s
   * Note that the cross product must by definition produce a 3D vector.
   * For this reason there is also not instance equivalent for this function.
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static cross(e, n, s) {
    const r = n[0] * s[1] - n[1] * s[0];
    return e[0] = e[1] = 0, e[2] = r, e;
  }
  /**
   * Performs a linear interpolation between two {@link Vec2}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @param t - Interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, n, s, r) {
    const a = n[0], o = n[1];
    return e[0] = a + r * (s[0] - a), e[1] = o + r * (s[1] - o), e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat2}
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat2(e, n, s) {
    const r = n[0], a = n[1];
    return e[0] = s[0] * r + s[2] * a, e[1] = s[1] * r + s[3] * a, e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat2d}
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat2d(e, n, s) {
    const r = n[0], a = n[1];
    return e[0] = s[0] * r + s[2] * a + s[4], e[1] = s[1] * r + s[3] * a + s[5], e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat3}
   * 3rd vector component is implicitly '1'
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat3(e, n, s) {
    const r = n[0], a = n[1];
    return e[0] = s[0] * r + s[3] * a + s[6], e[1] = s[1] * r + s[4] * a + s[7], e;
  }
  /**
   * Transforms the {@link Vec2} with a {@link Mat4}
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param out - The receiving vector
   * @param a - The vector to transform
   * @param m - Matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, n, s) {
    const r = n[0], a = n[1];
    return e[0] = s[0] * r + s[4] * a + s[12], e[1] = s[1] * r + s[5] * a + s[13], e;
  }
  /**
   * Rotate a 2D vector
   * @category Static
   *
   * @param out - The receiving {@link Vec2}
   * @param a - The {@link Vec2} point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotate(e, n, s, r) {
    const a = n[0] - s[0], o = n[1] - s[1], h = Math.sin(r), c = Math.cos(r);
    return e[0] = a * c - o * h + s[0], e[1] = a * h + o * c + s[1], e;
  }
  /**
   * Get the angle between two 2D vectors
   * @category Static
   *
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(e, n) {
    const s = e[0], r = e[1], a = n[0], o = n[1], h = Math.sqrt(s * s + r * r) * Math.sqrt(a * a + o * o), c = h && (s * a + r * o) / h;
    return Math.acos(Math.min(Math.max(c, -1), 1));
  }
  /**
   * Set the components of a {@link Vec2} to zero
   * @category Static
   *
   * @param out - The receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns `true` if the vectors components are ===, `false` otherwise.
   */
  static exactEquals(e, n) {
    return e[0] === n[0] && e[1] === n[1];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns `true` if the vectors are approximately equal, `false` otherwise.
   */
  static equals(e, n) {
    const s = e[0], r = e[1], a = n[0], o = n[1];
    return Math.abs(s - a) <= ct * Math.max(1, Math.abs(s), Math.abs(a)) && Math.abs(r - o) <= ct * Math.max(1, Math.abs(r), Math.abs(o));
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - Vector to represent as a string
   * @returns String representation of the vector
   */
  static str(e) {
    return `Vec2(${e.join(", ")})`;
  }
}
It.prototype.sub = It.prototype.subtract;
It.prototype.mul = It.prototype.multiply;
It.prototype.div = It.prototype.divide;
It.prototype.dist = It.prototype.distance;
It.prototype.sqrDist = It.prototype.squaredDistance;
It.sub = It.subtract;
It.mul = It.multiply;
It.div = It.divide;
It.dist = It.distance;
It.sqrDist = It.squaredDistance;
It.sqrLen = It.squaredLength;
It.mag = It.magnitude;
It.length = It.magnitude;
It.len = It.magnitude;
const tt = It, eS = ["xx", "xy", "yx", "yy", "xxx", "xxy", "xyx", "xyy", "yxx", "yxy", "yyx", "yyy", "xxxx", "xxxy", "xxyx", "xxyy", "xyxx", "xyxy", "xyyx", "xyyy", "yxxx", "yxxy", "yxyx", "yxyy", "yyxx", "yyxy", "yyyx", "yyyy", "rr", "rg", "gr", "gg", "rrr", "rrg", "rgr", "rgg", "grr", "grg", "ggr", "ggg", "rrrr", "rrrg", "rrgr", "rrgg", "rgrr", "rgrg", "rggr", "rggg", "grrr", "grrg", "grgr", "grgg", "ggrr", "ggrg", "gggr", "gggg"], nS = ["xz", "yz", "zx", "zy", "zz", "xxz", "xyz", "xzx", "xzy", "xzz", "yxz", "yyz", "yzx", "yzy", "yzz", "zxx", "zxy", "zxz", "zyx", "zyy", "zyz", "zzx", "zzy", "zzz", "xxxz", "xxyz", "xxzx", "xxzy", "xxzz", "xyxz", "xyyz", "xyzx", "xyzy", "xyzz", "xzxx", "xzxy", "xzxz", "xzyx", "xzyy", "xzyz", "xzzx", "xzzy", "xzzz", "yxxz", "yxyz", "yxzx", "yxzy", "yxzz", "yyxz", "yyyz", "yyzx", "yyzy", "yyzz", "yzxx", "yzxy", "yzxz", "yzyx", "yzyy", "yzyz", "yzzx", "yzzy", "yzzz", "zxxx", "zxxy", "zxxz", "zxyx", "zxyy", "zxyz", "zxzx", "zxzy", "zxzz", "zyxx", "zyxy", "zyxz", "zyyx", "zyyy", "zyyz", "zyzx", "zyzy", "zyzz", "zzxx", "zzxy", "zzxz", "zzyx", "zzyy", "zzyz", "zzzx", "zzzy", "zzzz", "rb", "gb", "br", "bg", "bb", "rrb", "rgb", "rbr", "rbg", "rbb", "grb", "ggb", "gbr", "gbg", "gbb", "brr", "brg", "brb", "bgr", "bgg", "bgb", "bbr", "bbg", "bbb", "rrrb", "rrgb", "rrbr", "rrbg", "rrbb", "rgrb", "rggb", "rgbr", "rgbg", "rgbb", "rbrr", "rbrg", "rbrb", "rbgr", "rbgg", "rbgb", "rbbr", "rbbg", "rbbb", "grrb", "grgb", "grbr", "grbg", "grbb", "ggrb", "gggb", "ggbr", "ggbg", "ggbb", "gbrr", "gbrg", "gbrb", "gbgr", "gbgg", "gbgb", "gbbr", "gbbg", "gbbb", "brrr", "brrg", "brrb", "brgr", "brgg", "brgb", "brbr", "brbg", "brbb", "bgrr", "bgrg", "bgrb", "bggr", "bggg", "bggb", "bgbr", "bgbg", "bgbb", "bbrr", "bbrg", "bbrb", "bbgr", "bbgg", "bbgb", "bbbr", "bbbg", "bbbb"], iS = ["xw", "yw", "zw", "wx", "wy", "wz", "ww", "xxw", "xyw", "xzw", "xwx", "xwy", "xwz", "xww", "yxw", "yyw", "yzw", "ywx", "ywy", "ywz", "yww", "zxw", "zyw", "zzw", "zwx", "zwy", "zwz", "zww", "wxx", "wxy", "wxz", "wxw", "wyx", "wyy", "wyz", "wyw", "wzx", "wzy", "wzz", "wzw", "wwx", "wwy", "wwz", "www", "xxxw", "xxyw", "xxzw", "xxwx", "xxwy", "xxwz", "xxww", "xyxw", "xyyw", "xyzw", "xywx", "xywy", "xywz", "xyww", "xzxw", "xzyw", "xzzw", "xzwx", "xzwy", "xzwz", "xzww", "xwxx", "xwxy", "xwxz", "xwxw", "xwyx", "xwyy", "xwyz", "xwyw", "xwzx", "xwzy", "xwzz", "xwzw", "xwwx", "xwwy", "xwwz", "xwww", "yxxw", "yxyw", "yxzw", "yxwx", "yxwy", "yxwz", "yxww", "yyxw", "yyyw", "yyzw", "yywx", "yywy", "yywz", "yyww", "yzxw", "yzyw", "yzzw", "yzwx", "yzwy", "yzwz", "yzww", "ywxx", "ywxy", "ywxz", "ywxw", "ywyx", "ywyy", "ywyz", "ywyw", "ywzx", "ywzy", "ywzz", "ywzw", "ywwx", "ywwy", "ywwz", "ywww", "zxxw", "zxyw", "zxzw", "zxwx", "zxwy", "zxwz", "zxww", "zyxw", "zyyw", "zyzw", "zywx", "zywy", "zywz", "zyww", "zzxw", "zzyw", "zzzw", "zzwx", "zzwy", "zzwz", "zzww", "zwxx", "zwxy", "zwxz", "zwxw", "zwyx", "zwyy", "zwyz", "zwyw", "zwzx", "zwzy", "zwzz", "zwzw", "zwwx", "zwwy", "zwwz", "zwww", "wxxx", "wxxy", "wxxz", "wxxw", "wxyx", "wxyy", "wxyz", "wxyw", "wxzx", "wxzy", "wxzz", "wxzw", "wxwx", "wxwy", "wxwz", "wxww", "wyxx", "wyxy", "wyxz", "wyxw", "wyyx", "wyyy", "wyyz", "wyyw", "wyzx", "wyzy", "wyzz", "wyzw", "wywx", "wywy", "wywz", "wyww", "wzxx", "wzxy", "wzxz", "wzxw", "wzyx", "wzyy", "wzyz", "wzyw", "wzzx", "wzzy", "wzzz", "wzzw", "wzwx", "wzwy", "wzwz", "wzww", "wwxx", "wwxy", "wwxz", "wwxw", "wwyx", "wwyy", "wwyz", "wwyw", "wwzx", "wwzy", "wwzz", "wwzw", "wwwx", "wwwy", "wwwz", "wwww", "ra", "ga", "ba", "ar", "ag", "ab", "aa", "rra", "rga", "rba", "rar", "rag", "rab", "raa", "gra", "gga", "gba", "gar", "gag", "gab", "gaa", "bra", "bga", "bba", "bar", "bag", "bab", "baa", "arr", "arg", "arb", "ara", "agr", "agg", "agb", "aga", "abr", "abg", "abb", "aba", "aar", "aag", "aab", "aaa", "rrra", "rrga", "rrba", "rrar", "rrag", "rrab", "rraa", "rgra", "rgga", "rgba", "rgar", "rgag", "rgab", "rgaa", "rbra", "rbga", "rbba", "rbar", "rbag", "rbab", "rbaa", "rarr", "rarg", "rarb", "rara", "ragr", "ragg", "ragb", "raga", "rabr", "rabg", "rabb", "raba", "raar", "raag", "raab", "raaa", "grra", "grga", "grba", "grar", "grag", "grab", "graa", "ggra", "ggga", "ggba", "ggar", "ggag", "ggab", "ggaa", "gbra", "gbga", "gbba", "gbar", "gbag", "gbab", "gbaa", "garr", "garg", "garb", "gara", "gagr", "gagg", "gagb", "gaga", "gabr", "gabg", "gabb", "gaba", "gaar", "gaag", "gaab", "gaaa", "brra", "brga", "brba", "brar", "brag", "brab", "braa", "bgra", "bgga", "bgba", "bgar", "bgag", "bgab", "bgaa", "bbra", "bbga", "bbba", "bbar", "bbag", "bbab", "bbaa", "barr", "barg", "barb", "bara", "bagr", "bagg", "bagb", "baga", "babr", "babg", "babb", "baba", "baar", "baag", "baab", "baaa", "arrr", "arrg", "arrb", "arra", "argr", "argg", "argb", "arga", "arbr", "arbg", "arbb", "arba", "arar", "arag", "arab", "araa", "agrr", "agrg", "agrb", "agra", "aggr", "aggg", "aggb", "agga", "agbr", "agbg", "agbb", "agba", "agar", "agag", "agab", "agaa", "abrr", "abrg", "abrb", "abra", "abgr", "abgg", "abgb", "abga", "abbr", "abbg", "abbb", "abba", "abar", "abag", "abab", "abaa", "aarr", "aarg", "aarb", "aara", "aagr", "aagg", "aagb", "aaga", "aabr", "aabg", "aabb", "aaba", "aaar", "aaag", "aaab", "aaaa"], Ti = {
  x: 0,
  r: 0,
  y: 1,
  g: 1,
  z: 2,
  b: 2,
  w: 3,
  a: 3
};
function Ru(i) {
  switch (i.length) {
    case 2:
      return function() {
        return new It(this[Ti[i[0]]], this[Ti[i[1]]]);
      };
    case 3:
      return function() {
        return new vt(this[Ti[i[0]]], this[Ti[i[1]]], this[Ti[i[2]]]);
      };
    case 4:
      return function() {
        return new gt(this[Ti[i[0]]], this[Ti[i[1]]], this[Ti[i[2]]], this[Ti[i[3]]]);
      };
  }
  return () => null;
}
let xy = !1;
function sS() {
  if (!xy) {
    for (const i of eS) {
      const e = Ru(i);
      Object.defineProperty(It.prototype, i, {
        get: e
      }), Object.defineProperty(vt.prototype, i, {
        get: e
      }), Object.defineProperty(gt.prototype, i, {
        get: e
      });
    }
    for (const i of nS) {
      const e = Ru(i);
      Object.defineProperty(vt.prototype, i, {
        get: e
      }), Object.defineProperty(gt.prototype, i, {
        get: e
      });
    }
    for (const i of iS) {
      const e = Ru(i);
      Object.defineProperty(gt.prototype, i, {
        get: e
      });
    }
    xy = !0;
  }
}
const w7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EnableSwizzles: sS,
  Mat2: Ae,
  Mat2d: He,
  Mat3: pe,
  Mat4: kt,
  Quat: yt,
  Quat2: ye,
  Vec2: It,
  Vec3: vt,
  Vec4: gt,
  mat2: ma,
  mat2d: os,
  mat3: nm,
  mat4: im,
  quat: K3,
  quat2: tS,
  vec2: tt,
  vec3: Fi,
  vec4: Zs
}, Symbol.toStringTag, { value: "Module" })), sm = Math.sqrt, rm = 1e-4;
class Ca {
  static fromPoints(e, n, s) {
    return new Ca(e, n, s);
  }
  static fromXY(e, n, s, r, a, o) {
    return new Ca(new N(e, n), new N(s, r), new N(a, o));
  }
  p0 = N.default();
  p1 = N.default();
  p2 = N.default();
  constructor(e, n, s) {
    this.p0.copy(e), this.p1.copy(n), this.p2.copy(s);
  }
  getBoundingBox() {
    let e = gr.default(), n = [];
    const s = Zf([this.p0, this.p1, this.p2], n);
    for (let r = 0; r < s; r++)
      e.expandByXY(n[r].x, n[r].y);
    return e;
  }
  split(e) {
    return Zl(this.p0, this.p1, this.p2, e);
  }
  /**
   * 获取贝塞尔曲线上某一点的坐标
   * @param {number} t
   * @returns
   * @memberof QuadBezier
   */
  getPoint(e) {
    return am(this.p0, this.p1, this.p2, e);
  }
  getPoints(e = 0.01) {
    return Yf(this.p0, this.p1, this.p2, e);
  }
  getExtermas(e) {
    return Zf([this.p0, this.p1, this.p2], e);
  }
  fatten(e = 1) {
    return Yf(this.p0, this.p1, this.p2, e);
  }
}
let Uf = class Wf {
  static fromQuadBezier(e) {
    const n = N.lerp(N.default(), e.p0, e.p1, 0.6666666666666666), s = N.lerp(N.default(), e.p2, e.p1, 2 / 3);
    return this.fromPoints(e.p0, n, s, e.p2);
  }
  static fromPoints(e, n, s, r) {
    return new Wf(e, n, s, r);
  }
  static fromXY(e, n, s, r, a, o, h, c) {
    return new Wf(new N(e, n), new N(s, r), new N(a, o), new N(h, c));
  }
  p0 = N.default();
  p1 = N.default();
  p2 = N.default();
  p3 = N.default();
  constructor(e, n, s, r) {
    this.p0.copy(e), this.p1.copy(n), this.p2.copy(s), this.p3.copy(r);
  }
  getBoundingBox() {
    let e = gr.default(), n = [];
    const s = Jf([this.p0, this.p1, this.p2, this.p3], n);
    for (let r = 0; r < s; r++)
      e.expandByXY(n[r].x, n[r].y);
    return e;
  }
  split(e) {
    return ld(this.p0, this.p1, this.p2, this.p3, e);
  }
  getPoint(e) {
    return cd(this.p0, this.p1, this.p2, this.p3, e);
  }
  getPoints(e = 0.01) {
    return jf(this.p0, this.p1, this.p2, this.p3, e);
  }
  getExtermas(e) {
    return Jf([this.p0, this.p1, this.p2, this.p3], e);
  }
  fatten(e = 1) {
    return jf(this.p0, this.p1, this.p2, this.p3, e);
  }
};
function Na(i, e, n) {
  return em(i, e) * Math.pow(n, e) * Math.pow(1 - n, i - e);
}
function rS(i, e) {
  const n = i.length - 1;
  if (n < 0) return N.default();
  const s = N.default();
  for (let r = 0; r <= n; r++) {
    const a = i[r], o = Na(n, r, e);
    s.x += a.x * o, s.y += a.y * o;
  }
  return s;
}
function hd(i, e) {
  const n = i.length - 1;
  if (n < 0) return N.default();
  let s = i.map((r) => r.clone());
  for (let r = 1; r <= n; r++)
    for (let a = 0; a < n - r + 1; a++)
      s[a] = s[a].lerp(s[a + 1], e);
  return s[0];
}
function aS(i, e, n, s = 1, r) {
  const a = 4 * s / (3 * (1 + s)), o = i + (e - i) * a, h = n + (e - n) * a;
  return Pn(i, o, h, n, r);
}
function oS(i, e, n, s = 1, r) {
  const a = 4 * s / (3 * (1 + s)), o = N.lerp(N.default(), i, e, a), h = N.lerp(N.default(), e, n, a);
  return cd(i, o, h, n, r);
}
function hS(i, e, n) {
  const s = i.length - 1;
  if (s < 0) return N.default();
  const r = N.default();
  let a = 0;
  for (let o = 0; o <= s; o++) {
    const h = i[o], c = Na(s, o, n);
    r.x += e[o] * c * h.x, r.y += e[o] * c * h.y, a += e[o] * c;
  }
  return r.x /= a, r.y /= a, r;
}
function cS(i, e) {
  const n = om(i, e), s = hm(i, e), r = Math.abs(n.cross(s)), a = Math.pow(n.magnitudeSquared(), 3 / 2);
  return r / a;
}
function lS(i, e, n, s) {
  const r = nm.fromValues(
    1,
    -2,
    1,
    0,
    2,
    -2,
    0,
    0,
    1
  ), a = Fi.fromValues(1, s, s * s), o = Fi.transformMat3(Fi.create(), a, r), h = Fi.fromValues(i.x, e.x, n.x), c = Fi.fromValues(i.y, e.y, n.y);
  return N.create(Fi.dot(o, h), Fi.dot(o, c));
}
function uS(i, e, n, s, r) {
  const a = im.fromValues(
    1,
    -3,
    3,
    -1,
    0,
    3,
    -6,
    3,
    0,
    0,
    3,
    -3,
    0,
    0,
    0,
    1
  ), o = Zs.fromValues(1, r, r * r, r * r * r), h = Zs.transformMat4(Fi.create(), o, a), c = Zs.fromValues(i.x, e.x, n.x, s.x), l = Zs.fromValues(i.y, e.y, n.y, s.y);
  return N.create(Zs.dot(h, c), Zs.dot(h, l));
}
function jn(i, e, n, s) {
  const r = s * s, a = 1 - s, o = a * a;
  return i * o + 2 * s * a * e + r * n;
}
function am(i, e, n, s) {
  const r = s * s, a = 1 - s, o = a * a, h = i.x * o + 2 * a * s * e.x + r * n.x, c = i.y * o + 2 * a * s * e.y + r * n.y;
  return N.create(h, c);
}
function Pn(i, e, n, s, r) {
  const a = r * r, o = a * r, h = 1 - r, c = h * h, l = c * h;
  return i * l + 3 * r * c * e + 3 * h * a * n + o * s;
}
function cd(i, e, n, s, r) {
  const a = r * r, o = a * r, h = 1 - r, c = h * h, l = c * h, u = i.x * l + 3 * c * r * e.x + 3 * h * a * n.x + o * s.x, f = i.y * l + 3 * c * r * e.y + 3 * h * a * n.y + o * s.y;
  return N.create(u, f);
}
function fS(i) {
  const e = i.length;
  if (e <= 1) return [];
  let n = [i[0]];
  for (let s = 1; s < e; s++) {
    let r = i[s - 1], a = i[s];
    n[s - 1] = N.create(
      r.x * s / e + a.x * (e - s) / e,
      r.y * s / e + a.y * (e - s) / e
    );
  }
  return n[e] = i[e - 1], n;
}
function om(i, e) {
  const n = i.length - 1;
  if (n < 0) return N.default();
  let s = N.default();
  for (let r = 0; r < n; r++) {
    const a = Na(n - 1, r, e);
    s.x += (i[r + 1].x - i[r].x) * a, s.y += (i[r + 1].y - i[r].y) * a;
  }
  return s.multiplyScalar(n);
}
function hm(i, e) {
  const n = i.length - 1;
  if (n < 2) return N.create(0, 0);
  let s = N.create(0, 0);
  for (let r = 0; r <= n - 2; r++) {
    const a = Na(n - 2, r, e);
    s.x += i[r + 2].x - 2 * i[r + 1].x + i[r].x * a, s.y += i[r + 2].y - 2 * i[r + 1].y + i[r].y * a;
  }
  return s.x *= n * (n - 1), s.y *= n * (n - 1), s;
}
function dS(i, e) {
  let n = i;
  for (let s = 0; s < e; s++) {
    const r = [];
    for (let a = 0; a < n.length - 1; a++) {
      const o = n[a + 1].clone().sub(n[a]);
      r.push(o);
    }
    n = r;
  }
  return n;
}
function pS(i, e, n) {
  const s = i.length - 1;
  if (n > s) throw new Error("导数阶数不能超过贝塞尔曲线阶数");
  const r = Gf(s) / Gf(s - n), a = dS(i, n), o = s - n, h = N.default();
  for (let c = 0; c <= o; c++) {
    const l = Na(o, c, e);
    h.x += a[c].x * l, h.y += a[c].y * l;
  }
  return h.x *= r, h.y *= r, h;
}
function yS(i) {
  const e = i.length - 1;
  if (e < 0) return [];
  let n = Array.from({ length: e }).map(() => N.default());
  for (let s = 0; s < e; s++)
    n[s].x = e * (i[s + 1].x - i[s].x), n[s].y = e * (i[s + 1].y - i[s].y);
  return n;
}
function xS(i, e, n) {
  if (e === 0 && n === 1) return i;
  if (e === 0)
    return ho(i, n).left;
  if (n === 1)
    return ho(i, e).right;
  const s = ho(i, e).right;
  return ho(s, n).left;
}
function ho(i, e = 0.5) {
  const n = i.length - 1, s = [], r = [], a = i.map((o) => o.clone());
  s.push(a[0].clone()), r.unshift(a[n].clone());
  for (let o = 1; o <= n; o++) {
    for (let h = 0; h < n - o + 1; h++)
      a[h].x = (1 - e) * a[h].x + e * a[h + 1].x, a[h].y = (1 - e) * a[h].y + e * a[h + 1].y;
    s.push(a[0].clone()), r.unshift(a[n - o].clone());
  }
  return {
    left: s,
    right: r
  };
}
function Zl(i, e, n, s = 0.5) {
  const r = i.clone().lerp(e, s), a = e.clone().lerp(n, s), o = r.clone().lerp(a, s);
  return [i, r, o, a, n];
}
function gS(i, e) {
  const n = cm(i[0], i[1], i[2]);
  return n > 0 && n < 1 ? Zl(i[0], i[1], i[2], n) : i;
}
function ld(i, e, n, s, r = 0.5) {
  const a = i.clone().lerp(e, r), o = e.clone().lerp(n, r), h = n.clone().lerp(s, r), c = a.clone().lerp(o, r), l = o.clone().lerp(h, r), u = c.clone().lerp(l, r);
  return [i, a, c, u, l, h, s];
}
function mS(i, e, n, s, r, a) {
  const o = r - n, h = a - s, c = i - n, l = e - s, u = o * o + h * h;
  if (u == 0)
    return 0;
  const f = Math.max(0, Math.min(1, (c * o + l * h) / u)), d = n + f * o, p = s + f * h, y = i - d, x = e - p;
  return y * y + x * x;
}
function pl(i, e, n, s, r, a) {
  const o = r - n, h = a - s, c = h, l = -o, u = o * s - h * n;
  return Math.abs(c * i + l * e + u) / Math.sqrt(c * c + l * l);
}
function Yf(i, e, n, s = 1, r = 1e3) {
  const a = [];
  function o(h, c, l, u = 0) {
    if (pl(c.x, c.y, h.x, h.y, l.x, l.y) < s || u > r) {
      a.push(l);
      return;
    }
    const [d, p, y, x, g] = Zl(h, c, l, 0.5);
    o(d, p, y, u + 1), o(y, x, g, u + 1);
  }
  return a.push(i), o(i, e, n), a;
}
function jf(i, e, n, s, r = 1, a = 1e3) {
  const o = [];
  function h(c, l, u, f, d = 0) {
    const p = pl(l.x, l.y, c.x, c.y, f.x, f.y), y = pl(u.x, u.y, c.x, c.y, f.x, f.y);
    if (Math.max(p, y) < r || d > a) {
      o.push(f);
      return;
    }
    const [x, g, m, v, w, b, S] = ld(c, l, u, f, 0.5);
    h(x, g, m, v, d + 1), h(v, w, b, S, d + 1);
  }
  return o.push(i), h(i, e, n, s), o;
}
function vS(i, e, n) {
  const s = N.lerp(N.default(), i, e, 0.6666666666666666), r = N.lerp(N.default(), n, e, 2 / 3);
  return [i, s, r, n];
}
function wS(i, e, n, s) {
  const r = 2 * (e.x - i.x) + 2 * (n.x - 2 * e.x + i.x) * s, a = 2 * (e.y - i.y) + 2 * (n.y - 2 * e.y + i.y) * s;
  return N.create(r, a);
}
function cm(i, e, n) {
  const s = 2 * (e.x - i.x), r = 2 * (e.y - i.y), a = 2 * (i.x - 2 * e.x + n.x), o = 2 * (i.y - 2 * e.y + n.y);
  let h = -(s * a + r * o), c = a * a + o * o;
  return c < 0 && (h = -h, c = -c), h <= 0 ? 0 : h >= c ? 1 : h / c;
}
function MS(i, e, n, s, r) {
  const a = 3 * r * r * (s.x - 3 * n.x + 3 * e.x - i.x) + 6 * r * (n.x - 2 * e.x + i.x) + 3 * (e.x - i.x), o = 3 * r * r * (s.y - 3 * n.y + 3 * e.y - i.y) + 6 * r * (n.y - 2 * e.y + i.y) + 3 * (e.y - i.x);
  return N.create(a, o);
}
function gy(i, e) {
  let n = i[2] - i[0], s = i[4] - 2 * i[2] + i[0], r = i[6] + 3 * (i[2] - i[4]) - i[0];
  e[0] = r * r, e[1] = 3 * s * r, e[2] = 2 * s * s + r * n, e[3] = n * s;
}
function bS(i, e) {
  let n = 0;
  for (let s = e; s > 1; --s)
    if (i[n] == i[n + 1]) {
      for (let r = 1; r < s; ++r)
        i[r - 1] = i[r];
      e -= 1;
    } else
      n++;
  return e;
}
function _S(i, e) {
  for (let n = e - 1; n > 0; --n)
    for (let s = n; s > 0; --s)
      if (i[s] < i[s - 1]) {
        let r = i[s];
        i[s] = i[s - 1], i[s - 1] = r;
      }
}
function SS(i, e) {
  if (Math.abs(i[0]) <= 1e-6)
    return ud(i[1], i[2], i[3], e);
  let n, s, r, a, o;
  {
    let u = 1 / i[0];
    n = i[1] * u, s = i[2] * u, r = i[3] * u;
  }
  a = (n * n - s * 3) / 9, o = (2 * n * n * n - 9 * n * s + 27 * r) / 54;
  let h = a * a * a, c = o * o - h, l = n / 3;
  if (c < 0) {
    let u = Math.cos(Je(o / Math.sqrt(h), -1, 1)), f = -2 * Math.sqrt(a);
    return e[0] = Je(f * Math.cos(u / 3) - l, 0, 1), e[1] = Je(f * Math.cos((u + 2 * Math.PI) / 3) - l, 0, 1), e[2] = Je(f * Math.cos((u - 2 * Math.PI) / 3) - l, 0, 1), _S(e, 3), bS(e, 3);
  } else {
    let u = Math.abs(o) + Math.sqrt(c);
    return u = Math.pow(u, 0.3333333), o > 0 && (u = -u), u != 0 && (u += a / u), e[0] = Je(u - l, 0, 1), 1;
  }
}
function TS(i, e) {
  let n = new Array(4).fill(0), s = new Array(4).fill(0), r;
  for (gy(i.map((o) => o.x), n), gy(i.map((o) => o.y), s), r = 0; r < 4; r++)
    n[r] += s[r];
  return SS(n, e);
}
function Yc(i, e, n) {
  if (i < 0 && (i = -i, e = -e), e == 0 || i == 0 || i >= e)
    return 0;
  let s = i / e;
  return !Number.isFinite(s) || s == 0 ? 0 : (n[0] = s, 1);
}
function Hf(i, e, n, s) {
  return Yc(i - e, i - e - e + n, s);
}
function Xf(i, e, n, s, r) {
  const a = s - i + 3 * (e - n), o = 2 * (i - e - e + n), h = e - i;
  return ud(a, o, h, r);
}
function ud(i, e, n, s) {
  if (i == 0)
    return Yc(-n, e, s);
  let r = 0, a = e * e - 4 * i * n;
  if (a < 0)
    return 0;
  a = Math.sqrt(a);
  let o = a;
  if (!Number.isFinite(o))
    return 0;
  let h = e < 0 ? -(e - o) / 2 : -(e + o) / 2, c = [];
  if (Yc(h, i, c) > 0 && (s[r] = c[0], r++), Yc(n, h, c) && (s[r] = c[0], r++), r == 2)
    if (s[0] > s[1]) {
      let l = s[0];
      s[0] = s[1], s[1] = l;
    } else s[0] == s[1] && (r -= 1);
  return r;
}
function Zf(i, e) {
  let n = [], s = [], r = 0;
  Hf(i[0].x, i[1].x, i[2].x, s) > 0 && (n[r] = s[0], r++), Hf(i[0].y, i[1].y, i[2].y, s) > 0 && (n[r] = s[0], r++);
  for (let a = 0; a < r; ++a)
    e[a] = hd(i, n[a]);
  return e[r] = i[2], r + 1;
}
function Jf(i, e) {
  let n = [0, 0, 0, 0], s = [], r = 0, a = 0;
  (a = Xf(i[0].x, i[1].x, i[2].x, i[3].x, s)) > 0 && (a == 1 && (n[0] = s[0]), a == 2 && (n[1] = s[1]), r += a), (a = Xf(i[0].y, i[1].y, i[2].y, i[3].y, s)) > 0 && (a == 1 && (n[r] = s[0]), a == 2 && (n[r + 1] = s[1]), r += a);
  for (let o = 0; o < r; ++o)
    e[o] = hd(i, n[o]);
  return e[r] = i[3], r + 1;
}
function lm(i, e, n, s, r, a, o, h, c) {
  let l = 0, u = 5e-3, f = 1 / 0;
  const d = N.create(o, h), p = N.default(), y = N.default();
  for (let x = 0; x < 1; x += 0.05) {
    p[0] = jn(i, n, r, x), p[1] = jn(e, s, a, x);
    const g = d.distanceSquared(p);
    g < f && (l = x, f = g);
  }
  f = 1 / 0;
  for (let x = 0; x < 32 && !(u < rm); x++) {
    const g = l - u, m = l + u;
    p[0] = jn(i, n, r, g), p[1] = jn(e, s, a, g);
    const v = d.distanceSquared(p);
    if (g >= 0 && v < f)
      l = g, f = v;
    else {
      y[0] = jn(i, n, r, m), y[1] = jn(e, s, a, m);
      const w = y.distanceSquared(d);
      m <= 1 && w < f ? (l = m, f = w) : u *= 0.5;
    }
  }
  return c && (c[0] = jn(i, n, r, l), c[1] = jn(e, s, a, l)), sm(f);
}
function ES(i, e, n, s, r, a, o) {
  let h = i, c = e, l = 0;
  const u = 1 / o;
  for (let f = 1; f <= o; f++) {
    let d = f * u;
    const p = jn(i, n, r, d), y = jn(e, s, a, d), x = p - h, g = y - c;
    l += Math.sqrt(x * x + g * g), h = p, c = y;
  }
  return l;
}
function um(i, e, n, s, r, a, o, h, c, l, u) {
  let f = 0, d = 5e-3, p = 1 / 0, y, x, g, m;
  const v = N.create(c, l), w = N.default(), b = N.default();
  for (let S = 0; S < 1; S += 0.05)
    w[0] = Pn(i, n, r, o, S), w[1] = Pn(e, s, a, h, S), g = v.distanceSquared(w), g < p && (f = S, p = g);
  p = 1 / 0;
  for (let S = 0; S < 32 && !(d < rm); S++)
    y = f - d, x = f + d, w[0] = Pn(i, n, r, o, y), w[1] = Pn(e, s, a, h, y), g = w.distanceSquared(v), y >= 0 && g < p ? (f = y, p = g) : (b[0] = Pn(i, n, r, o, x), b[1] = Pn(e, s, a, h, x), m = b.distanceSquared(v), x <= 1 && m < p ? (f = x, p = m) : d *= 0.5);
  return u && (u[0] = Pn(i, n, r, o, f), u[1] = Pn(e, s, a, h, f)), sm(p);
}
function zS(i, e, n, s, r, a, o, h, c) {
  let l = i, u = e, f = 0;
  const d = 1 / c;
  for (let p = 1; p <= c; p++) {
    let y = p * d;
    const x = Pn(i, n, r, o, y), g = Pn(e, s, a, h, y), m = x - l, v = g - u;
    f += Math.sqrt(m * m + v * v), l = x, u = g;
  }
  return f;
}
const { abs: Ga, cos: Ei, sin: Fr, acos: CS, atan2: Ua, sqrt: Hi, pow: An } = Math;
function Wa(i) {
  return i < 0 ? -An(-i, 1 / 3) : An(i, 1 / 3);
}
const fm = Math.PI, $h = 2 * fm, Xi = fm / 2, AS = 1e-6, Ou = Number.MAX_SAFE_INTEGER || 9007199254740991, ku = Number.MIN_SAFE_INTEGER || -9007199254740991, PS = { x: 0, y: 0, z: 0 }, K = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(i, e) {
    const n = e(i);
    let s = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (s += n.z * n.z), Hi(s);
  },
  compute: function(i, e, n) {
    if (i === 0)
      return e[0].t = 0, e[0];
    const s = e.length - 1;
    if (i === 1)
      return e[s].t = 1, e[s];
    const r = 1 - i;
    let a = e;
    if (s === 0)
      return e[0].t = i, e[0];
    if (s === 1) {
      const h = {
        x: r * a[0].x + i * a[1].x,
        y: r * a[0].y + i * a[1].y,
        t: i
      };
      return n && (h.z = r * a[0].z + i * a[1].z), h;
    }
    if (s < 4) {
      let h = r * r, c = i * i, l, u, f, d = 0;
      s === 2 ? (a = [a[0], a[1], a[2], PS], l = h, u = r * i * 2, f = c) : s === 3 && (l = h * r, u = h * i * 3, f = r * c * 3, d = i * c);
      const p = {
        x: l * a[0].x + u * a[1].x + f * a[2].x + d * a[3].x,
        y: l * a[0].y + u * a[1].y + f * a[2].y + d * a[3].y,
        t: i
      };
      return n && (p.z = l * a[0].z + u * a[1].z + f * a[2].z + d * a[3].z), p;
    }
    const o = JSON.parse(JSON.stringify(e));
    for (; o.length > 1; ) {
      for (let h = 0; h < o.length - 1; h++)
        o[h] = {
          x: o[h].x + (o[h + 1].x - o[h].x) * i,
          y: o[h].y + (o[h + 1].y - o[h].y) * i
        }, typeof o[h].z < "u" && (o[h].z = o[h].z + (o[h + 1].z - o[h].z) * i);
      o.splice(o.length - 1, 1);
    }
    return o[0].t = i, o[0];
  },
  computeWithRatios: function(i, e, n, s) {
    const r = 1 - i, a = n, o = e;
    let h = a[0], c = a[1], l = a[2], u = a[3], f;
    if (h *= r, c *= i, o.length === 2)
      return f = h + c, {
        x: (h * o[0].x + c * o[1].x) / f,
        y: (h * o[0].y + c * o[1].y) / f,
        z: s ? (h * o[0].z + c * o[1].z) / f : !1,
        t: i
      };
    if (h *= r, c *= 2 * r, l *= i * i, o.length === 3)
      return f = h + c + l, {
        x: (h * o[0].x + c * o[1].x + l * o[2].x) / f,
        y: (h * o[0].y + c * o[1].y + l * o[2].y) / f,
        z: s ? (h * o[0].z + c * o[1].z + l * o[2].z) / f : !1,
        t: i
      };
    if (h *= r, c *= 1.5 * r, l *= 3 * r, u *= i * i * i, o.length === 4)
      return f = h + c + l + u, {
        x: (h * o[0].x + c * o[1].x + l * o[2].x + u * o[3].x) / f,
        y: (h * o[0].y + c * o[1].y + l * o[2].y + u * o[3].y) / f,
        z: s ? (h * o[0].z + c * o[1].z + l * o[2].z + u * o[3].z) / f : !1,
        t: i
      };
  },
  // 导数控制点计算函数
  derive: function(i, e) {
    const n = [];
    for (let s = i, r = s.length, a = r - 1; r > 1; r--, a--) {
      const o = [];
      for (let h = 0, c; h < a; h++)
        c = {
          x: a * (s[h + 1].x - s[h].x),
          y: a * (s[h + 1].y - s[h].y)
        }, e && (c.z = a * (s[h + 1].z - s[h].z)), o.push(c);
      n.push(o), s = o;
    }
    return n;
  },
  between: function(i, e, n) {
    return e <= i && i <= n || K.approximately(i, e) || K.approximately(i, n);
  },
  approximately: function(i, e, n) {
    return Ga(i - e) <= (n || AS);
  },
  length: function(i) {
    const n = K.Tvalues.length;
    let s = 0;
    for (let r = 0, a; r < n; r++)
      a = 0.5 * K.Tvalues[r] + 0.5, s += K.Cvalues[r] * K.arcfn(a, i);
    return 0.5 * s;
  },
  map: function(i, e, n, s, r) {
    const a = n - e, o = r - s, h = i - e, c = h / a;
    return s + o * c;
  },
  lerp: function(i, e, n) {
    const s = {
      x: e.x + i * (n.x - e.x),
      y: e.y + i * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (s.z = e.z + i * (n.z - e.z)), s;
  },
  pointToString: function(i) {
    let e = i.x + "/" + i.y;
    return typeof i.z < "u" && (e += "/" + i.z), e;
  },
  pointsToString: function(i) {
    return "[" + i.map(K.pointToString).join(", ") + "]";
  },
  copy: function(i) {
    return JSON.parse(JSON.stringify(i));
  },
  angle: function(i, e, n) {
    const s = e.x - i.x, r = e.y - i.y, a = n.x - i.x, o = n.y - i.y, h = s * o - r * a, c = s * a + r * o;
    return Ua(h, c);
  },
  // round as string, to avoid rounding errors
  round: function(i, e) {
    const n = "" + i, s = n.indexOf(".");
    return parseFloat(n.substring(0, s + 1 + e));
  },
  dist: function(i, e) {
    const n = i.x - e.x, s = i.y - e.y;
    return Hi(n * n + s * s);
  },
  closest: function(i, e) {
    let n = An(2, 63), s, r;
    return i.forEach(function(a, o) {
      r = K.dist(e, a), r < n && (n = r, s = o);
    }), { mdist: n, mpos: s };
  },
  abcratio: function(i, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof i > "u")
      i = 0.5;
    else if (i === 0 || i === 1)
      return i;
    const n = An(i, e) + An(1 - i, e), s = n - 1;
    return Ga(s / n);
  },
  projectionratio: function(i, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof i > "u")
      i = 0.5;
    else if (i === 0 || i === 1)
      return i;
    const n = An(1 - i, e), s = An(i, e) + n;
    return n / s;
  },
  lli8: function(i, e, n, s, r, a, o, h) {
    const c = (i * s - e * n) * (r - o) - (i - n) * (r * h - a * o), l = (i * s - e * n) * (a - h) - (e - s) * (r * h - a * o), u = (i - n) * (a - h) - (e - s) * (r - o);
    return u == 0 ? !1 : { x: c / u, y: l / u };
  },
  lli4: function(i, e, n, s) {
    const r = i.x, a = i.y, o = e.x, h = e.y, c = n.x, l = n.y, u = s.x, f = s.y;
    return K.lli8(r, a, o, h, c, l, u, f);
  },
  lli: function(i, e) {
    return K.lli4(i, i.c, e, e.c);
  },
  makeline: function(i, e) {
    return new se(
      i.x,
      i.y,
      (i.x + e.x) / 2,
      (i.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(i) {
    let e = Ou, n = Ou, s = ku, r = ku;
    return i.forEach(function(a) {
      const o = a.bbox();
      e > o.x.min && (e = o.x.min), n > o.y.min && (n = o.y.min), s < o.x.max && (s = o.x.max), r < o.y.max && (r = o.y.max);
    }), {
      x: { min: e, mid: (e + s) / 2, max: s, size: s - e },
      y: { min: n, mid: (n + r) / 2, max: r, size: r - n }
    };
  },
  shapeintersections: function(i, e, n, s, r) {
    if (!K.bboxoverlap(e, s)) return [];
    const a = [], o = [i.startcap, i.forward, i.back, i.endcap], h = [n.startcap, n.forward, n.back, n.endcap];
    return o.forEach(function(c) {
      c.virtual || h.forEach(function(l) {
        if (l.virtual) return;
        const u = c.intersects(l, r);
        u.length > 0 && (u.c1 = c, u.c2 = l, u.s1 = i, u.s2 = n, a.push(u));
      });
    }), a;
  },
  makeshape: function(i, e, n) {
    const s = e.points.length, r = i.points.length, a = K.makeline(e.points[s - 1], i.points[0]), o = K.makeline(i.points[r - 1], e.points[0]), h = {
      startcap: a,
      forward: i,
      back: e,
      endcap: o,
      bbox: K.findbbox([a, i, e, o])
    };
    return h.intersections = function(c) {
      return K.shapeintersections(
        h,
        h.bbox,
        c,
        c.bbox,
        n
      );
    }, h;
  },
  getminmax: function(i, e, n) {
    if (!n) return { min: 0, max: 0 };
    let s = Ou, r = ku, a, o;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let h = 0, c = n.length; h < c; h++)
      a = n[h], o = i.get(a), o[e] < s && (s = o[e]), o[e] > r && (r = o[e]);
    return { min: s, mid: (s + r) / 2, max: r, size: r - s };
  },
  align: function(i, e) {
    const n = e.p1.x, s = e.p1.y, r = -Ua(e.p2.y - s, e.p2.x - n), a = function(o) {
      return {
        x: (o.x - n) * Ei(r) - (o.y - s) * Fr(r),
        y: (o.x - n) * Fr(r) + (o.y - s) * Ei(r)
      };
    };
    return i.map(a);
  },
  // 根据控制点求根
  roots: function(i, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = i.length - 1, s = K.align(i, e), r = function(A) {
      return 0 <= A && A <= 1;
    };
    if (n === 2) {
      const A = s[0].y, M = s[1].y, _ = s[2].y, T = A - 2 * M + _;
      if (T !== 0) {
        const C = -Hi(M * M - A * _), P = -A + M, R = -(C + P) / T, k = -(-C + P) / T;
        return [R, k].filter(r);
      } else if (M !== _ && T === 0)
        return [(2 * M - _) / (2 * M - 2 * _)].filter(r);
      return [];
    }
    const a = s[0].y, o = s[1].y, h = s[2].y, c = s[3].y;
    let l = -a + 3 * o - 3 * h + c, u = 3 * a - 6 * o + 3 * h, f = -3 * a + 3 * o, d = a;
    if (K.approximately(l, 0)) {
      if (K.approximately(u, 0))
        return K.approximately(f, 0) ? [] : [-d / f].filter(r);
      const A = Hi(f * f - 4 * u * d), M = 2 * u;
      return [(A - f) / M, (-f - A) / M].filter(r);
    }
    u /= l, f /= l, d /= l;
    const p = (3 * f - u * u) / 3, y = p / 3, x = (2 * u * u * u - 9 * u * f + 27 * d) / 27, g = x / 2, m = g * g + y * y * y;
    let v, w, b, S, E;
    if (m < 0) {
      const A = -p / 3, M = A * A * A, _ = Hi(M), T = -x / (2 * _), C = T < -1 ? -1 : T > 1 ? 1 : T, P = CS(C), R = Wa(_), k = 2 * R;
      return b = k * Ei(P / 3) - u / 3, S = k * Ei((P + $h) / 3) - u / 3, E = k * Ei((P + 2 * $h) / 3) - u / 3, [b, S, E].filter(r);
    } else {
      if (m === 0)
        return v = g < 0 ? Wa(-g) : -Wa(g), b = 2 * v - u / 3, S = -v - u / 3, [b, S].filter(r);
      {
        const A = Hi(m);
        return v = Wa(-g + A), w = Wa(g + A), [v - w - u / 3].filter(r);
      }
    }
  },
  // 根据导数控制点计算根，即曲线切线为零的点
  droots: function(i) {
    if (i.length === 3) {
      const e = i[0], n = i[1], s = i[2], r = e - 2 * n + s;
      if (r !== 0) {
        const a = -Hi(n * n - e * s), o = -e + n, h = -(a + o) / r, c = -(-a + o) / r;
        return [h, c];
      } else if (n !== s && r === 0)
        return [(2 * n - s) / (2 * (n - s))];
      return [];
    }
    if (i.length === 2) {
      const e = i[0], n = i[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(i, e, n, s, r) {
    let a, o, h, c, l = 0, u = 0;
    const f = K.compute(i, e), d = K.compute(i, n), p = f.x * f.x + f.y * f.y;
    if (s ? (a = Hi(
      An(f.y * d.z - d.y * f.z, 2) + An(f.z * d.x - d.z * f.x, 2) + An(f.x * d.y - d.x * f.y, 2)
    ), o = An(p + f.z * f.z, 3 / 2)) : (a = f.x * d.y - f.y * d.x, o = An(p, 3 / 2)), a === 0 || o === 0)
      return { k: 0, r: 0 };
    if (l = a / o, u = o / a, !r) {
      const y = K.curvature(i - 1e-3, e, n, s, !0).k, x = K.curvature(i + 1e-3, e, n, s, !0).k;
      c = (x - l + (l - y)) / 2, h = (Ga(x - l) + Ga(l - y)) / 2;
    }
    return { k: l, r: u, dk: c, adk: h };
  },
  inflections: function(i) {
    if (i.length < 4) return [];
    const e = K.align(i, { p1: i[0], p2: i.slice(-1)[0] }), n = e[2].x * e[1].y, s = e[3].x * e[1].y, r = e[1].x * e[2].y, a = e[3].x * e[2].y, o = 18 * (-3 * n + 2 * s + 3 * r - a), h = 18 * (3 * n - s - 3 * r), c = 18 * (r - n);
    if (K.approximately(o, 0)) {
      if (!K.approximately(h, 0)) {
        let d = -c / h;
        if (0 <= d && d <= 1) return [d];
      }
      return [];
    }
    const l = 2 * o;
    if (K.approximately(l, 0)) return [];
    const u = h * h - 4 * o * c;
    if (u < 0) return [];
    const f = Math.sqrt(u);
    return [(f - h) / l, -(h + f) / l].filter(function(d) {
      return 0 <= d && d <= 1;
    });
  },
  bboxoverlap: function(i, e) {
    const n = ["x", "y"], s = n.length;
    for (let r = 0, a, o, h, c; r < s; r++)
      if (a = n[r], o = i[a].mid, h = e[a].mid, c = (i[a].size + e[a].size) / 2, Ga(o - h) >= c) return !1;
    return !0;
  },
  expandbox: function(i, e) {
    e.x.min < i.x.min && (i.x.min = e.x.min), e.y.min < i.y.min && (i.y.min = e.y.min), e.z && e.z.min < i.z.min && (i.z.min = e.z.min), e.x.max > i.x.max && (i.x.max = e.x.max), e.y.max > i.y.max && (i.y.max = e.y.max), e.z && e.z.max > i.z.max && (i.z.max = e.z.max), i.x.mid = (i.x.min + i.x.max) / 2, i.y.mid = (i.y.min + i.y.max) / 2, i.z && (i.z.mid = (i.z.min + i.z.max) / 2), i.x.size = i.x.max - i.x.min, i.y.size = i.y.max - i.y.min, i.z && (i.z.size = i.z.max - i.z.min);
  },
  pairiteration: function(i, e, n) {
    const s = i.bbox(), r = e.bbox(), a = 1e5, o = n || 0.5;
    if (s.x.size + s.y.size < o && r.x.size + r.y.size < o)
      return [
        (a * (i._t1 + i._t2) / 2 | 0) / a + "/" + (a * (e._t1 + e._t2) / 2 | 0) / a
      ];
    let h = i.split(0.5), c = e.split(0.5), l = [
      { left: h.left, right: c.left },
      { left: h.left, right: c.right },
      { left: h.right, right: c.right },
      { left: h.right, right: c.left }
    ];
    l = l.filter(function(f) {
      return K.bboxoverlap(f.left.bbox(), f.right.bbox());
    });
    let u = [];
    return l.length === 0 || (l.forEach(function(f) {
      u = u.concat(
        K.pairiteration(f.left, f.right, o)
      );
    }), u = u.filter(function(f, d) {
      return u.indexOf(f) === d;
    })), u;
  },
  getccenter: function(i, e, n) {
    const s = e.x - i.x, r = e.y - i.y, a = n.x - e.x, o = n.y - e.y, h = s * Ei(Xi) - r * Fr(Xi), c = s * Fr(Xi) + r * Ei(Xi), l = a * Ei(Xi) - o * Fr(Xi), u = a * Fr(Xi) + o * Ei(Xi), f = (i.x + e.x) / 2, d = (i.y + e.y) / 2, p = (e.x + n.x) / 2, y = (e.y + n.y) / 2, x = f + h, g = d + c, m = p + l, v = y + u, w = K.lli8(f, d, x, g, p, y, m, v), b = K.dist(w, i);
    let S = Ua(i.y - w.y, i.x - w.x), E = Ua(e.y - w.y, e.x - w.x), A = Ua(n.y - w.y, n.x - w.x), M;
    return S < A ? ((S > E || E > A) && (S += $h), S > A && (M = A, A = S, S = M)) : A < E && E < S ? (M = A, A = S, S = M) : A += $h, w.s = S, w.e = A, w.r = b, w;
  },
  numberSort: function(i, e) {
    return i - e;
  }
};
class Po {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return K.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), s = 1; s < e.length; s++)
      K.expandbox(n, e[s].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(s) {
      n.push(...s.offset(e));
    }), new Po(n);
  }
}
const { abs: Ya, min: my, max: vy, cos: IS, sin: RS, acos: OS, sqrt: ja } = Math, kS = Math.PI;
class se {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), s = !1;
    if (typeof n[0] == "object") {
      s = n.length;
      const p = [];
      n.forEach(function(y) {
        ["x", "y", "z"].forEach(function(x) {
          typeof y[x] < "u" && p.push(y[x]);
        });
      }), n = p;
    }
    let r = !1;
    const a = n.length;
    if (s) {
      if (s > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        r = !0;
      }
    } else if (a !== 6 && a !== 8 && a !== 9 && a !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const o = this._3d = !r && (a === 9 || a === 12) || e && e[0] && typeof e[0].z < "u", h = this.points = [];
    for (let p = 0, y = o ? 3 : 2; p < a; p += y) {
      var c = {
        x: n[p],
        y: n[p + 1]
      };
      o && (c.z = n[p + 2]), h.push(c);
    }
    const l = this.order = h.length - 1, u = this.dims = ["x", "y"];
    o && u.push("z"), this.dimlen = u.length;
    const f = K.align(h, { p1: h[0], p2: h[l] }), d = K.dist(h[0], h[l]);
    this._linear = f.reduce((p, y) => p + Ya(y.y), 0) < d / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  // 根据t和二次控制点创建基于t的二次贝塞曲线
  static quadraticFromPoints(e, n, s, r) {
    if (typeof r > "u" && (r = 0.5), r === 0)
      return new se(n, n, s);
    if (r === 1)
      return new se(e, n, n);
    const a = se.getABC(2, e, n, s, r);
    return new se(e, a.A, s);
  }
  // 根据t和三次控制点创建基于t的三次贝塞曲线
  static cubicFromPoints(e, n, s, r, a) {
    typeof r > "u" && (r = 0.5);
    const o = se.getABC(3, e, n, s, r);
    typeof a > "u" && (a = K.dist(n, o.C));
    const h = a * (1 - r) / r, c = K.dist(e, s), l = (s.x - e.x) / c, u = (s.y - e.y) / c, f = a * l, d = a * u, p = h * l, y = h * u, x = { x: n.x - f, y: n.y - d }, g = { x: n.x + p, y: n.y + y }, m = o.A, v = { x: m.x + (x.x - m.x) / (1 - r), y: m.y + (x.y - m.y) / (1 - r) }, w = { x: m.x + (g.x - m.x) / r, y: m.y + (g.y - m.y) / r }, b = { x: e.x + (v.x - e.x) / r, y: e.y + (v.y - e.y) / r }, S = {
      x: s.x + (w.x - s.x) / (1 - r),
      y: s.y + (w.y - s.y) / (1 - r)
    };
    return new se(e, b, S, s);
  }
  static getUtils() {
    return K;
  }
  getUtils() {
    return se.getUtils();
  }
  static get PolyBezier() {
    return Po;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return K.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, s = e[0].y, r = ["M", n, s, this.order === 2 ? "Q" : "C"];
    for (let a = 1, o = e.length; a < o; a++)
      r.push(e[a].x), r.push(e[a].y);
    return r.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = K.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = K.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return K.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, s, r, a = 0.5) {
    const o = K.projectionratio(a, e), h = 1 - o, c = {
      x: o * n.x + h * r.x,
      y: o * n.y + h * r.y
    }, l = K.abcratio(a, e);
    return { A: {
      x: s.x + (s.x - c.x) / l,
      y: s.y + (s.y - c.y) / l
    }, B: s, C: c, S: n, E: r };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let s = this.points[0], r = this.points[this.order];
    return se.getABC(this.order, s, n, r, e);
  }
  // 根据步骤数分割贝塞尔曲线为多个点，并返回这些点的数组
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, s, r; n < e; n++)
      r = n / (e - 1), s = this.compute(r), s.t = r, this._lut.push(s);
    return this._lut;
  }
  // 判断点是否在贝塞尔曲线上，并返回t值
  on(e, n) {
    n = n || 5;
    const s = this.getLUT(), r = [];
    for (let a = 0, o, h = 0; a < s.length; a++)
      o = s[a], K.dist(o, e) < n && (r.push(o), h += a / s.length);
    return r.length ? t /= r.length : !1;
  }
  // 投影点至贝塞尔曲线
  //使用基于曲线查找表 (LUT) 的两遍投影测试，查找最接近特定曲线外点的曲线内点。通过距离比较找到最接近的匹配项，然后检查该匹配项周围的精细区间，看看是否可以找到更优的投影
  project(e) {
    const n = this.getLUT(), s = n.length - 1, r = K.closest(n, e), a = r.mpos, o = (a - 1) / s, h = (a + 1) / s, c = 0.1 / s;
    let l = r.mdist, u = o, f = u, d;
    l += 1;
    for (let p; u < h + c; u += c)
      d = this.compute(u), p = K.dist(e, d), p < l && (l = p, f = u);
    return f = f < 0 ? 0 : f > 1 ? 1 : f, d = this.compute(f), d.t = f, d.d = l, d;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  // 计算贝塞尔曲线在t时刻的点
  compute(e) {
    return this.ratios ? K.computeWithRatios(e, this.points, this.ratios, this._3d) : K.compute(e, this.points, this._3d, this.ratios);
  }
  // 向上提升曲线阶数，使之成为更高阶的贝塞尔曲线
  raise() {
    const e = this.points, n = [e[0]], s = e.length;
    for (let r = 1, a, o; r < s; r++)
      a = e[r], o = e[r - 1], n[r] = {
        x: (s - r) / s * a.x + r / s * o.x,
        y: (s - r) / s * a.y + r / s * o.y
      };
    return n[s] = e[s - 1], new se(n);
  }
  //计算指定值处的曲线切线t。注意，这将生成一个非标准化的向量{x: dx, y: dy}。
  derivative(e) {
    return K.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return K.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new se(K.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  //t使用曲率公式计算点处的曲线曲率：
  curvature(e) {
    return K.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  //计算曲线上的所有拐点。即曲线曲率符号发生变化的所有点。
  inflections() {
    return K.inflections(this.points);
  }
  /**
   * 计算指定t值处的曲线法线。注意，这将生成一个法线化的向量{x: nx, y: ny}。
  在二维空间中，法线就是将法线向量旋转四分之一圈。在三维空间中，法线就是将法线向量绕切平面旋转四分之一圈。
   */
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), s = ja(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / s, y: n.x / s };
  }
  __normal3(e) {
    const n = this.derivative(e), s = this.derivative(e + 0.01), r = ja(n.x * n.x + n.y * n.y + n.z * n.z), a = ja(s.x * s.x + s.y * s.y + s.z * s.z);
    n.x /= r, n.y /= r, n.z /= r, s.x /= a, s.y /= a, s.z /= a;
    const o = {
      x: s.y * n.z - s.z * n.y,
      y: s.z * n.x - s.x * n.z,
      z: s.x * n.y - s.y * n.x
    }, h = ja(o.x * o.x + o.y * o.y + o.z * o.z);
    o.x /= h, o.y /= h, o.z /= h;
    const c = [
      o.x * o.x,
      o.x * o.y - o.z,
      o.x * o.z + o.y,
      o.x * o.y + o.z,
      o.y * o.y,
      o.y * o.z - o.x,
      o.x * o.z - o.y,
      o.y * o.z + o.x,
      o.z * o.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  //在所有迭代中，为指定 t 值的曲线上点生成所有包点
  hull(e) {
    let n = this.points, s = [], r = [], a = 0;
    for (r[a++] = n[0], r[a++] = n[1], r[a++] = n[2], this.order === 3 && (r[a++] = n[3]); n.length > 1; ) {
      s = [];
      for (let o = 0, h, c = n.length - 1; o < c; o++)
        h = K.lerp(e, n[o], n[o + 1]), r[a++] = h, s.push(h);
      n = s;
    }
    return r;
  }
  //当仅给出一个值时，此函数将把曲线分成t=... 两条新曲线，这两条新曲线合在一起相当于原始曲线。
  //当提供两个t值时，曲线在 上分割t1，之后得到的第二个子曲线在 （缩放） 上分割t2，从而产生一条与区间 上的原始曲线等价的新曲线[t1,t2]。
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const s = this.hull(e), r = {
      left: this.order === 2 ? new se([s[0], s[3], s[5]]) : new se([s[0], s[4], s[7], s[9]]),
      right: this.order === 2 ? new se([s[5], s[4], s[2]]) : new se([s[9], s[8], s[6], s[3]]),
      span: s
    };
    return r.left._t1 = K.map(0, 0, 1, this._t1, this._t2), r.left._t2 = K.map(e, 0, 1, this._t1, this._t2), r.right._t1 = K.map(e, 0, 1, this._t1, this._t2), r.right._t2 = K.map(1, 0, 1, this._t1, this._t2), n ? (n = K.map(n, e, 1, 0, 1), r.right.split(n).left) : r;
  }
  /*** 
   * 计算曲线上的所有极值。极值是针对每个维度而不是整条曲线计算的，因此结果不是凸/凹过渡的数量，而是每个单独维度的过渡数量。
   * 此函数生成一个对象，其中每个维度列出了出现极值的值 {x: [num, num, ...], y: [...], z: [...], values: [...]} 数组，仅当曲线是 3d 曲线时才存在，并且该属性是所有维度上的值的总和。tzvaluest
  */
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(s) {
        let r = function(o) {
          return o[s];
        }, a = this.dpoints[0].map(r);
        e[s] = K.droots(a), this.order === 3 && (a = this.dpoints[1].map(r), e[s] = e[s].concat(K.droots(a))), e[s] = e[s].filter(function(o) {
          return o >= 0 && o <= 1;
        }), n = n.concat(e[s].sort(K.numberSort));
      }).bind(this)
    ), e.values = n.sort(K.numberSort).filter(function(s, r) {
      return n.indexOf(s) === r;
    }), e;
  }
  // 根据其外壳坐标和极值计算（如果未缓存）此曲线的边界框。
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(s) {
        n[s] = K.getminmax(this, s, e[s]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), s = e.bbox();
    return K.bboxoverlap(n, s);
  }
  /**
   * 如果仅使用距离参数调用此函数，则会创建一条沿曲线法线偏移距离为 的新曲线d。请注意，这里隐藏着深奥的魔法，贝塞尔曲线的偏移曲线永远不可能是另一条贝塞尔曲线。因此，此函数“作弊”并生成一个曲线数组，这些曲线组合在一起，形成一条与理论上的偏移曲线等同的连续曲线。
  
  如果同时给出了距离和t值，则返回坐标，表示曲线上位于 处的点t=...，沿其法线偏移距离d。
   * @param {*} t 
   * @param {*} d 
   * @returns 
   */
  offset(e, n) {
    if (typeof n < "u") {
      const s = this.get(e), r = this.normal(e), a = {
        c: s,
        n: r,
        x: s.x + r.x * n,
        y: s.y + r.y * n
      };
      return this._3d && (a.z = s.z + r.z * n), a;
    }
    if (this._linear) {
      const s = this.normal(0), r = this.points.map(function(a) {
        const o = {
          x: a.x + e * s.x,
          y: a.y + e * s.y
        };
        return a.z && s.z && (o.z = a.z + e * s.z), o;
      });
      return [new se(r)];
    }
    return this.reduce().map(function(s) {
      return s._linear ? s.offset(e)[0] : s.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const r = K.angle(this.points[0], this.points[3], this.points[1]), a = K.angle(this.points[0], this.points[3], this.points[2]);
      if (r > 0 && a < 0 || r < 0 && a > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let s = e.x * n.x + e.y * n.y;
    return this._3d && (s += e.z * n.z), Ya(OS(s)) < kS / 3;
  }
  /**
   * 将曲线简化为“简单”子曲线的集合，其中简单性定义为所有控制点都在基线的同一侧（三次曲线具有控制到端点线不得交叉的附加约束），并且端点法线之间的角度不大于 60 度。
   * @returns 
   */
  reduce() {
    let e, n = 0, s = 0, r = 0.01, a, o = [], h = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      s = c[e], a = this.split(n, s), a._t1 = n, a._t2 = s, o.push(a), n = s;
    return o.forEach(function(l) {
      for (n = 0, s = 0; s <= 1; )
        for (s = n + r; s <= 1 + r; s += r)
          if (a = l.split(n, s), !a.simple()) {
            if (s -= r, Ya(n - s) < r)
              return [];
            a = l.split(n, s), a._t1 = K.map(n, 0, 1, l._t1, l._t2), a._t2 = K.map(s, 0, 1, l._t1, l._t2), h.push(a), n = s;
            break;
          }
      n < 1 && (a = l.split(n, 1), a._t1 = K.map(n, 0, 1, l._t1, l._t2), a._t2 = l._t2, h.push(a));
    }), h;
  }
  translate(e, n, s) {
    s = typeof s == "number" ? s : n;
    const r = this.order;
    let a = this.points.map((o, h) => (1 - h / r) * n + h / r * s);
    return new se(
      this.points.map((o, h) => ({
        x: o.x + e.x * a[h],
        y: o.y + e.y * a[h]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let s = !1;
    if (typeof e == "function" && (s = e), s && n === 2)
      return this.raise().scale(s);
    const r = this.clockwise, a = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        s ? s(0) : e,
        s ? s(1) : e
      );
    const o = s ? s(0) : e, h = s ? s(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], l = [], u = K.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!u)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(f) {
      const d = l[f * n] = K.copy(a[f * n]);
      d.x += (f ? h : o) * c[f].n.x, d.y += (f ? h : o) * c[f].n.y;
    }), s ? ([0, 1].forEach(function(f) {
      if (!(n === 2 && f)) {
        var d = a[f + 1], p = {
          x: d.x - u.x,
          y: d.y - u.y
        }, y = s ? s((f + 1) / n) : e;
        s && !r && (y = -y);
        var x = ja(p.x * p.x + p.y * p.y);
        p.x /= x, p.y /= x, l[f + 1] = {
          x: d.x + y * p.x,
          y: d.y + y * p.y
        };
      }
    }), new se(l)) : ([0, 1].forEach((f) => {
      if (n === 2 && f) return;
      const d = l[f * n], p = this.derivative(f), y = { x: d.x + p.x, y: d.y + p.y };
      l[f + 1] = K.lli4(d, y, u, a[f + 1]);
    }), new se(l));
  }
  /**
   * 这将生成一条曲线的轮廓，该轮廓沿着曲线法线和反向法线方向的一定距离d。结果是一个曲线数组，这些曲线组合在一起构成了该曲线的轮廓路径。顶点是三次贝塞尔曲线，其控制点的方向形成一条直线。
   通过使用四个距离测量来实现渐进偏移，其中d1 是沿法线的初始偏移，d2沿反法线的初始距离，d3沿法线的最终偏移，以及d4沿反法线的最终偏移。
  * @param {*} d1 
   * @param {*} d2 
   * @param {*} d3 
   * @param {*} d4 
   * @returns 
   */
  outline(e, n, s, r) {
    if (n = n === void 0 ? e : n, this._linear) {
      const S = this.normal(0), E = this.points[0], A = this.points[this.points.length - 1];
      let M, _, T;
      s === void 0 && (s = e, r = n), M = { x: E.x + S.x * e, y: E.y + S.y * e }, T = { x: A.x + S.x * s, y: A.y + S.y * s }, _ = { x: (M.x + T.x) / 2, y: (M.y + T.y) / 2 };
      const C = [M, _, T];
      M = { x: E.x - S.x * n, y: E.y - S.y * n }, T = { x: A.x - S.x * r, y: A.y - S.y * r }, _ = { x: (M.x + T.x) / 2, y: (M.y + T.y) / 2 };
      const P = [T, _, M], R = K.makeline(P[2], C[0]), k = K.makeline(C[2], P[0]), I = [R, new se(C), k, new se(P)];
      return new Po(I);
    }
    const a = this.reduce(), o = a.length, h = [];
    let c = [], l, u = 0, f = this.length();
    const d = typeof s < "u" && typeof r < "u";
    function p(S, E, A, M, _) {
      return function(T) {
        const C = M / A, P = (M + _) / A, R = E - S;
        return K.map(T, 0, 1, S + C * R, S + P * R);
      };
    }
    a.forEach(function(S) {
      const E = S.length();
      d ? (h.push(
        S.scale(p(e, s, f, u, E))
      ), c.push(
        S.scale(p(-n, -r, f, u, E))
      )) : (h.push(S.scale(e)), c.push(S.scale(-n))), u += E;
    }), c = c.map(function(S) {
      return l = S.points, l[3] ? S.points = [l[3], l[2], l[1], l[0]] : S.points = [l[2], l[1], l[0]], S;
    }).reverse();
    const y = h[0].points[0], x = h[o - 1].points[h[o - 1].points.length - 1], g = c[o - 1].points[c[o - 1].points.length - 1], m = c[0].points[0], v = K.makeline(g, y), w = K.makeline(x, m), b = [v].concat(h).concat([w]).concat(c);
    return new Po(b);
  }
  /**
   * 这会将曲线轮廓生成为一系列形状，而不是路径序列。每个形状都是一个对象{startcap: (bezier), forward: (bezier), endcap: (bezier), back: (bezier)}。此外，每个端点都有一个.virtual属性，用于指示它是原始曲线轮廓的真正端点，还是轮廓形状集合中某个位置的中间端点。
   * @param {*} d1 
   * @param {*} d2 
   * @param {*} curveIntersectionThreshold 
   * @returns 
   */
  outlineshapes(e, n, s) {
    n = n || e;
    const r = this.outline(e, n).curves, a = [];
    for (let o = 1, h = r.length; o < h / 2; o++) {
      const c = K.makeshape(
        r[o],
        r[h - o],
        s
      );
      c.startcap.virtual = o > 1, c.endcap.virtual = o < h / 2 - 1, a.push(c);
    }
    return a;
  }
  /**
   * 如果不带参数，此函数将检查自相交。这意味着它对二次曲线没有意义，二次曲线若自相交则为退化曲线（即所有坐标都位于同一条线上，因此与其说是“曲线”，不如说是一种“奇怪的画线方法”）。相交结果将返回一个字符串数组float/float，其中两个浮点数由字符分隔/，并且两个浮点数都对应于t相交点处的曲线值。
   * @param {*} curve 
   * @param {*} curveIntersectionThreshold 
   * @returns 
   */
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof se && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  /**
    * 查找此曲线与某条线的交点{p1: {x:... ,y:...}, p2: ... }。交点是t此曲线上的值的数组。
  首先对曲线进行对齐（平移/旋转），使曲线的第一个坐标为 (0,0)，然后旋转曲线，使相交线与 x 轴重合。这样做会将“查找交点”转换为简单的“查找根点”。
  作为求根解决方案，使用您可能在高中时记得的标准平方根函数以及绝对非标准的 Cardano 求解立方根函数算法，以符号方式计算二次和三次曲线的根。
    * @param {*} line 
    * @returns 
    */
  lineIntersects(e) {
    const n = my(e.p1.x, e.p2.x), s = my(e.p1.y, e.p2.y), r = vy(e.p1.x, e.p2.x), a = vy(e.p1.y, e.p2.y);
    return K.roots(this.points, e).filter((o) => {
      var h = this.get(o);
      return K.between(h.x, n, r) && K.between(h.y, s, a);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), s = n.length - 2, r = [];
    for (let a = 0, o, h, c; a < s; a++)
      h = n.slice(a, a + 1), c = n.slice(a + 2), o = this.curveintersects(h, c, e), r.push(...o);
    return r;
  }
  curveintersects(e, n, s) {
    const r = [];
    e.forEach(function(o) {
      n.forEach(function(h) {
        o.overlaps(h) && r.push({ left: o, right: h });
      });
    });
    let a = [];
    return r.forEach(function(o) {
      const h = K.pairiteration(
        o.left,
        o.right,
        s
      );
      h.length > 0 && (a = a.concat(h));
    }), a;
  }
  /** 
   * 将贝塞尔曲线近似为一系列圆弧。可选的阈值参数控制圆弧需要达到何种程度的拟合才能被视为合理的近似值。阈值越高，圆弧拟合的精度越低。如果未设置明确的阈值，则使用threshold的值。0.5
  */
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, s, r) {
    const a = (r - s) / 4, o = this.get(s + a), h = this.get(r - a), c = K.dist(e, n), l = K.dist(e, o), u = K.dist(e, h);
    return Ya(l - c) + Ya(u - c);
  }
  _iterate(e, n) {
    let s = 0, r = 1, a;
    do {
      a = 0, r = 1;
      let o = this.get(s), h, c, l, u, f = !1, d = !1, p, y = r, x = 1;
      do
        if (d = f, u = l, y = (s + r) / 2, h = this.get(y), c = this.get(r), l = K.getccenter(o, h, c), l.interval = {
          start: s,
          end: r
        }, f = this._error(l, o, s, r) <= e, p = d && !f, p || (x = r), f) {
          if (r >= 1) {
            if (l.interval.end = x = 1, u = l, r > 1) {
              let m = {
                x: l.x + l.r * IS(l.e),
                y: l.y + l.r * RS(l.e)
              };
              l.e += K.angle({ x: l.x, y: l.y }, m, this.get(1));
            }
            break;
          }
          r = r + (r - s) / 2;
        } else
          r = y;
      while (!p && a++ < 100);
      if (a >= 100)
        break;
      u = u || l, n.push(u), s = x;
    } while (r < 1);
    return n;
  }
}
const va = N.distanceSquared, Vh = Math.pow, ms = Math.sqrt, yl = 1e-8, dm = 1e-4, wy = ms(3), Gh = 1 / 3, pi = N.default(), kn = N.default(), wa = N.default();
function fs(i) {
  return i > -yl && i < yl;
}
function pm(i) {
  return i > yl || i < -yl;
}
function Ve(i, e, n, s, r) {
  const a = 1 - r;
  return a * a * (a * i + 3 * r * e) + r * r * (r * s + 3 * a * n);
}
function LS(i, e, n, s, r) {
  const a = 1 - r;
  return 3 * (((e - i) * a + 2 * (n - e) * r) * a + (s - n) * r * r);
}
function fd(i, e, n, s, r, a) {
  const o = s + 3 * (e - n) - i, h = 3 * (n - e * 2 + i), c = 3 * (e - i), l = i - r, u = h * h - 3 * o * c, f = h * c - 9 * o * l, d = c * c - 3 * h * l;
  let p = 0;
  if (fs(u) && fs(f))
    if (fs(h))
      a[0] = 0;
    else {
      const y = -c / h;
      y >= 0 && y <= 1 && (a[p++] = y);
    }
  else {
    const y = f * f - 4 * u * d;
    if (fs(y)) {
      const x = f / u, g = -h / o + x, m = -x / 2;
      g >= 0 && g <= 1 && (a[p++] = g), m >= 0 && m <= 1 && (a[p++] = m);
    } else if (y > 0) {
      const x = ms(y);
      let g = u * h + 1.5 * o * (-f + x), m = u * h + 1.5 * o * (-f - x);
      g < 0 ? g = -Vh(-g, Gh) : g = Vh(g, Gh), m < 0 ? m = -Vh(-m, Gh) : m = Vh(m, Gh);
      const v = (-h - (g + m)) / (3 * o);
      v >= 0 && v <= 1 && (a[p++] = v);
    } else {
      const x = (2 * u * h - 3 * o * f) / (2 * ms(u * u * u)), g = Math.acos(x) / 3, m = ms(u), v = Math.cos(g), w = (-h - 2 * m * v) / (3 * o), b = (-h + m * (v + wy * Math.sin(g))) / (3 * o), S = (-h + m * (v - wy * Math.sin(g))) / (3 * o);
      w >= 0 && w <= 1 && (a[p++] = w), b >= 0 && b <= 1 && (a[p++] = b), S >= 0 && S <= 1 && (a[p++] = S);
    }
  }
  return p;
}
function dd(i, e, n, s, r) {
  const a = 6 * n - 12 * e + 6 * i, o = 9 * e + 3 * s - 3 * i - 9 * n, h = 3 * e - 3 * i;
  let c = 0;
  if (fs(o)) {
    if (pm(a)) {
      const l = -h / a;
      l >= 0 && l <= 1 && (r[c++] = l);
    }
  } else {
    const l = a * a - 4 * o * h;
    if (fs(l))
      r[0] = -a / (2 * o);
    else if (l > 0) {
      const u = ms(l), f = (-a + u) / (2 * o), d = (-a - u) / (2 * o);
      f >= 0 && f <= 1 && (r[c++] = f), d >= 0 && d <= 1 && (r[c++] = d);
    }
  }
  return c;
}
function Qf(i, e, n, s, r, a) {
  const o = (e - i) * r + i, h = (n - e) * r + e, c = (s - n) * r + n, l = (h - o) * r + o, u = (c - h) * r + h, f = (u - l) * r + l;
  a[0] = i, a[1] = o, a[2] = l, a[3] = f, a[4] = f, a[5] = u, a[6] = c, a[7] = s;
}
function FS(i, e, n, s, r, a, o, h, c, l, u) {
  let f = 0, d = 5e-3, p = 1 / 0, y, x, g, m;
  pi[0] = c, pi[1] = l;
  for (let v = 0; v < 1; v += 0.05)
    kn[0] = Ve(i, n, r, o, v), kn[1] = Ve(e, s, a, h, v), g = va(pi, kn), g < p && (f = v, p = g);
  p = 1 / 0;
  for (let v = 0; v < 32 && !(d < dm); v++)
    y = f - d, x = f + d, kn[0] = Ve(i, n, r, o, y), kn[1] = Ve(e, s, a, h, y), g = va(kn, pi), y >= 0 && g < p ? (f = y, p = g) : (wa[0] = Ve(i, n, r, o, x), wa[1] = Ve(e, s, a, h, x), m = va(wa, pi), x <= 1 && m < p ? (f = x, p = m) : d *= 0.5);
  return u && (u[0] = Ve(i, n, r, o, f), u[1] = Ve(e, s, a, h, f)), ms(p);
}
function ym(i, e, n, s, r, a, o, h, c) {
  let l = i, u = e, f = 0;
  const d = 1 / c;
  for (let p = 1; p <= c; p++) {
    let y = p * d;
    const x = Ve(i, n, r, o, y), g = Ve(e, s, a, h, y), m = x - l, v = g - u;
    f += Math.sqrt(m * m + v * v), l = x, u = g;
  }
  return f;
}
function Xe(i, e, n, s) {
  const r = 1 - s;
  return r * (r * i + 2 * s * e) + s * s * n;
}
function NS(i, e, n, s) {
  return 2 * ((1 - s) * (e - i) + s * (n - e));
}
function xm(i, e, n, s, r) {
  const a = i - 2 * e + n, o = 2 * (e - i), h = i - s;
  let c = 0;
  if (fs(a)) {
    if (pm(o)) {
      const l = -h / o;
      l >= 0 && l <= 1 && (r[c++] = l);
    }
  } else {
    const l = o * o - 4 * a * h;
    if (fs(l)) {
      const u = -o / (2 * a);
      u >= 0 && u <= 1 && (r[c++] = u);
    } else if (l > 0) {
      const u = ms(l), f = (-o + u) / (2 * a), d = (-o - u) / (2 * a);
      f >= 0 && f <= 1 && (r[c++] = f), d >= 0 && d <= 1 && (r[c++] = d);
    }
  }
  return c;
}
function pd(i, e, n) {
  const s = i + n - 2 * e;
  return s === 0 ? 0.5 : (i - e) / s;
}
function Kf(i, e, n, s, r) {
  const a = (e - i) * s + i, o = (n - e) * s + e, h = (o - a) * s + a;
  r[0] = i, r[1] = a, r[2] = h, r[3] = h, r[4] = o, r[5] = n;
}
function BS(i, e, n, s, r, a, o, h, c) {
  let l = 0, u = 5e-3, f = 1 / 0;
  pi[0] = o, pi[1] = h;
  for (let d = 0; d < 1; d += 0.05) {
    kn[0] = Xe(i, n, r, d), kn[1] = Xe(e, s, a, d);
    const p = va(pi, kn);
    p < f && (l = d, f = p);
  }
  f = 1 / 0;
  for (let d = 0; d < 32 && !(u < dm); d++) {
    const p = l - u, y = l + u;
    kn[0] = Xe(i, n, r, p), kn[1] = Xe(e, s, a, p);
    const x = va(kn, pi);
    if (p >= 0 && x < f)
      l = p, f = x;
    else {
      wa[0] = Xe(i, n, r, y), wa[1] = Xe(e, s, a, y);
      const g = va(wa, pi);
      y <= 1 && g < f ? (l = y, f = g) : u *= 0.5;
    }
  }
  return c && (c[0] = Xe(i, n, r, l), c[1] = Xe(e, s, a, l)), ms(f);
}
function gm(i, e, n, s, r, a, o) {
  let h = i, c = e, l = 0;
  const u = 1 / o;
  for (let f = 1; f <= o; f++) {
    let d = f * u;
    const p = Xe(i, n, r, d), y = Xe(e, s, a, d), x = p - h, g = y - c;
    l += Math.sqrt(x * x + g * g), h = p, c = y;
  }
  return l;
}
const DS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cubicAt: Ve,
  cubicDerivativeAt: LS,
  cubicExtrema: dd,
  cubicLength: ym,
  cubicProjectPoint: FS,
  cubicRootAt: fd,
  cubicSubdivide: Qf,
  quadraticAt: Xe,
  quadraticDerivativeAt: NS,
  quadraticExtremum: pd,
  quadraticLength: gm,
  quadraticProjectPoint: BS,
  quadraticRootAt: xm,
  quadraticSubdivide: Kf
}, Symbol.toStringTag, { value: "Module" }));
class qS {
  xs;
  ys;
  ks;
  constructor(e, n) {
    this.xs = e, this.ys = n, this.ks = this.getNaturalKs(new Float64Array(this.xs.length));
  }
  getNaturalKs(e) {
    const n = this.xs.length - 1, s = VS(n + 1, n + 2);
    for (let r = 1; r < n; r++)
      s[r][r - 1] = 1 / (this.xs[r] - this.xs[r - 1]), s[r][r] = 2 * (1 / (this.xs[r] - this.xs[r - 1]) + 1 / (this.xs[r + 1] - this.xs[r])), s[r][r + 1] = 1 / (this.xs[r + 1] - this.xs[r]), s[r][n + 1] = 3 * ((this.ys[r] - this.ys[r - 1]) / ((this.xs[r] - this.xs[r - 1]) * (this.xs[r] - this.xs[r - 1])) + (this.ys[r + 1] - this.ys[r]) / ((this.xs[r + 1] - this.xs[r]) * (this.xs[r + 1] - this.xs[r])));
    return s[0][0] = 2 / (this.xs[1] - this.xs[0]), s[0][1] = 1 / (this.xs[1] - this.xs[0]), s[0][n + 1] = 3 * (this.ys[1] - this.ys[0]) / ((this.xs[1] - this.xs[0]) * (this.xs[1] - this.xs[0])), s[n][n - 1] = 1 / (this.xs[n] - this.xs[n - 1]), s[n][n] = 2 / (this.xs[n] - this.xs[n - 1]), s[n][n + 1] = 3 * (this.ys[n] - this.ys[n - 1]) / ((this.xs[n] - this.xs[n - 1]) * (this.xs[n] - this.xs[n - 1])), $S(s, e);
  }
  /**
   * inspired by https://stackoverflow.com/a/40850313/4417327
   */
  getIndexBefore(e) {
    let n = 0, s = this.xs.length, r = 0;
    for (; n < s; )
      r = Math.floor((n + s) / 2), this.xs[r] < e && r !== n ? n = r : this.xs[r] >= e && r !== s ? s = r : s = n;
    return n === this.xs.length - 1 ? this.xs.length - 1 : n + 1;
  }
  at(e) {
    let n = this.getIndexBefore(e);
    const s = (e - this.xs[n - 1]) / (this.xs[n] - this.xs[n - 1]), r = this.ks[n - 1] * (this.xs[n] - this.xs[n - 1]) - (this.ys[n] - this.ys[n - 1]), a = -this.ks[n] * (this.xs[n] - this.xs[n - 1]) + (this.ys[n] - this.ys[n - 1]);
    return (1 - s) * this.ys[n - 1] + s * this.ys[n] + s * (1 - s) * (r * (1 - s) + a * s);
  }
}
function $S(i, e) {
  const n = i.length;
  let s = 0, r = 0;
  for (; s < n && r <= n; ) {
    let o = 0, h = -1 / 0;
    for (let c = s; c < n; c++) {
      const l = Math.abs(i[c][r]);
      l > h && (o = c, h = l);
    }
    if (i[o][r] === 0)
      r++;
    else {
      GS(i, s, o);
      for (let c = s + 1; c < n; c++) {
        const l = i[c][r] / i[s][r];
        i[c][r] = 0;
        for (let u = r + 1; u <= n; u++) i[c][u] -= i[s][u] * l;
      }
      s++, r++;
    }
  }
  for (let o = n - 1; o >= 0; o--) {
    var a = 0;
    i[o][o] && (a = i[o][n] / i[o][o]), e[o] = a;
    for (let h = o - 1; h >= 0; h--)
      i[h][n] -= i[h][o] * a, i[h][o] = 0;
  }
  return e;
}
function VS(i, e) {
  const n = [];
  for (let s = 0; s < i; s++) n.push(new Float64Array(e));
  return n;
}
function GS(i, e, n) {
  let s = i[e];
  i[e] = i[n], i[n] = s;
}
class US {
  firefox = !1;
  ie = !1;
  edge = !1;
  newEdge = !1;
  weChat = !1;
  version;
}
class WS {
  browser = new US();
  node = !1;
  wxa = !1;
  worker = !1;
  svgSupported = !1;
  touchEventsSupported = !1;
  pointerEventsSupported = !1;
  domSupported = !1;
  transformSupported = !1;
  transform3dSupported = !1;
  hasGlobalWindow = typeof window < "u";
}
const hs = new WS();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (hs.wxa = !0, hs.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? hs.worker = !0 : !hs.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (hs.node = !0, hs.svgSupported = !0) : YS(navigator.userAgent, hs);
function YS(i, e) {
  const n = e.browser, s = i.match(/Firefox\/([\d.]+)/), r = i.match(/MSIE\s([\d.]+)/) || i.match(/Trident\/.+?rv:(([\d.]+))/), a = i.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(i);
  if (s && (n.firefox = !0, n.version = s[1]), r && (n.ie = !0, n.version = r[1]), a && (n.edge = !0, n.version = a[1], n.newEdge = +a[1].split(".")[0] > 18), o && (n.weChat = !0), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !n.ie && !n.edge, e.pointerEventsSupported = "onpointerdown" in window && (n.edge || n.ie && +n.version >= 11), e.domSupported = typeof document < "u") {
    const c = document.documentElement.style;
    e.transform3dSupported = // IE9 only supports transform 2D
    // transform 3D supported since IE10
    // we detect it by whether 'transition' is in style
    (n.ie && "transition" in c || n.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in c) && !("OTransition" in c), e.transformSupported = e.transform3dSupported || n.ie && +n.version >= 9;
  }
}
hs.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame);
const mm = 12, jS = "sans-serif", xl = `${mm}px ${jS}`, HS = 20, XS = 100, ZS = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function JS(i) {
  const e = {};
  if (typeof JSON > "u")
    return e;
  for (let n = 0; n < i.length; n++) {
    const s = String.fromCharCode(n + 32), r = (i.charCodeAt(n) - HS) / XS;
    e[s] = r;
  }
  return e;
}
const QS = JS(ZS), Aa = {
  // Export methods
  createCanvas() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    let i, e;
    return (n, s) => {
      if (!i) {
        const r = Aa.createCanvas();
        i = r && r.getContext("2d");
      }
      if (i)
        return e !== s && (e = i.font = s || xl), i.measureText(n);
      {
        n = n || "", s = s || xl;
        const r = /((?:\d+)?\.?\d*)px/.exec(s), a = r && +r[1] || mm;
        let o = 0;
        if (s.indexOf("mono") >= 0)
          o = a * n.length;
        else
          for (let h = 0; h < n.length; h++) {
            const c = QS[n[h]];
            o += c == null ? a : c * a;
          }
        return { width: o };
      }
    };
  }(),
  loadImage(i, e, n) {
    const s = new Image();
    return s.onload = e, s.onerror = n, s.src = i, s;
  }
};
vm([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  // For node-canvas
  "Image",
  "Canvas"
], (i, e) => (i["[object " + e + "]"] = !0, i), {});
vm([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], (i, e) => (i["[object " + e + "Array]"] = !0, i), {});
const KS = Array.prototype, tT = KS.slice, My = (function() {
}).constructor, Uh = My ? My.prototype : null;
function by(i) {
  return !i || typeof i == "string" ? !1 : typeof i.length == "number";
}
function vm(i, e, n, s) {
  if (i && e) {
    for (let r = 0, a = i.length; r < a; r++)
      n = e.call(s, n, i[r], r, i);
    return n;
  }
}
function eT(i, e, ...n) {
  return function() {
    return i.apply(e, n.concat(tT.call(arguments)));
  };
}
Uh && nT(Uh.bind) && Uh.call.bind(Uh.bind);
function nT(i) {
  return typeof i == "function";
}
function Wh(i) {
  return i == null ? null : typeof i.trim == "function" ? i.trim() : i.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
const iT = /cubic-bezier\(([0-9,\.e ]+)\)/;
function sT(i) {
  const e = i && iT.exec(i);
  if (e) {
    const n = e[1].split(","), s = +Wh(n[0]), r = +Wh(n[1]), a = +Wh(n[2]), o = +Wh(n[3]);
    if (isNaN(s + r + a + o))
      return;
    const h = [];
    return (c) => c <= 0 ? 0 : c >= 1 ? 1 : fd(0, s, a, 1, c, h) && Ve(0, r, o, 1, h[0]);
  }
}
const _y = Array.prototype.slice;
function rT(i) {
  if (by(i)) {
    const e = i.length;
    if (by(i[0])) {
      const n = [];
      for (let s = 0; s < e; s++)
        n.push(_y.call(i[s]));
      return n;
    }
    return _y.call(i);
  }
  return i;
}
function aT() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const oT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cloneValue: rT,
  createCubicEasingFunc: sT,
  getTime: aT
}, Symbol.toStringTag, { value: "Module" })), Ma = Object.freeze({
  Linear: Object.freeze({
    None(i) {
      return i;
    },
    In(i) {
      return i;
    },
    Out(i) {
      return i;
    },
    InOut(i) {
      return i;
    }
  }),
  Quadratic: Object.freeze({
    In(i) {
      return i * i;
    },
    Out(i) {
      return i * (2 - i);
    },
    InOut(i) {
      return (i *= 2) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In(i) {
      return i * i * i;
    },
    Out(i) {
      return --i * i * i + 1;
    },
    InOut(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);
    }
  }),
  Quartic: Object.freeze({
    In(i) {
      return i * i * i * i;
    },
    Out(i) {
      return 1 - --i * i * i * i;
    },
    InOut(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);
    }
  }),
  Quintic: Object.freeze({
    In(i) {
      return i * i * i * i * i;
    },
    Out(i) {
      return --i * i * i * i * i + 1;
    },
    InOut(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In(i) {
      return 1 - Math.sin((1 - i) * Math.PI / 2);
    },
    Out(i) {
      return Math.sin(i * Math.PI / 2);
    },
    InOut(i) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - i)));
    }
  }),
  Exponential: Object.freeze({
    In(i) {
      return i === 0 ? 0 : Math.pow(1024, i - 1);
    },
    Out(i) {
      return i === 1 ? 1 : 1 - Math.pow(2, -10 * i);
    },
    InOut(i) {
      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2) < 1 ? 0.5 * Math.pow(1024, i - 1) : 0.5 * (-Math.pow(2, -10 * (i - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In(i) {
      return 1 - Math.sqrt(1 - i * i);
    },
    Out(i) {
      return Math.sqrt(1 - --i * i);
    },
    InOut(i) {
      return (i *= 2) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);
    }
  }),
  Elastic: Object.freeze({
    In(i) {
      return i === 0 ? 0 : i === 1 ? 1 : -Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI);
    },
    Out(i) {
      return i === 0 ? 0 : i === 1 ? 1 : Math.pow(2, -10 * i) * Math.sin((i - 0.1) * 5 * Math.PI) + 1;
    },
    InOut(i) {
      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2, i < 1 ? -0.5 * Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In(i) {
      return i === 1 ? 1 : i * i * ((1.70158 + 1) * i - 1.70158);
    },
    Out(i) {
      return i === 0 ? 0 : --i * i * ((1.70158 + 1) * i + 1.70158) + 1;
    },
    InOut(i) {
      const e = 2.5949095;
      return (i *= 2) < 1 ? 0.5 * (i * i * ((e + 1) * i - e)) : 0.5 * ((i -= 2) * i * ((e + 1) * i + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In(i) {
      return 1 - Ma.Bounce.Out(1 - i);
    },
    Out(i) {
      return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;
    },
    InOut(i) {
      return i < 0.5 ? Ma.Bounce.In(i * 2) * 0.5 : Ma.Bounce.Out(i * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow(i = 4) {
    return i = i < Number.EPSILON ? Number.EPSILON : i, i = i > 1e4 ? 1e4 : i, {
      In(e) {
        return e ** i;
      },
      Out(e) {
        return 1 - (1 - e) ** i;
      },
      InOut(e) {
        return e < 0.5 ? (e * 2) ** i / 2 : (1 - (2 - e * 2) ** i) / 2 + 0.5;
      }
    };
  }
});
let wm = () => performance.now();
const la = () => wm();
function hT(i) {
  wm = i;
}
class Mm {
  _tweens = {};
  _tweensAddedDuringUpdate = {};
  constructor(...e) {
    this.add(...e);
  }
  getAll() {
    return Object.keys(this._tweens).map((e) => this._tweens[e]);
  }
  removeAll() {
    this._tweens = {};
  }
  add(...e) {
    for (const n of e)
      n._group?.remove(n), n._group = this, this._tweens[n.getId()] = n, this._tweensAddedDuringUpdate[n.getId()] = n;
  }
  remove(...e) {
    for (const n of e)
      n._group = void 0, delete this._tweens[n.getId()], delete this._tweensAddedDuringUpdate[n.getId()];
  }
  /** Return true if all tweens in the group are not paused or playing. */
  allStopped() {
    return this.getAll().every((e) => !e.isPlaying());
  }
  update(e = la(), n = !0) {
    let s = Object.keys(this._tweens);
    if (s.length !== 0)
      for (; s.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (let r = 0; r < s.length; r++) {
          const a = this._tweens[s[r]], o = !n;
          a && a.update(e, o) === !1 && !n && this.remove(a);
        }
        s = Object.keys(this._tweensAddedDuringUpdate);
      }
  }
  onComplete(e) {
    const n = this.getAll();
    n.forEach((s) => {
      const r = s.getCompleteCallback();
      s.onComplete(() => {
        r?.(s), n.filter((o) => !o.isPlaying()).length === n.length - 1 && e(n);
      });
    });
  }
}
const rr = {
  Linear: function(i, e) {
    const n = i.length - 1, s = n * e, r = Math.floor(s), a = rr.Utils.Linear;
    return e < 0 ? a(i[0], i[1], s) : e > 1 ? a(i[n], i[n - 1], n - s) : a(i[r], i[r + 1 > n ? n : r + 1], s - r);
  },
  Bezier: function(i, e) {
    let n = 0;
    const s = i.length - 1, r = Math.pow, a = rr.Utils.Bernstein;
    for (let o = 0; o <= s; o++)
      n += r(1 - e, s - o) * r(e, o) * i[o] * a(s, o);
    return n;
  },
  CatmullRom: function(i, e) {
    const n = i.length - 1;
    let s = n * e, r = Math.floor(s);
    const a = rr.Utils.CatmullRom;
    return i[0] === i[n] ? (e < 0 && (r = Math.floor(s = n * (1 + e))), a(i[(r - 1 + n) % n], i[r], i[(r + 1) % n], i[(r + 2) % n], s - r)) : e < 0 ? i[0] - (a(i[0], i[0], i[1], i[1], -s) - i[0]) : e > 1 ? i[n] - (a(i[n], i[n], i[n - 1], i[n - 1], s - n) - i[n]) : a(i[r ? r - 1 : 0], i[r], i[n < r + 1 ? n : r + 1], i[n < r + 2 ? n : r + 2], s - r);
  },
  Utils: {
    Linear: function(i, e, n) {
      return (e - i) * n + i;
    },
    Bernstein: function(i, e) {
      const n = rr.Utils.Factorial;
      return n(i) / n(e) / n(i - e);
    },
    Factorial: /* @__PURE__ */ function() {
      const i = [1];
      return function(e) {
        let n = 1;
        if (i[e])
          return i[e];
        for (let s = e; s > 1; s--)
          n *= s;
        return i[e] = n, n;
      };
    }(),
    CatmullRom: function(i, e, n, s, r) {
      const a = (n - i) * 0.5, o = (s - e) * 0.5, h = r * r, c = r * h;
      return (2 * e - 2 * n + a + o) * c + (-3 * e + 3 * n - 2 * a - o) * h + a * r + e;
    }
  }
};
class Sh {
  static _nextId = 0;
  static nextId() {
    return Sh._nextId++;
  }
}
const t0 = new Mm();
let cT = class bm {
  static autoStartOnUpdate = !1;
  _isPaused = !1;
  _pauseStart = 0;
  _valuesStart = {};
  _valuesEnd = {};
  _valuesStartRepeat = {};
  _duration = 1e3;
  _isDynamic = !1;
  _initialRepeat = 0;
  _repeat = 0;
  _repeatDelayTime;
  _yoyo = !1;
  _isPlaying = !1;
  _reversed = !1;
  _delayTime = 0;
  _startTime = 0;
  _easingFunction = Ma.Linear.None;
  _interpolationFunction = rr.Linear;
  // eslint-disable-next-line
  _chainedTweens = [];
  _onStartCallback;
  _onStartCallbackFired = !1;
  _onEveryStartCallback;
  _onEveryStartCallbackFired = !1;
  _onUpdateCallback;
  _onRepeatCallback;
  _onCompleteCallback;
  _onStopCallback;
  _id = Sh.nextId();
  _isChainStopped = !1;
  _propertiesAreSetUp = !1;
  _object;
  _group;
  constructor(e, n) {
    this._object = e, typeof n == "object" ? (this._group = n, n.add(this)) : n === !0 && (this._group = t0, t0.add(this));
  }
  getId() {
    return this._id;
  }
  getCompleteCallback() {
    return this._onCompleteCallback;
  }
  isPlaying() {
    return this._isPlaying;
  }
  isPaused() {
    return this._isPaused;
  }
  getDuration() {
    return this._duration;
  }
  to(e, n = 1e3) {
    if (this._isPlaying)
      throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
    return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = n < 0 ? 0 : n, this;
  }
  duration(e = 1e3) {
    return this._duration = e < 0 ? 0 : e, this;
  }
  dynamic(e = !1) {
    return this._isDynamic = e, this;
  }
  start(e = la(), n = !1) {
    if (this._isPlaying)
      return this;
    if (this._repeat = this._initialRepeat, this._reversed) {
      this._reversed = !1;
      for (const s in this._valuesStartRepeat)
        this._swapEndStartRepeatValues(s), this._valuesStart[s] = this._valuesStartRepeat[s];
    }
    if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || n) {
      if (this._propertiesAreSetUp = !0, !this._isDynamic) {
        const s = {};
        for (const r in this._valuesEnd) s[r] = this._valuesEnd[r];
        this._valuesEnd = s;
      }
      this._setupProperties(
        this._object,
        this._valuesStart,
        this._valuesEnd,
        this._valuesStartRepeat,
        n
      );
    }
    return this;
  }
  startFromCurrentValues(e) {
    return this.start(e, !0);
  }
  _setupProperties(e, n, s, r, a) {
    for (const o in s) {
      const h = e[o], c = Array.isArray(h), l = c ? "array" : typeof h;
      let u = !c && Array.isArray(s[o]);
      if (!(l === "undefined" || l === "function")) {
        if (u) {
          const f = s[o];
          if (f.length === 0)
            continue;
          const d = [h];
          for (let p = 0, y = f.length; p < y; p += 1) {
            const x = this._handleRelativeValue(h, f[p]);
            if (isNaN(x)) {
              u = !1, console.warn("Found invalid interpolation list. Skipping.");
              break;
            }
            d.push(x);
          }
          u && (s[o] = d);
        }
        if ((l === "object" || c) && h && !u) {
          n[o] = c ? [] : {};
          const f = h;
          for (const p in f)
            n[o][p] = f[p];
          r[o] = c ? [] : {};
          let d = s[o];
          if (!this._isDynamic) {
            const p = {};
            for (const y in d) p[y] = d[y];
            s[o] = d = p;
          }
          this._setupProperties(
            f,
            n[o],
            d,
            r[o],
            a
          );
        } else
          (typeof n[o] > "u" || a) && (n[o] = h), c || (n[o] *= 1), u ? r[o] = s[o].slice().reverse() : r[o] = n[o] || 0;
      }
    }
  }
  stop() {
    return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
  }
  end() {
    return this._goToEnd = !0, this.update(this._startTime + this._duration), this;
  }
  pause(e = la()) {
    return this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this);
  }
  resume(e = la()) {
    return !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this);
  }
  stopChainedTweens() {
    for (let e = 0, n = this._chainedTweens.length; e < n; e++)
      this._chainedTweens[e].stop();
    return this;
  }
  group(e) {
    return e ? (e.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
  }
  /**
   * Removes the tween from whichever group it is in.
   */
  remove() {
    return this._group?.remove(this), this;
  }
  delay(e = 0) {
    return this._delayTime = e, this;
  }
  repeat(e = 0) {
    return this._initialRepeat = e, this._repeat = e, this;
  }
  repeatDelay(e) {
    return this._repeatDelayTime = e, this;
  }
  yoyo(e = !1) {
    return this._yoyo = e, this;
  }
  easing(e = Ma.Linear.None) {
    return this._easingFunction = e, this;
  }
  interpolation(e = rr.Linear) {
    return this._interpolationFunction = e, this;
  }
  // eslint-disable-next-line
  chain(...e) {
    return this._chainedTweens = e, this;
  }
  onStart(e) {
    return this._onStartCallback = e, this;
  }
  onEveryStart(e) {
    return this._onEveryStartCallback = e, this;
  }
  onUpdate(e) {
    return this._onUpdateCallback = e, this;
  }
  onRepeat(e) {
    return this._onRepeatCallback = e, this;
  }
  onComplete(e) {
    return this._onCompleteCallback = e, this;
  }
  onStop(e) {
    return this._onStopCallback = e, this;
  }
  _goToEnd = !1;
  /**
   * @returns true if the tween is still playing after the update, false
   * otherwise (calling update on a paused tween still returns true because
   * it is still playing, just paused).
   *
   * @param autoStart - When true, calling update will implicitly call start()
   * as well. Note, if you stop() or end() the tween, but are still calling
   * update(), it will start again!
   */
  update(e = la(), n = bm.autoStartOnUpdate) {
    if (this._isPaused) return !0;
    let s;
    if (!this._goToEnd && !this._isPlaying)
      if (n) this.start(e, !0);
      else return !1;
    if (this._goToEnd = !1, e < this._startTime)
      return !0;
    this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
    const r = e - this._startTime, a = this._duration + (this._repeatDelayTime ?? this._delayTime), o = this._duration + this._repeat * a, c = (() => {
      if (this._duration === 0 || r > o)
        return 1;
      const u = Math.trunc(r / a), f = r - u * a, d = Math.min(f / this._duration, 1);
      return d === 0 && r === this._duration ? 1 : d;
    })(), l = this._easingFunction(c);
    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, l), this._onUpdateCallback && this._onUpdateCallback(this._object, c), this._duration === 0 || r >= this._duration)
      if (this._repeat > 0) {
        const u = Math.min(Math.trunc((r - this._duration) / a) + 1, this._repeat);
        isFinite(this._repeat) && (this._repeat -= u);
        for (s in this._valuesStartRepeat)
          !this._yoyo && typeof this._valuesEnd[s] == "string" && (this._valuesStartRepeat[s] = // eslint-disable-next-line
          // @ts-ignore FIXME?
          this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])), this._yoyo && this._swapEndStartRepeatValues(s), this._valuesStart[s] = this._valuesStartRepeat[s];
        return this._yoyo && (this._reversed = !this._reversed), this._startTime += a * u, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
      } else {
        this._onCompleteCallback && this._onCompleteCallback(this._object);
        for (let u = 0, f = this._chainedTweens.length; u < f; u++)
          this._chainedTweens[u].start(this._startTime + this._duration, !1);
        return this._isPlaying = !1, !1;
      }
    return !0;
  }
  _updateProperties(e, n, s, r) {
    for (const a in s) {
      if (n[a] === void 0)
        continue;
      const o = n[a] || 0;
      let h = s[a];
      const c = Array.isArray(e[a]), l = Array.isArray(h);
      !c && l ? e[a] = this._interpolationFunction(h, r) : typeof h == "object" && h ? this._updateProperties(e[a], o, h, r) : (h = this._handleRelativeValue(o, h), typeof h == "number" && (e[a] = o + (h - o) * r));
    }
  }
  _handleRelativeValue(e, n) {
    return typeof n != "string" ? n : n.charAt(0) === "+" || n.charAt(0) === "-" ? e + parseFloat(n) : parseFloat(n);
  }
  _swapEndStartRepeatValues(e) {
    const n = this._valuesStartRepeat[e], s = this._valuesEnd[e];
    typeof s == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(s) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = n;
  }
};
const lT = "25.0.0", uT = Sh.nextId, bi = t0, fT = bi.getAll.bind(bi), dT = bi.removeAll.bind(bi), pT = bi.add.bind(bi), yT = bi.remove.bind(bi), xT = bi.update.bind(bi), gT = {
  Easing: Ma,
  Group: Mm,
  Interpolation: rr,
  now: la,
  setNow: hT,
  Sequence: Sh,
  nextId: uT,
  Tween: cT,
  VERSION: lT,
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  getAll: fT,
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  removeAll: dT,
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  add: pT,
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  remove: yT,
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  update: xT
};
function on(i, e, n, s, r) {
  var a = s - i, o = r - e;
  return a * a + o * o <= n * n;
}
function mT(i, e, n, s, r, a) {
  var o = i - s, h = r - e, c = n + a;
  return o * o + h * h <= c * c;
}
function Wo(i, e, n, s, r, a, o) {
  var h = [r - i, a - e], c = [n - i, s - e], l = Lu(c, c), u = Lu(h, c), f = u / l;
  f = f < 0 ? 0 : f, f = f > 1 ? 1 : f;
  var d = [c[0] * f + i - r, c[1] * f + e - a], p = Lu(d, d);
  return p <= o * o;
}
function Lu(i, e) {
  return i[0] * e[0] + i[1] * e[1];
}
function vT(i, e, n, s, r, a, o) {
  return Wo(s, r, a, o, i, e, n);
}
function yd(i, e, n, s, r, a, o) {
  var h = n / 2, c = s / 2, l = Math.abs(r - (i + n / 2)), u = Math.abs(a - (e + s / 2));
  if (l > h + o || u > c + o)
    return !1;
  if (l <= h || u <= c)
    return !0;
  var f = l - h, d = u - c;
  return f * f + d * d <= o * o;
}
function wT(i, e, n, s, r, a, o) {
  return yd(s, r, a, o, i, e, n);
}
function Fu(i, e, n, s) {
  return Math.sqrt(Math.pow(i - n, 2) + Math.pow(e - s, 2));
}
function xd(i, e, n, s, r, a, o) {
  return o = o || 1, Math.abs(Fu(i, e, n, s) - (Fu(i, e, r, a) + Fu(n, s, r, a))) <= o;
}
function Th(i, e, n, s) {
  var r = i.length, a = !1, o, h;
  for (o = 0, h = r - 2; o < r; o += 2)
    i[o + 1] > n != i[h + 1] > n && e < (i[h] - i[o]) * (n - i[o + 1]) / (i[h + 1] - i[o + 1]) + i[o] && (a = !a), h = o;
  if (a)
    return !0;
  for (o = 0; o < r; o += 2) {
    var c = i[o], l = i[o + 1], u, f;
    if (o === r - 2 ? (u = i[0], f = i[1]) : (u = i[o + 2], f = i[o + 3]), xd(c, l, u, f, e, n, s))
      return !0;
  }
  return !1;
}
function _m(i, e, n, s, r) {
  if (Th(i, e, n, r))
    return !0;
  for (var a = i.length, o = 0; o < a - 2; o += 2)
    if (Wo(i[o], i[o + 1], i[o + 2], i[o + 3], e, n, s))
      return !0;
  return Wo(i[0], i[1], i[a - 2], i[a - 1], e, n, s);
}
function MT(i, e, n, s, r) {
  return _m(s, i, e, n, r);
}
var Sm = 10, gl, ml, gd;
function Tm() {
  gl = [], ml = [];
  for (var i = 0; i <= Sm; i++) {
    var e = 4 << i;
    gl[i] = 0.5 / Math.cos(4 * Math.acos(0) / e), ml[i] = 0.5 / (Math.cos(2 * Math.acos(0) / e) * Math.cos(2 * Math.acos(0) / e));
  }
  gd = !0;
}
function Em(i, e, n, s, r, a, o) {
  for (var h = 1; h <= Sm; h++) {
    var c = (n + r) * gl[h], l = (s + a) * gl[h], u = i - c, f = e - l;
    if (u * u + f * f <= o)
      return !0;
    var d = r - c, p = a - l;
    if (u * d + f * p >= 0 && u * d + f * p <= d * d + p * p && (f * d - u * p >= 0 || o * (d * d + p * p) >= (f * d - u * p) * (f * d - u * p)))
      return !0;
    var y = n - c, x = s - l;
    if (u * y + f * x >= 0 && u * y + f * x <= y * y + x * x && (f * y - u * x <= 0 || o * (y * y + x * x) >= (f * y - u * x) * (f * y - u * x)))
      return !0;
    var g = (n + c) * ml[h], m = (s + l) * ml[h];
    if ((g - i) * (g - i) + (m - e) * (m - e) < o) {
      r = c, a = l;
      continue;
    }
    var v = c - g + c, w = l - m + l;
    if ((v - i) * (v - i) + (w - e) * (w - e) < o) {
      n = c, s = l;
      continue;
    }
    var b = g - c, S = m - l;
    if (f * b - u * S <= 0 || o * (b * b + S * S) > (f * b - u * S) * (f * b - u * S)) {
      if (u * b + f * S > 0) {
        if (Math.abs(u * b + f * S) <= b * b + S * S || (i - g) * (n - g) + (e - m) * (s - m) >= 0) {
          r = c, a = l;
          continue;
        }
      } else if (-(u * b + f * S) <= b * b + S * S || (i - v) * (r - v) + (e - w) * (a - w) >= 0) {
        n = c, s = l;
        continue;
      }
    }
    return !1;
  }
  return !1;
}
function bT(i, e, n, s, r, a, o, h) {
  gd || Tm();
  var c = Math.abs(r - i) * h, l = Math.abs(a - e) * o;
  n *= h, s *= o;
  var u = o * h;
  return c * c + (s - l) * (s - l) <= u * u || (n - c) * (n - c) + l * l <= u * u || c * s + l * n <= n * s || (c * s + l * n - n * s) * (c * s + l * n - n * s) <= u * u * (n * n + s * s) && c * n - l * s >= -s * s && c * n - l * s <= n * n ? !0 : (c - n) * (c - n) + (l - s) * (l - s) <= u * u || c <= n && l - u <= s || l <= s && c - u <= n ? Em(c, l, n, 0, 0, s, u * u) : !1;
}
function _T(i, e, n, s, r, a, o) {
  gd || Tm();
  var h = Math.abs(r - i), c = Math.abs(a - e);
  return h * h + (s - c) * (s - c) <= o * o || (n - h) * (n - h) + c * c <= o * o || h * s + c * n <= n * s || (h * s + c * n - n * s) * (h * s + c * n - n * s) <= o * o * (n * n + s * s) && h * n - c * s >= -s * s && h * n - c * s <= n * n ? !0 : (h - n) * (h - n) + (c - s) * (c - s) <= o * o || h <= n && c - o <= s || c <= s && h - o <= n ? Em(h, c, n, 0, 0, s, o * o) : !1;
}
const zm = {
  ellipseCircle: _T,
  ellipseEllipse: bT
};
function Cm(i, e, n, s, r, a, o) {
  return zm.ellipseCircle(i, e, n, s, r, a, o);
}
function ST(i, e, n, s, r, a, o) {
  return Cm(s, r, a, o, i, e, n);
}
function Am(i, e, n, s, r, a, o, h) {
  h = h || 1;
  var c = 0;
  if (c += on(i, e, n, s, r) ? 1 : 0, c += on(i, e, n, s + a, r) ? 1 : 0, c += on(i, e, n, s, r + o) ? 1 : 0, c += on(i, e, n, s + a, r + o) ? 1 : 0, c === 0)
    return yd(s, r, a, o, i, e, n);
  if (c >= 1 && c <= 3)
    return !0;
  if (c === 4)
    return !on(i, e, n - h, s, r) || !on(i, e, n - h, s + a, r) || !on(i, e, n - h, s, r + o) || !on(i, e, n - h, s + a, r + o);
}
function Pm(i, e, n, s, r, a, o, h) {
  return h = h || 1, Wo(s, r, a, o, i, e, n) && !(on(i, e, n - h, s, r) && on(i, e, n - h, a, o));
}
function Im(i, e, n, s, r, a) {
  return a = a || 1, on(i, e, n, s, r) && !on(i, e, n - a, s, r);
}
function Rm(i, e, n, s, r, a, o, h) {
  var c = n - i, l = s - e, u = o - r, f = h - a, d = (-l * (i - r) + c * (e - a)) / (-u * l + c * f), p = (u * (e - a) - f * (i - r)) / (-u * l + c * f);
  return d >= 0 && d <= 1 && p >= 0 && p <= 1;
}
function vl(i, e, n, s, r, a) {
  var o = r.length;
  if (Th(r, i, e, a))
    return !0;
  for (var h = 0; h < o; h += 2) {
    var c = (h + 2) % o;
    if (Rm(i, e, n, s, r[h], r[h + 1], r[c], r[c + 1]))
      return !0;
  }
  return !1;
}
function TT(i, e, n, s, r, a) {
  return vl(e, n, s, r, i, a);
}
function md(i, e) {
  for (var n = i, s = e, r = [n, s], a, o, h, c, l, u, f = 0; f < r.length; f++)
    for (var d = r[f], p = 0; p < d.length; p += 2) {
      var y = (p + 2) % d.length, x = { x: d[y + 1] - d[p + 1], y: d[p] - d[y] };
      for (a = o = null, u = 0; u < n.length; u += 2)
        h = x.x * n[u] + x.y * n[u + 1], (a === null || h < a) && (a = h), (o === null || h > o) && (o = h);
      for (c = l = null, u = 0; u < s.length; u += 2)
        h = x.x * s[u] + x.y * s[u + 1], (c === null || h < c) && (c = h), (l === null || h > l) && (l = h);
      if (o < c || l < a)
        return !1;
    }
  return !0;
}
function Om(i, e, n, s, r) {
  var a = [e, n, e + s, n, e + s, n + r, e, n + r];
  return md(i, a);
}
function ua(i, e, n, s, r, a, o, h) {
  r -= i, o -= i, a -= e, h -= e;
  var c = Math.pow(o - r, 2) / n / n + Math.pow(h - a, 2) / s / s, l = 2 * r * (o - r) / n / n + 2 * a * (h - a) / s / s, u = r * r / n / n + a * a / s / s - 1, f = l * l - 4 * c * u;
  if (f === 0) {
    var d = -l / 2 / c;
    return d >= 0 && d <= 1;
  } else if (f > 0) {
    var p = Math.sqrt(f), y = (-l + p) / 2 / c, x = (-l - p) / 2 / c;
    return y >= 0 && y <= 1 || x >= 0 && x <= 1;
  } else
    return !1;
}
function e0(i, e, n, s, r, a, o, h) {
  return ua(r, a, o, h, i, e, n, s);
}
function km(i, e, n, s, r) {
  if (Th(i, e, n))
    return !0;
  for (var a = i.length, o = 0; o < a - 2; o += 2)
    if (e0(i[o], i[o + 1], i[o + 2], i[o + 3], e, n, s, r))
      return !0;
  return e0(i[0], i[1], i[a - 2], i[a - 1], e, n, s, r);
}
function Yo(i, e, n, s, r, a) {
  return r >= i && r <= i + n && a >= e && a <= e + s;
}
function ET(i, e, n, s, r, a, o, h) {
  return i < r + o && i + n > r && e < a + h && e + s > a;
}
function Yh(i, e, n, s, r) {
  const a = Math.atan2(s - e, n - i) - Math.PI / 2, o = r / 2, h = Math.cos(a) * o, c = Math.sin(a) * o;
  return [
    i - h,
    e - c,
    n - h,
    s - c,
    n + h,
    s + c,
    i + h,
    e + c
  ];
}
function co(i, e, n, s, r, a, o, h, c, l) {
  return c || l ? zT(i, e, n, s, r, a, o, h, c, l) : Rm(i, e, n, s, r, a, o, h);
}
function zT(i, e, n, s, r, a, o, h, c, l) {
  if (c && l)
    return md(Yh(i, e, n, s, c), Yh(r, a, o, h, l));
  if (c)
    return vl(r, a, o, h, Yh(i, e, n, s, c));
  if (l)
    return vl(i, e, n, s, Yh(r, a, o, h, c));
}
function Lm(i, e, n, s, r, a, o, h) {
  return Yo(r, a, o, h, i, e) || Yo(r, a, o, h, n, s) ? !0 : co(i, e, n, s, r, a, r + o, a) || co(i, e, n, s, r + o, a, r + o, a + h) || co(i, e, n, s, r, a + h, r + o, a + h) || co(i, e, n, s, r, a, r, a + h);
}
function CT(i, e, n, s, r, a, o, h) {
  return Lm(r, a, o, h, i, e, n, s);
}
function AT(i, e, n, s, r) {
  return Om(r, i, e, n, s);
}
function Fm(i, e, n, s, r, a, o, h) {
  return Yo(r, a, o, h, i, e) || ua(i, e, n, s, r, a, r + o, a) || ua(i, e, n, s, r, a + h, r + o, a + h) || ua(i, e, n, s, r, a, r, a + h) || ua(i, e, n, s, r + o, a, r + o, a + h);
}
function PT(i, e, n, s, r, a, o, h) {
  return Fm(r, a, o, h, i, e, n, s);
}
function IT(i, e, n, s, r, a, o, h) {
  return Am(r, a, o, i, e, n, s, h);
}
function RT(i, e, n, s, r, a) {
  return Yo(n, s, r, a, i, e);
}
function OT(i, e, n, s) {
  return Th(n, i, e, s);
}
function kT(i, e, n, s, r) {
  return on(n, s, r, i, e);
}
function LT(i, e, n, s, r, a) {
  return xd(n, s, r, a, i, e);
}
function Nm(i, e, n, s, r, a) {
  var o = Math.pow(r - i, 2) / (n * n), h = Math.pow(a - e, 2) / (s * s);
  return o + h <= 1;
}
function FT(i, e, n, s, r, a) {
  return Nm(n, s, r, a, i, e);
}
function NT(i, e, n, s, r, a) {
  return Im(i, e, n, s, r, a);
}
function BT(i, e, n, s, r, a, o, h) {
  return Pm(r, a, o, i, e, n, s, h);
}
function DT(i, e, n, s, r, a, o, h) {
  return zm.ellipseEllipse(i, e, n, s, r, a, o, h);
}
function qT(i, e, n, s, r) {
  return km(r, i, e, n, s);
}
const $T = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boxBox: ET,
  boxCircle: yd,
  boxCircleOutline: IT,
  boxEllipse: PT,
  boxLine: CT,
  boxPoint: Yo,
  boxPolygon: AT,
  circleBox: wT,
  circleCircle: mT,
  circleEllipse: ST,
  circleLine: vT,
  circleOutlineBox: Am,
  circleOutlineLine: Pm,
  circleOutlinePoint: Im,
  circlePoint: on,
  circlePolygon: MT,
  ellipseBox: Fm,
  ellipseCircle: Cm,
  ellipseEllipse: DT,
  ellipseLine: ua,
  ellipsePoint: Nm,
  ellipsePolygon: qT,
  lineBox: Lm,
  lineCircle: Wo,
  lineCircleOutline: BT,
  lineEllipse: e0,
  lineLine: co,
  linePoint: xd,
  linePolygon: vl,
  pointBox: RT,
  pointCircle: kT,
  pointCircleOutline: NT,
  pointEllipse: FT,
  pointLine: LT,
  pointPolygon: OT,
  polygonBox: Om,
  polygonCircle: _m,
  polygonEllipse: km,
  polygonLine: TT,
  polygonPoint: Th,
  polygonPolygon: md
}, Symbol.toStringTag, { value: "Module" }));
class vd {
  length = 0;
  advance = 1;
  _currentIndex = 0;
  data = [];
  constructor(e, n = e.length, s = !1, r = 0) {
    this.data = e, this.length = n, this.advance = s ? -1 : 1, this._currentIndex = Math.floor(r) % n;
  }
  get current() {
    return this.data[this._currentIndex];
  }
  get(e = 0) {
    const n = (this._currentIndex + e * this.advance) % this.length;
    return this.data[n];
  }
  next(e = 0) {
    return this._currentIndex = (this._currentIndex + this.advance + e * this.advance) % this.length, this.current;
  }
}
class VT extends vd {
  constructor(e, n = !1, s = 0) {
    super([
      N.create(e.cx, e.top),
      N.create(e.right, e.cy),
      N.create(e.cx, e.bottom),
      N.create(e.left, e.cy)
    ], 4, n, s);
  }
}
class Nu extends vd {
  constructor(e, n = !1, s = 0) {
    super([
      N.create(e.left, e.top),
      N.create(e.right, e.top),
      N.create(e.right, e.bottom),
      N.create(e.left, e.bottom)
    ], 4, n, s);
  }
}
class Vi {
  static default() {
    return this.fromLTRB(0, 0, 0, 0);
  }
  static from(e, n) {
    return this.fromXYWH(e.x, e.x, n.width, n.height);
  }
  static fromXYWH(e, n, s, r) {
    return new Vi(e, n, e + s, n + r);
  }
  static fromLTRB(e, n, s, r) {
    return new Vi(e, n, s, r);
  }
  left = 0;
  top = 0;
  right = 0;
  bottom = 0;
  constructor(e = 0, n = 0, s = 0, r = 0) {
    this.left = e, this.top = n, this.right = s, this.bottom = r;
  }
  get x() {
    return this.left;
  }
  get y() {
    return this.top;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  get halfWidth() {
    return this.width * 0.5;
  }
  get halfHeight() {
    return this.height * 0.5;
  }
  get cx() {
    return (this.left + this.right) / 2;
  }
  get cy() {
    return (this.top + this.bottom) / 2;
  }
  isEmpty() {
    return !(this.left < this.right && this.top < this.bottom);
  }
  copy(e) {
    return this.left = e.left, this.top = e.top, this.right = e.right, this.bottom = e.bottom, this;
  }
  clone() {
    return new Vi(this.left, this.top, this.right, this.bottom);
  }
  offset(e, n) {
    return this.left += e, this.right += e, this.top += n, this.bottom += n, this;
  }
  isSorted() {
    return this.left <= this.right && this.top <= this.bottom;
  }
  isFinite() {
    let e = 0;
    return e *= this.left, e *= this.top, e *= this.right, e *= this.bottom, Number.isFinite(e);
  }
  makeSorted() {
    const e = this.left, n = this.right, s = this.top, r = this.bottom;
    return Vi.fromLTRB(
      Math.min(e, n),
      Math.min(s, r),
      Math.max(e, n),
      Math.max(s, r)
    );
  }
}
class GT extends vd {
  constructor(e, n = !1, s = 0) {
    super([], 8, n, s);
    const r = e.getBounds(), a = r.left, o = r.top, h = r.right, c = r.bottom, l = [];
    l[0] = N.create(a + e.radii(Hn.kUpperLeft_Corner).x, o), l[1] = N.create(h - e.radii(Hn.kUpperRight_Corner).x, o), l[2] = N.create(h, o + e.radii(Hn.kUpperRight_Corner).y), l[3] = N.create(h, c - e.radii(Hn.kLowerRight_Corner).y), l[4] = N.create(h - e.radii(Hn.kLowerRight_Corner).x, c), l[5] = N.create(a + e.radii(Hn.kLowerLeft_Corner).x, c), l[6] = N.create(a, c - e.radii(Hn.kLowerLeft_Corner).y), l[7] = N.create(a, o + e.radii(Hn.kUpperLeft_Corner).y), this.data = l;
  }
}
function Sy(i) {
  let e = !0;
  for (let n = 0; n < 4; ++n)
    i[n].x <= 0 || i[n].y <= 0 ? (i[n].x = 0, i[n].y = 0) : e = !1;
  return e;
}
function jh(i, e, n, s) {
  return i + e > n ? Math.min(s, n / (i + e)) : s;
}
function Hh(i, e, n) {
  i[n] + e[n] == i[n] ? e[n] = 0 : i[n] + e[n] == e[n] && (i[n] = 0);
}
function UT(i, e) {
  if (i === e) return i;
  const n = i > e ? -1 : 1, s = Number.EPSILON * Math.abs(i) || Number.MIN_VALUE;
  return i + n * s;
}
function Xh(i, e, n, s, r) {
  if (n[r] = n[r] * e, s[r] = s[r] * e, n[r] + s[r] > i) {
    let a = n, o = s;
    a[r] > o[r] && ([o, a] = [a, o]);
    let h = a[r], c = i - h;
    for (; c + h > i; )
      c = UT(c, 0);
    o[r] = c;
  }
}
function Ty(i) {
  return i[
    0
    /* kUpperLeft_Corner */
  ].x == i[
    3
    /* kLowerLeft_Corner */
  ].x && i[
    0
    /* kUpperLeft_Corner */
  ].y == i[
    1
    /* kUpperRight_Corner */
  ].y && i[
    1
    /* kUpperRight_Corner */
  ].x == i[
    2
    /* kLowerRight_Corner */
  ].x && i[
    3
    /* kLowerLeft_Corner */
  ].y == i[
    2
    /* kLowerRight_Corner */
  ].y;
}
function Ey(i, e, n) {
  return e <= n && i <= n - e && e + i <= n && n - i >= e && i >= 0;
}
class Hn {
  static default() {
    return new Hn();
  }
  static fromRect(e) {
    return this.default().setRect(e);
  }
  static fromOval(e) {
    return this.default().setOval(e);
  }
  static kUpperLeft_Corner = 0;
  static kUpperRight_Corner = 1;
  static kLowerRight_Corner = 2;
  static kLowerLeft_Corner = 3;
  type = 0;
  _rect = Vi.default();
  _radii = [N.default(), N.default(), N.default(), N.default()];
  radii(e) {
    return this._radii[e];
  }
  getType() {
    return this.type;
  }
  getBounds() {
    return this._rect;
  }
  isEmpty() {
    return this.type == 0;
  }
  isOval() {
    return this.type == 2;
  }
  isRect() {
    return this.type == 1;
  }
  resetRadii() {
    this._radii.forEach((e) => {
      e.setXY(0, 0);
    });
  }
  copyDadii(e) {
    e.forEach((n, s) => {
      this._radii[s].copy(n);
    });
  }
  scaleRadii() {
    let e = 1, n = this._rect, s = this._radii, r = n.right - n.left, a = n.bottom - n.top;
    return e = jh(s[0].x, s[1].x, r, e), e = jh(s[1].y, s[2].y, a, e), e = jh(s[2].x, s[3].x, r, e), e = jh(s[3].y, s[0].y, a, e), Hh(s[0], s[1], 0), Hh(s[1], s[2], 1), Hh(s[2], s[3], 0), Hh(s[3], s[0], 1), e < 1 && (Xh(r, e, s[0], s[1], 0), Xh(a, e, s[1], s[2], 1), Xh(r, e, s[2], s[3], 0), Xh(a, e, s[3], s[0], 1)), Sy(s), this.computeType(), e < 1;
  }
  initializeRect(e) {
    return e.isFinite() ? (this._rect = e.makeSorted(), this._rect.isEmpty() ? (this.resetRadii(), this.type = 0, !1) : !0) : (this._rect = Vi.default(), !1);
  }
  /**
   * 
   * @param rect 
   * @param radii [topLeft, topRight, bottomRight, bottomLeft] 
   */
  setRectRadii(e, n) {
    if (this.initializeRect(e)) {
      if (n.every((s) => s.x == 0)) {
        this.setRect(e);
        return;
      }
      if (this.copyDadii(n), Sy(this._radii)) {
        this.setRect(e);
        return;
      }
      this.scaleRadii(), this.isValid() || this.setRect(e);
    }
  }
  setRect(e) {
    return this._rect.copy(e), this.resetRadii(), this.type = 1, this;
  }
  setOval(e) {
    if (e.isEmpty() || !e.isFinite())
      return;
    this._rect.copy(e.makeSorted());
    let n = this._rect.halfWidth, s = this._rect.halfHeight;
    if (n == 0 || s == 0)
      this.resetRadii(), this.type = 1;
    else {
      for (let r = 0; r < 4; ++r)
        this._radii[r].setXY(n, s);
      this.type = 2;
    }
  }
  get width() {
    return this._rect.width;
  }
  get height() {
    return this._rect.height;
  }
  computeType() {
    if (this._rect.isEmpty()) {
      this.type = 0;
      return;
    }
    let e = this._radii, n = this._rect, s = !0, r = e[0].x == 0 || e[0].y == 0;
    for (let a = 1; a < 4; ++a)
      e[a].x != 0 && e[a].y != 0 && (r = !1), (e[a].x != e[a - 1].x || e[a].y != e[a - 1].y) && (s = !1);
    if (r) {
      this.type = 1;
      return;
    }
    if (s) {
      e[0].x >= n.halfWidth && e[0].y >= n.halfHeight ? this.type = 2 : this.type = 3;
      return;
    }
    Ty(e) ? this.type = 4 : this.type = 5, this.isValid() || this.setRect(this._rect);
  }
  areRectAndRadiiValid(e, n) {
    if (!e.isFinite() || !e.isSorted())
      return !1;
    for (let s = 0; s < 4; ++s)
      if (!Ey(n[s].x, e.left, e.right) || !Ey(n[s].y, e.top, e.bottom))
        return !1;
    return !0;
  }
  isValid() {
    let e = this.type, n = this._rect, s = this._radii;
    if (!this.areRectAndRadiiValid(n, s))
      return !1;
    let r = s[0].x == 0 && s[0].y == 0, a = s[0].x == 0 || s[0].y == 0, o = !0;
    for (let c = 1; c < 4; ++c)
      (s[c].x != 0 || s[c].y != 0) && (r = !1), (s[c].x != s[c - 1].x || s[c].y != s[c - 1].y) && (o = !1), s[c].x != 0 && s[c].y != 0 && (a = !1);
    let h = Ty(s);
    if (e < 0 || e > 5)
      return !1;
    switch (e) {
      case 0:
        if (!n.isEmpty() || !r || !o || !a)
          return !1;
        break;
      case 1:
        if (n.isEmpty() || !r || !o || !a)
          return !1;
        break;
      case 2:
        if (n.isEmpty() || r || !o || a)
          return !1;
        for (let c = 0; c < 4; ++c)
          if (!(Math.abs(s[c].x - n.halfWidth) <= 1e-6) || !(Math.abs(s[c].y - n.halfHeight) <= 1e-6))
            return !1;
        break;
      case 3:
        if (n.isEmpty() || r || !o || a)
          return !1;
        break;
      case 4:
        if (n.isEmpty() || r || o || a || !h)
          return !1;
        break;
      case 5:
        if (n.isEmpty() || r || o || a || h)
          return !1;
        break;
    }
    return !0;
  }
}
function WT(i) {
  let e = { tl: 0, tr: 0, br: 0, bl: 0 };
  return typeof i == "number" ? e = { tl: i, tr: i, br: i, bl: i } : Array.isArray(i) ? i.length === 1 ? e = { tl: i[0], tr: i[0], br: i[0], bl: i[0] } : i.length === 2 ? e = { tl: i[0], tr: i[1], br: i[0], bl: i[1] } : i.length === 3 ? e = { tl: i[0], tr: i[1], br: i[2], bl: i[1] } : i.length === 4 && (e = { tl: i[0], tr: i[1], br: i[2], bl: i[3] }) : i && (e.tl = i.x ?? 0, e.tr = i.y ?? 0, e.bl = i.z ?? 0, e.br = i.w ?? 0), e;
}
function zy(i) {
  return i !== null && typeof i == "object" && ("x" in i || "y" in i) && (typeof i.x == "number" || typeof i.y == "number" || typeof i.x > "u" || typeof i.y > "u");
}
function YT(i) {
  return typeof i == "number" ? { x: i, y: i } : {
    x: typeof i.x == "number" ? i.x : 0,
    y: typeof i.y == "number" ? i.y : 0
  };
}
function jT(i, e, n, s, r = 0) {
  if (typeof r == "number")
    r = [r];
  else if (zy(r))
    r = [r];
  else if (!Array.isArray(r))
    return;
  if (Array.isArray(r)) {
    if (r.length === 0 || r.length > 4)
      throw new RangeError(
        `Failed to execute 'roundRect' on '${this.constructor.name}': ${r.length} radii provided. Between one and four radii are necessary.`
      );
    r.forEach((d) => {
      if (zy(d)) {
        const p = d;
        if (typeof p.x == "number" && p.x < 0)
          throw new RangeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${p.x} is negative.`
          );
        if (typeof p.y == "number" && p.y < 0)
          throw new RangeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${p.y} is negative.`
          );
      } else {
        if (typeof d != "number")
          throw new TypeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${d} is not a number or DOMPointInit.`
          );
        if (typeof d == "number" && d < 0)
          throw new RangeError(
            `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${d} is negative.`
          );
      }
    });
  }
  const a = r.map(YT);
  if (r.length === 1 && a[0].x === 0 && a[0].y === 0) {
    this.rect(i, e, n, s);
    return;
  }
  const o = n / 2, h = s / 2, c = {
    x: Math.min(o, a[0].x),
    y: Math.min(h, a[0].y)
  };
  let l = c, u = c, f = c;
  a.length === 2 && (l = { x: Math.min(o, a[1].x), y: Math.min(h, a[1].y) }, f = l), a.length === 3 && (l = { x: Math.min(o, a[1].x), y: Math.min(h, a[1].y) }, f = l, u = { x: Math.min(o, a[2].x), y: Math.min(h, a[2].y) }), a.length === 4 && (l = { x: Math.min(o, a[1].x), y: Math.min(h, a[1].y) }, u = { x: Math.min(o, a[2].x), y: Math.min(h, a[2].y) }, f = { x: Math.min(o, a[3].x), y: Math.min(h, a[3].y) }), this.moveTo(i, e + s - f.y), c.x === c.y && c.x > 0 ? this.arcTo(i, e, i + c.x, e, c.x) : c.x > 0 || c.y > 0 ? this.ellipse(i + c.x, e + c.y, c.x, c.y, 0, Math.PI, Math.PI * 1.5, !1) : this.lineTo(i, e), this.lineTo(i + n - l.x, e), l.x === l.y && l.x > 0 ? this.arcTo(i + n, e, i + n, e + l.y, l.x) : l.x > 0 || l.y > 0 ? this.ellipse(i + n - l.x, e + l.y, l.x, l.y, 0, Math.PI * 1.5, 0, !1) : this.lineTo(i + n, e), this.lineTo(i + n, e + s - u.y), u.x === u.y && u.x > 0 ? this.arcTo(i + n, e + s, i + n - u.x, e + s, u.x) : u.x > 0 || u.y > 0 ? this.ellipse(i + n - u.x, e + s - u.y, u.x, u.y, 0, 0, Math.PI * 0.5, !1) : this.lineTo(i + n, e + s), this.lineTo(i + f.x, e + s), f.x === f.y && f.x > 0 ? this.arcTo(i, e + s, i, e + s - f.y, f.x) : f.x > 0 || f.y > 0 ? this.ellipse(i + f.x, e + s - f.y, f.x, f.y, 0, Math.PI * 0.5, Math.PI, !1) : this.lineTo(i, e + s), this.closePath(), this.moveTo(i, e);
}
const Cy = Math.PI * 2;
function Ay(i, e, n = !1) {
  const s = Math.PI * 2;
  let r = i % s;
  r <= 0 && (r += s);
  let a = r - i;
  return i = r, e += a, !n && e - i >= s ? e = i + s : n && i - e >= s ? e = i - s : !n && i > e ? e = i + (s - (i - e) % s) : n && i < e && (e = i - (s - (e - i) % s)), { startAngle: i, endAngle: e };
}
var wl = /* @__PURE__ */ ((i) => (i[i.CW = 0] = "CW", i[i.CCW = 1] = "CCW", i[i.Unknown = 2147483647] = "Unknown", i))(wl || {}), _e = /* @__PURE__ */ ((i) => (i[i.MoveTo = 0] = "MoveTo", i[i.LineTo = 1] = "LineTo", i[i.QuadCurveTo = 2] = "QuadCurveTo", i[i.CubicCurveTo = 3] = "CubicCurveTo", i[i.ConicTo = 4] = "ConicTo", i[i.Close = 5] = "Close", i))(_e || {}), Bm = /* @__PURE__ */ ((i) => (i[
  i.MoveTo = 0
  /* MoveTo */
] = "MoveTo", i[
  i.LineTo = 1
  /* LineTo */
] = "LineTo", i[
  i.QuadCurveTo = 2
  /* QuadCurveTo */
] = "QuadCurveTo", i[
  i.ConicTo = 4
  /* ConicTo */
] = "ConicTo", i[
  i.CubicCurveTo = 3
  /* CubicCurveTo */
] = "CubicCurveTo", i[
  i.Close = 5
  /* Close */
] = "Close", i[i.Done = 6] = "Done", i))(Bm || {}), Dm = /* @__PURE__ */ ((i) => (i[i.Line_SegmentMask = 1] = "Line_SegmentMask", i[i.Quad_SegmentMask = 2] = "Quad_SegmentMask", i[i.Conic_SegmentMask = 4] = "Conic_SegmentMask", i[i.Cubic_SegmentMask = 8] = "Cubic_SegmentMask", i))(Dm || {});
class mr {
  static default() {
    return new this();
  }
  static fromVectices(e) {
    const n = this.default();
    for (let s = 0; s < e.length; s += 2)
      s === 0 ? n.moveTo(e[s], e[s + 1]) : n.lineTo(e[s], e[s + 1]);
    return n;
  }
  static fromPoints(e) {
    const n = this.default();
    for (let s = 0; s < e.length; s++)
      s === 0 ? n.moveTo(e[s].x, e[s].y) : n.lineTo(e[s].x, e[s].y);
    return n;
  }
  points = [];
  verbs = [];
  _segmentMask = 1;
  _lastMovePointIndex = 0;
  _needMoveTo = !0;
  _bounds = null;
  reset() {
    return this._needMoveTo = !0, this.points.length = 0, this.verbs.length = 0, this._lastMovePointIndex = 0, this._bounds = null, this._segmentMask = 1, this;
  }
  clear() {
    return this.reset();
  }
  get isEmpty() {
    return this.verbs.length === 0;
  }
  get lastVerb() {
    return this.verbs[this.verbs.length - 1];
  }
  get lastPoint() {
    const e = this.points[this.points.length - 2] || 0, n = this.points[this.points.length - 1] || 0;
    return { x: e, y: n };
  }
  get length() {
    return this.points.length;
  }
  setLastPoint(e, n) {
    return this.isEmpty ? this.moveTo(e, n) : (this.points[this.length - 2] = e, this.points[this.length - 1] = n), this;
  }
  addPoint(e, n) {
    return this.points.push(e, n), this._bounds = null, this;
  }
  addVerb(e) {
    return this.verbs.push(e), this;
  }
  injectMoveToIfNeeded() {
    this._needMoveTo && (this.length <= 0 ? this.moveTo(0, 0) : this.moveTo(this.points[this.length - 2], this.points[this.length - 1]));
  }
  // contains(x: number, y: number) {
  //     return pointInPath(x, y, this, 0)
  // }
  moveTo(e, n) {
    return this._needMoveTo = !1, this.lastVerb === 0 ? (this.points[this._lastMovePointIndex] = e, this.points[this._lastMovePointIndex + 1] = n) : (this._lastMovePointIndex = this.points.length, this.addVerb(
      0
      /* MoveTo */
    ), this.addPoint(e, n)), this;
  }
  lineTo(e, n) {
    return this.injectMoveToIfNeeded(), this.addVerb(
      1
      /* LineTo */
    ), this._segmentMask |= 1, this.addPoint(e, n);
  }
  quadraticCurveTo(e, n, s, r) {
    return this.injectMoveToIfNeeded(), this.addVerb(
      2
      /* QuadCurveTo */
    ), this.addPoint(e, n), this._segmentMask |= 2, this.addPoint(s, r);
  }
  bezierCurveTo(e, n, s, r, a, o) {
    return this.cubicCurveTo(e, n, s, r, a, o);
  }
  cubicCurveTo(e, n, s, r, a, o) {
    return this.injectMoveToIfNeeded(), this.addVerb(
      3
      /* CubicCurveTo */
    ), this.addPoint(e, n), this.addPoint(s, r), this._segmentMask |= 8, this.addPoint(a, o);
  }
  conicTo(e, n, s, r, a) {
    const o = 4 * a / (3 * (a + 1)), h = this.lastPoint, c = h.x + (e - h.x) * o, l = h.y + (n - h.y) * o, u = s + (e - s) * o, f = r + (n - r) * o;
    return this.cubicCurveTo(c, l, u, f, s, r);
  }
  closePath() {
    return this.isEmpty || (this.lastVerb !== 5 && this.addVerb(
      5
      /* Close */
    ), this._needMoveTo = !0), this;
  }
  rect(e, n, s, r) {
    return this.moveTo(e, n), this.lineTo(e + s, n), this.lineTo(e + s, n + r), this.lineTo(e, n + r), this.closePath();
  }
  roundRect(e, n, s, r, a) {
    let o = WT(a);
    const h = [
      N.create(o.tl, o.tl),
      // 左上角 (x半径, y半径)
      N.create(o.tr, o.tr),
      // 右上角
      N.create(o.br, o.br),
      // 右下角
      N.create(o.bl, o.bl)
      // 左下角
    ];
    let c = Hn.default();
    c.setRectRadii(Vi.fromXYWH(e, n, s, r), h), this.addRRect(c);
  }
  /**
   * 
   * @param x 
   * @param y 
   * @param width 
   * @param height 
   * @param radius all-corners
      [all-corners]
      [top-left-and-bottom-right, top-right-and-bottom-left]
      [top-left, top-right-and-bottom-left, bottom-right]
      [top-left, top-right, bottom-right, bottom-left]
   */
  roundRect2(e, n, s, r, a = 0) {
    jT.call(this, e, n, s, r, a);
  }
  ellipse2(e, n, s, r, a = 0, o = 0, h = Cy, c = !1) {
    ({ startAngle: o, endAngle: h } = Ay(o, h, c));
    let l = h - o, u = o;
    if (Math.abs(l - Math.PI * 2) <= 1e-6) {
      const f = l / 2;
      this.arcToOval(e, n, s, r, a, u, f, !0), this.arcToOval(e, n, s, r, a, u + f, f, !1);
    } else
      this.arcToOval(e, n, s, r, a, u, l, !0);
  }
  ellipse(e, n, s, r, a = 0, o = 0, h = Cy, c = !1) {
    ({ startAngle: o, endAngle: h } = Ay(o, h, c));
    const l = h - o, u = Kg(e, n, s, r, a, o);
    this.isEmpty ? this.moveTo(u.x, u.y) : this.lineTo(u.x, u.y);
    const f = Math.ceil(Math.abs(l) / (Math.PI / 2));
    let d = l / f, p = o;
    for (let y = 0; y < f; y++) {
      const x = p + d, g = od(e, n, s, r, a, p, x);
      this.bezierCurveTo(g[2], g[3], g[4], g[5], g[6], g[7]), p = x;
    }
    return this;
  }
  ellipseArc(e, n, s, r, a, o, h, c, l) {
    Xl(e, n, s, r, a, o, h, c, l, (u, f, d, p, y, x, g, m, v) => {
      v === 0 && (this.isEmpty ? this.moveTo(u, f) : this.lineTo(u, f)), this.cubicCurveTo(d, p, y, x, g, m);
    });
  }
  arc(e, n, s, r, a, o = !1) {
    this.ellipse(e, n, s, s, 0, r, a, o);
  }
  arcTo(e, n, s, r, a) {
    if (this.injectMoveToIfNeeded(), a === 0) {
      this.lineTo(e, n);
      return;
    }
    const o = this.lastPoint, h = N.fromPoint(o), c = N.create(e, n), l = N.create(s, r);
    let u = c.clone().sub(h).normalize(), f = l.clone().sub(c).normalize(), d = u.dot(f), p = u.cross(f);
    if (!u.isFinite() || !f.isFinite() || Math.abs(p) <= 1e-6)
      return this.lineTo(e, n);
    let y = Math.abs(a * (1 - d) / p), x = c.clone().sub(u.mulScalar(y)), g = c.clone().add(f.mulScalar(y)), m = Math.sqrt(0.5 + d * 0.5);
    this.lineTo(x.x, x.y), this.conicTo(e, n, g.x, g.y, m);
  }
  arcTo2(e, n, s, r, a) {
    if (this.injectMoveToIfNeeded(), a === 0) {
      this.lineTo(e, n);
      return;
    }
    const o = this.lastPoint, h = N.fromPoint(o), c = N.create(e, n), l = N.create(s, r);
    let u = c.clone().sub(h).normalize(), f = l.clone().sub(c).normalize(), d = u.dot(f), p = u.cross(f);
    if (Math.abs(p) <= 1e-6) {
      this.lineTo(e, n);
      return;
    }
    let y = Math.abs(a * (1 - d) / p), x = c.clone().sub(u.mulScalar(y)), g = c.clone().add(f.mulScalar(y)), m = p > 0;
    this.lineTo(x.x, x.y), this.ellipseArc(x.x, x.y, g.x, g.y, a, a, 0, !1, m);
  }
  arcToOval(e, n, s, r, a, o, h, c = !1) {
    const { x1: l, y1: u, x2: f, y2: d, fa: p, fs: y } = Jg(
      e,
      n,
      s,
      r,
      a,
      o,
      h
    );
    c && this.moveTo(l, u), this.ellipseArc(l, u, f, d, s, r, a, !!p, !!y);
  }
  addCircle(e, n, s, r = !1) {
    return s >= 0 && this.addOval(Vi.fromLTRB(e - s, n - s, e + s, n + s), r), this;
  }
  addPolygon(e, n = !0) {
    if (e.length <= 0)
      return this;
    this.moveTo(e[0], e[1]);
    for (let s = 2; s < e.length; s += 2) {
      let r = e[s], a = e[s + 1];
      this.lineTo(r, a);
    }
    return n && this.closePath(), this;
  }
  addOval(e, n = !1, s = 1) {
    let r = new VT(e, n, s), a = new Nu(e, n, s + (n ? 1 : 0)), o = Math.SQRT1_2;
    this.moveTo(r.current.x, r.current.y), a.next(), r.next();
    for (let h = 0; h < 4; ++h)
      this.conicTo(a.get(h).x, a.get(h).y, r.get(h).x, r.get(h).y, o);
    this.closePath();
  }
  addRect(e, n = !1, s = 0) {
    let r = new Nu(e, n, s);
    return this.moveTo(r.get(0).x, r.get(0).y), this.lineTo(r.get(1).x, r.get(1).y), this.lineTo(r.get(2).x, r.get(2).y), this.lineTo(r.get(3).x, r.get(3).y), this.closePath();
  }
  addRRect(e, n = !1, s = n ? 7 : 6) {
    let r = e.getBounds();
    if (e.isRect() || e.isEmpty())
      this.addRect(r, n, (s + 1) / 2);
    else if (e.isOval())
      this.addOval(r, n, s / 2);
    else {
      const a = (s & 1) == +(n == !1);
      let o = Math.SQRT1_2, h = new GT(e, n, s);
      const c = s / 2 + (n ? 1 : 0);
      let l = new Nu(r, n, c);
      if (this.moveTo(h.current.x, h.current.y), a) {
        for (let u = 0; u < 3; ++u)
          l.next(), h.next(), this.conicTo(l.current.x, l.current.y, h.current.x, h.current.y, o), h.next(), this.lineTo(h.current.x, h.current.y);
        l.next(), h.next(), this.conicTo(l.current.x, l.current.y, h.current.x, h.current.y, o);
      } else
        for (let u = 0; u < 4; ++u)
          h.next(), this.lineTo(h.current.x, h.current.y), l.next(), h.next(), this.conicTo(l.current.x, l.current.y, h.current.x, h.current.y, o);
      this.closePath();
    }
  }
  copy(e) {
    return this.points = e.points.slice(), this.verbs = e.verbs.slice(), this._lastMovePointIndex = e._lastMovePointIndex, this._needMoveTo = e._needMoveTo, this;
  }
  clone() {
    return mr.default().copy(this);
  }
  equals(e) {
    if (this.points.length !== e.points.length)
      return !1;
    for (let n = 0; n < this.points.length; n++) {
      const s = this.points[n], r = e.points[n];
      if (s !== r)
        return !1;
    }
    return !0;
  }
  transform(e) {
    for (let n = 0; n < this.points.length; n += 2) {
      const s = this.points[n], r = this.points[n + 1];
      this.points[n] = e[0] * s + e[2] * r + e[4], this.points[n + 1] = e[1] * s + e[3] * r + e[5];
    }
  }
  scaleRound(e, n) {
    for (let s = 0; s < this.points.length; s += 2) {
      const r = this.points[s], a = this.points[s + 1];
      this.points[s] = Math.round(r * e), this.points[s + 1] = Math.round(a * e);
    }
  }
  computeTightBounds() {
    if (this.isEmpty)
      return gr.empty();
    if (this._segmentMask === 1)
      return this.getBounds();
    const e = gr.default();
    return this.visit({
      moveTo: (n, s) => {
        e.expandByXY(n, s);
      },
      lineTo: (n, s, r, a) => {
        e.expandByXY(r, a);
      },
      quadraticCurveTo: (n, s, r, a, o, h) => {
        let c = Ca.fromXY(n, s, r, a, o, h).getBoundingBox();
        e.expandByPoint(c.min), e.expandByPoint(c.max);
      },
      cubicCurveTo(n, s, r, a, o, h, c, l) {
        let u = Uf.fromXY(n, s, r, a, o, h, c, l).getBoundingBox();
        e.expandByPoint(u.min), e.expandByPoint(u.max);
      }
    }), e;
  }
  fatten(e = 1) {
    const n = mr.default();
    return this.isEmpty || this.visit({
      moveTo: (s, r) => {
        n.moveTo(s, r);
      },
      lineTo: (s, r, a, o) => {
        n.lineTo(a, o);
      },
      quadraticCurveTo: (s, r, a, o, h, c) => {
        Ca.fromXY(s, r, a, o, h, c).fatten(e).forEach((u) => {
          n.lineTo(u.x, u.y);
        });
      },
      cubicCurveTo: (s, r, a, o, h, c, l, u) => {
        Uf.fromXY(s, r, a, o, h, c, l, u).fatten(e).forEach((d) => {
          n.lineTo(d.x, d.y);
        });
      },
      close: () => {
        n.closePath();
      }
    }), n;
  }
  toPolygons(e = !0, n = 1) {
    const s = [];
    let r = null;
    return this.fatten(n).visit({
      moveTo: (o, h) => {
        r !== null && s.push(r), r = [o, h];
      },
      lineTo: (o, h, c, l) => {
        r.push(c, l);
      },
      close: (o, h) => {
        e && (r.push(o, h), s.push(r), r = null);
      }
    }), r !== null && s.push(r), s;
  }
  getBounds() {
    return this._bounds || (this._bounds = gr.default().setFromVertices(this.points)), this._bounds;
  }
  visit(e) {
    const n = this.points, s = this.verbs;
    let r = 0, a = { x: 0, y: 0 };
    for (let o = 0, h = 0, c = s.length; o < c; o++)
      switch (s[o]) {
        case 0:
          e.moveTo?.(n[h], n[h + 1]), a.x = n[h], a.y = n[h + 1], r = h, h += 2;
          break;
        case 1:
          e.lineTo?.(a.x, a.y, n[h], n[h + 1]), a.x = n[h], a.y = n[h + 1], h += 2;
          break;
        case 2:
          e.quadraticCurveTo?.(a.x, a.y, n[h], n[h + 1], n[h + 2], n[h + 3]), a.x = n[h + 2], a.y = n[h + 3], h += 4;
          break;
        case 3:
          e.cubicCurveTo?.(a.x, a.y, n[h], n[h + 1], n[h + 2], n[h + 3], n[h + 4], n[h + 5]), a.x = n[h + 4], a.y = n[h + 5], h += 6;
          break;
        case 5:
          e.close?.(n[r], n[r + 1], a.x, a.y);
          break;
      }
  }
  invertVisit(e) {
    const n = this.points, s = this.verbs;
    let r = 0, a = !0, o = !1, h = { x: 0, y: 0 };
    for (let c = s.length - 1, l = n.length; c >= 0; c--) {
      let u = s[c];
      switch (a && (l -= 2, a = !1, e.moveTo?.(n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1], r = l), u) {
        case 0:
          o && (e.close?.(n[r], n[r + 1], h.x, h.y), o = !1), a = !0;
          break;
        case 1:
          l -= 2, e.lineTo?.(h.x, h.y, n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1];
          break;
        case 2:
          l -= 4, e.quadraticCurveTo?.(h.x, h.y, n[l + 2], n[l + 3], n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1];
          break;
        case 3:
          l -= 6, e.cubicCurveTo?.(h.x, h.y, n[l + 4], n[l + 5], n[l + 2], n[l + 3], n[l], n[l + 1]), h.x = n[l], h.y = n[l + 1];
          break;
        case 5:
          o = !0;
          break;
      }
    }
  }
  addPath(e, n) {
    return n && (e = e.clone(), e.transform(n)), this._segmentMask |= e._segmentMask, this._needMoveTo = e._needMoveTo, this._lastMovePointIndex = this.points.length + e._lastMovePointIndex, this.points = this.points.concat(e.points), this.verbs = this.verbs.concat(e.verbs), this;
  }
  addReversePath(e) {
    e.invertVisit({
      moveTo: (n, s) => {
        this.moveTo(n, s);
      },
      lineTo: (n, s, r, a) => {
        this.lineTo(r, a);
      },
      quadraticCurveTo: (n, s, r, a, o, h) => {
        this.quadraticCurveTo(r, a, o, h);
      },
      cubicCurveTo: (n, s, r, a, o, h, c, l) => {
        this.cubicCurveTo(r, a, o, h, c, l);
      },
      close: () => {
        this.closePath();
      }
    });
  }
  // ignore move
  reversePathTo(e) {
    e.isEmpty || e.invertVisit({
      moveTo: (n, s) => {
      },
      lineTo: (n, s, r, a) => {
        this.lineTo(r, a);
      },
      quadraticCurveTo: (n, s, r, a, o, h) => {
        this.quadraticCurveTo(r, a, o, h);
      },
      cubicCurveTo: (n, s, r, a, o, h, c, l) => {
        this.cubicCurveTo(r, a, o, h, c, l);
      },
      close: () => {
        this.closePath();
      }
    });
  }
  offset(e, n) {
    for (let s = 0; s < this.points.length; s += 2)
      this.points[s] += e, this.points[s + 1] += n;
  }
  /*** 
   * 判断从某个点开始，后面的路径是否为零长度
   * 如果与start点形成闭合路径则认为非零长度
  */
  isZeroLengthSincePoint(e) {
    let n = this.points.length / 2 - e;
    if (n < 2)
      return !0;
    let s = this.points[e * 2], r = this.points[e * 2 + 1];
    for (let a = 1; a < n; a++)
      if (!(s === this.points[e + a * 2] && r === this.points[e + a * 2 + 1]))
        return !1;
    return !0;
  }
  finish() {
    return this.isEmpty || this.verbs.length == 1 ? null : this;
  }
  toCanvas(e) {
    this.visit({
      moveTo: (n, s) => {
        e.moveTo(n, s);
      },
      lineTo: (n, s, r, a) => {
        e.lineTo(r, a);
      },
      quadraticCurveTo: (n, s, r, a, o, h) => {
        e.quadraticCurveTo(r, a, o, h);
      },
      cubicCurveTo: (n, s, r, a, o, h, c, l) => {
        e.bezierCurveTo(r, a, o, h, c, l);
      },
      close: () => {
        e.closePath();
      }
    });
  }
  toPath2D() {
    const e = new Path2D();
    return this.toCanvas(e), e;
  }
  toSvgPath() {
    let e = [];
    return this.visit({
      moveTo: (n, s) => {
        e.push(["M", n, s]);
      },
      lineTo: (n, s, r, a) => {
        e.push(["L", r, a]);
      },
      quadraticCurveTo: (n, s, r, a, o, h) => {
        e.push(["Q", r, a, o, h]);
      },
      cubicCurveTo: (n, s, r, a, o, h, c, l) => {
        e.push(["C", r, a, o, h, c, l]);
      },
      close: () => {
        e.push(["Z"]);
      }
    }), e.map((n) => n[0] + n.slice(1).join(" ")).join("");
  }
  toPoints() {
    const e = [];
    for (let n = 0; n < this.points.length; n += 2)
      e.push({ x: this.points[n], y: this.points[n + 1] });
    return e;
  }
}
const HT = 3402823466e29, wd = 1 / 4096, Md = Math.SQRT1_2;
function XT(i, e = 1e-6) {
  return Math.abs(i) <= e;
}
const Py = Math.PI, Iy = 11920929e-14;
class bd {
  static from_points(e) {
    let n = e[0].clone(), s = e[1].clone(), r = e[2].clone(), a = Pa(s.clone().sub(n)), o = r.clone().sub(Pa(s)).add(n);
    return new this({
      a: o,
      b: a,
      c: n
    });
  }
  a = N.default();
  b = N.default();
  c = N.default();
  constructor(e) {
    e && Object.assign(this, e);
  }
  eval(e) {
    return N.default().copy(this.a).multiply(e).add(this.b).mul(e).add(this.c);
  }
}
class qm {
  static from_points(e) {
    let n = e[0].clone(), s = e[1].clone(), r = e[2].clone(), a = e[3].clone(), o = N.splat(3);
    return new this({
      a: a.clone().add(s.clone().sub(r).mul(o)).sub(n),
      b: o.clone().mul(r.clone().sub(Pa(s)).add(n)),
      c: o.clone().mul(s.clone().sub(n)),
      d: n.clone()
    });
  }
  a = N.default();
  b = N.default();
  c = N.default();
  d = N.default();
  constructor(e) {
    e && Object.assign(this, e);
  }
  eval(e) {
    return N.default().copy(this.a).multiply(e).add(this.b).mul(e).add(this.c).mul(e).add(this.d);
  }
}
function $m() {
  return new Array(3);
}
function ZT(i, e, n) {
  let s = i[0].clone(), r = i[1].clone(), a = i[2].clone(), o = N.splat(e), h = Ni(s, r, o), c = Ni(r, a, o);
  n[0] = N.from(s), n[1] = N.from(h), n[2] = N.from(Ni(h, c, o)), n[3] = N.from(c), n[4] = N.from(a);
}
function Eh(i, e, n, s) {
  if (i == 0) {
    let c = Io(-n, e);
    return c ? (s[0] = c, 1) : 0;
  }
  let r = e * e - 4 * i * n;
  if (r < 0)
    return 0;
  r = Math.sqrt(r);
  let a = r;
  if (!Number.isFinite(a))
    return 0;
  let o = e < 0 ? -(e - a) / 2 : -(e + a) / 2, h = 0;
  {
    let c = Io(o, i);
    c && (s[h] = c, h += 1);
  }
  {
    let c = Io(n, o);
    c && (s[h] = c, h += 1);
  }
  return h == 2 && (s[0] > s[1] ? [s[0], s[1]] = [s[1], s[0]] : s[0] == s[1] && (h -= 1)), h;
}
function Bu(i, e, n) {
  let s = i[e];
  return i[e] = i[n], i[n] = s, i;
}
function _d(i, e, n) {
  let s = i[0].clone(), r = i[1].clone(), a = i[2].clone(), o = i[3].clone(), h = N.splat(e), c = Ni(s, r, h), l = Ni(r, a, h), u = Ni(a, o, h), f = Ni(c, l, h), d = Ni(l, u, h), p = Ni(f, d, h);
  n[0] = N.from(s), n[1] = N.from(c), n[2] = N.from(f), n[3] = N.from(p), n[4] = N.from(d), n[5] = N.from(u), n[6] = N.from(o);
}
function JT(i, e, n) {
  return Io(i - e, i - e - e + n);
}
function Io(i, e) {
  return i < 0 && (i = -i, e = -e), e == 0 || i == 0 || i >= e ? void 0 : i / e;
}
function Ni(i, e, n) {
  return N.default().copy(i).add(e.clone().sub(i)).multiply(n);
}
function Pa(i) {
  return N.default().copy(i).add(i);
}
function Vm(i) {
  let e = i[1].x - i[0].x, n = i[1].y - i[0].y, s = i[0].x - i[1].x - i[1].x + i[2].x, r = i[0].y - i[1].y - i[1].y + i[2].y, a = -(e * s + n * r), o = s * s + r * r;
  if (o < 0 && (a = -a, o = -o), a <= 0)
    return 0;
  if (a >= o)
    return 1;
  let h = a / o;
  return (h < 0 || h > 1) && console.assert("值无效"), h;
}
class ar {
  static ZERO = 0;
  static ONE = 1;
  static new_clamped(e) {
    return Number.isFinite(e) ? Je(e, 0, 1) : this.ZERO;
  }
}
function Ro(i, e) {
  return N.from(bd.from_points(i).eval(N.splat(e)));
}
function Gm(i, e) {
  if (e == ar.ZERO && i[0] == i[1] || e == ar.ONE && i[1] == i[2])
    return i[2].clone().sub(i[0]);
  let n = i[0].clone(), s = i[1].clone(), r = i[2].clone(), a = s.clone().sub(n), h = r.clone().sub(s).sub(a).clone().mul(N.splat(e)).add(a);
  return N.from(h).add(h);
}
function Sd(i, e) {
  let n = Ry([i[0].x, i[1].x, i[2].x, i[3].x]), s = Ry([i[0].y, i[1].y, i[2].y, i[3].y]);
  for (let a = 0; a < 4; a++)
    n[a] += s[a];
  let r = QT(n, e);
  return e.slice(0, r);
}
function Ry(i) {
  let e = i[1] - i[0], n = i[2] - 2 * i[1] + i[0], s = i[3] + 3 * (i[1] - i[2]) - i[0];
  return [s * s, 3 * n * s, 2 * n * n + s * e, e * n];
}
function QT(i, e) {
  if (XT(i[0])) {
    let f = $m(), d = Eh(i[1], i[2], i[3], f);
    for (let p = 0; p < d; p++)
      e[p] = f[p];
    return d;
  }
  let n = 1 / i[0], s = i[1] * n, r = i[2] * n, a = i[3] * n, o = (s * s - r * 3) / 9, h = (2 * s * s * s - 9 * s * r + 27 * a) / 54, c = o * o * o, l = h * h - c, u = s / 3;
  if (l < 0) {
    let f = Math.acos(Je(h / Math.sqrt(c), -1, 1)), d = -2 * Math.sqrt(o);
    return e[0] = ar.new_clamped(d * Math.cos(f / 3) - u), e[1] = ar.new_clamped(
      d * Math.cos((f + 2 * Py) / 3) - u
    ), e[2] = ar.new_clamped(
      d * Math.cos((f - 2 * Py) / 3) - u
    ), KT(e), tE(e);
  } else {
    let f = Math.abs(h) + Math.sqrt(l);
    return f = eE(f), h > 0 && (f = -f), f != 0 && (f += o / f), e[0] = ar.new_clamped(f - u), 1;
  }
}
function KT(i) {
  i[0] > i[1] && Bu(i, 0, 1), i[1] > i[2] && Bu(i, 1, 2), i[0] > i[1] && Bu(i, 0, 1);
}
function tE(i) {
  let e = 3;
  return i[1] == i[2] && (e = 2), i[0] == i[1] && (e = 1), e;
}
function eE(i) {
  return Math.pow(i, 0.3333333);
}
function Ml(i, e) {
  return N.from(qm.from_points(i).eval(N.splat(e)));
}
function Um(i, e) {
  if (e == 0 && i[0] == i[1] || e == 1 && i[2] == i[3]) {
    let n = e == 0 ? i[2].clone().sub(i[0]) : i[3].clone().sub(i[1]);
    return n.x == 0 && n.y == 0 && (n = i[3].clone().sub(i[0])), n;
  } else
    return Wm(i, e);
}
function Wm(i, e) {
  let n = i[0].clone(), s = i[1].clone(), r = i[2].clone(), a = i[3].clone(), o = new bd({
    a: a.clone().add(N.splat(3).mul(s.clone().sub(r))).sub(n),
    b: Pa(r.clone().sub(Pa(s)).add(n)),
    c: s.clone().sub(n)
  });
  return N.from(o.eval(N.splat(e)));
}
function nE(i, e, n, s, r) {
  let a = s - i + 3 * (e - n), o = 2 * (i - e - e + n), h = e - i;
  const c = Eh(a, o, h, r);
  return r.slice(0, c);
}
function Ym(i, e) {
  let n = i[1].x - i[0].x, s = i[1].y - i[0].y, r = i[2].x - 2 * i[1].x + i[0].x, a = i[2].y - 2 * i[1].y + i[0].y, o = i[3].x + 3 * (i[1].x - i[2].x) - i[0].x, h = i[3].y + 3 * (i[1].y - i[2].y) - i[0].y, c = Eh(
    r * h - a * o,
    n * h - s * o,
    n * a - s * r,
    e
  );
  return e.slice(0, c);
}
function jm(i) {
  if (i[0].equals(i[1]) || i[2].equals(i[3]) || Oy(i, 0, 2) || Oy(i, 2, 0))
    return;
  let e = Array.from({ length: 3 }, () => ar.ZERO), n = Sd(i, e);
  for (let s of n) {
    if (0 >= s || s >= 1)
      continue;
    let a = Wm(i, s).magnitudeSquared(), o = iE(i);
    if (a < o)
      return Je(s, Iy, 1 - Iy);
  }
}
function Oy(i, e, n) {
  let s = i[n], r = i[n + 1].clone().sub(s), a = [0, 0];
  for (let o = 0; o < 2; o++) {
    let h = i[e + o].clone().sub(s);
    a[o] = r.clone().cross(h);
  }
  return a[0] * a[1] >= 0;
}
function iE(i) {
  return (i[1].distanceSquared(i[0]) + i[2].distanceSquared(i[1]) + i[3].distanceSquared(i[2])) * 1e-8;
}
class Qn {
  points = N.makeZeroArray(3);
  weight = 0;
  static default() {
    return new this();
  }
  static new(e, n, s, r) {
    const a = this.default();
    return a.points[0].copy(e), a.points[1].copy(n), a.points[2].copy(s), a.weight = r, a;
  }
  static from_points(e, n) {
    return this.new(e[0], e[1], e[2], n);
  }
  static build_unit_arc(e, n, s, r, a) {
    let o = e.dot(n), h = e.cross(n);
    if (Math.abs(h) <= wd && o > 0 && (h >= 0 && s == 0 || h <= 0 && s == 1))
      return;
    s == 1 && (h = -h);
    let l = 0;
    h == 0 ? l = 2 : o == 0 ? l = h > 0 ? 1 : 3 : (h < 0 && (l += 2), o < 0 != h < 0 && (l += 1));
    let u = [
      N.create(1, 0),
      N.create(1, 1),
      N.create(0, 1),
      N.create(-1, 1),
      N.create(-1, 0),
      N.create(-1, -1),
      N.create(0, -1),
      N.create(1, -1)
    ];
    const f = Md;
    let d = l;
    for (let m = 0; m < d; m++)
      a[m] = Qn.new(u[m * 2], u[m * 2 + 1], u[m * 2 + 2], f);
    let p = N.create(o, h), y = u[l * 2], x = y.dot(p);
    if (x < 1) {
      let m = N.create(y.x + o, y.y + h), v = Math.sqrt((1 + x) / 2);
      m.setLength(1 / v), y.equalsEpsilon(m) || (a[d] = Qn.new(y, m, p, v), d += 1);
    }
    let g = Pe.fromSinCos(e.y, e.x);
    s == 1 && (g = g.preScale(1, -1)), r && g.premultiply(r);
    for (let m = 0; m < d; m++)
      g.mapPoints(a[m].points, a[m].points);
    if (d != 0) return a.slice(0, d);
  }
  constructor(e) {
    e && (this.points.forEach((n, s) => {
      e.points[s] && n.copy(e.points[s]);
    }), this.weight = e.weight);
  }
  compute_quad_pow2(e) {
    if (e < 0 || !Number.isFinite(e))
      return;
    const n = this;
    if (!n.points[0].isFinite() || !n.points[1].isFinite() || !n.points[2].isFinite())
      return;
    const s = 4;
    let r = n.weight - 1, a = r / (4 * (2 + r)), o = a * (n.points[0].x - 2 * n.points[1].x + n.points[2].x), h = a * (n.points[0].y - 2 * n.points[1].y + n.points[2].y), c = Math.sqrt(o * o + h * h), l = 0;
    for (let u = 0; u < s && !(c <= e); u++)
      c *= 0.25, l += 1;
    return Math.max(l, 1);
  }
  // Chop this conic into N quads, stored continuously in pts[], where
  // N = 1 << pow2. The amount of storage needed is (1 + 2 * N)
  chop_into_quads_pow2(e, n) {
    const s = this;
    n[0] = s.points[0], n0(s, n.slice(1), e);
    let a = 2 * (1 << e) + 1;
    if (n.slice(0, a).some((h) => !Number.isFinite(h)))
      for (let h = 0; h < a - 1; h++)
        this.points[h + 1] = this.points[1];
    return 1 << e;
  }
  chop() {
    const e = this;
    let n = N.splat(1 / (1 + e.weight)), s = rE(e.weight), r = e.points[0].clone(), a = e.points[1].clone(), o = e.points[2].clone(), c = N.splat(e.weight).clone().mul(a), l = r.clone().add(Pa(c)).add(o).multiply(n).mul(N.splat(0.5)), u = N.from(l);
    if (!u.isFinite()) {
      let f = e.weight, d = f * 2, p = 1 / (1 + f) * 0.5;
      u.x = (e.points[0].x + d * e.points[1].x + e.points[2].x) * p, u.y = (e.points[0].y + d * e.points[1].y + e.points[2].y) * p;
    }
    return [
      new Qn({
        points: [e.points[0], N.from(r.clone().add(c).mul(n)), u],
        weight: s
      }),
      new Qn({
        points: [u, N.from(c.clone().add(o).mul(n)), e.points[2]],
        weight: s
      })
    ];
  }
}
function sE(i, e, n, s, r) {
  let a = i.dot(e), o = i.cross(e);
  if (Math.abs(o) <= wd && a > 0 && (o >= 0 && n == 0 || o <= 0 && n == 1))
    return;
  n == 1 && (o = -o);
  let c = 0;
  o == 0 ? c = 2 : a == 0 ? c = o > 0 ? 1 : 3 : (o < 0 && (c += 2), a < 0 != o < 0 && (c += 1));
  let l = [
    N.create(1, 0),
    N.create(1, 1),
    N.create(0, 1),
    N.create(-1, 1),
    N.create(-1, 0),
    N.create(-1, -1),
    N.create(0, -1),
    N.create(1, -1)
  ];
  const u = Md;
  let f = c;
  for (let g = 0; g < f; g++)
    r[g] = Qn.from_points(l.slice(g * 2), u);
  let d = N.create(a, o), p = l[c * 2], y = p.dot(d);
  if (y < 1) {
    let g = N.create(p.x + a, p.y + o), m = Math.sqrt((1 + y) / 2);
    g.setLength(1 / m), p.equalsEpsilon(g) || (r[f] = Qn.new(p, g, d, m), f += 1);
  }
  let x = Pe.fromSinCos(i.y, i.x);
  if (n == 1 && (x = x.preScale(1, -1)), x = x.premultiply(s), r.slice(f).forEach((g, m) => {
    x.mapPoints(g.points, g.points);
  }), f != 0)
    return r.slice(0, f);
}
function rE(i) {
  return Math.sqrt(0.5 + i * 0.5);
}
function n0(i, e, n) {
  if (n == 0)
    return e[0] = i.points[1], e[1] = i.points[2], e.slice(2);
  {
    let s = i.chop(), r = i.points[0].y, a = i.points[2].y;
    if (Zh(r, i.points[1].y, a)) {
      let o = s[0].points[2].y;
      if (!Zh(r, o, a)) {
        let h = Math.abs(o - r) < Math.abs(o - a) ? r : a;
        s[0].points[2].y = h, s[1].points[0].y = h;
      }
      Zh(r, s[0].points[1].y, s[0].points[2].y) || (s[0].points[1].y = r), Zh(s[1].points[0].y, s[1].points[1].y, a) || (s[1].points[1].y = a);
    }
    return n -= 1, e = n0(s[0], e, n), n0(s[1], e, n);
  }
}
function Zh(i, e, n) {
  return (i - e) * (n - e) <= 0;
}
class aE {
  points = [];
  len = 0;
  static compute(e, n, s, r) {
    let a = Qn.new(e, n, s, r), o = a.compute_quad_pow2(0.25);
    if (o === void 0)
      return;
    let h = Array.from({ length: 64 }, () => N.zero()), c = a.chop_into_quads_pow2(o, h);
    return new this({
      points: h,
      len: c
    });
  }
  constructor(e) {
    e && Object.assign(this, e);
  }
}
function oE(i, e, n) {
  if (e.length <= 0)
    n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3];
  else {
    let s = e[0], r = N.makeZeroArray(4), a = 0;
    for (let o = 0; o < e.length; o++) {
      let h = [];
      _d(i, s, h);
      for (let l = 0; l < h.length; l++)
        n[a + l] = h[l];
      if (o == e.length - 1)
        break;
      a += 3, r[0] = n[a + 0], r[1] = n[a + 1], r[2] = n[a + 2], r[3] = n[a + 3], i = r;
      let c = Io(
        e[o + 1] - e[o],
        1 - e[o]
      );
      c !== void 0 ? s = c : (n[a + 4].copy(i[3]), n[a + 5].copy(i[3]), n[a + 6].copy(i[3]));
    }
  }
}
function ky(i, e = 1e-6) {
  return Math.abs(i) <= e;
}
var Hm = /* @__PURE__ */ ((i) => (i.Miter = "miter", i.Round = "round", i.Bevel = "bevel", i.MiterClip = "miter-clip", i))(Hm || {}), Xm = /* @__PURE__ */ ((i) => (i.Butt = "butt", i.Round = "round", i.Square = "square", i))(Xm || {}), Zm = /* @__PURE__ */ ((i) => (i.NonZero = "nonzero", i.EvenOdd = "evenodd", i))(Zm || {});
class Jl {
  isAutoClose = !1;
  path;
  verbIndex;
  pointsIndex;
  lastMoveTo = N.default();
  lastPoint = N.default();
  constructor(e) {
    this.isAutoClose = e.isAutoClose ?? !1, this.verbIndex = e.verbIndex, this.pointsIndex = e.pointsIndex, this.path = e.path, e.lastMoveTo && this.lastMoveTo.copy(e.lastMoveTo), e.lastPoint && this.lastPoint.copy(e.lastPoint);
  }
  get curVerb() {
    return this.path.verbs[this.verbIndex - 1];
  }
  get nextVerb() {
    return this.path.verbs[this.verbIndex];
  }
  copy(e) {
    return this.isAutoClose = e.isAutoClose, this.verbIndex = e.verbIndex, this.pointsIndex = e.pointsIndex, this.lastMoveTo.copy(e.lastMoveTo), this.lastPoint.copy(e.lastPoint), this;
  }
  clone() {
    return new Jl({
      isAutoClose: this.isAutoClose,
      path: this.path,
      verbIndex: this.verbIndex,
      pointsIndex: this.pointsIndex,
      lastMoveTo: this.lastMoveTo,
      lastPoint: this.lastPoint
    });
  }
  *[Symbol.iterator]() {
    const e = Array.from({ length: this.path.points.length / 2 }, (r, a) => N.create(this.path.points[a * 2], this.path.points[a * 2 + 1])), n = this.path.verbs;
    let s = null;
    for (; this.verbIndex < n.length; ) {
      const r = n[this.verbIndex++];
      switch (r) {
        case _e.MoveTo:
          this.pointsIndex += 1, s = e[this.pointsIndex - 1], this.lastMoveTo.copy(s), this.lastPoint.copy(this.lastMoveTo), yield { type: r, p0: e[this.pointsIndex - 1] };
          break;
        case _e.LineTo:
          this.pointsIndex += 1, this.lastPoint.copy(e[this.pointsIndex - 1]), yield { type: r, p0: e[this.pointsIndex - 1] };
          break;
        case _e.QuadCurveTo:
          this.pointsIndex += 2, this.lastPoint.copy(e[this.pointsIndex - 1]), yield { type: r, p0: e[this.pointsIndex - 3], p1: e[this.pointsIndex - 2], p2: e[this.pointsIndex - 1] };
          break;
        case _e.CubicCurveTo:
          this.pointsIndex += 3, this.lastPoint.copy(e[this.pointsIndex - 1]), yield { type: r, p0: e[this.pointsIndex - 4], p1: e[this.pointsIndex - 3], p2: e[this.pointsIndex - 2], p3: e[this.pointsIndex - 1] };
          break;
        case _e.Close:
          const a = this.autoClose();
          this.lastPoint.copy(this.lastMoveTo), yield a;
          break;
      }
    }
  }
  hasValidTangent() {
    let e = this.clone();
    for (let n of e)
      switch (n.type) {
        case _e.MoveTo:
          return !1;
        case _e.LineTo: {
          if (e.lastPoint.equals(n.p0))
            continue;
          return !0;
        }
        case _e.QuadCurveTo: {
          if (e.lastPoint.equals(n.p1) && e.lastPoint.equals(n.p2))
            continue;
          return !0;
        }
        case _e.CubicCurveTo: {
          if (e.lastPoint.equals(n.p1) && e.lastPoint.equals(n.p2) && e.lastPoint.equals(n.p3))
            continue;
          return !0;
        }
        case _e.Close:
          return !1;
      }
    return !1;
  }
  setAutoClose(e) {
    this.isAutoClose = e;
  }
  autoClose() {
    return this.isAutoClose && !this.lastPoint.equals(this.lastMoveTo) ? (this.verbIndex -= 1, {
      type: _e.LineTo,
      p0: this.lastMoveTo
    }) : {
      type: _e.Close,
      p0: this.lastPoint,
      p1: this.lastMoveTo
    };
  }
}
class hE {
  constructor(e, n) {
    this.inner = e, this.outer = n;
  }
  swap() {
    [this.inner, this.outer] = [this.outer, this.inner];
  }
}
const i0 = 0.707106781, s0 = (i, e, n, s, r) => {
  r.lineTo(n.x, n.y);
}, cE = (i, e, n, s, r) => {
  let a = e.clone();
  a.cw();
  let o = i.clone().add(a), h = o.clone().add(e);
  r.conicTo(
    h.x,
    h.y,
    o.x,
    o.y,
    i0
  ), h.copy(o).sub(e), r.conicTo(
    h.x,
    h.y,
    n.x,
    n.y,
    i0
  );
}, lE = (i, e, n, s, r) => {
  let a = e.clone();
  a.cw(), s ? (r.setLastPoint(
    i.x + e.x + a.x,
    i.y + e.y + a.y
  ), r.lineTo(
    i.x - e.x + a.x,
    i.y - e.y + a.y
  )) : (r.lineTo(
    i.x + e.x + a.x,
    i.y + e.y + a.y
  ), r.lineTo(
    i.x - e.x + a.x,
    i.y - e.y + a.y
  ), r.lineTo(n.x, n.y));
};
function Ly(i) {
  return Math.abs(i) <= Ed;
}
function Jm(i) {
  return i >= 0 ? Ly(1 - i) ? 3 : 2 : Ly(1 + i) ? 0 : 1;
}
function Td(i, e) {
  return i.x * e.y > i.y * e.x;
}
function bl(i, e, n) {
  n.lineTo(i.x, i.y), n.lineTo(i.x - e.x, i.y - e.y);
}
const Qm = (i, e, n, s, r, a, o, h, c) => {
  function l(v, w, b, S, E, A, M, _, T, C) {
    if (_ = _.clone(), _.multiplyScalar(b), M = M.clone(), A = A.clone(), C) {
      M.normalize();
      let P = A.dot(M), R = A.cross(M), k = 0;
      Math.abs(R) <= Ed ? k = 1 / T : k = (1 / T - P) / R, A.multiplyScalar(b);
      let I = A.clone();
      I.cw();
      let L = _.clone();
      L.ccw();
      let F = N.default();
      F.addVectors(w, A).add(I.clone().multiplyScalar(k));
      let B = N.default();
      F.addVectors(w, _).add(L.clone().multiplyScalar(k)), S ? v.outer.setLastPoint(F.x, F.y) : v.outer.lineTo(F.x, F.y), v.outer.lineTo(B.x, B.y);
    }
    E || v.outer.lineTo(w.x + _.x, w.y + _.y), bl(w, _, v.inner);
  }
  function u(v, w, b, S, E, A, M) {
    M = M.clone(), M.multiplyScalar(b), S ? v.outer.setLastPoint(w.x + A.x, w.y + A.y) : v.outer.lineTo(w.x + A.x, w.y + A.y), E || v.outer.lineTo(w.x + M.x, w.y + M.y), bl(w, M, v.inner);
  }
  let f = i.dot(n), d = Jm(f), p = i.clone(), y = n.clone(), x = N.default();
  if (d == 3)
    return;
  if (d == 0) {
    h = !1, x.subVectors(y, p).multiplyScalar(s / 2), l(
      c,
      e,
      s,
      o,
      h,
      p,
      x,
      y,
      r,
      a
    );
    return;
  }
  let g = !Td(p, y);
  if (g && (c.swap(), p.negate(), y.negate()), f == 0 && r <= i0) {
    x.addVectors(p, y).multiplyScalar(s), u(
      c,
      e,
      s,
      o,
      h,
      x,
      y
    );
    return;
  }
  d == 1 ? (x = N.create(y.y - p.y, p.x - y.x), g && x.negate()) : x = N.create(p.x + y.x, p.y + y.y);
  let m = Math.sqrt((1 + f) / 2);
  if (m < r) {
    h = !1, l(
      c,
      e,
      s,
      o,
      h,
      p,
      x,
      y,
      r,
      a
    );
    return;
  }
  x.setLength(s / m), u(
    c,
    e,
    s,
    o,
    h,
    x,
    y
  );
}, uE = (i, e, n, s, r, a, o, h) => {
  let c = n.clone().multiplyScalar(s);
  Td(i, n) || (h.swap(), c.negate()), h.outer.lineTo(e.x + c.x, e.y + c.y), bl(e, c, h.inner);
}, fE = (i, e, n, s, r, a, o, h) => Qm(i, e, n, s, r, !1, a, o, h), dE = (i, e, n, s, r, a, o, h) => {
  Qm(
    i,
    e,
    n,
    s,
    r,
    !0,
    a,
    o,
    h
  );
}, r0 = (i, e, n, s, r, a, o, h) => {
  let c = i.dot(n);
  if (Jm(c) == 3)
    return;
  let u = i.clone(), f = n.clone(), d = wl.CW;
  Td(u, f) || (h.swap(), u.negate(), f.negate(), d = wl.CCW);
  let p = Pe.fromRows(s, 0, 0, s, e.x, e.y), y = new Array(5).fill(0).map(() => new Qn()), x = Qn.build_unit_arc(u, f, d, p, y);
  if (x) {
    for (let g of x)
      h.outer.conicTo(
        g.points[1].x,
        g.points[1].y,
        g.points[2].x,
        g.points[2].y,
        g.weight
      );
    f.multiplyScalar(s), bl(e, f, h.inner);
  }
};
function Fy(i, e, n, s, r, a) {
  return a.setLengthFromPoint((e.x - i.x) * n, (e.y - i.y) * n, 1) ? (a.ccw(), r.copy(a).multiplyScalar(s), !0) : !1;
}
function pE(i, e, n, s) {
  return s.setLengthFromPoint(i.x, i.y, 1) ? (s.ccw(), n.copy(s).multiplyScalar(e), !0) : !1;
}
class Jh {
  static default() {
    return new this();
  }
  // The state of the quad stroke under construction.
  quad = [N.default(), N.default(), N.default()];
  // the stroked quad parallel to the original curve
  tangent_start = N.default();
  // a point tangent to quad[0]
  tangent_end = N.default();
  // a point tangent to quad[2]
  start_t = 0;
  // a segment of the original curve
  mid_t = 0;
  end_t = 0;
  start_set = !1;
  // state to share common points across structs
  end_set = !1;
  opposite_tangents = !1;
  // set if coincident tangents have opposite directions
  init(e, n) {
    return this.start_t = e, this.mid_t = Math.min(1, Math.max(0, (e + n) / 2)), this.end_t = n, this.start_set = !1, this.end_set = !1, this.start_t < this.mid_t && this.mid_t < this.end_t;
  }
  initWithStart(e) {
    const n = this;
    return n.init(e.start_t, e.mid_t) ? (n.quad[0].copy(e.quad[0]), n.tangent_start.copy(e.tangent_start), n.start_set = !0, !0) : !1;
  }
  initWithEnd(e) {
    const n = this;
    return n.init(e.mid_t, e.end_t) ? (n.quad[2].copy(e.quad[2]), n.tangent_end.copy(e.tangent_end), n.end_set = !0, !0) : !1;
  }
}
function yE(i) {
  let e = Gi(i[1].clone().sub(i[0])), n = Gi(i[2].clone().sub(i[1]));
  if (e & n)
    return [
      N.default(),
      0
      /* Point */
    ];
  if (e | n)
    return [
      N.default(),
      1
      /* Line */
    ];
  if (!xE(i))
    return [
      N.default(),
      2
      /* Quad */
    ];
  let s = Vm(i);
  if (s == 0 || s == 1)
    return [
      N.default(),
      1
      /* Line */
    ];
  let r = Ro(i, s);
  return [
    N.create(r.x, r.y),
    3
    /* Degenerate */
  ];
}
function Gi(i) {
  return +!i.canNormalize();
}
function xE(i) {
  let e = -1, n = 0, s = 0;
  for (let h = 0; h < 2; h++)
    for (let c = h + 1; c < 3; c++) {
      let l = i[c].clone().sub(i[h]), u = Math.max(Math.abs(l.x), Math.abs(l.y));
      e < u && (n = h, s = c, e = u);
    }
  console.assert(n <= 1), console.assert(s >= 1 && s <= 2), console.assert(n < s);
  let r = n ^ s ^ 3, o = e * e * 5e-6;
  return ba(i[r], i[n], i[s]) <= o;
}
function ba(i, e, n) {
  let s = n.clone().sub(e), r = i.clone().sub(e), a = s.dot(r), o = s.dot(s), h = a / o;
  return h >= 0 && h <= 1 ? N.create(
    e.x * (1 - h) + n.x * h,
    e.y * (1 - h) + n.y * h
  ).distanceSquared(i) : i.distanceSquared(e);
}
function gE(i, e, n) {
  let s = i[1].clone().sub(i[0]), r = [0, 0, 0];
  for (let l = 0; l < 3; l++)
    r[l] = (e[l].y - i[0].y) * s.x - (e[l].x - i[0].x) * s.y;
  let a = r[2], o = r[1], h = r[0];
  a += h - 2 * o, o -= h;
  let c = Eh(a, 2 * o, h, n);
  return n.slice(0, c);
}
function Du(i, e, n) {
  return i.distanceSquared(e) <= n * n;
}
function Ny(i) {
  let e = i[1].clone().sub(i[0]), n = i[1].clone().sub(i[2]), s = e.magnitudeSquared(), r = n.magnitudeSquared();
  return s > r && ([e, n] = [n, e], r = s), e.setLength(r) ? e.dot(n) > 0 : !1;
}
function mE(i, e, n) {
  let s = Math.min(i[0].x, i[1].x, i[2].x);
  if (e.x + n < s)
    return !1;
  let r = Math.max(i[0].x, i[1].x, i[2].x);
  if (e.x - n > r)
    return !1;
  let a = Math.min(i[0].y, i[1].y, i[2].y);
  if (e.y + n < a)
    return !1;
  let o = Math.max(i[0].y, i[1].y, i[2].y);
  return !(e.y - n > o);
}
function vE(i, e, n) {
  let s = Gi(i[1].clone().sub(i[0])), r = Gi(i[2].clone().sub(i[1])), a = Gi(i[3].clone().sub(i[2]));
  if (s & r & a)
    return 0;
  if (s + r + a == 2)
    return 1;
  if (!wE(i))
    return n && (s ? n.copy(i[2]) : n.copy(i[1])), 2;
  let o = [0, 0, 0];
  o = Sd(i, o);
  let h = 0;
  for (let c of o) {
    if (0 >= c || c >= 1)
      continue;
    let l = Ml(i, c);
    e[h] = N.create(l.x, l.y), !e[h].equals(i[0]) && !e[h].equals(i[3]) && (h += 1);
  }
  switch (h) {
    case 0:
      return 1;
    case 1:
      return 1;
    case 2:
      return 4;
    case 3:
      return 5;
    default:
      return -1;
  }
}
function wE(i) {
  let e = -1, n = 0, s = 0;
  for (let h = 0; h < 3; h++)
    for (let c = h + 1; c < 4; c++) {
      let l = i[c].clone().sub(i[h]), u = Math.max(Math.abs(l.x), Math.abs(l.y));
      e < u && (n = h, s = c, e = u);
    }
  let r = 1 + (2 >> s) >> n, a = n ^ s ^ r, o = e * e * 1e-5;
  return ba(i[r], i[n], i[s]) <= o && ba(i[a], i[n], i[s]) <= o;
}
const ME = {
  bevel: uE,
  miter: fE,
  "miter-clip": dE,
  round: r0
}, bE = {
  butt: s0,
  round: cE,
  square: lE
}, _E = 3, By = [15, 78, 33, 33], Ed = 1 / 4096;
class SE {
  static computeResolutionScale(e) {
    let n = N.create(e.a, e.b).magnitude(), s = N.create(e.c, e.d).magnitude();
    if (Number.isFinite(n) && Number.isFinite(s)) {
      let r = Math.max(n, s);
      if (r > 0)
        return r;
    }
    return 1;
  }
  radius = 0;
  // 线段宽的一半
  inv_miter_limit = 0;
  // 1/miter_limit
  res_scale = 1;
  // 分辨率缩放因子
  inv_res_scale = 1;
  // 分辨率缩放因子的倒数
  inv_res_scale_squared = 1;
  // 分辨率缩放因子的倒数平方
  first_normal = N.default();
  // Move->LineTo 旋转-90法向量剩以radius
  prev_normal = N.default();
  // 上一个LineTo->lineTo点旋转-90法向量剩以radius
  first_unit_normal = N.default();
  // Move->LineTo 线段的，旋转-90度的单位法向量
  prev_unit_normal = N.default();
  // 上一个lineTo->LineTo点旋转-90度的单位法向量
  first_pt = N.default();
  // moveTo点
  prev_pt = N.default();
  // 上一个lineTo点
  first_outer_pt = N.default();
  // 第一个线段的外侧点
  first_outer_pt_index_in_contour = 0;
  // 第一个线段的外侧点在轮廓中的索引
  segment_count = -1;
  // 从MoveTo线段计数
  prev_is_line = !1;
  // 上一个绘制命令是否是lineTo
  capper;
  joiner;
  inner = mr.default();
  outer = mr.default();
  cusper = mr.default();
  stroke_type = 1;
  // 线段类型
  recursion_depth = 0;
  // 递归深度
  found_tangents = !1;
  // 是否找到切线
  join_completed = !1;
  // 是否完成连接
  get moveToPt() {
    return this.first_pt;
  }
  builders() {
    return new hE(this.inner, this.outer);
  }
  close(e) {
    this.finishContour(!0, e);
  }
  moveTo(e) {
    this.segment_count > 0 && this.finishContour(!1, !1), this.segment_count = 0, this.first_pt.copy(e), this.prev_pt.copy(e), this.join_completed = !1;
  }
  finishContour(e, n) {
    const s = this;
    if (s.segment_count > 0) {
      if (e) {
        s.joiner(
          s.prev_unit_normal,
          s.prev_pt,
          s.first_unit_normal,
          s.radius,
          s.inv_miter_limit,
          s.prev_is_line,
          n,
          s.builders()
        ), s.outer.closePath();
        let r = s.inner.lastPoint ?? N.create(0, 0);
        s.outer.moveTo(r.x, r.y), s.outer.reversePathTo(s.inner), s.outer.closePath();
      } else {
        let r = s.inner.lastPoint ? N.fromPoint(s.inner.lastPoint) : N.create(0, 0), a = n ? s.inner : null;
        s.capper(
          s.prev_pt,
          s.prev_normal,
          r,
          a,
          s.outer
        ), s.outer.reversePathTo(s.inner), a = s.prev_is_line ? s.inner : null, s.capper(
          s.first_pt,
          s.first_normal.clone().negate(),
          s.first_outer_pt,
          a,
          s.outer
        ), s.outer.closePath();
      }
      s.cusper.isEmpty || (s.outer.addPath(s.cusper), s.cusper.clear());
    }
    s.inner.clear(), s.segment_count = -1, s.first_outer_pt_index_in_contour = s.outer.points.length;
  }
  preJoinTo(e, n, s, r) {
    const a = this;
    let o = a.prev_pt.x, h = a.prev_pt.y;
    if (!Fy(
      a.prev_pt,
      e,
      a.res_scale,
      a.radius,
      s,
      r
    )) {
      if (a.capper === s0)
        return !1;
      s.set(a.radius, 0), r.set(1, 0);
    }
    return a.segment_count == 0 ? (a.first_normal.copy(s), a.first_unit_normal.copy(r), a.first_outer_pt = N.create(o + s.x, h + s.y), a.outer.moveTo(a.first_outer_pt.x, a.first_outer_pt.y), a.inner.moveTo(o - s.x, h - s.y)) : a.joiner(
      a.prev_unit_normal,
      a.prev_pt,
      r,
      a.radius,
      a.inv_miter_limit,
      a.prev_is_line,
      n,
      a.builders()
    ), a.prev_is_line = n, !0;
  }
  postJoinTo(e, n, s) {
    this.join_completed = !0, this.prev_pt.copy(e), this.prev_unit_normal.copy(s), this.prev_normal.copy(n), this.segment_count += 1;
  }
  initQuad(e, n, s, r) {
    this.stroke_type = e, this.found_tangents = !1, r.init(n, s);
  }
  quadStroke(e, n) {
    let s = this, r = s.compareQuadQuad(e, n);
    if (r == 2)
      return (s.stroke_type == 1 ? s.outer : s.inner).quadraticCurveTo(
        n.quad[1].x,
        n.quad[1].y,
        n.quad[2].x,
        n.quad[2].y
      ), !0;
    if (r == 1)
      return s.addDegenerateLine(n), !0;
    if (s.recursion_depth += 1, s.recursion_depth > By[_E])
      return !1;
    let a = Jh.default();
    return a.initWithStart(n), !s.quadStroke(e, a) || (a.initWithEnd(n), !s.quadStroke(e, a)) ? !1 : (s.recursion_depth -= 1, !0);
  }
  compareQuadQuad(e, n) {
    const s = this;
    if (!n.start_set) {
      let h = N.zero();
      s.quadPerpRay(
        e,
        n.start_t,
        h,
        n.quad[0],
        n.tangent_start
      ), n.start_set = !0;
    }
    if (!n.end_set) {
      let h = N.zero();
      s.quadPerpRay(
        e,
        n.end_t,
        h,
        n.quad[2],
        n.tangent_end
      ), n.end_set = !0;
    }
    let r = s.intersectRay(0, n);
    if (r != 2)
      return r;
    let a = N.zero(), o = N.zero();
    return s.quadPerpRay(e, n.mid_t, o, a), s.strokeCloseEnough(n.quad.slice(), [a, o], n);
  }
  // Given a point on the curve and its derivative, scale the derivative by the radius, and
  // compute the perpendicular point and its tangent.
  setRayPoints(e, n, s, r) {
    const a = this;
    n.setLength(a.radius) || n.copy(N.create(a.radius, 0));
    let o = a.stroke_type;
    s.x = e.x + o * n.y, s.y = e.y - o * n.x, r && (r.x = s.x + n.x, r.y = s.y + n.y);
  }
  // Given a quad and t, return the point on curve,
  // its perpendicular, and the perpendicular tangent.
  quadPerpRay(e, n, s, r, a) {
    let o = this, h = Ro(e, n);
    s.set(h.x, h.y), h = Gm(e, n);
    let c = N.create(h.x, h.y);
    c.isZero() && (c = e[2].sub(e[0])), o.setRayPoints(s, c, r, a);
  }
  strokeCloseEnough(e, n, s) {
    const r = this;
    let o = Ro(e, 0.5);
    if (Du(n[0], N.create(o.x, o.y), r.inv_res_scale))
      return Ny(s.quad) ? 0 : 2;
    if (!mE(e, n[0], r.inv_res_scale))
      return 0;
    let h = new Array(3).fill(0.5);
    if (h = gE(n, e, h), h.length != 1)
      return 0;
    let c = Ro(e, h[0]), l = r.inv_res_scale * (1 - Math.abs(h[0] - 0.5) * 2);
    return Du(n[0], N.create(c.x, c.y), l) ? Ny(s.quad) ? 0 : 2 : 0;
  }
  // Find the intersection of the stroke tangents to construct a stroke quad.
  // Return whether the stroke is a degenerate (a line), a quad, or must be split.
  // Optionally compute the quad's control point.
  intersectRay(e, n) {
    const s = this;
    let r = n.quad[0], a = n.quad[2], o = n.tangent_start.clone().sub(r), h = n.tangent_end.clone().sub(a), c = o.cross(h);
    if (c == 0 || !Number.isFinite(c))
      return n.opposite_tangents = o.dot(h) < 0, 1;
    n.opposite_tangents = !1;
    let l = r.clone().sub(a), u = h.cross(l), f = o.cross(l);
    if (u >= 0 == f >= 0) {
      let p = ba(r, a, n.tangent_end), y = ba(a, r, n.tangent_start);
      return Math.max(p, y) <= s.inv_res_scale_squared ? 1 : 0;
    }
    return u /= c, u > u - 1 ? (e == 0 && (n.quad[1].x = r.x * (1 - u) + n.tangent_start.x * u, n.quad[1].y = r.y * (1 - u) + n.tangent_start.y * u), 2) : (n.opposite_tangents = o.dot(h) < 0, 1);
  }
  addDegenerateLine(e) {
    const n = this;
    n.stroke_type == 1 ? n.outer.lineTo(e.quad[2].x, e.quad[2].y) : n.inner.lineTo(e.quad[2].x, e.quad[2].y);
  }
  setCubicEndNormal(e, n, s, r, a) {
    let o = this, h = e[1].clone().sub(e[0]), c = e[3].clone().sub(e[2]), l = Gi(h), u = Gi(c);
    if (l && u) {
      r.copy(n), a.copy(s);
      return;
    }
    if (l && (h = e[2].clone().sub(e[0]), l = Gi(h)), u && (c = e[3].clone().sub(e[1]), u = Gi(c)), l || u) {
      r.copy(n), a.copy(s);
      return;
    }
    return pE(c, o.radius, r, a);
  }
  lineTo(e, n) {
    const s = this;
    let r = s.prev_pt.equalsEpsilon(e, Ed * s.inv_res_scale);
    if (s.capper, s0 && r || r && (s.join_completed || n && n.hasValidTangent()))
      return;
    let a = N.default(), o = N.default();
    s.preJoinTo(e, !0, a, o) && (s.outer.lineTo(e.x + a.x, e.y + a.y), s.inner.lineTo(e.x - a.x, e.y - a.y), s.postJoinTo(e, a, o));
  }
  quadraticCurveTo(e, n) {
    const s = this;
    let r = [s.prev_pt, e, n], [a, o] = yE(r);
    if (o == 0) {
      s.lineTo(n);
      return;
    }
    if (o == 1) {
      s.lineTo(n);
      return;
    }
    if (o == 3) {
      s.lineTo(a);
      let p = s.joiner;
      s.joiner = r0, s.lineTo(n), s.joiner = p;
      return;
    }
    let h = N.default(), c = N.default(), l = N.default(), u = N.default();
    if (!s.preJoinTo(e, !1, h, c)) {
      s.lineTo(n);
      return;
    }
    let f = Jh.default();
    s.initQuad(
      1,
      0,
      1,
      f
    ), s.quadStroke(r, f), s.initQuad(
      -1,
      0,
      1,
      f
    ), s.quadStroke(r, f), Fy(
      r[1],
      r[2],
      s.res_scale,
      s.radius,
      l,
      u
    ) || (l = h, u = c), s.postJoinTo(n, l, u);
  }
  bezierCurveTo(e, n, s) {
    const r = this;
    let a = [r.prev_pt, e, n, s], o = Array.from({ length: 3 }, () => N.zero()), h = N.zero(), c = vE(a, o, h);
    if (c == 0) {
      r.lineTo(s);
      return;
    }
    if (c == 1) {
      r.lineTo(s);
      return;
    }
    if (3 <= c && 5 >= c) {
      r.lineTo(o[0]);
      let g = r.joiner;
      r.joiner = r0, 4 <= c && r.lineTo(o[1]), c == 5 && r.lineTo(o[2]), r.lineTo(s), r.joiner = g;
      return;
    }
    let l = N.zero(), u = N.zero(), f = N.zero(), d = N.zero();
    if (!r.preJoinTo(h, !1, l, u)) {
      r.lineTo(s);
      return;
    }
    let p = new Array(3).fill(0.5);
    p = Ym(a, p);
    let y = 0;
    for (let g = 0, m = p.length; g <= m; g++) {
      let v = Number.isFinite(p[g]) ? p[g] : 1, w = Jh.default();
      r.initQuad(1, y, v, w), r.cubicStroke(a, w), r.initQuad(-1, y, v, w), r.cubicStroke(a, w), y = v;
    }
    let x = jm(a);
    if (x) {
      let g = Ml(a, x);
      r.cusper.addCircle(g.x, g.y, r.radius);
    }
    r.setCubicEndNormal(a, l, u, f, d), r.postJoinTo(s, f, d);
  }
  cubicStroke(e, n) {
    const s = this;
    if (!s.found_tangents) {
      let a = s.tangentsMeet(e, n);
      if (a != 2) {
        let o = Du(
          n.quad[0],
          n.quad[2],
          s.inv_res_scale
        );
        if ((a == 1 || o) && s.cubicMidOnLine(e, n))
          return s.addDegenerateLine(n), !0;
      } else
        s.found_tangents = !0;
    }
    if (s.found_tangents) {
      let a = s.compareQuadCubic(e, n);
      if (a == 2) {
        let o = n.quad;
        return s.stroke_type == 1 ? s.outer.quadraticCurveTo(o[1].x, o[1].y, o[2].x, o[2].y) : s.inner.quadraticCurveTo(o[1].x, o[1].y, o[2].x, o[2].y), !0;
      }
      if (a == 1 && !n.opposite_tangents)
        return s.addDegenerateLine(n), !0;
    }
    if (!Number.isFinite(n.quad[2].x) || !Number.isFinite(n.quad[2].x) || (s.recursion_depth += 1, s.recursion_depth > By[Number(s.found_tangents)]))
      return !1;
    let r = Jh.default();
    return r.initWithStart(n) ? s.cubicStroke(e, r) ? r.initWithEnd(n) ? s.cubicStroke(e, r) ? (s.recursion_depth -= 1, !0) : !1 : (s.addDegenerateLine(n), s.recursion_depth -= 1, !0) : !1 : (s.addDegenerateLine(n), s.recursion_depth -= 1, !0);
  }
  cubicMidOnLine(e, n) {
    let s = this, r = N.zero();
    return s.cubicQuadMid(e, n, r), ba(r, n.quad[0], n.quad[2]) < s.inv_res_scale_squared;
  }
  cubicQuadMid(e, n, s) {
    let r = N.zero();
    this.cubicPerpRay(e, n.mid_t, r, s);
  }
  compareQuadCubic(e, n) {
    let s = this;
    s.cubicQuadEnds(e, n);
    let r = s.intersectRay(0, n);
    if (r != 2)
      return r;
    let a = N.zero(), o = N.zero();
    return s.cubicPerpRay(e, n.mid_t, o, a), s.strokeCloseEnough(n.quad.slice(), [a, o], n);
  }
  // Given a cubic and a t range, find the start and end if they haven't been found already.
  cubicQuadEnds(e, n) {
    const s = this;
    if (!n.start_set) {
      let r = N.zero();
      s.cubicPerpRay(
        e,
        n.start_t,
        r,
        n.quad[0],
        n.tangent_start
      ), n.start_set = !0;
    }
    if (!n.end_set) {
      let r = N.zero();
      s.cubicPerpRay(
        e,
        n.end_t,
        r,
        n.quad[2],
        n.tangent_end
      ), n.end_set = !0;
    }
  }
  tangentsMeet(e, n) {
    return this.cubicQuadEnds(e, n), this.intersectRay(1, n);
  }
  // Given a cubic and t, return the point on curve,
  // its perpendicular, and the perpendicular tangent.
  cubicPerpRay(e, n, s, r, a) {
    let o = this;
    s.copy(Ml(e, n));
    let h = Um(e, n), c = Array.from({ length: 7 }, () => N.zero());
    if (h.x == 0 && h.y == 0) {
      let l = e;
      ky(n) ? h = e[2].clone().sub(e[0]) : ky(1 - n) ? h = e[3].clone().sub(e[1]) : (_d(e, n, c), h = c[3].clone().sub(c[2]), h.x == 0 && h.y == 0 && (h = c[3].clone().sub(c[1]), l = c)), h.x == 0 && h.y == 0 && (h = l[3].clone().sub(l[0]));
    }
    o.setRayPoints(s, h, r, a);
  }
  stroke(e, n) {
    return this.strokeInner(e, n.strokeWidth, n.miterLimit, n.lineCap, n.lineJoin, this.res_scale);
  }
  strokeInner(e, n, s, r, a, o) {
    const h = this;
    let c = 0;
    a == "miter" && (s <= 1 ? a = "bevel" : c = 1 / s), a == "miter-clip" && (c = 1 / s), h.res_scale = o, h.inv_res_scale = 1 / (o * 4), h.inv_res_scale_squared = h.inv_res_scale ** 2, h.radius = n * 0.5, h.inv_miter_limit = c, h.first_normal = N.default(), h.prev_normal = N.default(), h.first_unit_normal = N.default(), h.prev_unit_normal = N.default(), h.first_pt = N.default(), h.prev_pt = N.default(), h.first_outer_pt = N.default(), h.first_outer_pt_index_in_contour = 0, h.segment_count = -1, h.prev_is_line = !1, h.capper = bE[r], h.joiner = ME[a], h.inner.clear(), h.outer.clear(), h.cusper.clear(), h.stroke_type = 1, h.recursion_depth = 0, h.found_tangents = !1, h.join_completed = !1;
    let l = !1, u = new Jl({
      path: e,
      verbIndex: 0,
      pointsIndex: 0,
      isAutoClose: !0
    });
    u.setAutoClose(!0);
    for (let f of u)
      switch (f.type) {
        case _e.MoveTo:
          h.moveTo(f.p0);
          break;
        case _e.LineTo:
          h.lineTo(f.p0, u), l = !0;
          break;
        case _e.QuadCurveTo:
          h.quadraticCurveTo(f.p1, f.p2), l = !1;
          break;
        case _e.CubicCurveTo:
          h.bezierCurveTo(f.p1, f.p2, f.p3), l = !1;
          break;
        case _e.Close:
          if (r != "butt") {
            if (h.hasOnlyMoveTo()) {
              h.lineTo(h.moveToPt), l = !0;
              continue;
            }
            if (h.isCurrentContourEmpty()) {
              l = !0;
              continue;
            }
          }
          h.close(l);
          break;
      }
    return h.finish(l);
  }
  finish(e) {
    return this.finishContour(!1, e), this.outer.clone();
  }
  hasOnlyMoveTo() {
    return this.segment_count == 0;
  }
  isCurrentContourEmpty() {
    return this.inner.isZeroLengthSincePoint(0) && this.outer.isZeroLengthSincePoint(this.first_outer_pt_index_in_contour);
  }
}
const ls = {
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7,
  Z: 0
}, TE = new Set(Object.keys(ls).concat(Object.keys(ls).map((i) => i.toLowerCase()))), EE = /([mlhvaqtcsz])([^mlhvaqtcsz]+)?/gi, zE = /-?\d*\.?\d+(e[-+]?\d+)?/gi;
function zd(i, e, n) {
  return i >= e && i <= n;
}
function Km(i) {
  return zd(i.charCodeAt(0), 1, 32);
}
function jc(i) {
  return zd(i.charCodeAt(0), 48, 57);
}
function tv(i) {
  return Km(i) || i === ",";
}
function CE(i) {
  return zd(i.charCodeAt(0), 97, 122);
}
function AE(i) {
  return String.fromCharCode(i.charCodeAt(0) - 97 + 65);
}
function Cd(i) {
  let e = 0;
  for (; i.length > 0 && Km(i[e]); )
    e++;
  return i.slice(e);
}
function _l(i) {
  let e = 0;
  for (; i.length > 0 && tv(i[e]); )
    e++;
  return i.slice(e);
}
function PE(i, e) {
  i = Cd(i);
  let n = 0;
  for (n < i.length && (i[n] === "+" || i[n] === "-") && n++; n < i.length && jc(i[n]); )
    n++;
  if (n < i.length && i[n] === ".")
    for (n++; n < i.length && jc(i[n]); )
      n++;
  if (n < i.length && (i[n] === "e" || i[n] === "E"))
    for (n++, n < i.length && (i[n] === "+" || i[n] === "-") && n++; n < i.length && jc(i[n]); )
      n++;
  return n == 0 ? (e.value = i, 0) : (e.value = i.substring(n), Number(i.substring(0, n)));
}
function ev(i, e) {
  i = Cd(i);
  let n = { value: "" }, s = PE(i, n);
  return i == n.value ? "" : (e && (e.value = s), n.value);
}
function Dy(i, e, n, s) {
  return i = ev(i, e), i ? (n && (e.value += s), i = _l(i), i) : "";
}
function IE(i, e, n) {
  if (n > 0) {
    let s = 0, r = { value: 0 };
    for (; i = ev(i, r), e[s] = r.value, !(--n == 0 || i.length <= 0); )
      i = _l(i), s++;
  }
  return i;
}
function zs(i, e, n, s, r) {
  if (i = IE(i, e, n), s)
    for (let a = 0; a < n; a += 2)
      e[a] += r.x, e[a + 1] += r.y;
  return i;
}
function nv(i, e) {
  let n = 0, s = 0, r = 0, a = 0, o = 0, h = 0, c = 0, l = 0, u = "";
  for (let f = 0, d = e.length; f < d; f++) {
    const p = e[f];
    switch (p[0]) {
      case "M":
        i.moveTo(p[1], p[2]), n = p[1], s = p[2], r = n, a = s;
        break;
      case "L":
        i.lineTo(p[1], p[2]), n = p[1], s = p[2];
        break;
      case "H":
        i.lineTo(p[1], s), n = p[1];
        break;
      case "V":
        i.lineTo(n, p[1]), s = p[1];
        break;
      case "Q":
        i.quadraticCurveTo(p[1], p[2], p[3], p[4]), o = p[1], h = p[2], n = p[3], s = p[4];
        break;
      case "T":
        c = n, l = s, (u === "Q" || u === "T") && (c -= o - n, l -= h - s), i.quadraticCurveTo(c, l, p[1], p[2]), o = c, h = l, n = p[1], s = p[2];
        break;
      case "C":
        i.bezierCurveTo(p[1], p[2], p[3], p[4], p[5], p[6]), o = p[3], h = p[4], n = p[5], s = p[6];
        break;
      case "S":
        c = n, l = s, (u === "C" || u === "S") && (c -= o - n, l -= h - s), i.bezierCurveTo(c, l, p[1], p[2], p[3], p[4]), o = p[1], h = p[2], n = p[3], s = p[4];
        break;
      case "A":
        {
          let y = n, x = s, g = p[1], m = p[2], v = p[3], w = !!p[4], b = !!p[5], S = p[6], E = p[7], A = S, M = E;
          Xl(y, x, S, E, g, m, v, w, b, (_, T, C, P, R, k, I, L, F) => {
            i.bezierCurveTo(C, P, R, k, I, L), A = I, M = L;
          }), n = A, s = M;
        }
        break;
      case "Z":
        i.closePath(), n = r, s = a;
        break;
    }
    u = p[0];
  }
}
function RE(i, e) {
  const n = sv(e);
  nv(i, n);
}
function OE(i) {
  const e = i.match(zE);
  return e ? e.map(Number) : [];
}
function iv(i) {
  const e = [], n = String(i).trim();
  return n[0] !== "M" && n[0] !== "m" || n.replace(EE, (s, r, a) => {
    const o = OE(a);
    let h = r.toUpperCase(), c = r;
    if (h === "M" && o.length > 2 && (e.push([c, ...o.splice(0, 2)]), c = c === "m" ? "l" : "L"), o.length < ls[h])
      return "";
    for (e.push([c, ...o.splice(0, ls[h])]); o.length >= ls[h] && o.length && ls[h]; )
      e.push([c, ...o.splice(0, ls[h])]);
    return "";
  }), e;
}
function a0(i, e) {
  let n = { x: 0, y: 0 }, s = { x: 0, y: 0 }, r = { x: 0, y: 0 }, a = new Float32Array(7), o = { value: 0 }, h = "", c = "", l = !1;
  for (; e.length && (e = Cd(e), e[0] !== ""); ) {
    let u = e[0];
    if (jc(u) || u === "-" || u === "+" || u === ".") {
      if (h == "" || h == "Z")
        return !1;
    } else tv(u) || (h = u, l = !1, CE(u) && (l = !0, h = AE(u)), e = e.substring(1)), e = _l(e);
    switch (h) {
      case "M":
        e = zs(e, a, 2, l, s), i.moveTo(a[0], a[1]), c = "", h = "L", s.x = a[0], s.y = a[1];
        break;
      case "L":
        e = zs(e, a, 2, l, s), i.lineTo(a[0], a[1]), s.x = a[0], s.y = a[1];
        break;
      case "H":
        e = Dy(e, o, l, s.x), i.lineTo(o.value, s.y), s.x = o.value;
        break;
      case "V":
        e = Dy(e, o, l, s.y), i.lineTo(s.x, o.value), s.y = o.value;
        break;
      case "C":
        e = zs(e, a, 6, l, s), i.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]), r.x = a[2], r.y = a[3], s.x = a[4], s.y = a[5];
        break;
      case "S":
        e = zs(e, a.subarray(2), 4, l, s), a[0] = s.x, a[1] = s.y, (c == "C" || c == "S") && (a[0] -= r.x - s.x, a[1] -= r.y - s.y), i.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]), r.x = a[2], r.y = a[3], s.x = a[4], s.y = a[5];
        break;
      case "Q":
        e = zs(e, a, 4, l, s), i.quadraticCurveTo(a[0], a[1], a[2], a[3]), r.x = a[0], r.y = a[1], s.x = a[2], s.y = a[3];
        break;
      case "T":
        e = zs(e, a.subarray(1), 2, l, s), a[0] = s.x, a[1] = s.y, (c == "Q" || c == "T") && (a[0] -= r.x - s.x, a[1] -= r.y - s.y), i.quadraticCurveTo(a[0], a[1], a[2], a[3]), r.x = a[0], r.y = a[1], s.x = a[2], s.y = a[3];
        break;
      case "A":
        e = zs(e, a, 7, !1);
        let f = s.x, d = s.y, p = a[0], y = a[1], x = a[2], g = !!a[3], m = !!a[4], v = a[5], w = a[6];
        v = l ? v + s.x : v, w = l ? w + s.y : w, Xl(f, d, v, w, p, y, x, g, m, (b, S, E, A, M, _, T, C, P) => {
          i.bezierCurveTo(E, A, M, _, T, C), s.x = T, s.y = C;
        });
        break;
      case "Z":
        i.closePath(), s.x = n.x, s.y = n.y;
        break;
      default:
        return !1;
    }
    c == "" && (n.x = s.x, n.y = s.y), c = h;
  }
  return !0;
}
function sv(i) {
  const e = [];
  let n = iv(i), s = 0, r = 0, a = 0, o = 0, h = 0, c = 0, l = 0, u = 0;
  for (let f = 0, d = n.length; f < d; f++) {
    const p = n[f];
    let y = p[0].toUpperCase(), x = y !== p[0], g = p.slice(1);
    switch (y) {
      case "M":
        s = x ? s + g[0] : g[0], r = x ? r + g[1] : g[1], g[0] = s, g[1] = r, a = s, o = r;
        break;
      case "L":
        s = x ? s + g[0] : g[0], r = x ? r + g[1] : g[1], g[0] = s, g[1] = r;
        break;
      case "H":
        s = x ? s + g[0] : g[0], g[0] = s;
        break;
      case "V":
        r = x ? r + g[0] : g[0], g[0] = r;
        break;
      case "Q":
        h = x ? s + g[0] : g[0], c = x ? r + g[1] : g[1], s = x ? s + g[2] : g[2], r = x ? r + g[3] : g[3], g[0] = h, g[1] = c, g[2] = s, g[3] = r;
        break;
      case "T":
        s = x ? s + g[0] : g[0], r = x ? r + g[1] : g[1], g[0] = s, g[1] = r;
        break;
      case "C":
        h = x ? s + g[0] : g[0], c = x ? r + g[1] : g[1], l = x ? s + g[2] : g[2], u = x ? r + g[3] : g[3], s = x ? s + g[4] : g[4], r = x ? r + g[5] : g[5], g[0] = h, g[1] = c, g[2] = l, g[3] = u, g[4] = s, g[5] = r;
        break;
      case "S":
        l = x ? s + g[0] : g[0], u = x ? r + g[1] : g[1], s = x ? s + g[2] : g[2], r = x ? r + g[3] : g[3], g[0] = l, g[1] = u, g[2] = s, g[3] = r;
        break;
      case "A":
        let m = g[0], v = g[1], w = g[2], b = g[3], S = g[4];
        s = x ? s + g[5] : g[5], r = x ? r + g[6] : g[6], g[0] = m, g[1] = v, g[2] = w, g[3] = b, g[4] = S, g[5] = s, g[6] = r;
        break;
      case "Z":
        s = a, r = o;
        break;
    }
    e.push([y].concat(g));
  }
  return e;
}
class Ad {
  commands = [];
  dirty = !1;
  _cb = null;
  constructor(e) {
    typeof e == "string" ? a0(this, e) : e instanceof Ad && (this.commands = [...e.commands]);
  }
  fromSvgPath(e) {
    a0(this, e);
  }
  onChange(e) {
    this._cb = e;
  }
  equals(e) {
    if (this.commands.length !== e.commands.length) return !1;
    for (let n = 0; n < this.commands.length; n++) {
      const s = this.commands[n], r = e.commands[n];
      if (s[0] !== r[0]) return !1;
      for (let a = 1; a < s.length; a++)
        if (s[a] !== r[a]) return !1;
    }
    return !0;
  }
  reset() {
    this.commands.length = 0, this.dirty = !0, this._cb?.();
  }
  clone() {
    return new this.constructor(this);
  }
  addCmd(e, n) {
    this.commands.push([e].concat(n)), this.dirty = !0, this._cb?.();
  }
  addPath(e, n) {
    this.commands = e.commands.slice();
  }
  arc(e, n, s, r, a, o = !1) {
    this.addCmd("AC", [e, n, s, r, a, o]);
  }
  arcTo(e, n, s, r, a) {
    this.addCmd("AT", [e, n, s, r, a]);
  }
  bezierCurveTo(e, n, s, r, a, o) {
    this.addCmd("C", [e, n, s, r, a, o]);
  }
  closePath() {
    this.commands.length > 0 && this.commands[this.commands.length - 1][0] !== "Z" && this.addCmd("Z", []);
  }
  ellipse(e, n, s, r, a, o, h, c = !1) {
    this.addCmd("E", [e, n, s, r, a, o, h, c]);
  }
  lineTo(e, n) {
    this.addCmd("L", [e, n]);
  }
  moveTo(e, n) {
    this.addCmd("M", [e, n]);
  }
  quadraticCurveTo(e, n, s, r) {
    this.addCmd("Q", [e, n, s, r]);
  }
  rect(e, n, s, r) {
    this.addCmd("R", [e, n, s, r]);
  }
  roundRect(e, n, s, r, a) {
    this.addCmd("RR", [e, n, s, r, a]);
  }
  toPath2D(e = new Path2D()) {
    return this.toCanvas(e);
  }
  toCanvas(e) {
    for (const n of this.commands)
      switch (n[0]) {
        case "M":
          e.moveTo(n[1], n[2]);
          break;
        case "L":
          e.lineTo(n[1], n[2]);
          break;
        case "Q":
          e.quadraticCurveTo(n[1], n[2], n[3], n[4]);
          break;
        case "C":
          e.bezierCurveTo(n[1], n[2], n[3], n[4], n[5], n[6]);
          break;
        case "AC":
          e.arc(n[1], n[2], n[3], n[4], n[5], n[6]);
          break;
        case "E":
          e.ellipse(n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8]);
          break;
        case "AT":
          e.arcTo(n[1], n[2], n[3], n[4], n[5]);
          break;
        case "RR":
          e.roundRect(n[1], n[2], n[3], n[4], n[5]);
          break;
        case "R":
          e.rect(n[1], n[2], n[3], n[4]);
          break;
        case "Z":
          e.closePath();
          break;
      }
    return e;
  }
}
const kE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AutoConicToQuads: aE,
  Command: ls,
  CommandSet: TE,
  Conic: Qn,
  CubicCoeff: qm,
  FillRule: Zm,
  LineCap: Xm,
  LineJoin: Hm,
  PathBuilder: mr,
  PathDirection: wl,
  PathIterVerb: Bm,
  PathSegmentsIter: Jl,
  PathStroker: SE,
  PathVerb: _e,
  ProxyPath2D: Ad,
  QuadCoeff: bd,
  SCALAR_MAX: HT,
  SCALAR_NEARLY_ZERO: wd,
  SCALAR_ROOT_2_OVER_2: Md,
  SegmentMask: Dm,
  build_unit_arc: sE,
  chop_cubic_at: oE,
  chop_cubic_at2: _d,
  chop_quad_at: ZT,
  eval_cubic_pos_at: Ml,
  eval_cubic_tangent_at: Um,
  eval_quad_at: Ro,
  eval_quad_tangent_at: Gm,
  find_cubic_cusp: jm,
  find_cubic_extrema: nE,
  find_cubic_inflections: Ym,
  find_cubic_max_curvature: Sd,
  find_quad_extrema: JT,
  find_quad_max_curvature: Vm,
  find_unit_quad_roots: Eh,
  new_t_values: $m,
  parseSvgPath: sv,
  parseSvgPathData: iv,
  pathFromSvgPath: a0,
  pathFromSvgPath2: RE,
  pathFromSvgPathCommand: nv
}, Symbol.toStringTag, { value: "Module" })), qy = Math.PI * 2;
function Qh(i) {
  return i %= qy, i < 0 && (i += qy), i;
}
const Ha = Math.PI * 2;
function rv(i, e, n, s, r, a, o, h, c) {
  if (o === 0)
    return !1;
  const l = o;
  h -= i, c -= e;
  const u = Math.sqrt(h * h + c * c);
  if (u - l > n || u + l < n)
    return !1;
  if (Math.abs(s - r) % Ha < 1e-4)
    return !0;
  if (a) {
    const d = s;
    s = Qh(r), r = Qh(d);
  } else
    s = Qh(s), r = Qh(r);
  s > r && (r += Ha);
  let f = Math.atan2(c, h);
  return f < 0 && (f += Ha), f >= s && f <= r || f + Ha >= s && f + Ha <= r;
}
const LE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: rv
}, Symbol.toStringTag, { value: "Module" }));
function av(i, e, n, s, r, a, o, h, c, l, u) {
  if (c === 0)
    return !1;
  const f = c;
  return u > e + f && u > s + f && u > a + f && u > h + f || u < e - f && u < s - f && u < a - f && u < h - f || l > i + f && l > n + f && l > r + f && l > o + f || l < i - f && l < n - f && l < r - f && l < o - f ? !1 : um(
    i,
    e,
    n,
    s,
    r,
    a,
    o,
    h,
    l,
    u,
    null
  ) <= f / 2;
}
const FE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: av
}, Symbol.toStringTag, { value: "Module" }));
function Js(i, e, n, s, r, a, o) {
  if (r === 0)
    return !1;
  const h = r;
  let c = 0, l = i;
  if (o > e + h && o > s + h || o < e - h && o < s - h || a > i + h && a > n + h || a < i - h && a < n - h)
    return !1;
  if (i !== n)
    c = (e - s) / (i - n), l = (i * s - n * e) / (i - n);
  else
    return Math.abs(a - i) <= h / 2;
  const u = c * a - o + l;
  return u * u / (c * c + 1) <= h / 2 * h / 2;
}
const NE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: Js
}, Symbol.toStringTag, { value: "Module" }));
function ov(i, e, n, s, r, a, o, h, c) {
  if (o === 0)
    return !1;
  const l = o;
  return c > e + l && c > s + l && c > a + l || c < e - l && c < s - l && c < a - l || h > i + l && h > n + l && h > r + l || h < i - l && h < n - l && h < r - l ? !1 : lm(
    i,
    e,
    n,
    s,
    r,
    a,
    h,
    c,
    null
  ) <= l / 2;
}
const BE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  containStroke: ov
}, Symbol.toStringTag, { value: "Module" }));
function Di(i, e, n, s, r, a) {
  if (a > e && a > s || a < e && a < s || s === e)
    return 0;
  const o = (a - e) / (s - e);
  let h = s < e ? 1 : -1;
  (o === 1 || o === 0) && (h = s < e ? 0.5 : -0.5);
  const c = o * (n - i) + i;
  return c === r ? 1 / 0 : c > r ? h : 0;
}
const DE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Di
}, Symbol.toStringTag, { value: "Module" })), Cs = {
  M: "M",
  L: "L",
  C: "C",
  Q: "Q",
  Z: "Z",
  R: "R",
  E: "E"
}, As = Math.PI * 2, qE = 1e-4;
function $E(i, e) {
  return Math.abs(i - e) < qE;
}
const Ze = [-1, -1, -1], In = [-1, -1];
function VE() {
  const i = In[0];
  In[0] = In[1], In[1] = i;
}
function hv(i, e, n, s, r, a, o, h, c, l) {
  if (l > e && l > s && l > a && l > h || l < e && l < s && l < a && l < h)
    return 0;
  const u = fd(e, s, a, h, l, Ze);
  if (u === 0)
    return 0;
  {
    let f = 0, d = -1, p = 0, y = 0;
    for (let x = 0; x < u; x++) {
      let g = Ze[x], m = g === 0 || g === 1 ? 0.5 : 1;
      Ve(i, n, r, o, g) < c || (d < 0 && (d = dd(e, s, a, h, In), In[1] < In[0] && d > 1 && VE(), p = Ve(e, s, a, h, In[0]), d > 1 && (y = Ve(e, s, a, h, In[1]))), d === 2 ? g < In[0] ? f += p < e ? m : -m : g < In[1] ? f += y < p ? m : -m : f += h < y ? m : -m : g < In[0] ? f += p < e ? m : -m : f += h < p ? m : -m);
    }
    return f;
  }
}
function cv(i, e, n, s, r, a, o, h) {
  if (h > e && h > s && h > a || h < e && h < s && h < a)
    return 0;
  const c = xm(e, s, a, h, Ze);
  if (c === 0)
    return 0;
  {
    const l = pd(e, s, a);
    if (l >= 0 && l <= 1) {
      let u = 0, f = Xe(e, s, a, l);
      for (let d = 0; d < c; d++) {
        let p = Ze[d] === 0 || Ze[d] === 1 ? 0.5 : 1;
        Xe(i, n, r, Ze[d]) < o || (Ze[d] < l ? u += f < e ? p : -p : u += a < f ? p : -p);
      }
      return u;
    } else {
      const u = Ze[0] === 0 || Ze[0] === 1 ? 0.5 : 1;
      return Xe(i, n, r, Ze[0]) < o ? 0 : a < e ? u : -u;
    }
  }
}
function lv(i, e, n, s, r, a, o, h) {
  if (h -= e, h > n || h < -n)
    return 0;
  const c = Math.sqrt(n * n - h * h);
  Ze[0] = -c, Ze[1] = c;
  const l = Math.abs(s - r);
  if (l < 1e-4)
    return 0;
  if (l >= As - 1e-4) {
    s = 0, r = As;
    const f = a ? 1 : -1;
    return o >= Ze[0] + i && o <= Ze[1] + i ? f : 0;
  }
  if (s > r) {
    const f = s;
    s = r, r = f;
  }
  s < 0 && (s += As, r += As);
  let u = 0;
  for (let f = 0; f < 2; f++) {
    const d = Ze[f];
    if (d + i > o) {
      let p = Math.atan2(h, d), y = a ? 1 : -1;
      p < 0 && (p = As + p), (p >= s && p <= r || p + As >= s && p + As <= r) && (p > Math.PI / 2 && p < Math.PI * 1.5 && (y = -y), u += y);
    }
  }
  return u;
}
function uv(i, e, n, s, r) {
  const a = i.commands, o = i.commands.length;
  let h = 0, c = 0, l = 0, u = 0, f = 0, d, p;
  for (let y = 0; y < o; ) {
    let x = 0, g = a[y];
    const m = g[x++];
    switch (c = g[x], l = g[x + 1], u = c, f = l, m) {
      case Cs.M:
        u = g[x++], f = g[x++], c = u, l = f;
        break;
      case Cs.L:
        if (n) {
          if (Js(c, l, g[x], g[x + 1], e, s, r))
            return !0;
        } else
          h += Di(c, l, g[x], g[x + 1], s, r) || 0;
        c = g[x++], l = g[x++];
        break;
      case Cs.C:
        if (n) {
          if (av(
            c,
            l,
            g[x++],
            g[x++],
            g[x++],
            g[x++],
            g[x],
            g[x + 1],
            e,
            s,
            r
          ))
            return !0;
        } else
          h += hv(
            c,
            l,
            g[x++],
            g[x++],
            g[x++],
            g[x++],
            g[x],
            g[x + 1],
            s,
            r
          ) || 0;
        c = g[x++], l = g[x++];
        break;
      case Cs.Q:
        if (n) {
          if (ov(
            c,
            l,
            g[x++],
            g[x++],
            g[x],
            g[x + 1],
            e,
            s,
            r
          ))
            return !0;
        } else
          h += cv(
            c,
            l,
            g[x++],
            g[x++],
            g[x],
            g[x + 1],
            s,
            r
          ) || 0;
        c = g[x++], l = g[x++];
        break;
      case Cs.E:
        const v = g[x++], w = g[x++], b = g[x++], S = g[x++], E = g[x++], A = g[x++];
        x += 1;
        const M = !!(1 - g[x++]);
        d = Math.cos(E) * b + v, p = Math.sin(E) * S + w, u = d, f = p;
        const _ = (s - v) * S / b + v;
        if (n) {
          if (rv(
            v,
            w,
            S,
            E,
            E + A,
            M,
            e,
            _,
            r
          ))
            return !0;
        } else
          h += lv(
            v,
            w,
            S,
            E,
            E + A,
            M,
            _,
            r
          );
        c = Math.cos(E + A) * b + v, l = Math.sin(E + A) * S + w;
        break;
      case Cs.R:
        u = c = g[x++], f = l = g[x++];
        const T = g[x++], C = g[x++];
        if (d = u + T, p = f + C, n) {
          if (Js(u, f, d, f, e, s, r) || Js(d, f, d, p, e, s, r) || Js(d, p, u, p, e, s, r) || Js(u, p, u, f, e, s, r))
            return !0;
        } else
          h += Di(d, f, d, p, s, r), h += Di(u, p, u, f, s, r);
        break;
      case Cs.Z:
        if (n) {
          if (Js(
            c,
            l,
            u,
            f,
            e,
            s,
            r
          ))
            return !0;
        } else
          h += Di(c, l, u, f, s, r);
        c = u, l = f;
        break;
    }
  }
  return !n && !$E(l, f) && (h += Di(c, l, u, f, s, r) || 0), h !== 0;
}
function GE(i, e, n) {
  return uv(i, 0, !1, e, n);
}
function UE(i, e, n, s) {
  return uv(i, e, !0, n, s);
}
const WE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contain: GE,
  containStroke: UE,
  windingArc: lv,
  windingCubic: hv,
  windingLine: Di,
  windingQuadratic: cv
}, Symbol.toStringTag, { value: "Module" })), YE = 1e-8;
function $y(i, e) {
  return Math.abs(i - e) < YE;
}
function jE(i, e, n) {
  let s = 0, r = i[0];
  if (!r)
    return !1;
  for (let o = 1; o < i.length; o++) {
    const h = i[o];
    s += Di(r[0], r[1], h[0], h[1], e, n), r = h;
  }
  const a = i[0];
  return (!$y(r[0], a[0]) || !$y(r[1], a[1])) && (s += Di(r[0], r[1], a[0], a[1], e, n)), s !== 0;
}
const HE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contain: jE
}, Symbol.toStringTag, { value: "Module" })), or = Math.min, fa = Math.max, o0 = Math.abs, Vy = ["x", "y"], XE = ["width", "height"], Ps = new Ue(), Is = new Ue(), Rs = new Ue(), Os = new Ue(), vn = fv(), lo = vn.minTv, h0 = vn.maxTv, Oo = [0, 0];
class Ce {
  x = 0;
  y = 0;
  width = 0;
  height = 0;
  constructor(e, n, s, r) {
    Ce.set(this, e, n, s, r);
  }
  static set(e, n, s, r, a) {
    return r < 0 && (n = n + r, r = -r), a < 0 && (s = s + a, a = -a), e.x = n, e.y = s, e.width = r, e.height = a, e;
  }
  union(e) {
    const n = or(e.x, this.x), s = or(e.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = fa(
      e.x + e.width,
      this.x + this.width
    ) - n : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = fa(
      e.y + e.height,
      this.y + this.height
    ) - s : this.height = e.height, this.x = n, this.y = s;
  }
  applyTransform(e) {
    Ce.applyTransform(this, this, e);
  }
  calculateTransform(e) {
    const n = this, s = e.width / n.width, r = e.height / n.height, a = Pe.default();
    return Pe.translate(a, a, [-n.x, -n.y]), Pe.scale(a, a, [s, r]), Pe.translate(a, a, [e.x, e.y]), a;
  }
  /**
   * @see `static intersect`
   */
  intersect(e, n, s) {
    return Ce.intersect(this, e, n, s);
  }
  /**
   * [NOTICE]
   *  Touching the edge is considered an intersection.
   *  zero-width/height can still cause intersection if `touchThreshold` is 0.
   *  See more in `BoundingRectIntersectOpt['touchThreshold']`
   *
   * @param mtv
   *  If it's not overlapped. it means needs to move `b` rect with Maximum Translation Vector to be overlapped.
   *  Else it means needs to move `b` rect with Minimum Translation Vector to be not overlapped.
   */
  static intersect(e, n, s, r) {
    s && Ue.set(s, 0, 0);
    const a = r && r.outIntersectRect || null, o = r && r.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !e || !n)
      return !1;
    e instanceof Ce || (e = Ce.set(ZE, e.x, e.y, e.width, e.height)), n instanceof Ce || (n = Ce.set(JE, n.x, n.y, n.width, n.height));
    const h = !!s;
    vn.reset(r, h);
    const c = vn.touchThreshold, l = e.x + c, u = e.x + e.width - c, f = e.y + c, d = e.y + e.height - c, p = n.x + c, y = n.x + n.width - c, x = n.y + c, g = n.y + n.height - c;
    if (l > u || f > d || p > y || x > g)
      return !1;
    const m = !(u < p || y < l || d < x || g < f);
    return (h || a) && (Oo[0] = 1 / 0, Oo[1] = 0, Gy(l, u, p, y, 0, h, a, o), Gy(f, d, x, g, 1, h, a, o), h && Ue.copy(
      s,
      m ? vn.useDir ? vn.dirMinTv : lo : h0
    )), m;
  }
  static contain(e, n, s) {
    return n >= e.x && n <= e.x + e.width && s >= e.y && s <= e.y + e.height;
  }
  contain(e, n) {
    return Ce.contain(this, e, n);
  }
  clone() {
    return new Ce(this.x, this.y, this.width, this.height);
  }
  /**
   * Copy from another rect
   */
  copy(e) {
    Ce.copy(this, e);
  }
  plain() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
  /**
   * If not having NaN or Infinity with attributes
   */
  isFinite() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }
  isZero() {
    return this.width === 0 || this.height === 0;
  }
  static create(e) {
    return new Ce(e.x, e.y, e.width, e.height);
  }
  static copy(e, n) {
    return e.x = n.x, e.y = n.y, e.width = n.width, e.height = n.height, e;
  }
  static applyTransform(e, n, s) {
    if (!s) {
      e !== n && Ce.copy(e, n);
      return;
    }
    if (s[1] < 1e-5 && s[1] > -1e-5 && s[2] < 1e-5 && s[2] > -1e-5) {
      const o = s[0], h = s[3], c = s[4], l = s[5];
      e.x = n.x * o + c, e.y = n.y * h + l, e.width = n.width * o, e.height = n.height * h, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
      return;
    }
    Ps.x = Rs.x = n.x, Ps.y = Os.y = n.y, Is.x = Os.x = n.x + n.width, Is.y = Rs.y = n.y + n.height, Ps.transform(s), Os.transform(s), Is.transform(s), Rs.transform(s), e.x = or(Ps.x, Is.x, Rs.x, Os.x), e.y = or(Ps.y, Is.y, Rs.y, Os.y);
    const r = fa(Ps.x, Is.x, Rs.x, Os.x), a = fa(Ps.y, Is.y, Rs.y, Os.y);
    e.width = r - e.x, e.height = a - e.y;
  }
}
const ZE = new Ce(0, 0, 0, 0), JE = new Ce(0, 0, 0, 0);
function Gy(i, e, n, s, r, a, o, h) {
  const c = o0(e - n), l = o0(s - i), u = or(c, l), f = Vy[r], d = Vy[1 - r], p = XE[r];
  e < n || s < i ? c < l ? (a && (h0[f] = -c), h && (o[f] = e, o[p] = 0)) : (a && (h0[f] = l), h && (o[f] = i, o[p] = 0)) : (o && (o[f] = fa(i, n), o[p] = or(e, s) - o[f]), a && (u < Oo[0] || vn.useDir) && (Oo[0] = or(u, Oo[0]), (c < l || !vn.bidirectional) && (lo[f] = c, lo[d] = 0, vn.useDir && vn.calcDirMTV()), (c >= l || !vn.bidirectional) && (lo[f] = -l, lo[d] = 0, vn.useDir && vn.calcDirMTV())));
}
function fv() {
  let i = 0;
  const e = new Ue(), n = new Ue(), s = {
    minTv: new Ue(),
    maxTv: new Ue(),
    useDir: !1,
    dirMinTv: new Ue(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset(a, o) {
      s.touchThreshold = 0, a && a.touchThreshold != null && (s.touchThreshold = fa(0, a.touchThreshold)), s.negativeSize = !1, o && (s.minTv.set(1 / 0, 1 / 0), s.maxTv.set(0, 0), s.useDir = !1, a && a.direction != null && (s.useDir = !0, s.dirMinTv.copy(s.minTv), n.copy(s.minTv), i = a.direction, s.bidirectional = a.bidirectional == null || !!a.bidirectional, s.bidirectional || e.set(Math.cos(i), Math.sin(i))));
    },
    calcDirMTV() {
      const a = s.minTv, o = s.dirMinTv, h = a.y * a.y + a.x * a.x, c = Math.sin(i), l = Math.cos(i), u = c * a.y + l * a.x;
      if (r(u)) {
        r(a.x) && r(a.y) && o.set(0, 0);
        return;
      }
      if (n.x = h * l / u, n.y = h * c / u, r(n.x) && r(n.y)) {
        o.set(0, 0);
        return;
      }
      (s.bidirectional || e.dot(n) > 0) && n.len() < o.len() && o.copy(n);
    }
  };
  function r(a) {
    return o0(a) < 1e-10;
  }
  return s;
}
class Pd {
  value;
  key;
  next;
  prev;
  constructor(e) {
    this.value = e;
  }
}
let dv = class {
  head;
  tail;
  _len = 0;
  /**
   * Insert a new value at the tail
   */
  insert(e) {
    const n = new Pd(e);
    return this.insertEntry(n), n;
  }
  /**
   * Insert an entry at the tail
   */
  insertEntry(e) {
    this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
  }
  /**
   * Remove entry.
   */
  remove(e) {
    const n = e.prev, s = e.next;
    n ? n.next = s : this.head = s, s ? s.prev = n : this.tail = n, e.next = e.prev = null, this._len--;
  }
  /**
   * Get length
   */
  len() {
    return this._len;
  }
  /**
   * Clear list
   */
  clear() {
    this.head = this.tail = null, this._len = 0;
  }
};
class Uy {
  _list = new dv();
  _maxSize = 10;
  _lastRemovedEntry;
  _map = {};
  constructor(e) {
    this._maxSize = e;
  }
  /**
   * @return Removed value
   */
  put(e, n) {
    const s = this._list, r = this._map;
    let a = null;
    if (r[e] == null) {
      const o = s.len();
      let h = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        const c = s.head;
        s.remove(c), delete r[c.key], a = c.value, this._lastRemovedEntry = c;
      }
      h ? h.value = n : h = new Pd(n), h.key = e, s.insertEntry(h), r[e] = h;
    }
    return a;
  }
  get(e) {
    const n = this._map[e], s = this._list;
    if (n != null)
      return n !== s.tail && (s.remove(n), s.insertEntry(n)), n.value;
  }
  /**
   * Clear the cache
   */
  clear() {
    this._list.clear(), this._map = {};
  }
  len() {
    return this._list.len();
  }
}
function QE(i, e) {
  return Id(Ql(e), i);
}
function Ql(i) {
  Kh || (Kh = new Uy(100)), i = i || xl;
  let e = Kh.get(i);
  return e || (e = {
    font: i,
    strWidthCache: new Uy(500),
    asciiWidthMap: null,
    // Init lazily for performance.
    asciiWidthMapTried: !1,
    // FIXME
    // Other languages?
    // FIXME
    // Consider proportional font?
    stWideCharWidth: Aa.measureText("国", i).width,
    asciiCharWidth: Aa.measureText("a", i).width
  }, Kh.put(i, e)), e;
}
let Kh;
function KE(i) {
  if (qu >= Wy)
    return;
  i = i || xl;
  const e = [], n = +/* @__PURE__ */ new Date();
  for (let r = 0; r <= 127; r++)
    e[r] = Aa.measureText(String.fromCharCode(r), i).width;
  const s = +/* @__PURE__ */ new Date() - n;
  return s > 16 ? qu = Wy : s > 2 && qu++, e;
}
let qu = 0;
const Wy = 5;
function tz(i, e) {
  return i.asciiWidthMapTried || (i.asciiWidthMap = KE(i.font), i.asciiWidthMapTried = !0), 0 <= e && e <= 127 ? i.asciiWidthMap != null ? i.asciiWidthMap[e] : i.asciiCharWidth : i.stWideCharWidth;
}
function Id(i, e) {
  const n = i.strWidthCache;
  let s = n.get(e);
  return s == null && (s = Aa.measureText(e, i.font).width, n.put(e, s)), s;
}
function c0(i, e, n, s) {
  const r = Id(Ql(e), i), a = xv(e), o = pv(0, r, n), h = yv(0, a, s);
  return new Ce(o, h, r, a);
}
function ez(i, e, n, s) {
  const r = ((i || "") + "").split(`
`);
  if (r.length === 1)
    return c0(r[0], e, n, s);
  {
    const o = new Ce(0, 0, 0, 0);
    for (let h = 0; h < r.length; h++) {
      const c = c0(r[h], e, n, s);
      h === 0 ? o.copy(c) : o.union(c);
    }
    return o;
  }
}
function pv(i, e, n, s) {
  return n === "right" ? s ? i += e : i -= e : n === "center" && (s ? i += e / 2 : i -= e / 2), i;
}
function yv(i, e, n, s) {
  return n === "middle" ? s ? i += e / 2 : i -= e / 2 : n === "bottom" && (s ? i += e : i -= e), i;
}
function xv(i) {
  return Ql(i).stWideCharWidth;
}
function nz(i, e) {
  return Aa.measureText(i, e);
}
function l0(i, e) {
  return typeof i == "string" ? i.lastIndexOf("%") >= 0 ? parseFloat(i) / 100 * e : parseFloat(i) : i;
}
function iz(i, e, n) {
  const s = e.position || "inside", r = e.distance != null ? e.distance : 5, a = n.height, o = n.width, h = a / 2;
  let c = n.x, l = n.y, u = "left", f = "top";
  if (s instanceof Array)
    c += l0(s[0], n.width), l += l0(s[1], n.height), u = null, f = null;
  else
    switch (s) {
      case "left":
        c -= r, l += h, u = "right", f = "middle";
        break;
      case "right":
        c += r + o, l += h, f = "middle";
        break;
      case "top":
        c += o / 2, l -= r, u = "center", f = "bottom";
        break;
      case "bottom":
        c += o / 2, l += a + r, u = "center";
        break;
      case "inside":
        c += o / 2, l += h, u = "center", f = "middle";
        break;
      case "insideLeft":
        c += r, l += h, f = "middle";
        break;
      case "insideRight":
        c += o - r, l += h, u = "right", f = "middle";
        break;
      case "insideTop":
        c += o / 2, l += r, u = "center";
        break;
      case "insideBottom":
        c += o / 2, l += a - r, u = "center", f = "bottom";
        break;
      case "insideTopLeft":
        c += r, l += r;
        break;
      case "insideTopRight":
        c += o - r, l += r, u = "right";
        break;
      case "insideBottomLeft":
        c += r, l += a - r, f = "bottom";
        break;
      case "insideBottomRight":
        c += o - r, l += a - r, u = "right", f = "bottom";
        break;
    }
  return i = i || {}, i.x = c, i.y = l, i.align = u, i.verticalAlign = f, i;
}
const sz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  adjustTextX: pv,
  adjustTextY: yv,
  calculateTextPosition: iz,
  ensureFontMeasureInfo: Ql,
  getBoundingRect: ez,
  getLineHeight: xv,
  getWidth: QE,
  innerGetBoundingRect: c0,
  measureCharWidth: tz,
  measureText: nz,
  measureWidth: Id,
  parsePercent: l0
}, Symbol.toStringTag, { value: "Module" })), rz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arc: LE,
  cubic: FE,
  line: NE,
  path: WE,
  polygon: HE,
  quadratic: BE,
  text: sz,
  windingLine: DE
}, Symbol.toStringTag, { value: "Module" })), hn = Math.min, cn = Math.max, $u = Math.sin, Vu = Math.cos, ks = Math.PI * 2, tc = tt.create(), ec = tt.create(), nc = tt.create();
function az(i, e, n) {
  if (i.length === 0)
    return;
  let s = i[0], r = s[0], a = s[0], o = s[1], h = s[1];
  for (let c = 1; c < i.length; c++)
    s = i[c], r = hn(r, s[0]), a = cn(a, s[0]), o = hn(o, s[1]), h = cn(h, s[1]);
  e[0] = r, e[1] = o, n[0] = a, n[1] = h;
}
function u0(i, e, n, s, r, a) {
  r[0] = hn(i, n), r[1] = hn(e, s), a[0] = cn(i, n), a[1] = cn(e, s);
}
const Yy = [], jy = [];
function gv(i, e, n, s, r, a, o, h, c, l) {
  const u = dd, f = Ve;
  let d = u(i, n, r, o, Yy);
  c[0] = 1 / 0, c[1] = 1 / 0, l[0] = -1 / 0, l[1] = -1 / 0;
  for (let p = 0; p < d; p++) {
    const y = f(i, n, r, o, Yy[p]);
    c[0] = hn(y, c[0]), l[0] = cn(y, l[0]);
  }
  d = u(e, s, a, h, jy);
  for (let p = 0; p < d; p++) {
    const y = f(e, s, a, h, jy[p]);
    c[1] = hn(y, c[1]), l[1] = cn(y, l[1]);
  }
  c[0] = hn(i, c[0]), l[0] = cn(i, l[0]), c[0] = hn(o, c[0]), l[0] = cn(o, l[0]), c[1] = hn(e, c[1]), l[1] = cn(e, l[1]), c[1] = hn(h, c[1]), l[1] = cn(h, l[1]);
}
function mv(i, e, n, s, r, a, o, h) {
  const c = pd, l = Xe, u = cn(
    hn(c(i, n, r), 1),
    0
  ), f = cn(
    hn(c(e, s, a), 1),
    0
  ), d = l(i, n, r, u), p = l(e, s, a, f);
  o[0] = hn(i, r, d), o[1] = hn(e, a, p), h[0] = cn(i, r, d), h[1] = cn(e, a, p);
}
function vv(i, e, n, s, r, a, o, h, c) {
  const l = tt.min, u = tt.max, f = Math.abs(r - a);
  if (f % ks < 1e-4 && f > 1e-4) {
    h[0] = i - n, h[1] = e - s, c[0] = i + n, c[1] = e + s;
    return;
  }
  if (tc[0] = Vu(r) * n + i, tc[1] = $u(r) * s + e, ec[0] = Vu(a) * n + i, ec[1] = $u(a) * s + e, l(h, tc, ec), u(c, tc, ec), r = r % ks, r < 0 && (r = r + ks), a = a % ks, a < 0 && (a = a + ks), r > a && !o ? a += ks : r < a && o && (r += ks), o) {
    const d = a;
    a = r, r = d;
  }
  for (let d = 0; d < a; d += Math.PI / 2)
    d > r && (nc[0] = Vu(d) * n + i, nc[1] = $u(d) * s + e, l(h, nc, h), u(c, nc, c));
}
const oz = () => typeof window < "u" && typeof window.document < "u";
let f0 = 1;
oz() && (f0 = Math.max(
  window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1,
  1
));
const jt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  // Rect
  R: 7
}, Ls = tt.create(), Fs = tt.create(), hi = tt.create(), Zi = tt.create(), ci = tt.create(), li = tt.create(), Gu = Math.min, Uu = Math.max, Ns = Math.cos, Bs = Math.sin, zi = Math.abs, d0 = Math.PI, cs = d0 * 2, Wu = typeof Float32Array < "u", Xa = [];
function Yu(i) {
  return Math.round(i / d0 * 1e8) / 1e8 % 2 * d0;
}
function wv(i, e) {
  let n = Yu(i[0]);
  n < 0 && (n += cs);
  let s = n - i[0], r = i[1];
  r += s, !e && r - n >= cs ? r = n + cs : e && n - r >= cs ? r = n - cs : !e && n > r ? r = n + (cs - Yu(n - r)) : e && n < r && (r = n - (cs - Yu(r - n))), i[0] = n, i[1] = r;
}
class p0 {
  dpr = 1;
  data;
  /**
   * Version is for tracking if the path has been changed.
   */
  _version;
  /**
   * If save path data.
   */
  _saveData;
  /**
   * If the line segment is too small to draw. It will be added to the pending pt.
   * It will be added if the subpath needs to be finished before stroke, fill, or starting a new subpath.
   */
  _pendingPtX;
  _pendingPtY;
  // Distance of pending pt to previous point.
  // 0 if there is no pending point.
  // Only update the pending pt when distance is larger.
  _pendingPtDist;
  _ctx;
  _xi = 0;
  _yi = 0;
  _x0 = 0;
  _y0 = 0;
  _len = 0;
  // Calculating path len and seg len.
  _pathSegLen;
  _pathLen;
  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
  _ux;
  _uy;
  static CMD = jt;
  constructor(e) {
    e && (this._saveData = !1), this._saveData && (this.data = []);
  }
  increaseVersion() {
    this._version++;
  }
  /**
   * Version can be used outside for compare if the path is changed.
   * For example to determine if need to update svg d str in svg renderer.
   */
  getVersion() {
    return this._version;
  }
  /**
   * @readOnly
   */
  setScale(e, n, s) {
    s = s || 0, s > 0 && (this._ux = zi(s / f0 / e) || 0, this._uy = zi(s / f0 / n) || 0);
  }
  setDPR(e) {
    this.dpr = e;
  }
  setContext(e) {
    this._ctx = e;
  }
  getContext() {
    return this._ctx;
  }
  beginPath() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }
  /**
   * Reset path data.
   */
  reset() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }
  moveTo(e, n) {
    return this._drawPendingPt(), this.addData(jt.M, e, n), this._ctx && this._ctx.moveTo(e, n), this._x0 = e, this._y0 = n, this._xi = e, this._yi = n, this;
  }
  lineTo(e, n) {
    const s = zi(e - this._xi), r = zi(n - this._yi), a = s > this._ux || r > this._uy;
    if (this.addData(jt.L, e, n), this._ctx && a && this._ctx.lineTo(e, n), a)
      this._xi = e, this._yi = n, this._pendingPtDist = 0;
    else {
      const o = s * s + r * r;
      o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = n, this._pendingPtDist = o);
    }
    return this;
  }
  bezierCurveTo(e, n, s, r, a, o) {
    return this._drawPendingPt(), this.addData(jt.C, e, n, s, r, a, o), this._ctx && this._ctx.bezierCurveTo(e, n, s, r, a, o), this._xi = a, this._yi = o, this;
  }
  quadraticCurveTo(e, n, s, r) {
    return this._drawPendingPt(), this.addData(jt.Q, e, n, s, r), this._ctx && this._ctx.quadraticCurveTo(e, n, s, r), this._xi = s, this._yi = r, this;
  }
  arc(e, n, s, r, a, o = !1) {
    this._drawPendingPt(), Xa[0] = r, Xa[1] = a, wv(Xa, o), r = Xa[0], a = Xa[1];
    let h = a - r;
    return this.addData(
      jt.A,
      e,
      n,
      s,
      s,
      r,
      h,
      0,
      o ? 0 : 1
    ), this._ctx && this._ctx.arc(e, n, s, r, a, o), this._xi = Ns(a) * s + e, this._yi = Bs(a) * s + n, this;
  }
  // TODO
  arcTo(e, n, s, r, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, n, s, r, a), this;
  }
  // TODO
  rect(e, n, s, r) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(e, n, s, r), this.addData(jt.R, e, n, s, r), this;
  }
  closePath() {
    this._drawPendingPt(), this.addData(jt.Z);
    const e = this._ctx, n = this._x0, s = this._y0;
    return e && e.closePath(), this._xi = n, this._yi = s, this;
  }
  fill(e) {
    e && e.fill(), this.toStatic();
  }
  stroke(e) {
    e && e.stroke(), this.toStatic();
  }
  len() {
    return this._len;
  }
  setData(e) {
    if (!this._saveData)
      return;
    const n = e.length;
    !(this.data && this.data.length === n) && Wu && (this.data = new Float32Array(n));
    for (let s = 0; s < n; s++)
      this.data[s] = e[s];
    this._len = n;
  }
  appendPath(e) {
    if (!this._saveData)
      return;
    e instanceof Array || (e = [e]);
    const n = e.length;
    let s = 0, r = this._len;
    for (let o = 0; o < n; o++)
      s += e[o].len();
    const a = this.data;
    if (Wu && (a instanceof Float32Array || !a) && (this.data = new Float32Array(r + s), r > 0 && a))
      for (let o = 0; o < r; o++)
        this.data[o] = a[o];
    for (let o = 0; o < n; o++) {
      const h = e[o].data;
      for (let c = 0; c < h.length; c++)
        this.data[r++] = h[c];
    }
    this._len = r;
  }
  /**
   * 填充 Path 数据。
   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
   */
  addData(e, n, s, r, a, o, h, c, l) {
    if (!this._saveData)
      return;
    let u = this.data;
    this._len + arguments.length > u.length && (this._expandData(), u = this.data);
    for (let f = 0; f < arguments.length; f++)
      u[this._len++] = arguments[f];
  }
  _drawPendingPt() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }
  _expandData() {
    if (!(this.data instanceof Array)) {
      const e = [];
      for (let n = 0; n < this._len; n++)
        e[n] = this.data[n];
      this.data = e;
    }
  }
  /**
   * Convert dynamic array to static Float32Array
   *
   * It will still use a normal array if command buffer length is less than 10
   * Because Float32Array itself may take more memory than a normal array.
   *
   * 10 length will make sure at least one M command and one A(arc) command.
   */
  toStatic() {
    if (!this._saveData)
      return;
    this._drawPendingPt();
    const e = this.data;
    e instanceof Array && (e.length = this._len, Wu && this._len > 11 && (this.data = new Float32Array(e)));
  }
  getBoundingRect() {
    hi[0] = hi[1] = ci[0] = ci[1] = Number.MAX_VALUE, Zi[0] = Zi[1] = li[0] = li[1] = -Number.MAX_VALUE;
    const e = this.data;
    let n = 0, s = 0, r = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      const h = e[o++], c = o === 1;
      switch (c && (n = e[o], s = e[o + 1], r = n, a = s), h) {
        case jt.M:
          n = r = e[o++], s = a = e[o++], ci[0] = r, ci[1] = a, li[0] = r, li[1] = a;
          break;
        case jt.L:
          u0(n, s, e[o], e[o + 1], ci, li), n = e[o++], s = e[o++];
          break;
        case jt.C:
          gv(
            n,
            s,
            e[o++],
            e[o++],
            e[o++],
            e[o++],
            e[o],
            e[o + 1],
            ci,
            li
          ), n = e[o++], s = e[o++];
          break;
        case jt.Q:
          mv(
            n,
            s,
            e[o++],
            e[o++],
            e[o],
            e[o + 1],
            ci,
            li
          ), n = e[o++], s = e[o++];
          break;
        case jt.A:
          const l = e[o++], u = e[o++], f = e[o++], d = e[o++], p = e[o++], y = e[o++] + p;
          o += 1;
          const x = !e[o++];
          c && (r = Ns(p) * f + l, a = Bs(p) * d + u), vv(
            l,
            u,
            f,
            d,
            p,
            y,
            x,
            ci,
            li
          ), n = Ns(y) * f + l, s = Bs(y) * d + u;
          break;
        case jt.R:
          r = n = e[o++], a = s = e[o++];
          const g = e[o++], m = e[o++];
          u0(r, a, r + g, a + m, ci, li);
          break;
        case jt.Z:
          n = r, s = a;
          break;
      }
      tt.min(hi, hi, ci), tt.max(Zi, Zi, li);
    }
    return o === 0 && (hi[0] = hi[1] = Zi[0] = Zi[1] = 0), new Ce(
      hi[0],
      hi[1],
      Zi[0] - hi[0],
      Zi[1] - hi[1]
    );
  }
  _calculateLength() {
    const e = this.data, n = this._len, s = this._ux, r = this._uy;
    let a = 0, o = 0, h = 0, c = 0;
    this._pathSegLen || (this._pathSegLen = []);
    const l = this._pathSegLen;
    let u = 0, f = 0;
    for (let d = 0; d < n; ) {
      const p = e[d++], y = d === 1;
      y && (a = e[d], o = e[d + 1], h = a, c = o);
      let x = -1;
      switch (p) {
        case jt.M:
          a = h = e[d++], o = c = e[d++];
          break;
        case jt.L: {
          const A = e[d++], M = e[d++], _ = A - a, T = M - o;
          (zi(_) > s || zi(T) > r || d === n - 1) && (x = Math.sqrt(_ * _ + T * T), a = A, o = M);
          break;
        }
        case jt.C: {
          const A = e[d++], M = e[d++], _ = e[d++], T = e[d++], C = e[d++], P = e[d++];
          x = ym(a, o, A, M, _, T, C, P, 10), a = C, o = P;
          break;
        }
        case jt.Q: {
          const A = e[d++], M = e[d++], _ = e[d++], T = e[d++];
          x = gm(a, o, A, M, _, T, 10), a = _, o = T;
          break;
        }
        case jt.A:
          const g = e[d++], m = e[d++], v = e[d++], w = e[d++], b = e[d++];
          let S = e[d++];
          const E = S + b;
          d += 1, y && (h = Ns(b) * v + g, c = Bs(b) * w + m), x = Uu(v, w) * Gu(cs, Math.abs(S)), a = Ns(E) * v + g, o = Bs(E) * w + m;
          break;
        case jt.R: {
          h = a = e[d++], c = o = e[d++];
          const A = e[d++], M = e[d++];
          x = A * 2 + M * 2;
          break;
        }
        case jt.Z: {
          const A = h - a, M = c - o;
          x = Math.sqrt(A * A + M * M), a = h, o = c;
          break;
        }
      }
      x >= 0 && (l[f++] = x, u += x);
    }
    return this._pathLen = u, u;
  }
  /**
   * Rebuild path from current data
   * Rebuild path will not consider javascript implemented line dash.
   * @param {CanvasRenderingContext2D} ctx
   */
  rebuildPath(e, n) {
    const s = this.data, r = this._ux, a = this._uy, o = this._len;
    let h = 0, c = 0, l = 0, u = 0, f = 0, d = 0;
    const p = n < 1;
    let y = [], x, g = 0, m = 0, v = 0, w = 0, b = 0, S = 0;
    if (!(p && (this._pathSegLen || this._calculateLength(), y = this._pathSegLen, x = this._pathLen, v = n * x, !v)))
      t: for (let E = 0; E < o; ) {
        const A = s[E++], M = E === 1;
        switch (M && (l = s[E], u = s[E + 1], h = l, c = u), A !== jt.L && w > 0 && (e.lineTo(b, S), w = 0), A) {
          case jt.M:
            h = l = s[E++], c = u = s[E++], e.moveTo(l, u);
            break;
          case jt.L: {
            f = s[E++], d = s[E++];
            const rt = zi(f - l), ft = zi(d - u);
            if (rt > r || ft > a) {
              if (p) {
                const lt = y[m++];
                if (g + lt > v) {
                  const wt = (v - g) / lt;
                  e.lineTo(l * (1 - wt) + f * wt, u * (1 - wt) + d * wt);
                  break t;
                }
                g += lt;
              }
              e.lineTo(f, d), l = f, u = d, w = 0;
            } else {
              const lt = rt * rt + ft * ft;
              lt > w && (b = f, S = d, w = lt);
            }
            break;
          }
          case jt.C: {
            const rt = s[E++], ft = s[E++], lt = s[E++], wt = s[E++], Ut = s[E++], fe = s[E++];
            if (p) {
              const ie = y[m++];
              if (g + ie > v) {
                const be = (v - g) / ie;
                Qf(l, rt, lt, Ut, be, Ls), Qf(u, ft, wt, fe, be, Fs), e.bezierCurveTo(Ls[1], Fs[1], Ls[2], Fs[2], Ls[3], Fs[3]);
                break t;
              }
              g += ie;
            }
            e.bezierCurveTo(rt, ft, lt, wt, Ut, fe), l = Ut, u = fe;
            break;
          }
          case jt.Q: {
            const rt = s[E++], ft = s[E++], lt = s[E++], wt = s[E++];
            if (p) {
              const Ut = y[m++];
              if (g + Ut > v) {
                const fe = (v - g) / Ut;
                Kf(l, rt, lt, fe, Ls), Kf(u, ft, wt, fe, Fs), e.quadraticCurveTo(Ls[1], Fs[1], Ls[2], Fs[2]);
                break t;
              }
              g += Ut;
            }
            e.quadraticCurveTo(rt, ft, lt, wt), l = lt, u = wt;
            break;
          }
          case jt.A:
            const _ = s[E++], T = s[E++], C = s[E++], P = s[E++];
            let R = s[E++], k = s[E++];
            const I = s[E++], L = !s[E++], F = C > P ? C : P, B = zi(C - P) > 1e-3;
            let V = R + k, J = !1;
            if (p) {
              const rt = y[m++];
              g + rt > v && (V = R + k * (v - g) / rt, J = !0), g += rt;
            }
            if (B && e.ellipse ? e.ellipse(_, T, C, P, I, R, V, L) : e.arc(_, T, F, R, V, L), J)
              break t;
            M && (h = Ns(R) * C + _, c = Bs(R) * P + T), l = Ns(V) * C + _, u = Bs(V) * P + T;
            break;
          case jt.R:
            h = l = s[E], c = u = s[E + 1], f = s[E++], d = s[E++];
            const j = s[E++], ht = s[E++];
            if (p) {
              const rt = y[m++];
              if (g + rt > v) {
                let ft = v - g;
                e.moveTo(f, d), e.lineTo(f + Gu(ft, j), d), ft -= j, ft > 0 && e.lineTo(f + j, d + Gu(ft, ht)), ft -= ht, ft > 0 && e.lineTo(f + Uu(j - ft, 0), d + ht), ft -= j, ft > 0 && e.lineTo(f, d + Uu(ht - ft, 0));
                break t;
              }
              g += rt;
            }
            e.rect(f, d, j, ht);
            break;
          case jt.Z:
            if (p) {
              const rt = y[m++];
              if (g + rt > v) {
                const ft = (v - g) / rt;
                e.lineTo(l * (1 - ft) + h * ft, u * (1 - ft) + c * ft);
                break t;
              }
              g += rt;
            }
            e.closePath(), l = h, u = c;
        }
      }
  }
  clone() {
    const e = new p0(), n = this.data;
    return e.data = n.slice ? n.slice() : Array.prototype.slice.call(n), e._len = this._len, e;
  }
  canSave() {
    return !!this._saveData;
  }
  static initDefaultProps = function() {
    const e = p0.prototype;
    e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
  }();
}
const hz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Entry: Pd,
  LinkedList: dv,
  createIntersectContext: fv,
  fromArc: vv,
  fromCubic: gv,
  fromLine: u0,
  fromPoints: az,
  fromQuadratic: mv,
  normalizeArcAngles: wv
}, Symbol.toStringTag, { value: "Module" })), Mv = (i) => () => i, y0 = (i) => {
  const e = i ? (n, s) => s.minus(n).abs().isLessThanOrEqualTo(i) : Mv(!1);
  return (n, s) => e(n, s) ? 0 : n.comparedTo(s);
};
function cz(i) {
  const e = i ? (n, s, r, a, o) => n.exponentiatedBy(2).isLessThanOrEqualTo(
    a.minus(s).exponentiatedBy(2).plus(o.minus(r).exponentiatedBy(2)).times(i)
  ) : Mv(!1);
  return (n, s, r) => {
    const a = n.x, o = n.y, h = r.x, c = r.y, l = o.minus(c).times(s.x.minus(h)).minus(a.minus(h).times(s.y.minus(c)));
    return e(l, a, o, h, c) ? 0 : l.comparedTo(0);
  };
}
var lz = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, ju = Math.ceil, En = Math.floor, an = "[BigNumber Error] ", Hy = an + "Number primitive has more than 15 significant digits: ", $n = 1e14, Et = 14, Hu = 9007199254740991, Xu = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], Ji = 1e7, Te = 1e9;
function bv(i) {
  var e, n, s, r = v.prototype = { constructor: v, toString: null, valueOf: null }, a = new v(1), o = 20, h = 4, c = -7, l = 21, u = -1e7, f = 1e7, d = !1, p = 1, y = 0, x = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, g = "0123456789abcdefghijklmnopqrstuvwxyz", m = !0;
  function v(M, _) {
    var T, C, P, R, k, I, L, F, B = this;
    if (!(B instanceof v)) return new v(M, _);
    if (_ == null) {
      if (M && M._isBigNumber === !0) {
        B.s = M.s, !M.c || M.e > f ? B.c = B.e = null : M.e < u ? B.c = [B.e = 0] : (B.e = M.e, B.c = M.c.slice());
        return;
      }
      if ((I = typeof M == "number") && M * 0 == 0) {
        if (B.s = 1 / M < 0 ? (M = -M, -1) : 1, M === ~~M) {
          for (R = 0, k = M; k >= 10; k /= 10, R++) ;
          R > f ? B.c = B.e = null : (B.e = R, B.c = [M]);
          return;
        }
        F = String(M);
      } else {
        if (!lz.test(F = String(M))) return s(B, F, I);
        B.s = F.charCodeAt(0) == 45 ? (F = F.slice(1), -1) : 1;
      }
      (R = F.indexOf(".")) > -1 && (F = F.replace(".", "")), (k = F.search(/e/i)) > 0 ? (R < 0 && (R = k), R += +F.slice(k + 1), F = F.substring(0, k)) : R < 0 && (R = F.length);
    } else {
      if (re(_, 2, g.length, "Base"), _ == 10 && m)
        return B = new v(M), E(B, o + B.e + 1, h);
      if (F = String(M), I = typeof M == "number") {
        if (M * 0 != 0) return s(B, F, I, _);
        if (B.s = 1 / M < 0 ? (F = F.slice(1), -1) : 1, v.DEBUG && F.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Hy + M);
      } else
        B.s = F.charCodeAt(0) === 45 ? (F = F.slice(1), -1) : 1;
      for (T = g.slice(0, _), R = k = 0, L = F.length; k < L; k++)
        if (T.indexOf(C = F.charAt(k)) < 0) {
          if (C == ".") {
            if (k > R) {
              R = L;
              continue;
            }
          } else if (!P && (F == F.toUpperCase() && (F = F.toLowerCase()) || F == F.toLowerCase() && (F = F.toUpperCase()))) {
            P = !0, k = -1, R = 0;
            continue;
          }
          return s(B, String(M), I, _);
        }
      I = !1, F = n(F, _, 10, B.s), (R = F.indexOf(".")) > -1 ? F = F.replace(".", "") : R = F.length;
    }
    for (k = 0; F.charCodeAt(k) === 48; k++) ;
    for (L = F.length; F.charCodeAt(--L) === 48; ) ;
    if (F = F.slice(k, ++L)) {
      if (L -= k, I && v.DEBUG && L > 15 && (M > Hu || M !== En(M)))
        throw Error(Hy + B.s * M);
      if ((R = R - k - 1) > f)
        B.c = B.e = null;
      else if (R < u)
        B.c = [B.e = 0];
      else {
        if (B.e = R, B.c = [], k = (R + 1) % Et, R < 0 && (k += Et), k < L) {
          for (k && B.c.push(+F.slice(0, k)), L -= Et; k < L; )
            B.c.push(+F.slice(k, k += Et));
          k = Et - (F = F.slice(k)).length;
        } else
          k -= L;
        for (; k--; F += "0") ;
        B.c.push(+F);
      }
    } else
      B.c = [B.e = 0];
  }
  v.clone = bv, v.ROUND_UP = 0, v.ROUND_DOWN = 1, v.ROUND_CEIL = 2, v.ROUND_FLOOR = 3, v.ROUND_HALF_UP = 4, v.ROUND_HALF_DOWN = 5, v.ROUND_HALF_EVEN = 6, v.ROUND_HALF_CEIL = 7, v.ROUND_HALF_FLOOR = 8, v.EUCLID = 9, v.config = v.set = function(M) {
    var _, T;
    if (M != null)
      if (typeof M == "object") {
        if (M.hasOwnProperty(_ = "DECIMAL_PLACES") && (T = M[_], re(T, 0, Te, _), o = T), M.hasOwnProperty(_ = "ROUNDING_MODE") && (T = M[_], re(T, 0, 8, _), h = T), M.hasOwnProperty(_ = "EXPONENTIAL_AT") && (T = M[_], T && T.pop ? (re(T[0], -Te, 0, _), re(T[1], 0, Te, _), c = T[0], l = T[1]) : (re(T, -Te, Te, _), c = -(l = T < 0 ? -T : T))), M.hasOwnProperty(_ = "RANGE"))
          if (T = M[_], T && T.pop)
            re(T[0], -Te, -1, _), re(T[1], 1, Te, _), u = T[0], f = T[1];
          else if (re(T, -Te, Te, _), T)
            u = -(f = T < 0 ? -T : T);
          else
            throw Error(an + _ + " cannot be zero: " + T);
        if (M.hasOwnProperty(_ = "CRYPTO"))
          if (T = M[_], T === !!T)
            if (T)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                d = T;
              else
                throw d = !T, Error(an + "crypto unavailable");
            else
              d = T;
          else
            throw Error(an + _ + " not true or false: " + T);
        if (M.hasOwnProperty(_ = "MODULO_MODE") && (T = M[_], re(T, 0, 9, _), p = T), M.hasOwnProperty(_ = "POW_PRECISION") && (T = M[_], re(T, 0, Te, _), y = T), M.hasOwnProperty(_ = "FORMAT"))
          if (T = M[_], typeof T == "object") x = T;
          else throw Error(an + _ + " not an object: " + T);
        if (M.hasOwnProperty(_ = "ALPHABET"))
          if (T = M[_], typeof T == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(T))
            m = T.slice(0, 10) == "0123456789", g = T;
          else
            throw Error(an + _ + " invalid: " + T);
      } else
        throw Error(an + "Object expected: " + M);
    return {
      DECIMAL_PLACES: o,
      ROUNDING_MODE: h,
      EXPONENTIAL_AT: [c, l],
      RANGE: [u, f],
      CRYPTO: d,
      MODULO_MODE: p,
      POW_PRECISION: y,
      FORMAT: x,
      ALPHABET: g
    };
  }, v.isBigNumber = function(M) {
    if (!M || M._isBigNumber !== !0) return !1;
    if (!v.DEBUG) return !0;
    var _, T, C = M.c, P = M.e, R = M.s;
    t: if ({}.toString.call(C) == "[object Array]") {
      if ((R === 1 || R === -1) && P >= -Te && P <= Te && P === En(P)) {
        if (C[0] === 0) {
          if (P === 0 && C.length === 1) return !0;
          break t;
        }
        if (_ = (P + 1) % Et, _ < 1 && (_ += Et), String(C[0]).length == _) {
          for (_ = 0; _ < C.length; _++)
            if (T = C[_], T < 0 || T >= $n || T !== En(T)) break t;
          if (T !== 0) return !0;
        }
      }
    } else if (C === null && P === null && (R === null || R === 1 || R === -1))
      return !0;
    throw Error(an + "Invalid BigNumber: " + M);
  }, v.maximum = v.max = function() {
    return b(arguments, -1);
  }, v.minimum = v.min = function() {
    return b(arguments, 1);
  }, v.random = function() {
    var M = 9007199254740992, _ = Math.random() * M & 2097151 ? function() {
      return En(Math.random() * M);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(T) {
      var C, P, R, k, I, L = 0, F = [], B = new v(a);
      if (T == null ? T = o : re(T, 0, Te), k = ju(T / Et), d)
        if (crypto.getRandomValues) {
          for (C = crypto.getRandomValues(new Uint32Array(k *= 2)); L < k; )
            I = C[L] * 131072 + (C[L + 1] >>> 11), I >= 9e15 ? (P = crypto.getRandomValues(new Uint32Array(2)), C[L] = P[0], C[L + 1] = P[1]) : (F.push(I % 1e14), L += 2);
          L = k / 2;
        } else if (crypto.randomBytes) {
          for (C = crypto.randomBytes(k *= 7); L < k; )
            I = (C[L] & 31) * 281474976710656 + C[L + 1] * 1099511627776 + C[L + 2] * 4294967296 + C[L + 3] * 16777216 + (C[L + 4] << 16) + (C[L + 5] << 8) + C[L + 6], I >= 9e15 ? crypto.randomBytes(7).copy(C, L) : (F.push(I % 1e14), L += 7);
          L = k / 7;
        } else
          throw d = !1, Error(an + "crypto unavailable");
      if (!d)
        for (; L < k; )
          I = _(), I < 9e15 && (F[L++] = I % 1e14);
      for (k = F[--L], T %= Et, k && T && (I = Xu[Et - T], F[L] = En(k / I) * I); F[L] === 0; F.pop(), L--) ;
      if (L < 0)
        F = [R = 0];
      else {
        for (R = -1; F[0] === 0; F.splice(0, 1), R -= Et) ;
        for (L = 1, I = F[0]; I >= 10; I /= 10, L++) ;
        L < Et && (R -= Et - L);
      }
      return B.e = R, B.c = F, B;
    };
  }(), v.sum = function() {
    for (var M = 1, _ = arguments, T = new v(_[0]); M < _.length; ) T = T.plus(_[M++]);
    return T;
  }, n = /* @__PURE__ */ function() {
    var M = "0123456789";
    function _(T, C, P, R) {
      for (var k, I = [0], L, F = 0, B = T.length; F < B; ) {
        for (L = I.length; L--; I[L] *= C) ;
        for (I[0] += R.indexOf(T.charAt(F++)), k = 0; k < I.length; k++)
          I[k] > P - 1 && (I[k + 1] == null && (I[k + 1] = 0), I[k + 1] += I[k] / P | 0, I[k] %= P);
      }
      return I.reverse();
    }
    return function(T, C, P, R, k) {
      var I, L, F, B, V, J, j, ht, rt = T.indexOf("."), ft = o, lt = h;
      for (rt >= 0 && (B = y, y = 0, T = T.replace(".", ""), ht = new v(C), J = ht.pow(T.length - rt), y = B, ht.c = _(
        Ci(Sn(J.c), J.e, "0"),
        10,
        P,
        M
      ), ht.e = ht.c.length), j = _(T, C, P, k ? (I = g, M) : (I = M, g)), F = B = j.length; j[--B] == 0; j.pop()) ;
      if (!j[0]) return I.charAt(0);
      if (rt < 0 ? --F : (J.c = j, J.e = F, J.s = R, J = e(J, ht, ft, lt, P), j = J.c, V = J.r, F = J.e), L = F + ft + 1, rt = j[L], B = P / 2, V = V || L < 0 || j[L + 1] != null, V = lt < 4 ? (rt != null || V) && (lt == 0 || lt == (J.s < 0 ? 3 : 2)) : rt > B || rt == B && (lt == 4 || V || lt == 6 && j[L - 1] & 1 || lt == (J.s < 0 ? 8 : 7)), L < 1 || !j[0])
        T = V ? Ci(I.charAt(1), -ft, I.charAt(0)) : I.charAt(0);
      else {
        if (j.length = L, V)
          for (--P; ++j[--L] > P; )
            j[L] = 0, L || (++F, j = [1].concat(j));
        for (B = j.length; !j[--B]; ) ;
        for (rt = 0, T = ""; rt <= B; T += I.charAt(j[rt++])) ;
        T = Ci(T, F, I.charAt(0));
      }
      return T;
    };
  }(), e = /* @__PURE__ */ function() {
    function M(C, P, R) {
      var k, I, L, F, B = 0, V = C.length, J = P % Ji, j = P / Ji | 0;
      for (C = C.slice(); V--; )
        L = C[V] % Ji, F = C[V] / Ji | 0, k = j * L + F * J, I = J * L + k % Ji * Ji + B, B = (I / R | 0) + (k / Ji | 0) + j * F, C[V] = I % R;
      return B && (C = [B].concat(C)), C;
    }
    function _(C, P, R, k) {
      var I, L;
      if (R != k)
        L = R > k ? 1 : -1;
      else
        for (I = L = 0; I < R; I++)
          if (C[I] != P[I]) {
            L = C[I] > P[I] ? 1 : -1;
            break;
          }
      return L;
    }
    function T(C, P, R, k) {
      for (var I = 0; R--; )
        C[R] -= I, I = C[R] < P[R] ? 1 : 0, C[R] = I * k + C[R] - P[R];
      for (; !C[0] && C.length > 1; C.splice(0, 1)) ;
    }
    return function(C, P, R, k, I) {
      var L, F, B, V, J, j, ht, rt, ft, lt, wt, Ut, fe, ie, be, de, Qt, Xt = C.s == P.s ? 1 : -1, H = C.c, Z = P.c;
      if (!H || !H[0] || !Z || !Z[0])
        return new v(
          // Return NaN if either NaN, or both Infinity or 0.
          !C.s || !P.s || (H ? Z && H[0] == Z[0] : !Z) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            H && H[0] == 0 || !Z ? Xt * 0 : Xt / 0
          )
        );
      for (rt = new v(Xt), ft = rt.c = [], F = C.e - P.e, Xt = R + F + 1, I || (I = $n, F = zn(C.e / Et) - zn(P.e / Et), Xt = Xt / Et | 0), B = 0; Z[B] == (H[B] || 0); B++) ;
      if (Z[B] > (H[B] || 0) && F--, Xt < 0)
        ft.push(1), V = !0;
      else {
        for (ie = H.length, de = Z.length, B = 0, Xt += 2, J = En(I / (Z[0] + 1)), J > 1 && (Z = M(Z, J, I), H = M(H, J, I), de = Z.length, ie = H.length), fe = de, lt = H.slice(0, de), wt = lt.length; wt < de; lt[wt++] = 0) ;
        Qt = Z.slice(), Qt = [0].concat(Qt), be = Z[0], Z[1] >= I / 2 && be++;
        do {
          if (J = 0, L = _(Z, lt, de, wt), L < 0) {
            if (Ut = lt[0], de != wt && (Ut = Ut * I + (lt[1] || 0)), J = En(Ut / be), J > 1)
              for (J >= I && (J = I - 1), j = M(Z, J, I), ht = j.length, wt = lt.length; _(j, lt, ht, wt) == 1; )
                J--, T(j, de < ht ? Qt : Z, ht, I), ht = j.length, L = 1;
            else
              J == 0 && (L = J = 1), j = Z.slice(), ht = j.length;
            if (ht < wt && (j = [0].concat(j)), T(lt, j, wt, I), wt = lt.length, L == -1)
              for (; _(Z, lt, de, wt) < 1; )
                J++, T(lt, de < wt ? Qt : Z, wt, I), wt = lt.length;
          } else L === 0 && (J++, lt = [0]);
          ft[B++] = J, lt[0] ? lt[wt++] = H[fe] || 0 : (lt = [H[fe]], wt = 1);
        } while ((fe++ < ie || lt[0] != null) && Xt--);
        V = lt[0] != null, ft[0] || ft.splice(0, 1);
      }
      if (I == $n) {
        for (B = 1, Xt = ft[0]; Xt >= 10; Xt /= 10, B++) ;
        E(rt, R + (rt.e = B + F * Et - 1) + 1, k, V);
      } else
        rt.e = F, rt.r = +V;
      return rt;
    };
  }();
  function w(M, _, T, C) {
    var P, R, k, I, L;
    if (T == null ? T = h : re(T, 0, 8), !M.c) return M.toString();
    if (P = M.c[0], k = M.e, _ == null)
      L = Sn(M.c), L = C == 1 || C == 2 && (k <= c || k >= l) ? sc(L, k) : Ci(L, k, "0");
    else if (M = E(new v(M), _, T), R = M.e, L = Sn(M.c), I = L.length, C == 1 || C == 2 && (_ <= R || R <= c)) {
      for (; I < _; L += "0", I++) ;
      L = sc(L, R);
    } else if (_ -= k, L = Ci(L, R, "0"), R + 1 > I) {
      if (--_ > 0) for (L += "."; _--; L += "0") ;
    } else if (_ += R - I, _ > 0)
      for (R + 1 == I && (L += "."); _--; L += "0") ;
    return M.s < 0 && P ? "-" + L : L;
  }
  function b(M, _) {
    for (var T, C, P = 1, R = new v(M[0]); P < M.length; P++)
      C = new v(M[P]), (!C.s || (T = Ds(R, C)) === _ || T === 0 && R.s === _) && (R = C);
    return R;
  }
  function S(M, _, T) {
    for (var C = 1, P = _.length; !_[--P]; _.pop()) ;
    for (P = _[0]; P >= 10; P /= 10, C++) ;
    return (T = C + T * Et - 1) > f ? M.c = M.e = null : T < u ? M.c = [M.e = 0] : (M.e = T, M.c = _), M;
  }
  s = /* @__PURE__ */ function() {
    var M = /^(-?)0([xbo])(?=\w[\w.]*$)/i, _ = /^([^.]+)\.$/, T = /^\.([^.]+)$/, C = /^-?(Infinity|NaN)$/, P = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(R, k, I, L) {
      var F, B = I ? k : k.replace(P, "");
      if (C.test(B))
        R.s = isNaN(B) ? null : B < 0 ? -1 : 1;
      else {
        if (!I && (B = B.replace(M, function(V, J, j) {
          return F = (j = j.toLowerCase()) == "x" ? 16 : j == "b" ? 2 : 8, !L || L == F ? J : V;
        }), L && (F = L, B = B.replace(_, "$1").replace(T, "0.$1")), k != B))
          return new v(B, F);
        if (v.DEBUG)
          throw Error(an + "Not a" + (L ? " base " + L : "") + " number: " + k);
        R.s = null;
      }
      R.c = R.e = null;
    };
  }();
  function E(M, _, T, C) {
    var P, R, k, I, L, F, B, V = M.c, J = Xu;
    if (V) {
      t: {
        for (P = 1, I = V[0]; I >= 10; I /= 10, P++) ;
        if (R = _ - P, R < 0)
          R += Et, k = _, L = V[F = 0], B = En(L / J[P - k - 1] % 10);
        else if (F = ju((R + 1) / Et), F >= V.length)
          if (C) {
            for (; V.length <= F; V.push(0)) ;
            L = B = 0, P = 1, R %= Et, k = R - Et + 1;
          } else
            break t;
        else {
          for (L = I = V[F], P = 1; I >= 10; I /= 10, P++) ;
          R %= Et, k = R - Et + P, B = k < 0 ? 0 : En(L / J[P - k - 1] % 10);
        }
        if (C = C || _ < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        V[F + 1] != null || (k < 0 ? L : L % J[P - k - 1]), C = T < 4 ? (B || C) && (T == 0 || T == (M.s < 0 ? 3 : 2)) : B > 5 || B == 5 && (T == 4 || C || T == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (R > 0 ? k > 0 ? L / J[P - k] : 0 : V[F - 1]) % 10 & 1 || T == (M.s < 0 ? 8 : 7)), _ < 1 || !V[0])
          return V.length = 0, C ? (_ -= M.e + 1, V[0] = J[(Et - _ % Et) % Et], M.e = -_ || 0) : V[0] = M.e = 0, M;
        if (R == 0 ? (V.length = F, I = 1, F--) : (V.length = F + 1, I = J[Et - R], V[F] = k > 0 ? En(L / J[P - k] % J[k]) * I : 0), C)
          for (; ; )
            if (F == 0) {
              for (R = 1, k = V[0]; k >= 10; k /= 10, R++) ;
              for (k = V[0] += I, I = 1; k >= 10; k /= 10, I++) ;
              R != I && (M.e++, V[0] == $n && (V[0] = 1));
              break;
            } else {
              if (V[F] += I, V[F] != $n) break;
              V[F--] = 0, I = 1;
            }
        for (R = V.length; V[--R] === 0; V.pop()) ;
      }
      M.e > f ? M.c = M.e = null : M.e < u && (M.c = [M.e = 0]);
    }
    return M;
  }
  function A(M) {
    var _, T = M.e;
    return T === null ? M.toString() : (_ = Sn(M.c), _ = T <= c || T >= l ? sc(_, T) : Ci(_, T, "0"), M.s < 0 ? "-" + _ : _);
  }
  return r.absoluteValue = r.abs = function() {
    var M = new v(this);
    return M.s < 0 && (M.s = 1), M;
  }, r.comparedTo = function(M, _) {
    return Ds(this, new v(M, _));
  }, r.decimalPlaces = r.dp = function(M, _) {
    var T, C, P, R = this;
    if (M != null)
      return re(M, 0, Te), _ == null ? _ = h : re(_, 0, 8), E(new v(R), M + R.e + 1, _);
    if (!(T = R.c)) return null;
    if (C = ((P = T.length - 1) - zn(this.e / Et)) * Et, P = T[P]) for (; P % 10 == 0; P /= 10, C--) ;
    return C < 0 && (C = 0), C;
  }, r.dividedBy = r.div = function(M, _) {
    return e(this, new v(M, _), o, h);
  }, r.dividedToIntegerBy = r.idiv = function(M, _) {
    return e(this, new v(M, _), 0, 1);
  }, r.exponentiatedBy = r.pow = function(M, _) {
    var T, C, P, R, k, I, L, F, B, V = this;
    if (M = new v(M), M.c && !M.isInteger())
      throw Error(an + "Exponent not an integer: " + A(M));
    if (_ != null && (_ = new v(_)), I = M.e > 14, !V.c || !V.c[0] || V.c[0] == 1 && !V.e && V.c.length == 1 || !M.c || !M.c[0])
      return B = new v(Math.pow(+A(V), I ? M.s * (2 - ic(M)) : +A(M))), _ ? B.mod(_) : B;
    if (L = M.s < 0, _) {
      if (_.c ? !_.c[0] : !_.s) return new v(NaN);
      C = !L && V.isInteger() && _.isInteger(), C && (V = V.mod(_));
    } else {
      if (M.e > 9 && (V.e > 0 || V.e < -1 || (V.e == 0 ? V.c[0] > 1 || I && V.c[1] >= 24e7 : V.c[0] < 8e13 || I && V.c[0] <= 9999975e7)))
        return R = V.s < 0 && ic(M) ? -0 : 0, V.e > -1 && (R = 1 / R), new v(L ? 1 / R : R);
      y && (R = ju(y / Et + 2));
    }
    for (I ? (T = new v(0.5), L && (M.s = 1), F = ic(M)) : (P = Math.abs(+A(M)), F = P % 2), B = new v(a); ; ) {
      if (F) {
        if (B = B.times(V), !B.c) break;
        R ? B.c.length > R && (B.c.length = R) : C && (B = B.mod(_));
      }
      if (P) {
        if (P = En(P / 2), P === 0) break;
        F = P % 2;
      } else if (M = M.times(T), E(M, M.e + 1, 1), M.e > 14)
        F = ic(M);
      else {
        if (P = +A(M), P === 0) break;
        F = P % 2;
      }
      V = V.times(V), R ? V.c && V.c.length > R && (V.c.length = R) : C && (V = V.mod(_));
    }
    return C ? B : (L && (B = a.div(B)), _ ? B.mod(_) : R ? E(B, y, h, k) : B);
  }, r.integerValue = function(M) {
    var _ = new v(this);
    return M == null ? M = h : re(M, 0, 8), E(_, _.e + 1, M);
  }, r.isEqualTo = r.eq = function(M, _) {
    return Ds(this, new v(M, _)) === 0;
  }, r.isFinite = function() {
    return !!this.c;
  }, r.isGreaterThan = r.gt = function(M, _) {
    return Ds(this, new v(M, _)) > 0;
  }, r.isGreaterThanOrEqualTo = r.gte = function(M, _) {
    return (_ = Ds(this, new v(M, _))) === 1 || _ === 0;
  }, r.isInteger = function() {
    return !!this.c && zn(this.e / Et) > this.c.length - 2;
  }, r.isLessThan = r.lt = function(M, _) {
    return Ds(this, new v(M, _)) < 0;
  }, r.isLessThanOrEqualTo = r.lte = function(M, _) {
    return (_ = Ds(this, new v(M, _))) === -1 || _ === 0;
  }, r.isNaN = function() {
    return !this.s;
  }, r.isNegative = function() {
    return this.s < 0;
  }, r.isPositive = function() {
    return this.s > 0;
  }, r.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, r.minus = function(M, _) {
    var T, C, P, R, k = this, I = k.s;
    if (M = new v(M, _), _ = M.s, !I || !_) return new v(NaN);
    if (I != _)
      return M.s = -_, k.plus(M);
    var L = k.e / Et, F = M.e / Et, B = k.c, V = M.c;
    if (!L || !F) {
      if (!B || !V) return B ? (M.s = -_, M) : new v(V ? k : NaN);
      if (!B[0] || !V[0])
        return V[0] ? (M.s = -_, M) : new v(B[0] ? k : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          h == 3 ? -0 : 0
        ));
    }
    if (L = zn(L), F = zn(F), B = B.slice(), I = L - F) {
      for ((R = I < 0) ? (I = -I, P = B) : (F = L, P = V), P.reverse(), _ = I; _--; P.push(0)) ;
      P.reverse();
    } else
      for (C = (R = (I = B.length) < (_ = V.length)) ? I : _, I = _ = 0; _ < C; _++)
        if (B[_] != V[_]) {
          R = B[_] < V[_];
          break;
        }
    if (R && (P = B, B = V, V = P, M.s = -M.s), _ = (C = V.length) - (T = B.length), _ > 0) for (; _--; B[T++] = 0) ;
    for (_ = $n - 1; C > I; ) {
      if (B[--C] < V[C]) {
        for (T = C; T && !B[--T]; B[T] = _) ;
        --B[T], B[C] += $n;
      }
      B[C] -= V[C];
    }
    for (; B[0] == 0; B.splice(0, 1), --F) ;
    return B[0] ? S(M, B, F) : (M.s = h == 3 ? -1 : 1, M.c = [M.e = 0], M);
  }, r.modulo = r.mod = function(M, _) {
    var T, C, P = this;
    return M = new v(M, _), !P.c || !M.s || M.c && !M.c[0] ? new v(NaN) : !M.c || P.c && !P.c[0] ? new v(P) : (p == 9 ? (C = M.s, M.s = 1, T = e(P, M, 0, 3), M.s = C, T.s *= C) : T = e(P, M, 0, p), M = P.minus(T.times(M)), !M.c[0] && p == 1 && (M.s = P.s), M);
  }, r.multipliedBy = r.times = function(M, _) {
    var T, C, P, R, k, I, L, F, B, V, J, j, ht, rt, ft, lt = this, wt = lt.c, Ut = (M = new v(M, _)).c;
    if (!wt || !Ut || !wt[0] || !Ut[0])
      return !lt.s || !M.s || wt && !wt[0] && !Ut || Ut && !Ut[0] && !wt ? M.c = M.e = M.s = null : (M.s *= lt.s, !wt || !Ut ? M.c = M.e = null : (M.c = [0], M.e = 0)), M;
    for (C = zn(lt.e / Et) + zn(M.e / Et), M.s *= lt.s, L = wt.length, V = Ut.length, L < V && (ht = wt, wt = Ut, Ut = ht, P = L, L = V, V = P), P = L + V, ht = []; P--; ht.push(0)) ;
    for (rt = $n, ft = Ji, P = V; --P >= 0; ) {
      for (T = 0, J = Ut[P] % ft, j = Ut[P] / ft | 0, k = L, R = P + k; R > P; )
        F = wt[--k] % ft, B = wt[k] / ft | 0, I = j * F + B * J, F = J * F + I % ft * ft + ht[R] + T, T = (F / rt | 0) + (I / ft | 0) + j * B, ht[R--] = F % rt;
      ht[R] = T;
    }
    return T ? ++C : ht.splice(0, 1), S(M, ht, C);
  }, r.negated = function() {
    var M = new v(this);
    return M.s = -M.s || null, M;
  }, r.plus = function(M, _) {
    var T, C = this, P = C.s;
    if (M = new v(M, _), _ = M.s, !P || !_) return new v(NaN);
    if (P != _)
      return M.s = -_, C.minus(M);
    var R = C.e / Et, k = M.e / Et, I = C.c, L = M.c;
    if (!R || !k) {
      if (!I || !L) return new v(P / 0);
      if (!I[0] || !L[0]) return L[0] ? M : new v(I[0] ? C : P * 0);
    }
    if (R = zn(R), k = zn(k), I = I.slice(), P = R - k) {
      for (P > 0 ? (k = R, T = L) : (P = -P, T = I), T.reverse(); P--; T.push(0)) ;
      T.reverse();
    }
    for (P = I.length, _ = L.length, P - _ < 0 && (T = L, L = I, I = T, _ = P), P = 0; _; )
      P = (I[--_] = I[_] + L[_] + P) / $n | 0, I[_] = $n === I[_] ? 0 : I[_] % $n;
    return P && (I = [P].concat(I), ++k), S(M, I, k);
  }, r.precision = r.sd = function(M, _) {
    var T, C, P, R = this;
    if (M != null && M !== !!M)
      return re(M, 1, Te), _ == null ? _ = h : re(_, 0, 8), E(new v(R), M, _);
    if (!(T = R.c)) return null;
    if (P = T.length - 1, C = P * Et + 1, P = T[P]) {
      for (; P % 10 == 0; P /= 10, C--) ;
      for (P = T[0]; P >= 10; P /= 10, C++) ;
    }
    return M && R.e + 1 > C && (C = R.e + 1), C;
  }, r.shiftedBy = function(M) {
    return re(M, -Hu, Hu), this.times("1e" + M);
  }, r.squareRoot = r.sqrt = function() {
    var M, _, T, C, P, R = this, k = R.c, I = R.s, L = R.e, F = o + 4, B = new v("0.5");
    if (I !== 1 || !k || !k[0])
      return new v(!I || I < 0 && (!k || k[0]) ? NaN : k ? R : 1 / 0);
    if (I = Math.sqrt(+A(R)), I == 0 || I == 1 / 0 ? (_ = Sn(k), (_.length + L) % 2 == 0 && (_ += "0"), I = Math.sqrt(+_), L = zn((L + 1) / 2) - (L < 0 || L % 2), I == 1 / 0 ? _ = "5e" + L : (_ = I.toExponential(), _ = _.slice(0, _.indexOf("e") + 1) + L), T = new v(_)) : T = new v(I + ""), T.c[0]) {
      for (L = T.e, I = L + F, I < 3 && (I = 0); ; )
        if (P = T, T = B.times(P.plus(e(R, P, F, 1))), Sn(P.c).slice(0, I) === (_ = Sn(T.c)).slice(0, I))
          if (T.e < L && --I, _ = _.slice(I - 3, I + 1), _ == "9999" || !C && _ == "4999") {
            if (!C && (E(P, P.e + o + 2, 0), P.times(P).eq(R))) {
              T = P;
              break;
            }
            F += 4, I += 4, C = 1;
          } else {
            (!+_ || !+_.slice(1) && _.charAt(0) == "5") && (E(T, T.e + o + 2, 1), M = !T.times(T).eq(R));
            break;
          }
    }
    return E(T, T.e + o + 1, h, M);
  }, r.toExponential = function(M, _) {
    return M != null && (re(M, 0, Te), M++), w(this, M, _, 1);
  }, r.toFixed = function(M, _) {
    return M != null && (re(M, 0, Te), M = M + this.e + 1), w(this, M, _);
  }, r.toFormat = function(M, _, T) {
    var C, P = this;
    if (T == null)
      M != null && _ && typeof _ == "object" ? (T = _, _ = null) : M && typeof M == "object" ? (T = M, M = _ = null) : T = x;
    else if (typeof T != "object")
      throw Error(an + "Argument not an object: " + T);
    if (C = P.toFixed(M, _), P.c) {
      var R, k = C.split("."), I = +T.groupSize, L = +T.secondaryGroupSize, F = T.groupSeparator || "", B = k[0], V = k[1], J = P.s < 0, j = J ? B.slice(1) : B, ht = j.length;
      if (L && (R = I, I = L, L = R, ht -= R), I > 0 && ht > 0) {
        for (R = ht % I || I, B = j.substr(0, R); R < ht; R += I) B += F + j.substr(R, I);
        L > 0 && (B += F + j.slice(R)), J && (B = "-" + B);
      }
      C = V ? B + (T.decimalSeparator || "") + ((L = +T.fractionGroupSize) ? V.replace(
        new RegExp("\\d{" + L + "}\\B", "g"),
        "$&" + (T.fractionGroupSeparator || "")
      ) : V) : B;
    }
    return (T.prefix || "") + C + (T.suffix || "");
  }, r.toFraction = function(M) {
    var _, T, C, P, R, k, I, L, F, B, V, J, j = this, ht = j.c;
    if (M != null && (I = new v(M), !I.isInteger() && (I.c || I.s !== 1) || I.lt(a)))
      throw Error(an + "Argument " + (I.isInteger() ? "out of range: " : "not an integer: ") + A(I));
    if (!ht) return new v(j);
    for (_ = new v(a), F = T = new v(a), C = L = new v(a), J = Sn(ht), R = _.e = J.length - j.e - 1, _.c[0] = Xu[(k = R % Et) < 0 ? Et + k : k], M = !M || I.comparedTo(_) > 0 ? R > 0 ? _ : F : I, k = f, f = 1 / 0, I = new v(J), L.c[0] = 0; B = e(I, _, 0, 1), P = T.plus(B.times(C)), P.comparedTo(M) != 1; )
      T = C, C = P, F = L.plus(B.times(P = F)), L = P, _ = I.minus(B.times(P = _)), I = P;
    return P = e(M.minus(T), C, 0, 1), L = L.plus(P.times(F)), T = T.plus(P.times(C)), L.s = F.s = j.s, R = R * 2, V = e(F, C, R, h).minus(j).abs().comparedTo(
      e(L, T, R, h).minus(j).abs()
    ) < 1 ? [F, C] : [L, T], f = k, V;
  }, r.toNumber = function() {
    return +A(this);
  }, r.toPrecision = function(M, _) {
    return M != null && re(M, 1, Te), w(this, M, _, 2);
  }, r.toString = function(M) {
    var _, T = this, C = T.s, P = T.e;
    return P === null ? C ? (_ = "Infinity", C < 0 && (_ = "-" + _)) : _ = "NaN" : (M == null ? _ = P <= c || P >= l ? sc(Sn(T.c), P) : Ci(Sn(T.c), P, "0") : M === 10 && m ? (T = E(new v(T), o + P + 1, h), _ = Ci(Sn(T.c), T.e, "0")) : (re(M, 2, g.length, "Base"), _ = n(Ci(Sn(T.c), P, "0"), 10, M, C, !0)), C < 0 && T.c[0] && (_ = "-" + _)), _;
  }, r.valueOf = r.toJSON = function() {
    return A(this);
  }, r._isBigNumber = !0, r[Symbol.toStringTag] = "BigNumber", r[Symbol.for("nodejs.util.inspect.custom")] = r.valueOf, i != null && v.set(i), v;
}
function zn(i) {
  var e = i | 0;
  return i > 0 || i === e ? e : e - 1;
}
function Sn(i) {
  for (var e, n, s = 1, r = i.length, a = i[0] + ""; s < r; ) {
    for (e = i[s++] + "", n = Et - e.length; n--; e = "0" + e) ;
    a += e;
  }
  for (r = a.length; a.charCodeAt(--r) === 48; ) ;
  return a.slice(0, r + 1 || 1);
}
function Ds(i, e) {
  var n, s, r = i.c, a = e.c, o = i.s, h = e.s, c = i.e, l = e.e;
  if (!o || !h) return null;
  if (n = r && !r[0], s = a && !a[0], n || s) return n ? s ? 0 : -h : o;
  if (o != h) return o;
  if (n = o < 0, s = c == l, !r || !a) return s ? 0 : !r ^ n ? 1 : -1;
  if (!s) return c > l ^ n ? 1 : -1;
  for (h = (c = r.length) < (l = a.length) ? c : l, o = 0; o < h; o++) if (r[o] != a[o]) return r[o] > a[o] ^ n ? 1 : -1;
  return c == l ? 0 : c > l ^ n ? 1 : -1;
}
function re(i, e, n, s) {
  if (i < e || i > n || i !== En(i))
    throw Error(an + (s || "Argument") + (typeof i == "number" ? i < e || i > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(i));
}
function ic(i) {
  var e = i.c.length - 1;
  return zn(i.e / Et) == e && i.c[e] % 2 != 0;
}
function sc(i, e) {
  return (i.length > 1 ? i.charAt(0) + "." + i.slice(1) : i) + (e < 0 ? "e" : "e+") + e;
}
function Ci(i, e, n) {
  var s, r;
  if (e < 0) {
    for (r = n + "."; ++e; r += n) ;
    i = r + i;
  } else if (s = i.length, ++e > s) {
    for (r = n, e -= s; --e; r += n) ;
    i += r;
  } else e < s && (i = i.slice(0, e) + "." + i.slice(e));
  return i;
}
var Kn = bv(), uz = class {
  key;
  left = null;
  right = null;
  constructor(i) {
    this.key = i;
  }
}, Za = class extends uz {
  constructor(i) {
    super(i);
  }
}, fz = class {
  size = 0;
  modificationCount = 0;
  splayCount = 0;
  splay(i) {
    const e = this.root;
    if (e == null)
      return this.compare(i, i), -1;
    let n = null, s = null, r = null, a = null, o = e;
    const h = this.compare;
    let c;
    for (; ; )
      if (c = h(o.key, i), c > 0) {
        let l = o.left;
        if (l == null || (c = h(l.key, i), c > 0 && (o.left = l.right, l.right = o, o = l, l = o.left, l == null)))
          break;
        n == null ? s = o : n.left = o, n = o, o = l;
      } else if (c < 0) {
        let l = o.right;
        if (l == null || (c = h(l.key, i), c < 0 && (o.right = l.left, l.left = o, o = l, l = o.right, l == null)))
          break;
        r == null ? a = o : r.right = o, r = o, o = l;
      } else
        break;
    return r != null && (r.right = o.left, o.left = a), n != null && (n.left = o.right, o.right = s), this.root !== o && (this.root = o, this.splayCount++), c;
  }
  splayMin(i) {
    let e = i, n = e.left;
    for (; n != null; ) {
      const s = n;
      e.left = s.right, s.right = e, e = s, n = e.left;
    }
    return e;
  }
  splayMax(i) {
    let e = i, n = e.right;
    for (; n != null; ) {
      const s = n;
      e.right = s.left, s.left = e, e = s, n = e.right;
    }
    return e;
  }
  _delete(i) {
    if (this.root == null || this.splay(i) != 0) return null;
    let n = this.root;
    const s = n, r = n.left;
    if (this.size--, r == null)
      this.root = n.right;
    else {
      const a = n.right;
      n = this.splayMax(r), n.right = a, this.root = n;
    }
    return this.modificationCount++, s;
  }
  addNewRoot(i, e) {
    this.size++, this.modificationCount++;
    const n = this.root;
    if (n == null) {
      this.root = i;
      return;
    }
    e < 0 ? (i.left = n, i.right = n.right, n.right = null) : (i.right = n, i.left = n.left, n.left = null), this.root = i;
  }
  _first() {
    const i = this.root;
    return i == null ? null : (this.root = this.splayMin(i), this.root);
  }
  _last() {
    const i = this.root;
    return i == null ? null : (this.root = this.splayMax(i), this.root);
  }
  clear() {
    this.root = null, this.size = 0, this.modificationCount++;
  }
  has(i) {
    return this.validKey(i) && this.splay(i) == 0;
  }
  defaultCompare() {
    return (i, e) => i < e ? -1 : i > e ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => this.root,
      setRoot: (i) => {
        this.root = i;
      },
      getSize: () => this.size,
      getModificationCount: () => this.modificationCount,
      getSplayCount: () => this.splayCount,
      setSplayCount: (i) => {
        this.splayCount = i;
      },
      splay: (i) => this.splay(i),
      has: (i) => this.has(i)
    };
  }
}, Sl = class uo extends fz {
  root = null;
  compare;
  validKey;
  constructor(e, n) {
    super(), this.compare = e ?? this.defaultCompare(), this.validKey = n ?? ((s) => s != null && s != null);
  }
  delete(e) {
    return this.validKey(e) ? this._delete(e) != null : !1;
  }
  deleteAll(e) {
    for (const n of e)
      this.delete(n);
  }
  forEach(e) {
    const n = this[Symbol.iterator]();
    let s;
    for (; s = n.next(), !s.done; )
      e(s.value, s.value, this);
  }
  add(e) {
    const n = this.splay(e);
    return n != 0 && this.addNewRoot(new Za(e), n), this;
  }
  addAndReturn(e) {
    const n = this.splay(e);
    return n != 0 && this.addNewRoot(new Za(e), n), this.root.key;
  }
  addAll(e) {
    for (const n of e)
      this.add(n);
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) < 0) return this.root.key;
    let s = this.root.left;
    if (s == null) return null;
    let r = s.right;
    for (; r != null; )
      s = r, r = s.right;
    return s.key;
  }
  firstAfter(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) > 0) return this.root.key;
    let s = this.root.right;
    if (s == null) return null;
    let r = s.left;
    for (; r != null; )
      s = r, r = s.left;
    return s.key;
  }
  retainAll(e) {
    const n = new uo(this.compare, this.validKey), s = this.modificationCount;
    for (const r of e) {
      if (s != this.modificationCount)
        throw "Concurrent modification during iteration.";
      this.validKey(r) && this.splay(r) == 0 && n.add(this.root.key);
    }
    n.size != this.size && (this.root = n.root, this.size = n.size, this.modificationCount++);
  }
  lookup(e) {
    return !this.validKey(e) || this.splay(e) != 0 ? null : this.root.key;
  }
  intersection(e) {
    const n = new uo(this.compare, this.validKey);
    for (const s of this)
      e.has(s) && n.add(s);
    return n;
  }
  difference(e) {
    const n = new uo(this.compare, this.validKey);
    for (const s of this)
      e.has(s) || n.add(s);
    return n;
  }
  union(e) {
    const n = this.clone();
    return n.addAll(e), n;
  }
  clone() {
    const e = new uo(this.compare, this.validKey);
    return e.size = this.size, e.root = this.copyNode(this.root), e;
  }
  copyNode(e) {
    if (e == null) return null;
    function n(r, a) {
      let o, h;
      do {
        if (o = r.left, h = r.right, o != null) {
          const c = new Za(o.key);
          a.left = c, n(o, c);
        }
        if (h != null) {
          const c = new Za(h.key);
          a.right = c, r = h, a = c;
        }
      } while (h != null);
    }
    const s = new Za(e.key);
    return n(e, s), s;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new pz(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new dz(this.wrap());
  }
  [Symbol.toStringTag] = "[object Set]";
}, _v = class {
  tree;
  path = new Array();
  modificationCount = null;
  splayCount;
  constructor(i) {
    this.tree = i, this.splayCount = i.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const i = this.path[this.path.length - 1];
    return this.getValue(i);
  }
  rebuildPath(i) {
    this.path.splice(0, this.path.length), this.tree.splay(i), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(i) {
    for (; i != null; )
      this.path.push(i), i = i.left;
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let n = this.tree.getRoot();
        for (; n != null; )
          this.path.push(n), n = n.left;
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return !1;
    this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
    let i = this.path[this.path.length - 1], e = i.right;
    if (e != null) {
      for (; e != null; )
        this.path.push(e), e = e.left;
      return !0;
    }
    for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === i; )
      i = this.path.pop();
    return this.path.length > 0;
  }
}, dz = class extends _v {
  getValue(i) {
    return i.key;
  }
}, pz = class extends _v {
  getValue(i) {
    return [i.key, i.key];
  }
};
const yz = (i) => i, xz = (i) => {
  if (i) {
    const e = new Sl(y0(i)), n = new Sl(y0(i)), s = (a, o) => o.addAndReturn(a), r = (a) => ({
      x: s(a.x, e),
      y: s(a.y, n)
    });
    return r({ x: new Kn(0), y: new Kn(0) }), r;
  }
  return yz;
}, x0 = (i) => ({
  set: (e) => {
    Yi = x0(e);
  },
  reset: () => x0(i),
  compare: y0(i),
  snap: xz(i),
  orient: cz(i)
});
let Yi = x0();
const Ja = (i, e) => i.ll.x.isLessThanOrEqualTo(e.x) && e.x.isLessThanOrEqualTo(i.ur.x) && i.ll.y.isLessThanOrEqualTo(e.y) && e.y.isLessThanOrEqualTo(i.ur.y), g0 = (i, e) => {
  if (e.ur.x.isLessThan(i.ll.x) || i.ur.x.isLessThan(e.ll.x) || e.ur.y.isLessThan(i.ll.y) || i.ur.y.isLessThan(e.ll.y))
    return null;
  const n = i.ll.x.isLessThan(e.ll.x) ? e.ll.x : i.ll.x, s = i.ur.x.isLessThan(e.ur.x) ? i.ur.x : e.ur.x, r = i.ll.y.isLessThan(e.ll.y) ? e.ll.y : i.ll.y, a = i.ur.y.isLessThan(e.ur.y) ? i.ur.y : e.ur.y;
  return { ll: { x: n, y: r }, ur: { x: s, y: a } };
}, Hc = (i, e) => i.x.times(e.y).minus(i.y.times(e.x)), Sv = (i, e) => i.x.times(e.x).plus(i.y.times(e.y)), Tl = (i) => Sv(i, i).sqrt(), gz = (i, e, n) => {
  const s = { x: e.x.minus(i.x), y: e.y.minus(i.y) }, r = { x: n.x.minus(i.x), y: n.y.minus(i.y) };
  return Hc(r, s).div(Tl(r)).div(Tl(s));
}, mz = (i, e, n) => {
  const s = { x: e.x.minus(i.x), y: e.y.minus(i.y) }, r = { x: n.x.minus(i.x), y: n.y.minus(i.y) };
  return Sv(r, s).div(Tl(r)).div(Tl(s));
}, Xy = (i, e, n) => e.y.isZero() ? null : { x: i.x.plus(e.x.div(e.y).times(n.minus(i.y))), y: n }, Zy = (i, e, n) => e.x.isZero() ? null : { x: n, y: i.y.plus(e.y.div(e.x).times(n.minus(i.x))) }, vz = (i, e, n, s) => {
  if (e.x.isZero()) return Zy(n, s, i.x);
  if (s.x.isZero()) return Zy(i, e, n.x);
  if (e.y.isZero()) return Xy(n, s, i.y);
  if (s.y.isZero()) return Xy(i, e, n.y);
  const r = Hc(e, s);
  if (r.isZero()) return null;
  const a = { x: n.x.minus(i.x), y: n.y.minus(i.y) }, o = Hc(a, e).div(r), h = Hc(a, s).div(r), c = i.x.plus(h.times(e.x)), l = n.x.plus(o.times(s.x)), u = i.y.plus(h.times(e.y)), f = n.y.plus(o.times(s.y)), d = c.plus(l).div(2), p = u.plus(f).div(2);
  return { x: d, y: p };
};
class Rn {
  point;
  isLeft;
  segment;
  otherSE;
  consumedBy;
  // for ordering sweep events in the sweep event queue
  static compare(e, n) {
    const s = Rn.comparePoints(e.point, n.point);
    return s !== 0 ? s : (e.point !== n.point && e.link(n), e.isLeft !== n.isLeft ? e.isLeft ? 1 : -1 : El.compare(e.segment, n.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(e, n) {
    return e.x.isLessThan(n.x) ? -1 : e.x.isGreaterThan(n.x) ? 1 : e.y.isLessThan(n.y) ? -1 : e.y.isGreaterThan(n.y) ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(e, n) {
    e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = n;
  }
  link(e) {
    if (e.point === this.point)
      throw new Error("Tried to link already linked events");
    const n = e.point.events;
    for (let s = 0, r = n.length; s < r; s++) {
      const a = n[s];
      this.point.events.push(a), a.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const e = this.point.events.length;
    for (let n = 0; n < e; n++) {
      const s = this.point.events[n];
      if (s.segment.consumedBy === void 0)
        for (let r = n + 1; r < e; r++) {
          const a = this.point.events[r];
          a.consumedBy === void 0 && s.otherSE.point.events === a.otherSE.point.events && s.segment.consume(a.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const e = [];
    for (let n = 0, s = this.point.events.length; n < s; n++) {
      const r = this.point.events[n];
      r !== this && !r.segment.ringOut && r.segment.isInResult() && e.push(r);
    }
    return e;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(e) {
    const n = /* @__PURE__ */ new Map(), s = (r) => {
      const a = r.otherSE;
      n.set(r, {
        sine: gz(this.point, e.point, a.point),
        cosine: mz(this.point, e.point, a.point)
      });
    };
    return (r, a) => {
      n.has(r) || s(r), n.has(a) || s(a);
      const { sine: o, cosine: h } = n.get(r), { sine: c, cosine: l } = n.get(a);
      return o.isGreaterThanOrEqualTo(0) && c.isGreaterThanOrEqualTo(0) ? h.isLessThan(l) ? 1 : h.isGreaterThan(l) ? -1 : 0 : o.isLessThan(0) && c.isLessThan(0) ? h.isLessThan(l) ? -1 : h.isGreaterThan(l) ? 1 : 0 : c.isLessThan(o) ? -1 : c.isGreaterThan(o) ? 1 : 0;
    };
  }
}
let wz = 0, El = class Xc {
  id;
  leftSE;
  rightSE;
  rings;
  windings;
  ringOut;
  consumedBy;
  prev;
  _prevInResult;
  _beforeState;
  _afterState;
  _isInResult;
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(e, n) {
    const s = e.leftSE.point.x, r = n.leftSE.point.x, a = e.rightSE.point.x, o = n.rightSE.point.x;
    if (o.isLessThan(s)) return 1;
    if (a.isLessThan(r)) return -1;
    const h = e.leftSE.point.y, c = n.leftSE.point.y, l = e.rightSE.point.y, u = n.rightSE.point.y;
    if (s.isLessThan(r)) {
      if (c.isLessThan(h) && c.isLessThan(l)) return 1;
      if (c.isGreaterThan(h) && c.isGreaterThan(l)) return -1;
      const f = e.comparePoint(n.leftSE.point);
      if (f < 0) return 1;
      if (f > 0) return -1;
      const d = n.comparePoint(e.rightSE.point);
      return d !== 0 ? d : -1;
    }
    if (s.isGreaterThan(r)) {
      if (h.isLessThan(c) && h.isLessThan(u)) return -1;
      if (h.isGreaterThan(c) && h.isGreaterThan(u)) return 1;
      const f = n.comparePoint(e.leftSE.point);
      if (f !== 0) return f;
      const d = e.comparePoint(n.rightSE.point);
      return d < 0 ? 1 : d > 0 ? -1 : 1;
    }
    if (h.isLessThan(c)) return -1;
    if (h.isGreaterThan(c)) return 1;
    if (a.isLessThan(o)) {
      const f = n.comparePoint(e.rightSE.point);
      if (f !== 0) return f;
    }
    if (a.isGreaterThan(o)) {
      const f = e.comparePoint(n.rightSE.point);
      if (f < 0) return 1;
      if (f > 0) return -1;
    }
    if (!a.eq(o)) {
      const f = l.minus(h), d = a.minus(s), p = u.minus(c), y = o.minus(r);
      if (f.isGreaterThan(d) && p.isLessThan(y)) return 1;
      if (f.isLessThan(d) && p.isGreaterThan(y)) return -1;
    }
    return a.isGreaterThan(o) ? 1 : a.isLessThan(o) || l.isLessThan(u) ? -1 : l.isGreaterThan(u) ? 1 : e.id < n.id ? -1 : e.id > n.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(e, n, s, r) {
    this.id = ++wz, this.leftSE = e, e.segment = this, e.otherSE = n, this.rightSE = n, n.segment = this, n.otherSE = e, this.rings = s, this.windings = r;
  }
  static fromRing(e, n, s) {
    let r, a, o;
    const h = Rn.comparePoints(e, n);
    if (h < 0)
      r = e, a = n, o = 1;
    else if (h > 0)
      r = n, a = e, o = -1;
    else
      throw new Error(
        `Tried to create degenerate segment at [${e.x}, ${e.y}]`
      );
    const c = new Rn(r, !0), l = new Rn(a, !1);
    return new Xc(c, l, [s], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(e) {
    this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const e = this.leftSE.point.y, n = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: e.isLessThan(n) ? e : n },
      ur: { x: this.rightSE.point.x, y: e.isGreaterThan(n) ? e : n }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(e) {
    return e.x.eq(this.leftSE.point.x) && e.y.eq(this.leftSE.point.y) || e.x.eq(this.rightSE.point.x) && e.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(e) {
    return Yi.orient(this.leftSE.point, e, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(e) {
    const n = this.bbox(), s = e.bbox(), r = g0(n, s);
    if (r === null) return null;
    const a = this.leftSE.point, o = this.rightSE.point, h = e.leftSE.point, c = e.rightSE.point, l = Ja(n, h) && this.comparePoint(h) === 0, u = Ja(s, a) && e.comparePoint(a) === 0, f = Ja(n, c) && this.comparePoint(c) === 0, d = Ja(s, o) && e.comparePoint(o) === 0;
    if (u && l)
      return d && !f ? o : !d && f ? c : null;
    if (u)
      return f && a.x.eq(c.x) && a.y.eq(c.y) ? null : a;
    if (l)
      return d && o.x.eq(h.x) && o.y.eq(h.y) ? null : h;
    if (d && f) return null;
    if (d) return o;
    if (f) return c;
    const p = vz(a, this.vector(), h, e.vector());
    return p === null || !Ja(r, p) ? null : Yi.snap(p);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(e) {
    const n = [], s = e.events !== void 0, r = new Rn(e, !0), a = new Rn(e, !1), o = this.rightSE;
    this.replaceRightSE(a), n.push(a), n.push(r);
    const h = new Xc(
      r,
      o,
      this.rings.slice(),
      this.windings.slice()
    );
    return Rn.comparePoints(h.leftSE.point, h.rightSE.point) > 0 && h.swapEvents(), Rn.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), s && (r.checkForConsuming(), a.checkForConsuming()), n;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const e = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let n = 0, s = this.windings.length; n < s; n++)
      this.windings[n] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(e) {
    let n = this, s = e;
    for (; n.consumedBy; ) n = n.consumedBy;
    for (; s.consumedBy; ) s = s.consumedBy;
    const r = Xc.compare(n, s);
    if (r !== 0) {
      if (r > 0) {
        const a = n;
        n = s, s = a;
      }
      if (n.prev === s) {
        const a = n;
        n = s, s = a;
      }
      for (let a = 0, o = s.rings.length; a < o; a++) {
        const h = s.rings[a], c = s.windings[a], l = n.rings.indexOf(h);
        l === -1 ? (n.rings.push(h), n.windings.push(c)) : n.windings[l] += c;
      }
      s.rings = null, s.windings = null, s.consumedBy = n, s.leftSE.consumedBy = n.leftSE, s.rightSE.consumedBy = n.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const e = this.prev.consumedBy || this.prev;
      this._beforeState = e.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const e = this.beforeState();
    this._afterState = {
      rings: e.rings.slice(0),
      windings: e.windings.slice(0),
      multiPolys: []
    };
    const n = this._afterState.rings, s = this._afterState.windings, r = this._afterState.multiPolys;
    for (let h = 0, c = this.rings.length; h < c; h++) {
      const l = this.rings[h], u = this.windings[h], f = n.indexOf(l);
      f === -1 ? (n.push(l), s.push(u)) : s[f] += u;
    }
    const a = [], o = [];
    for (let h = 0, c = n.length; h < c; h++) {
      if (s[h] === 0) continue;
      const l = n[h], u = l.poly;
      if (o.indexOf(u) === -1)
        if (l.isExterior) a.push(u);
        else {
          o.indexOf(u) === -1 && o.push(u);
          const f = a.indexOf(l.poly);
          f !== -1 && a.splice(f, 1);
        }
    }
    for (let h = 0, c = a.length; h < c; h++) {
      const l = a[h].multiPoly;
      r.indexOf(l) === -1 && r.push(l);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const e = this.beforeState().multiPolys, n = this.afterState().multiPolys;
    switch (yi.type) {
      case "union": {
        const s = e.length === 0, r = n.length === 0;
        this._isInResult = s !== r;
        break;
      }
      case "intersection": {
        let s, r;
        e.length < n.length ? (s = e.length, r = n.length) : (s = n.length, r = e.length), this._isInResult = r === yi.numMultiPolys && s < r;
        break;
      }
      case "xor": {
        const s = Math.abs(e.length - n.length);
        this._isInResult = s % 2 === 1;
        break;
      }
      case "difference": {
        const s = (r) => r.length === 1 && r[0].isSubject;
        this._isInResult = s(e) !== s(n);
        break;
      }
    }
    return this._isInResult;
  }
};
class Jy {
  poly;
  isExterior;
  segments;
  bbox;
  constructor(e, n, s) {
    if (!Array.isArray(e) || e.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = n, this.isExterior = s, this.segments = [], typeof e[0][0] != "number" || typeof e[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const r = Yi.snap({ x: new Kn(e[0][0]), y: new Kn(e[0][1]) });
    this.bbox = {
      ll: { x: r.x, y: r.y },
      ur: { x: r.x, y: r.y }
    };
    let a = r;
    for (let o = 1, h = e.length; o < h; o++) {
      if (typeof e[o][0] != "number" || typeof e[o][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const c = Yi.snap({ x: new Kn(e[o][0]), y: new Kn(e[o][1]) });
      c.x.eq(a.x) && c.y.eq(a.y) || (this.segments.push(El.fromRing(a, c, this)), c.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = c.x), c.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = c.y), c.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = c.x), c.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = c.y), a = c);
    }
    (!r.x.eq(a.x) || !r.y.eq(a.y)) && this.segments.push(El.fromRing(a, r, this));
  }
  getSweepEvents() {
    const e = [];
    for (let n = 0, s = this.segments.length; n < s; n++) {
      const r = this.segments[n];
      e.push(r.leftSE), e.push(r.rightSE);
    }
    return e;
  }
}
class Mz {
  multiPoly;
  exteriorRing;
  interiorRings;
  bbox;
  constructor(e, n) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new Jy(e[0], this, !0), this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    }, this.interiorRings = [];
    for (let s = 1, r = e.length; s < r; s++) {
      const a = new Jy(e[s], this, !1);
      a.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = a.bbox.ll.x), a.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = a.bbox.ll.y), a.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = a.bbox.ur.x), a.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = a.bbox.ur.y), this.interiorRings.push(a);
    }
    this.multiPoly = n;
  }
  getSweepEvents() {
    const e = this.exteriorRing.getSweepEvents();
    for (let n = 0, s = this.interiorRings.length; n < s; n++) {
      const r = this.interiorRings[n].getSweepEvents();
      for (let a = 0, o = r.length; a < o; a++)
        e.push(r[a]);
    }
    return e;
  }
}
class Qy {
  isSubject;
  polys;
  bbox;
  constructor(e, n) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof e[0][0][0] == "number" && (e = [e]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: { x: new Kn(Number.POSITIVE_INFINITY), y: new Kn(Number.POSITIVE_INFINITY) },
      ur: { x: new Kn(Number.NEGATIVE_INFINITY), y: new Kn(Number.NEGATIVE_INFINITY) }
    };
    for (let s = 0, r = e.length; s < r; s++) {
      const a = new Mz(e[s], this);
      a.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = a.bbox.ll.x), a.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = a.bbox.ll.y), a.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = a.bbox.ur.x), a.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = a.bbox.ur.y), this.polys.push(a);
    }
    this.isSubject = n;
  }
  getSweepEvents() {
    const e = [];
    for (let n = 0, s = this.polys.length; n < s; n++) {
      const r = this.polys[n].getSweepEvents();
      for (let a = 0, o = r.length; a < o; a++)
        e.push(r[a]);
    }
    return e;
  }
}
class zl {
  events;
  poly;
  _isExteriorRing;
  _enclosingRing;
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(e) {
    const n = [];
    for (let s = 0, r = e.length; s < r; s++) {
      const a = e[s];
      if (!a.isInResult() || a.ringOut) continue;
      let o = null, h = a.leftSE, c = a.rightSE;
      const l = [h], u = h.point, f = [];
      for (; o = h, h = c, l.push(h), h.point !== u; )
        for (; ; ) {
          const d = h.getAvailableLinkedEvents();
          if (d.length === 0) {
            const x = l[0].point, g = l[l.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${x.x}, ${x.y}]. Last matching segment found ends at [${g.x}, ${g.y}].`
            );
          }
          if (d.length === 1) {
            c = d[0].otherSE;
            break;
          }
          let p = null;
          for (let x = 0, g = f.length; x < g; x++)
            if (f[x].point === h.point) {
              p = x;
              break;
            }
          if (p !== null) {
            const x = f.splice(p)[0], g = l.splice(x.index);
            g.unshift(g[0].otherSE), n.push(new zl(g.reverse()));
            continue;
          }
          f.push({
            index: l.length,
            point: h.point
          });
          const y = h.getLeftmostComparator(o);
          c = d.sort(y)[0].otherSE;
          break;
        }
      n.push(new zl(l));
    }
    return n;
  }
  constructor(e) {
    this.events = e;
    for (let n = 0, s = e.length; n < s; n++)
      e[n].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let e = this.events[0].point;
    const n = [e];
    for (let l = 1, u = this.events.length - 1; l < u; l++) {
      const f = this.events[l].point, d = this.events[l + 1].point;
      Yi.orient(f, e, d) !== 0 && (n.push(f), e = f);
    }
    if (n.length === 1) return null;
    const s = n[0], r = n[1];
    Yi.orient(s, e, r) === 0 && n.shift(), n.push(n[0]);
    const a = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : n.length - 1, h = this.isExteriorRing() ? n.length : -1, c = [];
    for (let l = o; l != h; l += a)
      c.push([n[l].x.toNumber(), n[l].y.toNumber()]);
    return c;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const e = this.enclosingRing();
      this._isExteriorRing = e ? !e.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let e = this.events[0];
    for (let r = 1, a = this.events.length; r < a; r++) {
      const o = this.events[r];
      Rn.compare(e, o) > 0 && (e = o);
    }
    let n = e.segment.prevInResult(), s = n ? n.prevInResult() : null;
    for (; ; ) {
      if (!n) return null;
      if (!s) return n.ringOut;
      if (s.ringOut !== n.ringOut)
        return s.ringOut?.enclosingRing() !== n.ringOut ? n.ringOut : n.ringOut?.enclosingRing();
      n = s.prevInResult(), s = n ? n.prevInResult() : null;
    }
  }
}
class Ky {
  exteriorRing;
  interiorRings;
  constructor(e) {
    this.exteriorRing = e, e.poly = this, this.interiorRings = [];
  }
  addInterior(e) {
    this.interiorRings.push(e), e.poly = this;
  }
  getGeom() {
    const e = this.exteriorRing.getGeom();
    if (e === null) return null;
    const n = [e];
    for (let s = 0, r = this.interiorRings.length; s < r; s++) {
      const a = this.interiorRings[s].getGeom();
      a !== null && n.push(a);
    }
    return n;
  }
}
class bz {
  rings;
  polys;
  constructor(e) {
    this.rings = e, this.polys = this._composePolys(e);
  }
  getGeom() {
    const e = [];
    for (let n = 0, s = this.polys.length; n < s; n++) {
      const r = this.polys[n].getGeom();
      r !== null && e.push(r);
    }
    return e;
  }
  _composePolys(e) {
    const n = [];
    for (let s = 0, r = e.length; s < r; s++) {
      const a = e[s];
      if (!a.poly)
        if (a.isExteriorRing()) n.push(new Ky(a));
        else {
          const o = a.enclosingRing();
          o?.poly || n.push(new Ky(o)), o?.poly?.addInterior(a);
        }
    }
    return n;
  }
}
class _z {
  queue;
  tree;
  segments;
  constructor(e, n = El.compare) {
    this.queue = e, this.tree = new Sl(n), this.segments = [];
  }
  process(e) {
    const n = e.segment, s = [];
    if (e.consumedBy)
      return e.isLeft ? this.queue.delete(e.otherSE) : this.tree.delete(n), s;
    e.isLeft && this.tree.add(n);
    let r = n, a = n;
    do
      r = this.tree.lastBefore(r);
    while (r != null && r.consumedBy != null);
    do
      a = this.tree.firstAfter(a);
    while (a != null && a.consumedBy != null);
    if (e.isLeft) {
      let o = null;
      if (r) {
        const c = r.getIntersection(n);
        if (c !== null && (n.isAnEndpoint(c) || (o = c), !r.isAnEndpoint(c))) {
          const l = this._splitSafely(r, c);
          for (let u = 0, f = l.length; u < f; u++)
            s.push(l[u]);
        }
      }
      let h = null;
      if (a) {
        const c = a.getIntersection(n);
        if (c !== null && (n.isAnEndpoint(c) || (h = c), !a.isAnEndpoint(c))) {
          const l = this._splitSafely(a, c);
          for (let u = 0, f = l.length; u < f; u++)
            s.push(l[u]);
        }
      }
      if (o !== null || h !== null) {
        let c = null;
        o === null ? c = h : h === null ? c = o : c = Rn.comparePoints(
          o,
          h
        ) <= 0 ? o : h, this.queue.delete(n.rightSE), s.push(n.rightSE);
        const l = n.split(c);
        for (let u = 0, f = l.length; u < f; u++)
          s.push(l[u]);
      }
      s.length > 0 ? (this.tree.delete(n), s.push(e)) : (this.segments.push(n), n.prev = r);
    } else {
      if (r && a) {
        const o = r.getIntersection(a);
        if (o !== null) {
          if (!r.isAnEndpoint(o)) {
            const h = this._splitSafely(r, o);
            for (let c = 0, l = h.length; c < l; c++)
              s.push(h[c]);
          }
          if (!a.isAnEndpoint(o)) {
            const h = this._splitSafely(a, o);
            for (let c = 0, l = h.length; c < l; c++)
              s.push(h[c]);
          }
        }
      }
      this.tree.delete(n);
    }
    return s;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(e, n) {
    this.tree.delete(e);
    const s = e.rightSE;
    this.queue.delete(s);
    const r = e.split(n);
    return r.push(s), e.consumedBy === void 0 && this.tree.add(e), r;
  }
}
class Sz {
  type;
  numMultiPolys;
  run(e, n, s) {
    yi.type = e;
    const r = [new Qy(n, !0)];
    for (let u = 0, f = s.length; u < f; u++)
      r.push(new Qy(s[u], !1));
    if (yi.numMultiPolys = r.length, yi.type === "difference") {
      const u = r[0];
      let f = 1;
      for (; f < r.length; )
        g0(r[f].bbox, u.bbox) !== null ? f++ : r.splice(f, 1);
    }
    if (yi.type === "intersection")
      for (let u = 0, f = r.length; u < f; u++) {
        const d = r[u];
        for (let p = u + 1, y = r.length; p < y; p++)
          if (g0(d.bbox, r[p].bbox) === null) return [];
      }
    const a = new Sl(Rn.compare);
    for (let u = 0, f = r.length; u < f; u++) {
      const d = r[u].getSweepEvents();
      for (let p = 0, y = d.length; p < y; p++)
        a.add(d[p]);
    }
    const o = new _z(a);
    let h = null;
    for (a.size != 0 && (h = a.first(), a.delete(h)); h; ) {
      const u = o.process(h);
      for (let f = 0, d = u.length; f < d; f++) {
        const p = u[f];
        p.consumedBy === void 0 && a.add(p);
      }
      a.size != 0 ? (h = a.first(), a.delete(h)) : h = null;
    }
    Yi.reset();
    const c = zl.factory(o.segments);
    return new bz(c).getGeom();
  }
}
const yi = new Sz(), Tz = (i, ...e) => yi.run("union", i, e), Ez = (i, ...e) => yi.run("intersection", i, e), zz = (i, ...e) => yi.run("xor", i, e), Cz = (i, ...e) => yi.run("difference", i, e), Az = Yi.set, Pz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  difference: Cz,
  intersection: Ez,
  setPrecision: Az,
  union: Tz,
  xor: zz
}, Symbol.toStringTag, { value: "Module" })), Iz = 0, Tv = 1, Ev = 2, zv = 4, Cv = 8;
function rc(i, e, n) {
  let s = Iz;
  return i < n.left ? s |= Tv : i > n.right && (s |= Ev), e < n.top ? s |= zv : e > n.bottom && (s |= Cv), s;
}
function Cl(i, e) {
  let [[n, s], [r, a]] = i, o = rc(n, s, e), h = rc(r, a, e);
  for (; ; )
    if (o | h) {
      if (o & h)
        return !1;
      {
        const { top: c, right: l, bottom: u, left: f } = e;
        let d, p;
        const y = h > o ? h : o;
        y & Cv ? (d = n + (r - n) * (u - s) / (a - s), p = u) : y & zv ? (d = n + (r - n) * (c - s) / (a - s), p = c) : y & Ev ? (p = s + (a - s) * (l - n) / (r - n), d = l) : y & Tv && (p = s + (a - s) * (f - n) / (r - n), d = f), y == o ? (n = d, s = p, o = rc(n, s, e)) : (r = d, a = p, h = rc(r, a, e));
      }
    } else return !0;
}
function Zc(i, e) {
  return i.left <= e.right && e.left <= i.right && i.top <= e.bottom && e.top <= i.bottom;
}
function Av(i, e) {
  return i ? {
    top: Math.min(i.top, e.top),
    right: Math.max(i.right, e.right),
    bottom: Math.max(i.bottom, e.bottom),
    left: Math.min(i.left, e.left)
  } : e;
}
function Nr(i, e) {
  return i ? {
    top: Math.min(i.top, e[1]),
    right: Math.max(i.right, e[0]),
    bottom: Math.max(i.bottom, e[1]),
    left: Math.min(i.left, e[0])
  } : {
    top: e[1],
    right: e[0],
    bottom: e[1],
    left: e[0]
  };
}
function Pv(i) {
  return Math.max(
    i.right - i.left,
    i.bottom - i.top
  );
}
function Jc(i, e) {
  return {
    top: i[1] - e,
    right: i[0] + e,
    bottom: i[1] + e,
    left: i[0] - e
  };
}
function Rz(i, e) {
  return {
    top: i.top - e,
    right: i.right + e,
    bottom: i.bottom + e,
    left: i.left - e
  };
}
class hr {
  constructor(e, n, s = 16) {
    this.boundingBox = e, this.depth = n, this.innerNodeCapacity = s;
  }
  subtrees = null;
  pairs = [];
  insert(e, n) {
    if (!Zc(e, this.boundingBox)) return !1;
    if (this.depth > 0 && this.pairs.length >= this.innerNodeCapacity) {
      this.ensureSubtrees();
      for (let s = 0; s < this.subtrees.length; s++)
        this.subtrees[s].insert(e, n);
    } else
      this.pairs.push([e, n]);
    return !0;
  }
  find(e, n = /* @__PURE__ */ new Set()) {
    if (!Zc(e, this.boundingBox)) return n;
    for (let s = 0; s < this.pairs.length; s++) {
      const [r, a] = this.pairs[s];
      Zc(e, r) && n.add(a);
    }
    if (this.subtrees)
      for (let s = 0; s < this.subtrees.length; s++)
        this.subtrees[s].find(e, n);
    return n;
  }
  findOnLineSegment(e, n = /* @__PURE__ */ new Set()) {
    if (!Cl(e, this.boundingBox)) return n;
    for (const [s, r] of this.pairs)
      Cl(e, s) && n.add(r);
    if (this.subtrees)
      for (const s of this.subtrees)
        s.findOnLineSegment(e, n);
    return n;
  }
  ensureSubtrees() {
    if (this.subtrees) return;
    const { top: e, right: n, bottom: s, left: r } = this.boundingBox, a = (this.boundingBox.left + this.boundingBox.right) / 2, o = (this.boundingBox.top + this.boundingBox.bottom) / 2;
    this.subtrees = [
      new hr(
        { top: e, right: a, bottom: o, left: r },
        this.depth - 1,
        this.innerNodeCapacity
      ),
      new hr(
        { top: e, right: n, bottom: o, left: a },
        this.depth - 1,
        this.innerNodeCapacity
      ),
      new hr(
        { top: o, right: a, bottom: s, left: r },
        this.depth - 1,
        this.innerNodeCapacity
      ),
      new hr(
        { top: o, right: n, bottom: s, left: a },
        this.depth - 1,
        this.innerNodeCapacity
      )
    ];
  }
}
class Kl extends Error {
  constructor(e) {
    super("Assertion error: " + e);
  }
}
function tx(i, e) {
  if (!i)
    throw new Kl(`Expected 'cond' to be truthy: ${e}`);
}
function vi(i, e) {
  if (i == null)
    throw new Kl(
      `Expected 'val' to be defined, but received ${i}: ${e}`
    );
}
function Iv(i, e, n) {
  if (i !== e)
    throw new Kl(
      `Expected 'lhs' to equal ${e}, but received ${i}: ${n}`
    );
}
function Oz(i) {
  throw new Kl(
    `Reached code that was supposed to be unreachable: ${i}`
  );
}
const ac = 1e-12;
function Rv(i) {
  const e = i[1], n = i[2], s = i[3], r = i[4], a = -e[0] + 3 * n[0] - 3 * s[0] + r[0], o = -e[1] + 3 * n[1] - 3 * s[1] + r[1], h = 3 * e[0] - 6 * n[0] + 3 * s[0], c = 3 * e[1] - 6 * n[1] + 3 * s[1], l = -3 * e[0] + 3 * n[0], u = -3 * e[1] + 3 * n[1], f = o * h - a * c, d = a * u - o * l, p = (-3 * a * a * u * u + 6 * a * o * l * u + 4 * a * h * c * u - 4 * a * c * c * l - 3 * o * o * l * l - 4 * o * h * h * u + 4 * o * h * c * l) / (a * a * c * c - 2 * a * o * h * c + o * o * h * h);
  if (p < 0) return null;
  const y = (d / f + Math.sqrt(p)) / 2, x = (d / f - Math.sqrt(p)) / 2;
  return ac <= y && y <= 1 - ac && ac <= x && x <= 1 - ac ? [y, x] : null;
}
const ex = 2 * Math.PI;
function kz(i, e, n, s, r) {
  return (i - e) / (n - e) * (r - s) + s;
}
function Xn(i, e, n) {
  return i + (e - i) * n;
}
function Ov(i) {
  return i / 180 * Math.PI;
}
function nx(i, e) {
  const s = Math.sign(i[0] * e[1] - i[1] * e[0]);
  return s === 0 && Math.abs(i[0] + e[0]) < 1e-12 && Math.abs(i[1] + e[1]) < 1e-12 ? Math.PI : s * Math.acos(tt.dot(i, e) / tt.len(i) / tt.len(e));
}
function te() {
  return [0, 0];
}
function je(i, e, n = 0) {
  return Math.abs(i[0] - e[0]) <= n && Math.abs(i[1] - e[1]) <= n;
}
function Rd(i) {
  return i[1];
}
function kv(i) {
  switch (i[0]) {
    case "L":
      return i[2];
    case "C":
      return i[4];
    case "Q":
      return i[3];
    case "A":
      return i[7];
  }
}
function Al(i) {
  switch (i[0]) {
    case "L":
      return ["L", i[2], i[1]];
    case "C":
      return ["C", i[4], i[3], i[2], i[1]];
    case "Q":
      return ["Q", i[3], i[2], i[1]];
    case "A":
      return [
        "A",
        i[7],
        i[2],
        i[3],
        i[4],
        i[5],
        !i[6],
        i[1]
      ];
  }
}
const tu = (() => {
  const i = te(), e = ma.create(), n = te(), s = te();
  return function([
    a,
    o,
    h,
    c,
    l,
    u,
    f,
    d
  ]) {
    if (h === 0 || c === 0)
      return null;
    ma.fromRotation(e, -Ov(l)), tt.sub(i, o, d), tt.scale(i, i, 0.5), tt.transformMat2(i, i, e);
    let p = h * h, y = c * c;
    const x = i[0] * i[0], g = i[1] * i[1];
    h = Math.abs(h), c = Math.abs(c);
    const m = x / p + g / y + 1e-12;
    if (m > 1) {
      const _ = Math.sqrt(m);
      h *= _, c *= _;
      const T = Math.abs(m);
      p *= T, y *= T;
    }
    const v = u === f ? -1 : 1, w = Math.sqrt(
      (p * y - p * g - y * x) / (p * g + y * x)
    ), b = v * w * (h * i[1] / c), S = v * w * (-c * i[0] / h);
    ma.transpose(e, e), tt.add(n, o, d), tt.scale(n, n, 0.5), tt.transformMat2(s, [b, S], e), tt.add(s, s, n);
    const E = [
      (i[0] - b) / h,
      (i[1] - S) / c
    ], A = nx([1, 0], E);
    let M = nx(E, [
      (-i[0] - b) / h,
      (-i[1] - S) / c
    ]);
    return !f && M > 0 ? M -= ex : f && M < 0 && (M += ex), {
      center: [s[0], s[1]],
      theta1: A,
      deltaTheta: M,
      rx: h,
      ry: c,
      phi: l
    };
  };
})(), ix = (() => {
  const i = te(), e = te(), n = ma.create();
  return function({
    center: r,
    theta1: a,
    deltaTheta: o,
    rx: h,
    ry: c,
    phi: l
  }) {
    ma.fromRotation(n, l), tt.set(i, h * Math.cos(a), c * Math.sin(a)), tt.transformMat2(i, i, n), tt.add(i, i, r), tt.set(
      e,
      h * Math.cos(a + o),
      c * Math.sin(a + o)
    ), tt.transformMat2(e, e, n), tt.add(e, e, r);
    const u = Math.abs(o) > Math.PI, f = o > 0;
    return ["A", [i[0], i[1]], h, c, l, u, f, [e[0], e[1]]];
  };
})(), da = (() => {
  const i = te(), e = te(), n = te(), s = te(), r = te(), a = te();
  return function(h, c) {
    switch (h[0]) {
      case "L":
        tt.lerp(a, h[1], h[2], c);
        break;
      case "C":
        tt.lerp(i, h[1], h[2], c), tt.lerp(e, h[2], h[3], c), tt.lerp(n, h[3], h[4], c), tt.lerp(s, i, e, c), tt.lerp(r, e, n, c), tt.lerp(a, s, r, c);
        break;
      case "Q":
        tt.lerp(i, h[1], h[2], c), tt.lerp(e, h[2], h[3], c), tt.lerp(a, i, e, c);
        break;
      case "A": {
        const l = tu(h);
        if (!l) {
          tt.lerp(a, h[1], h[7], c);
          break;
        }
        const { deltaTheta: u, phi: f, theta1: d, rx: p, ry: y, center: x } = l, g = d + c * u;
        tt.set(a, p * Math.cos(g), y * Math.sin(g)), tt.rotate(a, a, [0, 0], f), tt.add(a, a, x);
        break;
      }
    }
    return [a[0], a[1]];
  };
})(), Lv = (() => {
  const i = os.create(), e = os.create();
  return function(s, r = Math.PI / 2) {
    const a = tu(s);
    if (!a)
      return [["L", s[1], s[7]]];
    const { center: o, theta1: h, deltaTheta: c, rx: l, ry: u } = a, f = Math.ceil(Math.abs(c) / r);
    os.fromTranslation(i, o), os.rotate(i, i, Ov(s[4])), os.scale(i, i, [l, u]);
    const d = [], p = c / f, y = 4 / 3 * Math.tan(p / 4), x = Math.sin(p), g = Math.cos(p);
    for (let m = 0; m < f; m++) {
      const v = [1, 0], w = [1, y], b = [
        g + y * x,
        x - y * g
      ], S = [g, x];
      os.fromRotation(e, h + m * p), os.mul(e, i, e), tt.transformMat2d(v, v, e), tt.transformMat2d(w, w, e), tt.transformMat2d(b, b, e), tt.transformMat2d(S, S, e), d.push(["C", v, w, b, S]);
    }
    return d;
  };
})();
function sx(i, e, n, s, r) {
  const a = Xn(i, e, r), o = Xn(e, n, r), h = Xn(n, s, r), c = Xn(a, o, r), l = Xn(o, h, r);
  return Xn(c, l, r);
}
function rx(i, e, n, s) {
  let r = Math.min(i, s), a = Math.max(i, s);
  const o = 3 * (-i + 3 * e - 3 * n + s), h = 6 * (i - 2 * e + n), c = 3 * (e - i), l = h * h - 4 * o * c;
  if (l < 0 || o === 0)
    return [r, a];
  const u = Math.sqrt(l), f = (-h - u) / (2 * o);
  if (0 < f && f < 1) {
    const p = sx(i, e, n, s, f);
    r = Math.min(r, p), a = Math.max(a, p);
  }
  const d = (-h + u) / (2 * o);
  if (0 < d && d < 1) {
    const p = sx(i, e, n, s, d);
    r = Math.min(r, p), a = Math.max(a, p);
  }
  return [r, a];
}
function Lz(i, e, n, s) {
  const r = Xn(i, e, s), a = Xn(e, n, s);
  return Xn(r, a, s);
}
function ax(i, e, n) {
  let s = Math.min(i, n), r = Math.max(i, n);
  const a = i - 2 * e + n;
  if (a === 0)
    return [s, r];
  const o = (i - e) / a;
  if (0 <= o && o <= 1) {
    const h = Lz(i, e, n, o);
    s = Math.min(s, h), r = Math.max(r, h);
  }
  return [s, r];
}
function Qi(i, e, n) {
  const s = (i - e) / (n - e);
  return 0 <= s && s <= 1;
}
function Bn(i) {
  switch (i[0]) {
    case "L":
      return {
        top: Math.min(i[1][1], i[2][1]),
        right: Math.max(i[1][0], i[2][0]),
        bottom: Math.max(i[1][1], i[2][1]),
        left: Math.min(i[1][0], i[2][0])
      };
    case "C": {
      const [e, n] = rx(
        i[1][0],
        i[2][0],
        i[3][0],
        i[4][0]
      ), [s, r] = rx(
        i[1][1],
        i[2][1],
        i[3][1],
        i[4][1]
      );
      return { top: s, right: n, bottom: r, left: e };
    }
    case "Q": {
      const [e, n] = ax(
        i[1][0],
        i[2][0],
        i[3][0]
      ), [s, r] = ax(
        i[1][1],
        i[2][1],
        i[3][1]
      );
      return { top: s, right: n, bottom: r, left: e };
    }
    case "A": {
      const e = tu(i);
      if (!e)
        return Nr(
          Jc(i[1], 0),
          i[7]
        );
      const { theta1: n, deltaTheta: s, phi: r, center: a, rx: o, ry: h } = e;
      if (r === 0 || o === h) {
        const u = n + s;
        let f = Nr(
          Jc(i[1], 0),
          i[7]
        );
        return (Qi(-Math.PI, n, u) || Qi(Math.PI, n, u)) && (f = Nr(f, [
          a[0] - o,
          a[1]
        ])), (Qi(-Math.PI / 2, n, u) || Qi(3 * Math.PI / 2, n, u)) && (f = Nr(f, [
          a[0],
          a[1] - h
        ])), (Qi(0, n, u) || Qi(2 * Math.PI, n, u)) && (f = Nr(f, [
          a[0] + o,
          a[1]
        ])), (Qi(Math.PI / 2, n, u) || Qi(5 * Math.PI / 2, n, u)) && (f = Nr(f, [
          a[0],
          a[1] + h
        ])), Rz(f, 1e-11);
      }
      const c = Lv(i, Math.PI / 16);
      let l = null;
      for (const u of c)
        l = Av(
          l,
          Bn(u)
        );
      return l || Jc(i[1], 0);
    }
  }
}
function Fv(i, e) {
  const n = i[1], s = i[2], r = tt.lerp(te(), n, s, e);
  return [
    ["L", n, r],
    ["L", r, s]
  ];
}
function Qc(i, e) {
  const n = i[1], s = i[2], r = i[3], a = i[4], o = tt.lerp(te(), n, s, e), h = tt.lerp(te(), s, r, e), c = tt.lerp(te(), r, a, e), l = tt.lerp(te(), o, h, e), u = tt.lerp(te(), h, c, e), f = tt.lerp(te(), l, u, e);
  return [
    ["C", n, o, l, f],
    ["C", f, u, c, a]
  ];
}
function Fz(i, e) {
  const n = i[1], s = i[2], r = i[3], a = tt.lerp(te(), n, s, e), o = tt.lerp(te(), s, r, e), h = tt.lerp(te(), a, o, e);
  return [
    ["Q", n, a, h],
    ["Q", h, o, r]
  ];
}
function Nz(i, e) {
  const n = tu(i);
  if (!n)
    return Fv(["L", i[1], i[7]], e);
  const s = n.deltaTheta * e;
  return [
    ix({
      ...n,
      deltaTheta: s
    }),
    ix({
      ...n,
      theta1: n.theta1 + s,
      deltaTheta: n.deltaTheta - s
    })
  ];
}
function Od(i, e) {
  switch (i[0]) {
    case "L":
      return Fv(i, e);
    case "C":
      return Qc(i, e);
    case "Q":
      return Fz(i, e);
    case "A":
      return Nz(i, e);
  }
}
function m0([[i, e], [n, s]], [[r, a], [o, h]], c) {
  const l = n - i, u = r - o, f = r - i, d = s - e, p = a - h, y = a - e, x = l * p - d * u;
  if (Math.abs(x) < c.collinear) return null;
  const g = (f * p - y * u) / x, m = (l * y - d * f) / x;
  return -c.param <= g && g <= 1 + c.param && -c.param <= m && m <= 1 + c.param ? [g, m] : null;
}
function Bz(i, e, n) {
  return !!m0(i, e, n);
}
function ox(i) {
  const [e, n] = Od(i.seg, 0.5), s = (i.startParam + i.endParam) / 2;
  return [
    {
      seg: e,
      startParam: i.startParam,
      endParam: s,
      boundingBox: Bn(e)
    },
    {
      seg: n,
      startParam: s,
      endParam: i.endParam,
      boundingBox: Bn(n)
    }
  ];
}
function hx(i) {
  switch (i[0]) {
    case "L":
      return [i[1], i[2]];
    case "C":
      return [i[1], i[4]];
    case "Q":
      return [i[1], i[3]];
    case "A":
      return [i[1], i[7]];
  }
}
function Dz({ seg: i, boundingBox: e }, { seg: n, boundingBox: s }, r) {
  return i[0] === "L" ? n[0] === "L" ? Bz(
    [i[1], i[2]],
    [n[1], n[2]],
    r
  ) : Cl([i[1], i[2]], s) : n[0] === "L" ? Cl([n[1], n[2]], e) : Zc(e, s);
}
function v0(i, e, n) {
  const s = i[0];
  if (e[0] !== s) return !1;
  switch (s) {
    case "L":
      return je(i[1], e[1], n) && je(i[2], e[2], n);
    case "C":
      return je(i[1], e[1], n) && je(i[2], e[2], n) && je(i[3], e[3], n) && je(i[4], e[4], n);
    case "Q":
      return je(i[1], e[1], n) && je(i[2], e[2], n) && je(i[3], e[3], n);
    case "A":
      return je(i[1], e[1], n) && Math.abs(i[2] - e[2]) < n && Math.abs(i[3] - e[3]) < n && (Math.abs(i[2] - i[3]) < n || Math.abs(i[4] - e[4]) < n) && // TODO: Handle rotations by Pi/2.
      i[5] === e[5] && i[6] === e[6] && je(i[7], e[7], n);
  }
}
function qz(i, e, n) {
  const s = tt.sub([0, 0], i[1], i[0]), r = tt.sub([0, 0], e[1], e[0]);
  tt.normalize(s, s), tt.normalize(r, r);
  const a = Math.abs(tt.dot(s, r));
  return Math.abs(a - 1) < n;
}
const $z = (() => {
  const i = te(), e = te(), n = te(), s = te(), r = te(), a = te();
  return function(h, c) {
    tt.sub(i, h[1], h[0]), tt.sub(e, c[1], c[0]), tt.scale(i, i, 1 / tt.squaredLength(i)), tt.scale(e, e, 1 / tt.squaredLength(e));
    const l = [];
    tt.sub(n, c[0], h[0]);
    const u = tt.dot(n, i);
    u >= 0 && u <= 1 && l.push([u, 0]), tt.sub(s, c[1], h[0]);
    const f = tt.dot(s, i);
    f >= 0 && f <= 1 && l.push([f, 1]), tt.sub(r, h[0], c[0]);
    const d = tt.dot(r, e);
    d >= 0 && d <= 1 && l.push([0, d]), tt.sub(a, h[1], c[0]);
    const p = tt.dot(a, e);
    return p >= 0 && p <= 1 && l.push([1, p]), l;
  };
})();
function Nv(i, e, n) {
  if (i[0] === "L" && e[0] === "L") {
    const o = [i[1], i[2]], h = [e[1], e[2]];
    if (qz(o, h, n.collinear))
      return $z(o, h);
    const c = m0(o, h, n);
    return c ? [c] : [];
  }
  let s = [
    [
      {
        seg: i,
        startParam: 0,
        endParam: 1,
        boundingBox: Bn(i)
      },
      {
        seg: e,
        startParam: 0,
        endParam: 1,
        boundingBox: Bn(e)
      }
    ]
  ];
  const r = [];
  function a(o) {
    return Pv(o.boundingBox) <= n.linear || o.endParam - o.startParam < n.param;
  }
  for (; s.length; ) {
    const o = [];
    for (const [h, c] of s) {
      if (v0(h.seg, c.seg, n.point))
        continue;
      const l = a(h), u = a(c);
      if (l && u) {
        const f = hx(h.seg), d = hx(c.seg), p = m0(
          f,
          d,
          n
        );
        p && r.push([
          Xn(h.startParam, h.endParam, p[0]),
          Xn(c.startParam, c.endParam, p[1])
        ]);
      } else {
        const f = l ? [h] : ox(h), d = u ? [c] : ox(c);
        for (const p of f)
          for (const y of d)
            Dz(p, y, n) && o.push([p, y]);
      }
    }
    s = o;
  }
  return r;
}
function Vz(i) {
  return typeof i == "number";
}
function Gz(i) {
  return typeof i == "string";
}
function Uz(i) {
  return typeof i == "boolean";
}
const ko = Object.hasOwn;
function eu(i) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n, ...s) => {
    if (e.has(n))
      return e.get(n);
    {
      const r = i(n, ...s);
      return e.set(n, r), r;
    }
  };
}
function Wz(i, e) {
  return i.reduce((n, s) => n + (e(s) ? 1 : 0), 0);
}
function* Pl(i, e) {
  let n = 0;
  for (const s of i)
    yield e(s, n++);
}
const Yz = 8, jz = 8, ln = {
  point: 1e-6,
  linear: 1e-4,
  param: 1e-8,
  collinear: Number.MIN_VALUE * 64
};
var Bv = /* @__PURE__ */ ((i) => (i[i.Union = 0] = "Union", i[i.Difference = 1] = "Difference", i[i.Intersection = 2] = "Intersection", i[i.Exclusion = 3] = "Exclusion", i[i.Division = 4] = "Division", i[i.Fracture = 5] = "Fracture", i))(Bv || {}), Dv = /* @__PURE__ */ ((i) => (i[i.NonZero = 0] = "NonZero", i[i.EvenOdd = 1] = "EvenOdd", i))(Dv || {});
function Hz(i) {
  return i.values().next().value;
}
function qv() {
  let i = 0;
  return eu(() => i++);
}
function cx(i) {
  return (e) => ({ seg: e, parent: i });
}
function Xz(i) {
  for (let e = 0; e < i.length; e++) {
    const n = i[e];
    if (n.seg[0] !== "C") continue;
    const s = Rv(n.seg);
    if (!s) continue;
    s[0] > s[1] && s.reverse();
    const [r, a] = s;
    if (Math.abs(r - a) < ln.param) {
      const [o, h] = Qc(n.seg, r);
      i[e] = {
        seg: o,
        parent: n.parent
      }, i.push({
        seg: h,
        parent: n.parent
      });
    } else {
      const [o, h] = Qc(n.seg, r), [c, l] = Qc(
        h,
        (a - r) / (1 - r)
      );
      i[e] = {
        seg: o,
        parent: n.parent
      }, i.push(
        {
          seg: c,
          parent: n.parent
        },
        {
          seg: l,
          parent: n.parent
        }
      );
    }
  }
}
function Zz(i) {
  const e = i.map((h) => ({
    ...h,
    boundingBox: Bn(h.seg)
  })), n = e.reduce(
    (h, { boundingBox: c }) => Av(h, c),
    null
  );
  if (!n)
    return { edges: [], totalBoundingBox: null };
  const s = new hr(
    n,
    Yz
  ), r = {};
  function a(h, c) {
    ko(r, h) || (r[h] = []), r[h].push(c);
  }
  for (let h = 0; h < e.length; h++) {
    const c = e[h], l = s.find(c.boundingBox);
    for (const u of l) {
      const f = i[u], d = Nv(
        c.seg,
        f.seg,
        ln
      );
      for (const [p, y] of d)
        a(h, p), a(u, y);
    }
    s.insert(c.boundingBox, h);
  }
  const o = [];
  for (let h = 0; h < e.length; h++) {
    const c = e[h];
    if (!ko(r, h)) {
      o.push(c);
      continue;
    }
    const l = r[h];
    l.sort();
    let u = c.seg, f = 0;
    for (let d = 0; d < l.length; d++) {
      const p = l[d];
      if (p > 1 - ln.param) break;
      const y = (p - f) / (1 - f);
      if (f = p, y < ln.param || y > 1 - ln.param) continue;
      const [x, g] = Od(u, y);
      o.push({
        seg: x,
        boundingBox: Bn(x),
        parent: c.parent
      }), u = g;
    }
    o.push({
      seg: u,
      boundingBox: Bn(u),
      parent: c.parent
    });
  }
  return { edges: o, totalBoundingBox: n };
}
function Jz(i, e) {
  const n = new hr(
    e,
    jz
  ), s = [];
  function r(c) {
    const l = Jc(c, ln.point), u = n.find(l);
    if (u.size)
      return Hz(u);
    {
      const f = {
        point: c,
        outgoingEdges: []
      };
      return n.insert(l, f), s.push(f), f;
    }
  }
  const a = qv(), o = {};
  return {
    edges: i.flatMap((c) => {
      const l = r(Rd(c.seg)), u = r(kv(c.seg));
      if (l === u)
        switch (c.seg[0]) {
          case "L":
            return [];
          case "C":
            if (je(c.seg[1], c.seg[2], ln.point) && je(c.seg[3], c.seg[4], ln.point))
              return [];
            break;
          case "Q":
            if (je(c.seg[1], c.seg[2], ln.point))
              return [];
            break;
          case "A":
            if (c.seg[5] === !1)
              return [];
            break;
        }
      const f = `${a(l)}:${a(u)}`;
      if (ko(o, f)) {
        const x = o[f].find(
          (g) => v0(g[0].seg, c.seg, ln.point)
        );
        if (x)
          return x[1].parent |= c.parent, x[2].parent |= c.parent, [];
      }
      const d = `${a(u)}:${a(l)}`;
      if (ko(o, d)) {
        const x = Al(c.seg), g = o[d].find(
          (m) => v0(m[0].seg, x, ln.point)
        );
        if (g)
          return g[0].parent === c.parent ? [] : (g[1].parent |= c.parent, g[1].directionFlagA = c.parent === 1, g[1].directionFlagB = c.parent === 2, g[2].parent |= c.parent, g[2].directionFlagA = c.parent === 1, g[2].directionFlagB = c.parent === 2, []);
      }
      const p = {
        ...c,
        incidentVertices: [l, u],
        directionFlag: !1,
        directionFlagA: !1,
        directionFlagB: !1,
        twin: null
      }, y = {
        ...c,
        incidentVertices: [u, l],
        directionFlag: !0,
        directionFlagA: c.parent === 1,
        directionFlagB: c.parent === 2,
        twin: p
      };
      return p.twin = y, l.outgoingEdges.push(p), u.outgoingEdges.push(y), ko(o, f) ? o[f].push([c, p, y]) : o[f] = [[c, p, y]], [p, y];
    }),
    vertices: s
  };
}
function fo(i) {
  return i.outgoingEdges.length;
}
function Qz({ vertices: i }) {
  const e = [], n = [], s = eu((c) => {
    const l = { outgoingEdges: [] };
    return n.push(l), l;
  }), r = qv(), a = {}, o = /* @__PURE__ */ new WeakSet();
  for (const c of i) {
    if (fo(c) === 2) continue;
    const l = s(c);
    for (const u of c.outgoingEdges) {
      const f = [];
      let d = u;
      for (; d.parent === u.parent && d.directionFlag === u.directionFlag && d.directionFlagA === u.directionFlagA && d.directionFlagB === u.directionFlagB && fo(d.incidentVertices[1]) === 2; ) {
        f.push(d.seg), o.add(d.incidentVertices[1]);
        const [v, w] = d.incidentVertices[1].outgoingEdges;
        tx(
          v.twin === d || w.twin === d,
          "Wrong twin structure."
        ), d = v.twin === d ? w : v;
      }
      f.push(d.seg);
      const p = s(d.incidentVertices[1]);
      vi(d.twin, "Edge doesn't have a twin."), vi(u.twin, "Edge doesn't have a twin.");
      const y = `${r(u)}-${r(d)}`, x = `${r(d.twin)}-${r(u.twin)}`, g = a[x] ?? null, m = {
        segments: f,
        parent: u.parent,
        incidentVertices: [l, p],
        directionFlag: u.directionFlag,
        directionFlagA: u.directionFlagA,
        directionFlagB: u.directionFlagB,
        twin: g
      };
      g && (g.twin = m), a[y] = m, l.outgoingEdges.push(m), e.push(m);
    }
  }
  const h = [];
  for (const c of i) {
    if (fo(c) !== 2 || o.has(c)) continue;
    let l = c.outgoingEdges[0];
    const u = {
      segments: [],
      parent: l.parent,
      directionFlag: l.directionFlag,
      directionFlagA: l.directionFlagA,
      directionFlagB: l.directionFlagB
    };
    do {
      u.segments.push(l.seg), o.add(l.incidentVertices[0]), Iv(
        fo(l.incidentVertices[1]),
        2,
        "Found an unvisited vertex of order != 2."
      );
      const [f, d] = l.incidentVertices[1].outgoingEdges;
      tx(
        f.twin === l || d.twin === l,
        "Wrong twin structure."
      ), l = f.twin === l ? d : f;
    } while (l.incidentVertices[0] !== c);
    h.push(u);
  }
  return {
    edges: e,
    vertices: n,
    cycles: h
  };
}
function Kz(i) {
  function e(o) {
    const h = /* @__PURE__ */ new WeakSet(), c = /* @__PURE__ */ new WeakMap();
    function l(u, f, d) {
      if (c.has(u))
        return c.get(u);
      c.set(u, d);
      let p = 1 / 0;
      for (const y of u.outgoingEdges)
        y.parent & o && y !== f && (p = Math.min(
          p,
          l(y.incidentVertices[1], y.twin, d + 1)
        ));
      return p <= d && h.add(u), p;
    }
    for (const u of i.edges)
      u.parent & o && l(u.incidentVertices[0], null, 0);
    return h;
  }
  const n = e(1), s = e(2);
  function r(o) {
    return n.has(o) || s.has(o);
  }
  function a(o) {
    return (o.parent & 1) === 1 && n.has(o.incidentVertices[0]) && n.has(o.incidentVertices[1]) || (o.parent & 2) === 2 && s.has(o.incidentVertices[0]) && s.has(o.incidentVertices[1]);
  }
  i.vertices = i.vertices.filter(r);
  for (const o of i.vertices)
    o.outgoingEdges = o.outgoingEdges.filter(a);
  i.edges = i.edges.filter(a);
}
function tC({ directionFlag: i, segments: e }) {
  let n, s;
  const r = e[0];
  return i ? (n = da(r, 1), s = da(r, 1 - ln.param)) : (n = da(r, 0), s = da(r, ln.param)), Math.atan2(s[1] - n[1], s[0] - n[0]);
}
function eC({ vertices: i }) {
  const e = eu(tC);
  for (const n of i)
    fo(n) > 2 && n.outgoingEdges.sort((s, r) => e(s) - e(r));
}
function nC(i) {
  const { outgoingEdges: e } = i.incidentVertices[1], n = e.findIndex((s) => s.twin === i);
  return e[(n + 1) % e.length];
}
const iC = eu(
  (i) => i.incidentEdges.flatMap((e) => {
    const s = [];
    for (const r of e.segments)
      for (let a = 0; a < 64; a++) {
        const o = a / 64, h = e.directionFlag ? 1 - o : o;
        s.push(da(r, h));
      }
    return s;
  })
);
function $v(i, e, n) {
  const s = i >= n, r = e < n;
  return s === r;
}
function Vv(i, e, n) {
  return $v(i[1], e[1], n[1]) ? kz(n[1], i[1], e[1], i[0], e[0]) >= n[0] : !1;
}
function sC(i, e) {
  if (i.length <= 2) return 0;
  let n = i[i.length - 1], s = 0;
  for (const r of i)
    Vv(n, r, e) && (s += r[1] > n[1] ? -1 : 1), n = r;
  return s;
}
function lx(i) {
  const e = iC(i);
  for (let n = 0; n < e.length; n++) {
    const s = e[n], r = e[(n + 1) % e.length], a = e[(n + 2) % e.length], o = [
      (s[0] + r[0] + a[0]) / 3,
      (s[1] + r[1] + a[1]) / 3
    ], h = sC(e, o);
    if (h !== 0)
      return {
        winding: h,
        point: o
      };
  }
  Oz("No ear in polygon found.");
}
function rC({ edges: i, cycles: e }) {
  const n = [], s = /* @__PURE__ */ new WeakMap();
  for (const h of i) {
    if (s.has(h)) continue;
    const c = {
      incidentEdges: [],
      flag: 0
    };
    let l = h;
    do {
      vi(l.twin, "Edge doesn't have a twin");
      const u = s.get(l.twin) ?? null, f = {
        segments: l.segments,
        parent: l.parent,
        incidentVertex: c,
        directionFlag: l.directionFlag,
        directionFlagA: l.directionFlagA,
        directionFlagB: l.directionFlagB,
        twin: u
      };
      u && (u.twin = f), s.set(l, f), c.incidentEdges.push(f), l = nC(l);
    } while (l !== h);
    n.push(c);
  }
  for (const h of e) {
    const c = {
      incidentEdges: [],
      flag: 0
    }, l = {
      segments: h.segments,
      parent: h.parent,
      incidentVertex: c,
      directionFlag: h.directionFlag,
      directionFlagA: h.directionFlagA,
      directionFlagB: h.directionFlagB,
      twin: null
    }, u = {
      incidentEdges: [],
      flag: 0
    }, f = {
      segments: [...h.segments].reverse(),
      parent: h.parent,
      incidentVertex: u,
      directionFlag: !h.directionFlag,
      directionFlagA: !h.directionFlagA,
      directionFlagB: !h.directionFlagB,
      twin: l
    };
    l.twin = f, c.incidentEdges.push(l), u.incidentEdges.push(f), n.push(c, u);
  }
  const r = [], a = /* @__PURE__ */ new WeakSet(), o = /* @__PURE__ */ new WeakSet();
  for (const h of n) {
    if (a.has(h)) continue;
    const c = [], l = [], u = (d) => {
      a.has(d) || c.push(d), a.add(d);
      for (const p of d.incidentEdges) {
        if (o.has(p))
          continue;
        const { twin: y } = p;
        vi(y, "Edge doesn't have a twin."), l.push(p, y), o.add(p), o.add(y), u(y.incidentVertex);
      }
    };
    u(h);
    const f = c.find(
      (d) => lx(d).winding < 0
    );
    vi(f, "No outer face of a component found."), Iv(
      Wz(
        c,
        (d) => lx(d).winding < 0
      ),
      1,
      "Multiple outer faces found."
    ), r.push({
      vertices: c,
      edges: l,
      outerFace: f
    });
  }
  return r;
}
function Zu(i, e) {
  return $v(i.top, i.bottom, e[1]) && i.right >= e[0];
}
function aC(i, e) {
  const n = Bn(i);
  if (!Zu(n, e)) return 0;
  let s = [
    { boundingBox: n, seg: i }
  ], r = 0;
  for (; s.length > 0; ) {
    const a = [];
    for (const { boundingBox: o, seg: h } of s)
      if (Pv(o) < ln.linear)
        Vv(
          Rd(h),
          kv(h),
          e
        ) && r++;
      else {
        const c = Od(h, 0.5), l = Bn(c[0]);
        Zu(l, e) && a.push({
          boundingBox: l,
          seg: c[0]
        });
        const u = Bn(c[1]);
        Zu(u, e) && a.push({
          boundingBox: u,
          seg: c[1]
        });
      }
    s = a;
  }
  return r;
}
function ux(i, e) {
  const n = Rd(i.edges[0].segments[0]);
  for (const s of e.vertices) {
    if (s === e.outerFace) continue;
    let r = 0;
    for (const a of s.incidentEdges)
      for (const o of a.segments)
        r += aC(
          o,
          n
        );
    if (r % 2 === 1) return s;
  }
  return null;
}
function oC(i) {
  let e = [];
  function n(s, r) {
    let a = !1;
    for (const o of s) {
      const h = ux(r, o.component);
      if (h) {
        if (o.outgoingEdges.has(h)) {
          const c = o.outgoingEdges.get(h);
          o.outgoingEdges.set(h, n(c, r));
        } else
          o.outgoingEdges.set(h, [
            { component: r, outgoingEdges: /* @__PURE__ */ new Map() }
          ]);
        a = !0;
        break;
      }
    }
    if (a)
      return s;
    {
      const o = {
        component: r,
        outgoingEdges: /* @__PURE__ */ new Map()
      }, h = [o];
      for (const c of s) {
        const l = ux(c.component, r);
        l ? o.outgoingEdges.has(l) ? o.outgoingEdges.get(l).push(c) : o.outgoingEdges.set(l, [c]) : h.push(c);
      }
      return h;
    }
  }
  for (const s of i)
    e = n(e, s);
  return e;
}
function fx(i, e) {
  switch (e) {
    case 0:
      return i === 0 ? 0 : 1;
    case 1:
      return i % 2 === 0 ? 0 : 1;
  }
}
function hC(i, e, n) {
  function s(r, a, o) {
    const h = /* @__PURE__ */ new WeakSet();
    function c(l, u, f) {
      if (h.has(l)) return;
      h.add(l);
      const d = fx(u, e), p = fx(f, n);
      l.flag = d | p << 1;
      for (const y of l.incidentEdges) {
        const x = y.twin;
        vi(x, "Edge doesn't have a twin.");
        let g = u;
        y.parent & 1 && (g += y.directionFlagA ? -1 : 1);
        let m = f;
        y.parent & 2 && (m += y.directionFlagB ? -1 : 1), c(x.incidentVertex, g, m);
      }
      if (r.outgoingEdges.has(l)) {
        const y = r.outgoingEdges.get(l);
        for (const x of y)
          s(x, u, f);
      }
    }
    vi(
      r.component.outerFace,
      "Component doesn't have an outer face."
    ), c(r.component.outerFace, a, o);
  }
  for (const r of i)
    s(r, 0, 0);
}
function* cC(i, e) {
  function* n(s) {
    for (const r of s.component.vertices)
      e(r) && (yield r);
    for (const r of s.outgoingEdges.values())
      for (const a of r)
        yield* n(a);
  }
  for (const s of i)
    yield* n(s);
}
function* lC(i) {
  function e(r) {
    return vi(r.twin, "Edge doesn't have a twin."), i.has(r.incidentVertex) === i.has(r.twin.incidentVertex);
  }
  const n = /* @__PURE__ */ new WeakMap();
  for (const r of i) {
    let a = r.incidentEdges[r.incidentEdges.length - 1];
    for (const o of r.incidentEdges)
      n.set(a, o), a = o;
  }
  const s = /* @__PURE__ */ new WeakSet();
  for (const r of i)
    for (const a of r.incidentEdges) {
      if (e(a) || s.has(a))
        continue;
      let o = a;
      do
        for (o.directionFlag ? yield* Pl(o.segments, Al) : yield* o.segments, s.add(o), o = n.get(o); e(o); )
          vi(o.twin, "Edge doesn't have a twin."), o = n.get(o.twin);
      while (o !== a);
    }
}
function uC(i, e) {
  const n = [];
  function s(r) {
    for (const a of r.component.vertices) {
      if (!e(a) || a === r.component.outerFace)
        continue;
      const o = [];
      for (const h of a.incidentEdges)
        h.directionFlag ? o.push(...h.segments.map(Al)) : o.push(...h.segments);
      if (r.outgoingEdges.has(a))
        for (const h of r.outgoingEdges.get(a)) {
          const { outerFace: c } = h.component;
          vi(c, "Component has no outer face.");
          for (const l of c.incidentEdges)
            l.directionFlag ? o.push(...l.segments.map(Al)) : o.push(...l.segments);
        }
      n.push(o);
    }
    for (const a of r.outgoingEdges.values())
      for (const o of a)
        s(o);
  }
  for (const r of i)
    s(r);
  return n;
}
const fC = {
  0: ({ flag: i }) => i > 0,
  1: ({ flag: i }) => i === 1,
  2: ({ flag: i }) => i === 3,
  3: ({ flag: i }) => i === 1 || i === 2,
  4: ({ flag: i }) => (i & 1) === 1,
  5: ({ flag: i }) => i > 0
};
function dC(i, e, n, s, r) {
  const a = [
    ...Pl(i, cx(1)),
    ...Pl(n, cx(2))
  ];
  Xz(a);
  const { edges: o, totalBoundingBox: h } = Zz(a);
  if (!h)
    return [];
  const c = Jz(o, h), l = Qz(c);
  Kz(l), eC(l);
  const u = rC(l), f = oC(u);
  hC(f, e, s);
  const d = fC[r];
  switch (r) {
    case 4:
    case 5:
      return uC(f, d);
    default: {
      const p = new Set(
        cC(f, d)
      );
      return [[...lC(p)]];
    }
  }
}
function* pC(i) {
  let e = [0, 0], n = e;
  for (const s of i)
    switch (s[0]) {
      case "M":
        yield s, e = n = s[1];
        break;
      case "L":
        yield s, e = s[1];
        break;
      case "C":
        yield s, e = s[3];
        break;
      case "S":
        yield s, e = s[2];
        break;
      case "Q":
        yield s, e = s[2];
        break;
      case "T":
        yield s, e = s[1];
        break;
      case "A":
        yield s, e = s[6];
        break;
      case "Z":
      case "z":
        e = n, yield ["Z"];
        break;
      case "H":
        e = [s[1], e[1]], yield ["L", e];
        break;
      case "V":
        e = [e[0], s[1]], yield ["L", e];
        break;
      case "m":
        e = n = [
          e[0] + s[1],
          e[1] + s[2]
        ], yield ["M", e];
        break;
      case "l":
        e = [e[0] + s[1], e[1] + s[2]], yield ["L", e];
        break;
      case "h":
        e = [e[0] + s[1], e[1]], yield ["L", e];
        break;
      case "v":
        e = [e[0], e[1] + s[1]], yield ["L", e];
        break;
      case "c":
        yield [
          "C",
          [e[0] + s[1], e[1] + s[2]],
          [e[0] + s[3], e[1] + s[4]],
          e = [
            e[0] + s[5],
            e[1] + s[6]
          ]
        ];
        break;
      case "s":
        yield [
          "S",
          [e[0] + s[1], e[1] + s[2]],
          e = [
            e[0] + s[3],
            e[1] + s[4]
          ]
        ];
        break;
      case "q":
        yield [
          "Q",
          [e[0] + s[1], e[1] + s[2]],
          e = [
            e[0] + s[3],
            e[1] + s[4]
          ]
        ];
        break;
      case "t":
        yield [
          "T",
          e = [
            e[0] + s[1],
            e[1] + s[2]
          ]
        ];
        break;
      case "a":
        yield [
          "A",
          s[1],
          s[2],
          s[3],
          s[4],
          s[5],
          e = [
            e[0] + s[6],
            e[1] + s[7]
          ]
        ];
        break;
    }
}
function dx(i, e) {
  return [2 * i[0] - e[0], 2 * i[1] - e[1]];
}
function* Gv(i) {
  let e = null, n = null, s = null;
  function r() {
    throw new Error("Bad SVG path data sequence.");
  }
  for (const a of pC(i))
    switch (a[0]) {
      case "M":
        n = e = a[1], s = null;
        break;
      case "L":
        n || r(), yield ["L", n, a[1]], n = a[1], s = null;
        break;
      case "C":
        n || r(), yield ["C", n, a[1], a[2], a[3]], n = a[3], s = a[2];
        break;
      case "S":
        n || r(), s || r(), yield [
          "C",
          n,
          dx(n, s),
          a[1],
          a[2]
        ], n = a[2], s = a[1];
        break;
      case "Q":
        n || r(), yield ["Q", n, a[1], a[2]], n = a[2], s = a[1];
        break;
      case "T":
        n || r(), s || r(), s = dx(
          n,
          s
        ), yield ["Q", n, s, a[1]], n = a[1];
        break;
      case "A":
        n || r(), yield [
          "A",
          n,
          a[1],
          a[2],
          a[3],
          a[4],
          a[5],
          a[6]
        ], n = a[6], s = null;
        break;
      case "Z":
      case "z":
        n || r(), e || r(), yield ["L", n, e], n = e, s = null;
        break;
    }
}
function* Uv(i, e = 1e-4) {
  let n = null;
  for (const s of i)
    switch ((!n || !je(s[1], n, e)) && (yield ["M", s[1]]), s[0]) {
      case "L":
        yield ["L", n = s[2]];
        break;
      case "C":
        yield ["C", s[2], s[3], n = s[4]];
        break;
      case "Q":
        yield ["Q", s[2], n = s[3]];
        break;
      case "A":
        yield [
          "A",
          s[2],
          s[3],
          s[4],
          s[5],
          s[6],
          n = s[7]
        ];
        break;
    }
}
const px = Symbol();
function* Wv(i) {
  const e = /(-?\d*(?:\d\.|\.\d|\d)\d*(?:[eE][+\-]?\d+)?)/y, n = /([MLCSQTAZHVmlhvcsqtaz])/y, s = /([01])/y, r = /\s*,?\s*/y;
  let a = 0;
  function o() {
    r.lastIndex = a, r.exec(i) !== null && (a = r.lastIndex);
  }
  let h = "M", c = -1;
  function l() {
    if (o(), a > i.length - 1) return px;
    n.lastIndex = a;
    const d = n.exec(i);
    if (!d)
      switch (h) {
        case "M":
          return "L";
        case "m":
          return "l";
        case "Z":
        case "z":
          if (a === c)
            throw new Error(
              `Invalid path data. Invalid syntax at index ${a}.`
            );
          return c = a, h;
        default:
          return h;
      }
    return a = n.lastIndex, d[1];
  }
  function u() {
    o(), e.lastIndex = a;
    const d = e.exec(i);
    if (!d)
      throw new Error(
        `Invalid path data. Expected a number at index ${a}.`
      );
    return a = e.lastIndex, Number(d[1]);
  }
  function f() {
    o(), s.lastIndex = a;
    const d = s.exec(i);
    if (!d)
      throw new Error(
        `Invalid path data. Expected a flag at index ${a}.`
      );
    return a = s.lastIndex, d[1] === "1";
  }
  for (; ; )
    switch (l()) {
      case "M":
        yield [h = "M", [u(), u()]];
        break;
      case "L":
        yield [h = "L", [u(), u()]];
        break;
      case "C":
        yield [
          h = "C",
          [u(), u()],
          [u(), u()],
          [u(), u()]
        ];
        break;
      case "S":
        yield [
          h = "S",
          [u(), u()],
          [u(), u()]
        ];
        break;
      case "Q":
        yield [
          h = "Q",
          [u(), u()],
          [u(), u()]
        ];
        break;
      case "T":
        yield [h = "T", [u(), u()]];
        break;
      case "A":
        yield [
          h = "A",
          u(),
          u(),
          u(),
          f(),
          f(),
          [u(), u()]
        ];
        break;
      case "Z":
      case "z":
        yield [h = "Z"];
        break;
      case "H":
        yield [h = "H", u()];
        break;
      case "V":
        yield [h = "V", u()];
        break;
      case "m":
        yield [h = "m", u(), u()];
        break;
      case "l":
        yield [h = "l", u(), u()];
        break;
      case "h":
        yield [h = "h", u()];
        break;
      case "v":
        yield [h = "v", u()];
        break;
      case "c":
        yield [
          h = "c",
          u(),
          u(),
          u(),
          u(),
          u(),
          u()
        ];
        break;
      case "s":
        yield [
          h = "s",
          u(),
          u(),
          u(),
          u()
        ];
        break;
      case "q":
        yield [
          h = "q",
          u(),
          u(),
          u(),
          u()
        ];
        break;
      case "t":
        yield [h = "t", u(), u()];
        break;
      case "a":
        yield [
          h = "a",
          u(),
          u(),
          u(),
          f(),
          f(),
          u(),
          u()
        ];
        break;
      case px:
        return;
    }
}
function yC(i) {
  return [...Gv(Wv(i))];
}
function xC(i, e = 1e-4) {
  function n(s) {
    return Gz(s) ? s : Vz(s) ? s.toFixed(12) : Uz(s) ? s ? "1" : "0" : s.map((r) => r.toFixed(12)).join(",");
  }
  return [
    ...Pl(Uv(i, e), (s) => s.map(n).join(" "))
  ].join(" ");
}
const gC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FillRule: Dv,
  PathBooleanOperation: Bv,
  arcSegmentToCubics: Lv,
  commandsFromPathData: Wv,
  pathBoolean: dC,
  pathCubicSegmentSelfIntersection: Rv,
  pathFromCommands: Gv,
  pathFromPathData: yC,
  pathSegmentBoundingBox: Bn,
  pathSegmentIntersection: Nv,
  pathToCommands: Uv,
  pathToPathData: xC,
  samplePathSegmentAt: da
}, Symbol.toStringTag, { value: "Module" }));
function Yv(i) {
  return "(" + i.x + ";" + i.y + ")";
}
function kd(i) {
  var e = i.toString();
  return e === "[object Object]" ? Yv(i) : e;
}
function jv(i, e) {
  return i.y === e.y ? i.x - e.x : i.y - e.y;
}
function mC(i, e) {
  return i.x === e.x && i.y === e.y;
}
var ji = function(i, e) {
  this.name = "PointError", this.points = e = e || [], this.message = i || "Invalid Points!";
  for (var n = 0; n < e.length; n++)
    this.message += " " + kd(e[n]);
};
ji.prototype = new Error();
ji.prototype.constructor = ji;
var Ft = function(i, e) {
  this.x = +i || 0, this.y = +e || 0, this._p2t_edge_list = null;
};
Ft.prototype.toString = function() {
  return Yv(this);
};
Ft.prototype.toJSON = function() {
  return { x: this.x, y: this.y };
};
Ft.prototype.clone = function() {
  return new Ft(this.x, this.y);
};
Ft.prototype.set_zero = function() {
  return this.x = 0, this.y = 0, this;
};
Ft.prototype.set = function(i, e) {
  return this.x = +i || 0, this.y = +e || 0, this;
};
Ft.prototype.negate = function() {
  return this.x = -this.x, this.y = -this.y, this;
};
Ft.prototype.add = function(i) {
  return this.x += i.x, this.y += i.y, this;
};
Ft.prototype.sub = function(i) {
  return this.x -= i.x, this.y -= i.y, this;
};
Ft.prototype.mul = function(i) {
  return this.x *= i, this.y *= i, this;
};
Ft.prototype.length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y);
};
Ft.prototype.normalize = function() {
  var i = this.length();
  return this.x /= i, this.y /= i, i;
};
Ft.prototype.equals = function(i) {
  return this.x === i.x && this.y === i.y;
};
Ft.negate = function(i) {
  return new Ft(-i.x, -i.y);
};
Ft.add = function(i, e) {
  return new Ft(i.x + e.x, i.y + e.y);
};
Ft.sub = function(i, e) {
  return new Ft(i.x - e.x, i.y - e.y);
};
Ft.mul = function(i, e) {
  return new Ft(i * e.x, i * e.y);
};
Ft.cross = function(i, e) {
  return typeof i == "number" ? typeof e == "number" ? i * e : new Ft(-i * e.y, i * e.x) : typeof e == "number" ? new Ft(e * i.y, -e * i.x) : i.x * e.y - i.y * e.x;
};
Ft.toString = kd;
Ft.compare = jv;
Ft.cmp = jv;
Ft.equals = mC;
Ft.dot = function(i, e) {
  return i.x * e.x + i.y * e.y;
};
var Rt = function(i, e, n) {
  this.points_ = [i, e, n], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1];
}, Ju = kd;
Rt.prototype.toString = function() {
  return "[" + Ju(this.points_[0]) + Ju(this.points_[1]) + Ju(this.points_[2]) + "]";
};
Rt.prototype.getPoint = function(i) {
  return this.points_[i];
};
Rt.prototype.GetPoint = Rt.prototype.getPoint;
Rt.prototype.getPoints = function() {
  return this.points_;
};
Rt.prototype.getNeighbor = function(i) {
  return this.neighbors_[i];
};
Rt.prototype.containsPoint = function(i) {
  var e = this.points_;
  return i === e[0] || i === e[1] || i === e[2];
};
Rt.prototype.containsEdge = function(i) {
  return this.containsPoint(i.p) && this.containsPoint(i.q);
};
Rt.prototype.containsPoints = function(i, e) {
  return this.containsPoint(i) && this.containsPoint(e);
};
Rt.prototype.isInterior = function() {
  return this.interior_;
};
Rt.prototype.setInterior = function(i) {
  return this.interior_ = i, this;
};
Rt.prototype.markNeighborPointers = function(i, e, n) {
  var s = this.points_;
  if (i === s[2] && e === s[1] || i === s[1] && e === s[2])
    this.neighbors_[0] = n;
  else if (i === s[0] && e === s[2] || i === s[2] && e === s[0])
    this.neighbors_[1] = n;
  else if (i === s[0] && e === s[1] || i === s[1] && e === s[0])
    this.neighbors_[2] = n;
  else
    throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");
};
Rt.prototype.markNeighbor = function(i) {
  var e = this.points_;
  i.containsPoints(e[1], e[2]) ? (this.neighbors_[0] = i, i.markNeighborPointers(e[1], e[2], this)) : i.containsPoints(e[0], e[2]) ? (this.neighbors_[1] = i, i.markNeighborPointers(e[0], e[2], this)) : i.containsPoints(e[0], e[1]) && (this.neighbors_[2] = i, i.markNeighborPointers(e[0], e[1], this));
};
Rt.prototype.clearNeighbors = function() {
  this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null;
};
Rt.prototype.clearDelaunayEdges = function() {
  this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1;
};
Rt.prototype.pointCW = function(i) {
  var e = this.points_;
  return i === e[0] ? e[2] : i === e[1] ? e[0] : i === e[2] ? e[1] : null;
};
Rt.prototype.pointCCW = function(i) {
  var e = this.points_;
  return i === e[0] ? e[1] : i === e[1] ? e[2] : i === e[2] ? e[0] : null;
};
Rt.prototype.neighborCW = function(i) {
  return i === this.points_[0] ? this.neighbors_[1] : i === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0];
};
Rt.prototype.neighborCCW = function(i) {
  return i === this.points_[0] ? this.neighbors_[2] : i === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1];
};
Rt.prototype.getConstrainedEdgeCW = function(i) {
  return i === this.points_[0] ? this.constrained_edge[1] : i === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0];
};
Rt.prototype.getConstrainedEdgeCCW = function(i) {
  return i === this.points_[0] ? this.constrained_edge[2] : i === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1];
};
Rt.prototype.getConstrainedEdgeAcross = function(i) {
  return i === this.points_[0] ? this.constrained_edge[0] : i === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2];
};
Rt.prototype.setConstrainedEdgeCW = function(i, e) {
  i === this.points_[0] ? this.constrained_edge[1] = e : i === this.points_[1] ? this.constrained_edge[2] = e : this.constrained_edge[0] = e;
};
Rt.prototype.setConstrainedEdgeCCW = function(i, e) {
  i === this.points_[0] ? this.constrained_edge[2] = e : i === this.points_[1] ? this.constrained_edge[0] = e : this.constrained_edge[1] = e;
};
Rt.prototype.getDelaunayEdgeCW = function(i) {
  return i === this.points_[0] ? this.delaunay_edge[1] : i === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0];
};
Rt.prototype.getDelaunayEdgeCCW = function(i) {
  return i === this.points_[0] ? this.delaunay_edge[2] : i === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1];
};
Rt.prototype.setDelaunayEdgeCW = function(i, e) {
  i === this.points_[0] ? this.delaunay_edge[1] = e : i === this.points_[1] ? this.delaunay_edge[2] = e : this.delaunay_edge[0] = e;
};
Rt.prototype.setDelaunayEdgeCCW = function(i, e) {
  i === this.points_[0] ? this.delaunay_edge[2] = e : i === this.points_[1] ? this.delaunay_edge[0] = e : this.delaunay_edge[1] = e;
};
Rt.prototype.neighborAcross = function(i) {
  return i === this.points_[0] ? this.neighbors_[0] : i === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2];
};
Rt.prototype.oppositePoint = function(i, e) {
  var n = i.pointCW(e);
  return this.pointCW(n);
};
Rt.prototype.legalize = function(i, e) {
  var n = this.points_;
  if (i === n[0])
    n[1] = n[0], n[0] = n[2], n[2] = e;
  else if (i === n[1])
    n[2] = n[1], n[1] = n[0], n[0] = e;
  else if (i === n[2])
    n[0] = n[2], n[2] = n[1], n[1] = e;
  else
    throw new Error("poly2tri Invalid Triangle.legalize() call");
};
Rt.prototype.index = function(i) {
  var e = this.points_;
  if (i === e[0])
    return 0;
  if (i === e[1])
    return 1;
  if (i === e[2])
    return 2;
  throw new Error("poly2tri Invalid Triangle.index() call");
};
Rt.prototype.edgeIndex = function(i, e) {
  var n = this.points_;
  if (i === n[0]) {
    if (e === n[1])
      return 2;
    if (e === n[2])
      return 1;
  } else if (i === n[1]) {
    if (e === n[2])
      return 0;
    if (e === n[0])
      return 2;
  } else if (i === n[2]) {
    if (e === n[0])
      return 1;
    if (e === n[1])
      return 0;
  }
  return -1;
};
Rt.prototype.markConstrainedEdgeByIndex = function(i) {
  this.constrained_edge[i] = !0;
};
Rt.prototype.markConstrainedEdgeByEdge = function(i) {
  this.markConstrainedEdgeByPoints(i.p, i.q);
};
Rt.prototype.markConstrainedEdgeByPoints = function(i, e) {
  var n = this.points_;
  e === n[0] && i === n[1] || e === n[1] && i === n[0] ? this.constrained_edge[2] = !0 : e === n[0] && i === n[2] || e === n[2] && i === n[0] ? this.constrained_edge[1] = !0 : (e === n[1] && i === n[2] || e === n[2] && i === n[1]) && (this.constrained_edge[0] = !0);
};
function Ld(i, e) {
  if (!i)
    throw new Error(e || "Assert Failed");
}
var Fd = function(i, e) {
  this.point = i, this.triangle = e || null, this.next = null, this.prev = null, this.value = i.x;
}, _i = function(i, e) {
  this.head_ = i, this.tail_ = e, this.search_node_ = i;
};
_i.prototype.head = function() {
  return this.head_;
};
_i.prototype.setHead = function(i) {
  this.head_ = i;
};
_i.prototype.tail = function() {
  return this.tail_;
};
_i.prototype.setTail = function(i) {
  this.tail_ = i;
};
_i.prototype.search = function() {
  return this.search_node_;
};
_i.prototype.setSearch = function(i) {
  this.search_node_ = i;
};
_i.prototype.findSearchNode = function() {
  return this.search_node_;
};
_i.prototype.locateNode = function(i) {
  var e = this.search_node_;
  if (i < e.value) {
    for (; e = e.prev; )
      if (i >= e.value)
        return this.search_node_ = e, e;
  } else
    for (; e = e.next; )
      if (i < e.value)
        return this.search_node_ = e.prev, e.prev;
  return null;
};
_i.prototype.locatePoint = function(i) {
  var e = i.x, n = this.findSearchNode(e), s = n.point.x;
  if (e === s) {
    if (i !== n.point)
      if (i === n.prev.point)
        n = n.prev;
      else if (i === n.next.point)
        n = n.next;
      else
        throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");
  } else if (e < s)
    for (; (n = n.prev) && i !== n.point; )
      ;
  else
    for (; (n = n.next) && i !== n.point; )
      ;
  return n && (this.search_node_ = n), n;
};
const vC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AdvancingFront: _i,
  Node: Fd
}, Symbol.toStringTag, { value: "Module" }));
var jo = 1e-12, Kc = {
  CW: 1,
  CCW: -1,
  COLLINEAR: 0
};
function wC(i, e, n) {
  var s = (i.x - n.x) * (e.y - n.y), r = (i.y - n.y) * (e.x - n.x), a = s - r;
  return a > -jo && a < jo ? Kc.COLLINEAR : a > 0 ? Kc.CCW : Kc.CW;
}
function MC(i, e, n, s) {
  var r = (i.x - e.x) * (s.y - e.y) - (s.x - e.x) * (i.y - e.y);
  if (r >= -jo)
    return !1;
  var a = (i.x - n.x) * (s.y - n.y) - (s.x - n.x) * (i.y - n.y);
  return !(a <= jo);
}
function bC(i, e, n) {
  var s = e.x - i.x, r = e.y - i.y, a = n.x - i.x, o = n.y - i.y;
  return s * a + r * o < 0;
}
var _C = jo, xe = Kc, Se = wC, Hv = MC, yx = bC;
function Xv(i) {
  i.initTriangulation(), i.createAdvancingFront(), SC(i), TC(i);
}
function SC(i) {
  var e, n = i.pointCount();
  for (e = 1; e < n; ++e)
    for (var s = i.getPoint(e), r = EC(i, s), a = s._p2t_edge_list, o = 0; a && o < a.length; ++o)
      zC(i, a[o], r);
}
function TC(i) {
  for (var e = i.front().head().next.triangle, n = i.front().head().next.point; !e.getConstrainedEdgeCW(n); )
    e = e.neighborCCW(n);
  i.meshClean(e);
}
function EC(i, e) {
  var n = i.locateNode(e), s = CC(i, e, n);
  return e.x <= n.point.x + _C && Ia(i, n), AC(i, s), s;
}
function zC(i, e, n) {
  i.edge_event.constrained_edge = e, i.edge_event.right = e.p.x > e.q.x, !Zv(n.triangle, e.p, e.q) && (kC(i, e, n), Nd(i, e.p, e.q, n.triangle, e.q));
}
function Nd(i, e, n, s, r) {
  if (!Zv(s, e, n)) {
    var a = s.pointCCW(r), o = Se(n, a, e);
    if (o === xe.COLLINEAR)
      throw new ji("poly2tri EdgeEvent: Collinear not supported!", [n, a, e]);
    var h = s.pointCW(r), c = Se(n, h, e);
    if (c === xe.COLLINEAR)
      throw new ji("poly2tri EdgeEvent: Collinear not supported!", [n, h, e]);
    o === c ? (o === xe.CW ? s = s.neighborCCW(r) : s = s.neighborCW(r), Nd(i, e, n, s, r)) : qd(i, e, n, s, r);
  }
}
function Zv(i, e, n) {
  var s = i.edgeIndex(e, n);
  if (s !== -1) {
    i.markConstrainedEdgeByIndex(s);
    var r = i.getNeighbor(s);
    return r && r.markConstrainedEdgeByPoints(e, n), !0;
  }
  return !1;
}
function CC(i, e, n) {
  var s = new Rt(e, n.point, n.next.point);
  s.markNeighbor(n.triangle), i.addToMap(s);
  var r = new Fd(e);
  return r.next = n.next, r.prev = n, n.next.prev = r, n.next = r, ws(i, s) || i.mapTriangleToNodes(s), r;
}
function Ia(i, e) {
  var n = new Rt(e.prev.point, e.point, e.next.point);
  n.markNeighbor(e.prev.triangle), n.markNeighbor(e.triangle), i.addToMap(n), e.prev.next = e.next, e.next.prev = e.prev, ws(i, n) || i.mapTriangleToNodes(n);
}
function AC(i, e) {
  for (var n = e.next; n.next && !yx(n.point, n.next.point, n.prev.point); )
    Ia(i, n), n = n.next;
  for (n = e.prev; n.prev && !yx(n.point, n.next.point, n.prev.point); )
    Ia(i, n), n = n.prev;
  e.next && e.next.next && PC(e) && RC(i, e);
}
function PC(i) {
  var e = i.point.x - i.next.next.point.x, n = i.point.y - i.next.next.point.y;
  return Ld(n >= 0, "unordered y"), e >= 0 || Math.abs(e) < n;
}
function ws(i, e) {
  for (var n = 0; n < 3; ++n)
    if (!e.delaunay_edge[n]) {
      var s = e.getNeighbor(n);
      if (s) {
        var r = e.getPoint(n), a = s.oppositePoint(e, r), o = s.index(a);
        if (s.constrained_edge[o] || s.delaunay_edge[o]) {
          e.constrained_edge[n] = s.constrained_edge[o];
          continue;
        }
        var h = IC(r, e.pointCCW(r), e.pointCW(r), a);
        if (h) {
          e.delaunay_edge[n] = !0, s.delaunay_edge[o] = !0, Jv(e, r, s, a);
          var c = !ws(i, e);
          return c && i.mapTriangleToNodes(e), c = !ws(i, s), c && i.mapTriangleToNodes(s), e.delaunay_edge[n] = !1, s.delaunay_edge[o] = !1, !0;
        }
      }
    }
  return !1;
}
function IC(i, e, n, s) {
  var r = i.x - s.x, a = i.y - s.y, o = e.x - s.x, h = e.y - s.y, c = r * h, l = o * a, u = c - l;
  if (u <= 0)
    return !1;
  var f = n.x - s.x, d = n.y - s.y, p = f * a, y = r * d, x = p - y;
  if (x <= 0)
    return !1;
  var g = o * d, m = f * h, v = r * r + a * a, w = o * o + h * h, b = f * f + d * d, S = v * (g - m) + w * x + b * u;
  return S > 0;
}
function Jv(i, e, n, s) {
  var r, a, o, h;
  r = i.neighborCCW(e), a = i.neighborCW(e), o = n.neighborCCW(s), h = n.neighborCW(s);
  var c, l, u, f;
  c = i.getConstrainedEdgeCCW(e), l = i.getConstrainedEdgeCW(e), u = n.getConstrainedEdgeCCW(s), f = n.getConstrainedEdgeCW(s);
  var d, p, y, x;
  d = i.getDelaunayEdgeCCW(e), p = i.getDelaunayEdgeCW(e), y = n.getDelaunayEdgeCCW(s), x = n.getDelaunayEdgeCW(s), i.legalize(e, s), n.legalize(s, e), n.setDelaunayEdgeCCW(e, d), i.setDelaunayEdgeCW(e, p), i.setDelaunayEdgeCCW(s, y), n.setDelaunayEdgeCW(s, x), n.setConstrainedEdgeCCW(e, c), i.setConstrainedEdgeCW(e, l), i.setConstrainedEdgeCCW(s, u), n.setConstrainedEdgeCW(s, f), i.clearNeighbors(), n.clearNeighbors(), r && n.markNeighbor(r), a && i.markNeighbor(a), o && i.markNeighbor(o), h && n.markNeighbor(h), i.markNeighbor(n);
}
function RC(i, e) {
  for (Se(e.point, e.next.point, e.next.next.point) === xe.CCW ? i.basin.left_node = e.next.next : i.basin.left_node = e.next, i.basin.bottom_node = i.basin.left_node; i.basin.bottom_node.next && i.basin.bottom_node.point.y >= i.basin.bottom_node.next.point.y; )
    i.basin.bottom_node = i.basin.bottom_node.next;
  if (i.basin.bottom_node !== i.basin.left_node) {
    for (i.basin.right_node = i.basin.bottom_node; i.basin.right_node.next && i.basin.right_node.point.y < i.basin.right_node.next.point.y; )
      i.basin.right_node = i.basin.right_node.next;
    i.basin.right_node !== i.basin.bottom_node && (i.basin.width = i.basin.right_node.point.x - i.basin.left_node.point.x, i.basin.left_highest = i.basin.left_node.point.y > i.basin.right_node.point.y, Qv(i, i.basin.bottom_node));
  }
}
function Qv(i, e) {
  if (!OC(i, e)) {
    Ia(i, e);
    var n;
    if (!(e.prev === i.basin.left_node && e.next === i.basin.right_node)) {
      if (e.prev === i.basin.left_node) {
        if (n = Se(e.point, e.next.point, e.next.next.point), n === xe.CW)
          return;
        e = e.next;
      } else if (e.next === i.basin.right_node) {
        if (n = Se(e.point, e.prev.point, e.prev.prev.point), n === xe.CCW)
          return;
        e = e.prev;
      } else
        e.prev.point.y < e.next.point.y ? e = e.prev : e = e.next;
      Qv(i, e);
    }
  }
}
function OC(i, e) {
  var n;
  return i.basin.left_highest ? n = i.basin.left_node.point.y - e.point.y : n = i.basin.right_node.point.y - e.point.y, i.basin.width > n;
}
function kC(i, e, n) {
  i.edge_event.right ? LC(i, e, n) : FC(i, e, n);
}
function LC(i, e, n) {
  for (; n.next.point.x < e.p.x; )
    Se(e.q, n.next.point, e.p) === xe.CCW ? Kv(i, e, n) : n = n.next;
}
function Kv(i, e, n) {
  n.point.x < e.p.x && (Se(n.point, n.next.point, n.next.next.point) === xe.CCW ? Bd(i, e, n) : (t2(i, e, n), Kv(i, e, n)));
}
function Bd(i, e, n) {
  Ia(i, n.next), n.next.point !== e.p && Se(e.q, n.next.point, e.p) === xe.CCW && Se(n.point, n.next.point, n.next.next.point) === xe.CCW && Bd(i, e, n);
}
function t2(i, e, n) {
  Se(n.next.point, n.next.next.point, n.next.next.next.point) === xe.CCW ? Bd(i, e, n.next) : Se(e.q, n.next.next.point, e.p) === xe.CCW && t2(i, e, n.next);
}
function FC(i, e, n) {
  for (; n.prev.point.x > e.p.x; )
    Se(e.q, n.prev.point, e.p) === xe.CW ? e2(i, e, n) : n = n.prev;
}
function e2(i, e, n) {
  n.point.x > e.p.x && (Se(n.point, n.prev.point, n.prev.prev.point) === xe.CW ? Dd(i, e, n) : (n2(i, e, n), e2(i, e, n)));
}
function n2(i, e, n) {
  Se(n.prev.point, n.prev.prev.point, n.prev.prev.prev.point) === xe.CW ? Dd(i, e, n.prev) : Se(e.q, n.prev.prev.point, e.p) === xe.CW && n2(i, e, n.prev);
}
function Dd(i, e, n) {
  Ia(i, n.prev), n.prev.point !== e.p && Se(e.q, n.prev.point, e.p) === xe.CW && Se(n.point, n.prev.point, n.prev.prev.point) === xe.CW && Dd(i, e, n);
}
function qd(i, e, n, s, r) {
  var a = s.neighborAcross(r);
  Ld(a, "FLIP failed due to missing triangle!");
  var o = a.oppositePoint(s, r);
  if (s.getConstrainedEdgeAcross(r)) {
    var h = s.index(r);
    throw new ji(
      "poly2tri Intersecting Constraints",
      [r, o, s.getPoint((h + 1) % 3), s.getPoint((h + 2) % 3)]
    );
  }
  if (Hv(r, s.pointCCW(r), s.pointCW(r), o))
    if (Jv(s, r, a, o), i.mapTriangleToNodes(s), i.mapTriangleToNodes(a), r === n && o === e)
      n === i.edge_event.constrained_edge.q && e === i.edge_event.constrained_edge.p && (s.markConstrainedEdgeByPoints(e, n), a.markConstrainedEdgeByPoints(e, n), ws(i, s), ws(i, a));
    else {
      var c = Se(n, o, e);
      s = NC(i, c, s, a, r, o), qd(i, e, n, s, r);
    }
  else {
    var l = i2(e, n, a, o);
    s2(i, e, n, s, a, l), Nd(i, e, n, s, r);
  }
}
function NC(i, e, n, s, r, a) {
  var o;
  return e === xe.CCW ? (o = s.edgeIndex(r, a), s.delaunay_edge[o] = !0, ws(i, s), s.clearDelaunayEdges(), n) : (o = n.edgeIndex(r, a), n.delaunay_edge[o] = !0, ws(i, n), n.clearDelaunayEdges(), s);
}
function i2(i, e, n, s) {
  var r = Se(e, s, i);
  if (r === xe.CW)
    return n.pointCCW(s);
  if (r === xe.CCW)
    return n.pointCW(s);
  throw new ji("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [e, s, i]);
}
function s2(i, e, n, s, r, a) {
  var o = r.neighborAcross(a);
  Ld(o, "FLIP failed due to missing triangle");
  var h = o.oppositePoint(r, a);
  if (Hv(n, s.pointCCW(n), s.pointCW(n), h))
    qd(i, n, h, o, h);
  else {
    var c = i2(e, n, o, h);
    s2(i, e, n, s, o, c);
  }
}
const BC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  triangulate: Xv
}, Symbol.toStringTag, { value: "Module" })), Qu = Fd;
var xx = 0.3, DC = function(i, e) {
  if (this.p = i, this.q = e, i.y > e.y)
    this.q = i, this.p = e;
  else if (i.y === e.y) {
    if (i.x > e.x)
      this.q = i, this.p = e;
    else if (i.x === e.x)
      throw new ji("poly2tri Invalid Edge constructor: repeated points!", [i]);
  }
  this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this);
}, r2 = function() {
  this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;
};
r2.prototype.clear = function() {
  this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;
};
var qC = function() {
  this.constrained_edge = null, this.right = !1;
}, Vt = function(i, e) {
  e = e || {}, this.triangles_ = [], this.map_ = [], this.points_ = e.cloneArrays ? i.slice(0) : i, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new r2(), this.edge_event = new qC(), this.initEdges(this.points_);
};
Vt.prototype.addHole = function(i) {
  this.initEdges(i);
  var e, n = i.length;
  for (e = 0; e < n; e++)
    this.points_.push(i[e]);
  return this;
};
Vt.prototype.AddHole = Vt.prototype.addHole;
Vt.prototype.addHoles = function(i) {
  var e, n = i.length;
  for (e = 0; e < n; e++)
    this.initEdges(i[e]);
  return this.points_ = this.points_.concat.apply(this.points_, i), this;
};
Vt.prototype.addPoint = function(i) {
  return this.points_.push(i), this;
};
Vt.prototype.AddPoint = Vt.prototype.addPoint;
Vt.prototype.addPoints = function(i) {
  return this.points_ = this.points_.concat(i), this;
};
Vt.prototype.triangulate = function() {
  return Xv(this), this;
};
Vt.prototype.getBoundingBox = function() {
  return { min: this.pmin_, max: this.pmax_ };
};
Vt.prototype.getTriangles = function() {
  return this.triangles_;
};
Vt.prototype.GetTriangles = Vt.prototype.getTriangles;
Vt.prototype.front = function() {
  return this.front_;
};
Vt.prototype.pointCount = function() {
  return this.points_.length;
};
Vt.prototype.head = function() {
  return this.head_;
};
Vt.prototype.setHead = function(i) {
  this.head_ = i;
};
Vt.prototype.tail = function() {
  return this.tail_;
};
Vt.prototype.setTail = function(i) {
  this.tail_ = i;
};
Vt.prototype.getMap = function() {
  return this.map_;
};
Vt.prototype.initTriangulation = function() {
  var i = this.points_[0].x, e = this.points_[0].x, n = this.points_[0].y, s = this.points_[0].y, r, a = this.points_.length;
  for (r = 1; r < a; r++) {
    var o = this.points_[r];
    o.x > i && (i = o.x), o.x < e && (e = o.x), o.y > n && (n = o.y), o.y < s && (s = o.y);
  }
  this.pmin_ = new Ft(e, s), this.pmax_ = new Ft(i, n);
  var h = xx * (i - e), c = xx * (n - s);
  this.head_ = new Ft(i + h, s - c), this.tail_ = new Ft(e - h, s - c), this.points_.sort(Ft.compare);
};
Vt.prototype.initEdges = function(i) {
  var e, n = i.length;
  for (e = 0; e < n; ++e)
    this.edge_list.push(new DC(i[e], i[(e + 1) % n]));
};
Vt.prototype.getPoint = function(i) {
  return this.points_[i];
};
Vt.prototype.addToMap = function(i) {
  this.map_.push(i);
};
Vt.prototype.locateNode = function(i) {
  return this.front_.locateNode(i.x);
};
Vt.prototype.createAdvancingFront = function() {
  var i, e, n, s = new Rt(this.points_[0], this.tail_, this.head_);
  this.map_.push(s), i = new Qu(s.getPoint(1), s), e = new Qu(s.getPoint(0), s), n = new Qu(s.getPoint(2)), this.front_ = new vC(i, n), i.next = e, e.next = n, e.prev = i, n.prev = e;
};
Vt.prototype.removeNode = function(i) {
};
Vt.prototype.mapTriangleToNodes = function(i) {
  for (var e = 0; e < 3; ++e)
    if (!i.getNeighbor(e)) {
      var n = this.front_.locatePoint(i.pointCW(i.getPoint(e)));
      n && (n.triangle = i);
    }
};
Vt.prototype.removeFromMap = function(i) {
  var e, n = this.map_, s = n.length;
  for (e = 0; e < s; e++)
    if (n[e] === i) {
      n.splice(e, 1);
      break;
    }
};
Vt.prototype.meshClean = function(i) {
  for (var e = [i], n, s; n = e.pop(); )
    if (!n.isInterior())
      for (n.setInterior(!0), this.triangles_.push(n), s = 0; s < 3; s++)
        n.constrained_edge[s] || e.push(n.getNeighbor(s));
};
var $C = window.poly2tri;
const VC = function() {
  return global.poly2tri = $C, exports;
}, GC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Point: Ft,
  PointError: ji,
  SweepContext: Vt,
  Triangle: Rt,
  noConflict: VC,
  sweep: BC
}, Symbol.toStringTag, { value: "Module" })), gx = gr.default();
let UC = class a2 {
  constructor(e, n, s) {
    this.cx = e, this.cy = n, this.radius = s;
  }
  clone() {
    return new a2(this.cx, this.cy, this.radius);
  }
  copy(e) {
    return this.cx = e.cx, this.cy = e.cy, this.radius = e.radius, this;
  }
  setRadius(e) {
    return this.radius = e, this;
  }
  setCenter(e, n) {
    return this.cx = e, this.cy = n, this;
  }
  /**
   * 计算圆的面积
   *
   * @returns 返回圆的面积
   */
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  /**
   * 计算圆的周长
   *
   * @returns 返回圆的周长
   */
  getCircumference() {
    return 2 * Math.PI * this.radius;
  }
  distanceTo(e, n) {
    return Math.sqrt((e - this.cx) ** 2 + (n - this.cy) ** 2);
  }
  contains(e, n) {
    return this.distanceTo(e, n) <= this.radius;
  }
  containsStroke(e, n, s, r = 0.5) {
    const a = this.distanceTo(e, n), o = s * 0.5, h = (r - 0.5) * 2 * o, c = this.radius + h;
    return Math.abs(a - c) <= o;
  }
  containsBoundingRect(e, n) {
    return gx.fromCircle(this.cx, this.cy, this.radius), gx.containsXY(e, n);
  }
  getBoundingBox(e) {
    return e.fromCircle(this.cx, this.cy, this.radius), e;
  }
}, WC = class o2 {
  start = N.default();
  end = N.default();
  constructor(e = N.default(), n = N.default()) {
    this.start.copy(e), this.end.copy(n);
  }
  get length() {
    return this.end.distance(this.start);
  }
  get lengthSquared() {
    return this.end.distanceSquared(this.start);
  }
  clone() {
    return new o2(this.start, this.end);
  }
  copy(e) {
    this.start.copy(e.start), this.end.copy(e.end);
  }
  offset(e) {
    const n = this.end.clone().sub(this.start).normalize().perp();
    return this.start.add(n.clone().multiplyScalar(e)), this.end.add(n.clone().multiplyScalar(e)), this;
  }
  getDelta(e = N.default()) {
    return e.subVectors(this.end, this.start);
  }
  getCenter(e = N.default()) {
    return N.lerp(e, this.start, this.end, 0.5);
  }
  distanceTo(e, n) {
    const s = N.create(e, n), r = this.end.clone().sub(this.start), a = s.clone().sub(this.start);
    let o = a.dot(r) / r.dot(r);
    return o = Je(o, 0, 1), a.distance(r.multiplyScalar(o));
  }
  /** 
       * 直线参数方程(x,y)=(x0+at, y0+bt) (a,b)是单位向量
       * 线段上的点参数方程:(x,y)=(x0+(x1-x0)t, y0+(y1-y0)t)
       * 直线一般式 Ax+By+C=0
        参数方程转一般式：
        x=x0+(x1-x0)t  t=(x-x0)/(x1-x0)
        y=y0+(y1-y0)t  t=(y-y0)/(y1-y0)
        (x-x0)/(x1-x0)=(y-y0)/(y1-y0)=(x-x0)(y1-y0)=(y-y0)(x1-x0)=(x-x0)dy=(y-y0)dx
        dx=bx-ax dy=by-ay
        (x-x0)dy-(y-y0)dx=0 =dx*x-x0dy-dx*y+y0dx=0
  
        Ax=dy,By=-dx,C=y0dx-x0dy
  
  
       * 线段与线段相交点
       * 法向式:
       * (x-x0)dy=(y-y0)dx
       * Ax+By+C=0
       * Cx+Dy+E=0
       * 克莱姆法则求解：
       * Ax+By=-C
       * Cx+Dy=-E
         d=AD-BC
         u=(BE-DC)/d
         v=(AE-CD)/d
      */
  intersectionFromLine(e, n = N.default()) {
    const s = this.getDelta(), r = e.getDelta(), a = s.cross(r);
    if (a === 0)
      return null;
    const o = e.start.clone().sub(this.start), h = o.cross(r) / a, c = o.cross(s) / a;
    return h < 0 || h > 1 || c < 0 || c > 1 ? null : (n.copy(s).multiplyScalar(h).add(this.start), n);
  }
  /**
   * y=xk+b b=y-xk
   * 适用所有直线
   * 计算截距:Ax+By+C=0
   * (x-x0)dy-(y-y0)dx=
   * 横截距 a=-C/A 
   * 纵截距 b=-C/B 
  */
  intercept() {
    const e = this.getDelta(), n = e.y, s = -e.x, r = e.cross(this.start);
    return {
      x: -r / n,
      y: -r / s
    };
  }
  contains(e, n) {
    return this.distanceTo(e, n) < 1e-6;
  }
  containsStroke(e, n, s, r = 0.5) {
    const a = s * 0.5, o = (r - 0.5) * 2 * a;
    return this.clone().offset(o).distanceTo(e, n) <= a;
  }
  getBoundingBox(e) {
    let n = Math.min(this.start.x, this.end.x), s = Math.min(this.start.y, this.end.y), r = Math.abs(this.start.x - this.end.x), a = Math.abs(this.start.y - this.end.y);
    return e.fromRect(n, s, r, a), e;
  }
};
function YC(i, e, n, s, r, a) {
  let o = r - n, h = a - s, c = i - n, l = e - s;
  if (o !== 0 || h !== 0) {
    let u = (c * o + l * h) / (o * o + h * h);
    return u = Je(u, 0, 1), Math.hypot(c - o * u, c - h * u);
  }
  return Number.POSITIVE_INFINITY;
}
let jC = class {
  vertices;
  constructor(e) {
    this.vertices = e;
  }
  getVectors() {
    return this.vertices.map((e) => N.create(e.x, e.y));
  }
  getArea() {
    let e = 0;
    for (let n = 0; n < this.vertices.length; n++) {
      const s = this.vertices[n], r = this.vertices[(n + 1) % this.vertices.length];
      e += s.x * r.y - s.y * r.x;
    }
    return Math.abs(e / 2);
  }
  getBoundingBox(e) {
    return e.setFromPoints(this.vertices), e;
  }
  contains(e, n, s) {
    let r = 0;
    for (let a = 0; a < this.vertices.length; a++) {
      let o = this.vertices[a], h = this.vertices[(a + 1) % this.vertices.length], c = o.x, l = o.y, u = h.x, f = h.y;
      n > l != n > f && e < (u - c) * (n - l) / (f - l) + c && (s === "nonzero" ? r += l < f ? 1 : -1 : s === "evenodd" && r++);
    }
    return r % 2 !== 0;
  }
  containsStroke(e, n, s, r = 0.5) {
    const a = s * 0.5, o = (r - 0.5) * 2 * a;
    for (let h = 0; h < this.vertices.length; h++) {
      let { x: c, y: l } = this.vertices[h], { x: u, y: f } = this.vertices[(h + 1) % this.vertices.length];
      const d = Math.hypot(u - c, f - l), p = (u - c) / d, y = (f - l) / d;
      c = c - y * o, l = l + p * o, u = u - y * o, f = f + p * o;
      const x = YC(e, n, c, l, u, f);
      if (Math.abs(x) <= a)
        return !0;
    }
    return !1;
  }
}, HC = class {
  constructor(e, n, s, r) {
    this.x = e, this.y = n, this.width = s, this.height = r;
  }
  getCenter() {
    return N.create(this.x + this.width / 2, this.y + this.height / 2);
  }
  /**
   * 计算矩形的面积
   * @returns 矩形的面积
   */
  getArea() {
    return this.width * this.height;
  }
  /**
   * 计算矩形的周长
   * @returns 矩形的周长
   */
  getPerimeter() {
    return 2 * (this.width + this.height);
  }
  distanceTo(e, n) {
    const s = this.getCenter(), r = this.width / 2, a = this.height / 2, o = Math.abs(e - s.x) - r, h = Math.abs(n - s.y) - a, c = Math.max(0, o), l = Math.max(0, h);
    return c > 0 || l > 0 ? Math.sqrt(c * c + l * l) : Math.min(0, Math.max(o, h));
  }
  /**
   * 判断一个点是否在矩形内
   * @param x 点的 x 坐标
   * @param y 点的 y 坐标
   * @returns 如果点在矩形内返回 true，否则返回 false
   */
  containsPoint(e, n) {
    return !(e < this.x || e > this.x + this.width || n < this.y || n > this.y + this.height);
  }
  containsStroke(e, n, s, r = 0.5) {
    const a = this.distanceTo(e, n), o = s * 0.5, h = (r - 0.5) * 2 * o;
    return Math.abs(a - h) <= o;
  }
};
class XC {
  constructor(e, n) {
    this.m = e, this.x0 = n;
  }
  static from(e, n) {
    return new this(e, n.x - e * n.y);
  }
  static fromPoint(e, n) {
    return this.from((n.x - e.x) / (n.y - e.y), e);
  }
  static fromFloat(e) {
    return new this(0, e);
  }
  getX(e) {
    return this.m * e + this.x0;
  }
}
class ZC {
  static fromLine(e, n, s, r) {
    return new this(e, n, s.getX(e), s.getX(n), r.getX(e), r.getX(n));
  }
  //    y1    --------
  //         /       /
  //        /       /
  //       /       /
  //    y0 --------
  //      x0 x1   x2 x3
  y0 = 0;
  y1 = 0;
  x0 = 0;
  x1 = 0;
  x2 = 0;
  x3 = 0;
  constructor(e, n, s, r, a, o) {
    this.y0 = e, this.y1 = n, this.x0 = s, this.x1 = r, this.x2 = a, this.x3 = o;
  }
  getArea() {
    const { y0: e, y1: n, x2: s, x3: r, x0: a, x1: o } = this;
    return (n - e) * (s + r - a - o) * 0.5;
  }
}
let JC = class Qs {
  constructor(e, n, s, r, a, o) {
    this.x1 = e, this.y1 = n, this.x2 = s, this.y2 = r, this.x3 = a, this.y3 = o;
  }
  /**
   * 计算三角形的面积（使用向量叉积法）
   * @returns 三角形的面积
   */
  getArea() {
    return Math.abs(
      0.5 * (this.x1 * (this.y2 - this.y3) + this.x2 * (this.y3 - this.y1) + this.x3 * (this.y1 - this.y2))
    );
  }
  /**
   * 判断一个点是否在三角形内（使用面积法）
   * @param px 点的 x 坐标
   * @param py 点的 y 坐标
   * @returns 如果点在三角形内返回 true，否则返回 false
   */
  containsPoint(e, n) {
    const s = this.getArea(), r = new Qs(e, n, this.x1, this.y1, this.x2, this.y2).getArea(), a = new Qs(e, n, this.x2, this.y2, this.x3, this.y3).getArea(), o = new Qs(e, n, this.x3, this.y3, this.x1, this.y1).getArea();
    return Math.abs(s - (r + a + o)) < 1e-9;
  }
  /**
   * 计算给定点相对于当前三角形的重心坐标
   * @param px 点的 x 坐标
   * @param py 点的 y 坐标
   * @returns 包含重心坐标 (u, v, w) 的对象，如果点不在三角形内，返回 null
   */
  getBarycentricCoordinates(e, n) {
    const s = this.getArea(), r = new Qs(e, n, this.x2, this.y2, this.x3, this.y3).getArea(), a = new Qs(e, n, this.x3, this.y3, this.x1, this.y1).getArea(), o = new Qs(e, n, this.x1, this.y1, this.x2, this.y2).getArea(), h = r / s, c = a / s, l = o / s;
    return { u: h, v: c, w: l };
  }
  // barycentric(x:number,y:number) {
  //     const cross = (a, b) => {
  //         return a[0] * b[1] - a[1] * b[0]
  //     }
  //     // 一般要保证叉乘的顺序，保证p如果在三角形内是正数
  //     let bc = vec2.sub([], b, c)
  //     let ca = vec2.sub([], c, a)
  //     let pc = vec2.sub([], p, c)
  //     let area = cross(bc, ca)
  //     // 如果在右边，叉乘的结果是正数
  //     let alpha = cross(pc, bc) / area 
  //     let beta = cross(pc, ca) / area
  //     let gamma = 1 - alpha - beta
  //     return [alpha, beta, gamma]
  //     //  return barycentric4(a,b,c,p)
  // }
};
const QC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: UC,
  Line: WC,
  Polygon: jC,
  RasterizeLine: XC,
  Rectangle: HC,
  Trapezoid: ZC,
  Triangle: JC
}, Symbol.toStringTag, { value: "Module" }));
function nu(i, e, n) {
  let s = 0, r = 1;
  const a = e.x - i.x, o = e.y - i.y, h = (c, l) => {
    if (c == 0 && l < 0) return !1;
    const u = l / c;
    if (c < 0) {
      if (u > r) return !1;
      u > s && (s = u);
    } else if (c > 0) {
      if (u < s) return !1;
      u < r && (r = u);
    }
    return !0;
  };
  return !h(-a, i.x - n.xmin) || !h(a, n.xmax - i.x) || !h(-o, i.y - n.ymin) || !h(o, n.ymax - i.y) ? null : [
    { x: i.x + s * a, y: i.y + s * o },
    { x: i.x + r * a, y: i.y + r * o }
  ];
}
function KC(i, e, n) {
  return nu(i, e, n);
}
const t5 = 0, h2 = 1, c2 = 2, l2 = 4, u2 = 8;
function pa(i, e) {
  let n = t5;
  return i.x < e.xmin ? n |= h2 : i.x > e.xmax && (n |= c2), i.y < e.ymin ? n |= l2 : i.y > e.ymax && (n |= u2), n;
}
function e5(i, e, n) {
  let s = pa(i, n), r = pa(e, n);
  for (; ; ) {
    if (!(s | r)) return [i, e];
    if (s & r) return null;
    let a = 0, o = 0;
    const h = s || r;
    h & u2 ? (a = i.x + (e.x - i.x) * (n.ymax - i.y) / (e.y - i.y), o = n.ymax) : h & l2 ? (a = i.x + (e.x - i.x) * (n.ymin - i.y) / (e.y - i.y), o = n.ymin) : h & c2 ? (o = i.y + (e.y - i.y) * (n.xmax - i.x) / (e.x - i.x), a = n.xmax) : h & h2 && (o = i.y + (e.y - i.y) * (n.xmin - i.x) / (e.x - i.x), a = n.xmin), h === s ? (i = { x: a, y: o }, s = pa(i, n)) : (e = { x: a, y: o }, r = pa(e, n));
  }
}
function w0(i, e, n) {
  let s = pa(i, n), r = pa(e, n);
  if (!(s | r)) return [i, e];
  if (s & r || Math.abs(e.x - i.x) < 1e-6 && Math.abs(e.y - i.y) < 1e-6) return null;
  const a = { x: (i.x + e.x) / 2, y: (i.y + e.y) / 2 };
  return [...w0(i, a, n) || [], ...w0(a, e, n) || []];
}
function n5(i, e, n) {
  return nu(i, e, n);
}
function i5(i, e, n) {
  return nu(i, e, n);
}
const s5 = (i, e) => {
  const n = (h) => {
    let c = 0;
    return h.x < e.left && (c |= 1), h.x > e.right && (c |= 2), h.y < e.bottom && (c |= 4), h.y > e.top && (c |= 8), c;
  };
  let [s, r] = i, a = n(s), o = n(r);
  for (; ; ) {
    if ((a | o) === 0) return [s, r];
    if ((a & o) !== 0) return null;
    const h = a !== 0 ? a : o;
    let c = { x: 0, y: 0 };
    h & 8 ? (c.x = s.x + (r.x - s.x) * (e.top - s.y) / (r.y - s.y), c.y = e.top) : h & 4 ? (c.x = s.x + (r.x - s.x) * (e.bottom - s.y) / (r.y - s.y), c.y = e.bottom) : h & 2 ? (c.y = s.y + (r.y - s.y) * (e.right - s.x) / (r.x - s.x), c.x = e.right) : h & 1 && (c.y = s.y + (r.y - s.y) * (e.left - s.x) / (r.x - s.x), c.x = e.left), h === a ? (s = c, a = n(s)) : (r = c, o = n(r));
  }
}, r5 = (i, e) => {
  let n = [i[0], i[1]];
  for (const s of e) {
    const r = [];
    for (let a = 0; a < n.length; a++) {
      const o = n[a], h = n[(a + 1) % n.length], c = s.normal[0] * (o.x - s.point.x) + s.normal[1] * (o.y - s.point.y), l = s.normal[0] * (h.x - s.point.x) + s.normal[1] * (h.y - s.point.y);
      if (c <= 0 && r.push(o), c < 0 && l > 0 || c > 0 && l < 0) {
        const u = -c / (l - c);
        r.push({
          x: o.x + u * (h.x - o.x),
          y: o.y + u * (h.y - o.y)
        });
      }
    }
    n = r;
  }
  return n;
}, a5 = (i, e, n = 1) => {
  const s = (o, h) => {
    let c = o, l = h;
    for (; Math.hypot(l.x - c.x, l.y - c.y) > n; ) {
      const u = {
        x: (c.x + l.x) / 2,
        y: (c.y + l.y) / 2
      };
      u.x < e.left || u.x > e.right || u.y < e.bottom || u.y > e.top ? l = u : c = u;
    }
    return c;
  }, r = s(i[0], i[1]), a = s(i[1], i[0]);
  return Math.abs(r.x - a.x) > n || Math.abs(r.y - a.y) > n ? [r, a] : null;
};
function o5(i, e) {
  let n = i;
  for (let s = 0; s < e.length; s++) {
    const r = e[s], a = e[(s + 1) % e.length], o = n;
    if (n = [], o.length === 0) break;
    let h = o[o.length - 1];
    for (const c of o) {
      const l = mx(h, r, a);
      if (mx(c, r, a)) {
        if (!l) {
          const f = vx(
            h,
            c,
            r,
            a
          );
          f && n.push(f);
        }
        n.push(c);
      } else if (l) {
        const f = vx(
          h,
          c,
          r,
          a
        );
        f && n.push(f);
      }
      h = c;
    }
  }
  return n;
}
function mx(i, e, n) {
  return (n.x - e.x) * (i.y - e.y) > (n.y - e.y) * (i.x - e.x);
}
function vx(i, e, n, s) {
  const r = e.x - i.x, a = e.y - i.y, o = s.x - n.x, h = s.y - n.y, c = r * h - a * o;
  if (c === 0) return null;
  const l = n.x - i.x, u = n.y - i.y, f = (l * h - u * o) / c;
  return {
    x: i.x + f * (e.x - i.x),
    y: i.y + f * (e.y - i.y)
  };
}
const h5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CohenSutherlandClip: s5,
  MidpointClip: a5,
  SutherlandHodgmanClip: r5,
  cohenSutherland: e5,
  cyrusBeck: i5,
  equationBasedClipping: n5,
  liangBarsky: nu,
  midpointSubdivision: w0,
  nichollLeeNicholl: KC,
  sutherlandHodgmanClip: o5
}, Symbol.toStringTag, { value: "Module" }));
var Qe = /* @__PURE__ */ ((i) => (i[i.ODD = 0] = "ODD", i[i.NONZERO = 1] = "NONZERO", i[i.POSITIVE = 2] = "POSITIVE", i[i.NEGATIVE = 3] = "NEGATIVE", i[i.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO", i))(Qe || {}), Jn = /* @__PURE__ */ ((i) => (i[i.POLYGONS = 0] = "POLYGONS", i[i.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", i[i.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS", i))(Jn || {});
function pt(i, e = void 0) {
  if (!i)
    throw e || "Assertion Failed!";
}
let dt = class Bt {
  static vertEq(e, n) {
    return e.s === n.s && e.t === n.t;
  }
  /* Returns TRUE if u is lexicographically <= v. */
  static vertLeq(e, n) {
    return e.s < n.s || e.s === n.s && e.t <= n.t;
  }
  /* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */
  static transLeq(e, n) {
    return e.t < n.t || e.t === n.t && e.s <= n.s;
  }
  static edgeGoesLeft(e) {
    return Bt.vertLeq(e.Dst, e.Org);
  }
  static edgeGoesRight(e) {
    return Bt.vertLeq(e.Org, e.Dst);
  }
  static vertL1dist(e, n) {
    return Math.abs(e.s - n.s) + Math.abs(e.t - n.t);
  }
  //TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static edgeEval(e, n, s) {
    pt(Bt.vertLeq(e, n) && Bt.vertLeq(n, s));
    var r = n.s - e.s, a = s.s - n.s;
    return r + a > 0 ? r < a ? n.t - e.t + (e.t - s.t) * (r / (r + a)) : n.t - s.t + (s.t - e.t) * (a / (r + a)) : 0;
  }
  //TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static edgeSign(e, n, s) {
    pt(Bt.vertLeq(e, n) && Bt.vertLeq(n, s));
    var r = n.s - e.s, a = s.s - n.s;
    return r + a > 0 ? (n.t - s.t) * r + (n.t - e.t) * a : 0;
  }
  /***********************************************************************
   * Define versions of EdgeSign, EdgeEval with s and t transposed.
   */
  //TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static transEval(e, n, s) {
    pt(Bt.transLeq(e, n) && Bt.transLeq(n, s));
    var r = n.t - e.t, a = s.t - n.t;
    return r + a > 0 ? r < a ? n.s - e.s + (e.s - s.s) * (r / (r + a)) : n.s - s.s + (s.s - e.s) * (a / (r + a)) : 0;
  }
  //TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static transSign(e, n, s) {
    pt(Bt.transLeq(e, n) && Bt.transLeq(n, s));
    var r = n.t - e.t, a = s.t - n.t;
    return r + a > 0 ? (n.s - s.s) * r + (n.s - e.s) * a : 0;
  }
  //int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )
  static vertCCW(e, n, s) {
    return e.s * (n.t - s.t) + n.s * (s.t - e.t) + s.s * (e.t - n.t) >= 0;
  }
  /* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
   * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
   * this in the rare case that one argument is slightly negative.
   * The implementation is extremely stable numerically.
   * In particular it guarantees that the result r satisfies
   * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
   * even when a and b differ greatly in magnitude.
   */
  static interpolate(e, n, s, r) {
    return e = e < 0 ? 0 : e, s = s < 0 ? 0 : s, e <= s ? s === 0 ? (n + r) / 2 : n + (r - n) * (e / (e + s)) : r + (n - r) * (s / (e + s));
  }
  /*
  	#ifndef FOR_TRITE_TEST_PROGRAM
  	#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
  	#else
  
  	// Claim: the ONLY property the sweep algorithm relies on is that
  	// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
  	#include <stdlib.h>
  	extern int RandomInterpolate;
  
  	double Interpolate( double a, double x, double b, double y)
  	{
  		printf("*********************%d\n",RandomInterpolate);
  		if( RandomInterpolate ) {
  			a = 1.2 * drand48() - 0.1;
  			a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
  			b = 1.0 - a;
  		}
  		return RealInterpolate(a,x,b,y);
  	}
  	#endif*/
  static intersect(e, n, s, r, a) {
    var o, h, c;
    Bt.vertLeq(e, n) || (c = e, e = n, n = c), Bt.vertLeq(s, r) || (c = s, s = r, r = c), Bt.vertLeq(e, s) || (c = e, e = s, s = c, c = n, n = r, r = c), Bt.vertLeq(s, n) ? Bt.vertLeq(n, r) ? (o = Bt.edgeEval(e, s, n), h = Bt.edgeEval(s, n, r), o + h < 0 && (o = -o, h = -h), a.s = Bt.interpolate(o, s.s, h, n.s)) : (o = Bt.edgeSign(e, s, n), h = -Bt.edgeSign(e, r, n), o + h < 0 && (o = -o, h = -h), a.s = Bt.interpolate(o, s.s, h, r.s)) : a.s = (s.s + n.s) / 2, Bt.transLeq(e, n) || (c = e, e = n, n = c), Bt.transLeq(s, r) || (c = s, s = r, r = c), Bt.transLeq(e, s) || (c = e, e = s, s = c, c = n, n = r, r = c), Bt.transLeq(s, n) ? Bt.transLeq(n, r) ? (o = Bt.transEval(e, s, n), h = Bt.transEval(s, n, r), o + h < 0 && (o = -o, h = -h), a.t = Bt.interpolate(o, s.t, h, n.t)) : (o = Bt.transSign(e, s, n), h = -Bt.transSign(e, r, n), o + h < 0 && (o = -o, h = -h), a.t = Bt.interpolate(o, s.t, h, r.t)) : a.t = (s.t + n.t) / 2;
  }
};
class Qa {
  next = null;
  /* next face (never NULL) */
  prev = null;
  /* previous face (never NULL) */
  anEdge = null;
  /* a half edge with this left face */
  /* Internal data (keep hidden) */
  trail = null;
  /* "stack" for conversion to strips */
  n = 0;
  /* to allow identiy unique faces */
  marked = !1;
  /* flag for conversion to strips */
  inside = !1;
  /* this face is in the polygon interior */
}
class oc {
  /* change in winding number when crossing from the right face to the left face */
  constructor(e) {
    this.side = e;
  }
  next = null;
  /* doubly-linked list (prev==Sym->next) */
  Org = null;
  /* origin vertex (Overtex too long) */
  Sym = null;
  /* same edge, opposite direction */
  Onext = null;
  /* next edge CCW around origin */
  Lnext = null;
  /* next edge CCW around left face */
  Lface = null;
  /* left face */
  /* Internal data (keep hidden) */
  activeRegion = null;
  /* a region with this upper edge (sweep.c) */
  winding = 0;
  get Rface() {
    return this.Sym.Lface;
  }
  set Rface(e) {
    this.Sym.Lface = e;
  }
  get Dst() {
    return this.Sym.Org;
  }
  set Dst(e) {
    this.Sym.Org = e;
  }
  get Oprev() {
    return this.Sym.Lnext;
  }
  set Oprev(e) {
    this.Sym.Lnext = e;
  }
  get Lprev() {
    return this.Onext.Sym;
  }
  set Lprev(e) {
    this.Onext.Sym = e;
  }
  get Dprev() {
    return this.Lnext.Sym;
  }
  set Dprev(e) {
    this.Lnext.Sym = e;
  }
  get Rprev() {
    return this.Sym.Onext;
  }
  set Rprev(e) {
    this.Sym.Onext = e;
  }
  get Dnext() {
    return this.Sym.Onext.Sym;
  }
  set Dnext(e) {
    this.Sym.Onext.Sym = e;
  }
  get Rnext() {
    return this.Sym.Lnext.Sym;
  }
  set Rnext(e) {
    this.Sym.Lnext.Sym = e;
  }
}
class na {
  next = null;
  /* next vertex (never NULL) */
  prev = null;
  /* previous vertex (never NULL) */
  anEdge = null;
  /* a half-edge with this origin */
  /* Internal data (keep hidden) */
  coords = [0, 0, 0];
  /* vertex location in 3D */
  s = 0;
  t = 0;
  /* projection onto the sweep plane */
  pqHandle = 0;
  /* to allow deletion from priority queue */
  n = 0;
  /* to allow identify unique vertices */
  idx = 0;
  /* to allow map result to original verts */
}
class Mx {
  vHead;
  /* dummy header for vertex list */
  fHead;
  /* dummy header for face list */
  eHead;
  /* dummy header for edge list */
  eHeadSym;
  /* and its symmetric counterpart */
  constructor() {
    const e = new na(), n = new Qa(), s = new oc(0), r = new oc(1);
    e.next = e.prev = e, e.anEdge = null, n.next = n.prev = n, s.next = s, s.Sym = r, r.next = r, r.Sym = s, this.vHead = e, this.fHead = n, this.eHead = s, this.eHeadSym = r;
  }
  /* MakeEdge creates a new pair of half-edges which form their own loop.
   * No vertex or face structures are allocated, but these must be assigned
   * before the current edge operation is completed.
   */
  //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
  makeEdge_(e) {
    var n = new oc(0), s = new oc(1);
    e.Sym.side < e.side && (e = e.Sym);
    var r = e.Sym.next;
    return s.next = r, r.Sym.next = n, n.next = e, e.Sym.next = s, n.Sym = s, n.Onext = n, n.Lnext = s, n.Org = null, n.Lface = null, n.winding = 0, n.activeRegion = null, s.Sym = n, s.Onext = s, s.Lnext = n, s.Org = null, s.Lface = null, s.winding = 0, s.activeRegion = null, n;
  }
  /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
   * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
   * a->Onext and b->Onext are exchanged.  This can have various effects
   * depending on whether a and b belong to different face or vertex rings.
   * For more explanation see tessMeshSplice() below.
   */
  // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
  splice_(e, n) {
    var s = e.Onext, r = n.Onext;
    s.Sym.Lnext = n, r.Sym.Lnext = e, e.Onext = r, n.Onext = s;
  }
  /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
   * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
   * a place to insert the new vertex in the global vertex list.  We insert
   * the new vertex *before* vNext so that algorithms which walk the vertex
   * list will not see the newly created vertices.
   */
  //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
  makeVertex_(e, n, s) {
    var r = e;
    pt(r, "Vertex can't be null!");
    var a = s.prev;
    r.prev = a, a.next = r, r.next = s, s.prev = r, r.anEdge = n;
    var o = n;
    do
      o.Org = r, o = o.Onext;
    while (o !== n);
  }
  /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
   * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
   * a place to insert the new face in the global face list.  We insert
   * the new face *before* fNext so that algorithms which walk the face
   * list will not see the newly created faces.
   */
  // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
  makeFace_(e, n, s) {
    var r = e;
    pt(r, "Face can't be null");
    var a = s.prev;
    r.prev = a, a.next = r, r.next = s, s.prev = r, r.anEdge = n, r.trail = null, r.marked = !1, r.inside = s.inside;
    var o = n;
    do
      o.Lface = r, o = o.Lnext;
    while (o !== n);
  }
  /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
   * and removes from the global edge list.
   */
  //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
  killEdge_(e) {
    e.Sym.side < e.side && (e = e.Sym);
    var n = e.next, s = e.Sym.next;
    n.Sym.next = s, s.Sym.next = n;
  }
  /* KillVertex( vDel ) destroys a vertex and removes it from the global
   * vertex list.  It updates the vertex loop to point to a given new vertex.
   */
  //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
  killVertex_(e, n) {
    var s = e.anEdge, r = s;
    do
      r.Org = n, r = r.Onext;
    while (r !== s);
    var a = e.prev, o = e.next;
    o.prev = a, a.next = o;
  }
  /* KillFace( fDel ) destroys a face and removes it from the global face
   * list.  It updates the face loop to point to a given new face.
   */
  //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
  killFace_(e, n) {
    var s = e.anEdge, r = s;
    do
      r.Lface = n, r = r.Lnext;
    while (r !== s);
    var a = e.prev, o = e.next;
    o.prev = a, a.next = o;
  }
  /****************** Basic Edge Operations **********************/
  /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
   * The loop consists of the two new half-edges.
   */
  //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
  makeEdge() {
    var e = new na(), n = new na(), s = new Qa(), r = this.makeEdge_(this.eHead);
    return this.makeVertex_(e, r, this.vHead), this.makeVertex_(n, r.Sym, this.vHead), this.makeFace_(s, r, this.fHead), r;
  }
  /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
   * mesh connectivity and topology.  It changes the mesh so that
   *	eOrg->Onext <- OLD( eDst->Onext )
   *	eDst->Onext <- OLD( eOrg->Onext )
   * where OLD(...) means the value before the meshSplice operation.
   *
   * This can have two effects on the vertex structure:
   *  - if eOrg->Org != eDst->Org, the two vertices are merged together
   *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
   * In both cases, eDst->Org is changed and eOrg->Org is untouched.
   *
   * Similarly (and independently) for the face structure,
   *  - if eOrg->Lface == eDst->Lface, one loop is split into two
   *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
   * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
   *
   * Some special cases:
   * If eDst == eOrg, the operation has no effect.
   * If eDst == eOrg->Lnext, the new face will have a single edge.
   * If eDst == eOrg->Lprev, the old face will have a single edge.
   * If eDst == eOrg->Onext, the new vertex will have a single edge.
   * If eDst == eOrg->Oprev, the old vertex will have a single edge.
   */
  //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
  splice(e, n) {
    var s = !1, r = !1;
    if (e !== n) {
      if (n.Org !== e.Org && (r = !0, this.killVertex_(n.Org, e.Org)), n.Lface !== e.Lface && (s = !0, this.killFace_(n.Lface, e.Lface)), this.splice_(n, e), !r) {
        var a = new na();
        this.makeVertex_(a, n, e.Org), e.Org.anEdge = e;
      }
      if (!s) {
        var o = new Qa();
        this.makeFace_(o, n, e.Lface), e.Lface.anEdge = e;
      }
    }
  }
  /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
   * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
   * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
   * the newly created loop will contain eDel->Dst.  If the deletion of eDel
   * would create isolated vertices, those are deleted as well.
   *
   * This function could be implemented as two calls to tessMeshSplice
   * plus a few calls to memFree, but this would allocate and delete
   * unnecessary vertices and faces.
   */
  //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
  delete(e) {
    var n = e.Sym, s = !1;
    if (e.Lface !== e.Rface && (s = !0, this.killFace_(e.Lface, e.Rface)), e.Onext === e)
      this.killVertex_(e.Org, null);
    else if (e.Rface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev), !s) {
      var r = new Qa();
      this.makeFace_(r, e, e.Lface);
    }
    n.Onext === n ? (this.killVertex_(n.Org, null), this.killFace_(n.Lface, null)) : (e.Lface.anEdge = n.Oprev, n.Org.anEdge = n.Onext, this.splice_(n, n.Oprev)), this.killEdge_(e);
  }
  /******************** Other Edge Operations **********************/
  /* All these routines can be implemented with the basic edge
   * operations above.  They are provided for convenience and efficiency.
   */
  /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
   * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
   * eOrg and eNew will have the same left face.
   */
  // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
  addEdgeVertex(e) {
    var n = this.makeEdge_(e), s = n.Sym;
    this.splice_(n, e.Lnext), n.Org = e.Dst;
    var r = new na();
    return this.makeVertex_(r, s, n.Org), n.Lface = s.Lface = e.Lface, n;
  }
  /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
   * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
   * eOrg and eNew will have the same left face.
   */
  // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
  splitEdge(e) {
    var n = this.addEdgeVertex(e), s = n.Sym;
    return this.splice_(e.Sym, e.Sym.Oprev), this.splice_(e.Sym, s), e.Dst = s.Org, s.Dst.anEdge = s.Sym, s.Rface = e.Rface, s.winding = e.winding, s.Sym.winding = e.Sym.winding, s;
  }
  /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
   * to eDst->Org, and returns the corresponding half-edge eNew.
   * If eOrg->Lface == eDst->Lface, this splits one loop into two,
   * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
   * loops are merged into one, and the loop eDst->Lface is destroyed.
   *
   * If (eOrg == eDst), the new face will have only two edges.
   * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
   * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
   */
  // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
  connect(e, n) {
    var s = !1, r = this.makeEdge_(e), a = r.Sym;
    if (n.Lface !== e.Lface && (s = !0, this.killFace_(n.Lface, e.Lface)), this.splice_(r, e.Lnext), this.splice_(a, n), r.Org = e.Dst, a.Org = n.Org, r.Lface = a.Lface = e.Lface, e.Lface.anEdge = a, !s) {
      var o = new Qa();
      this.makeFace_(o, r, e.Lface);
    }
    return r;
  }
  /* tessMeshZapFace( fZap ) destroys a face and removes it from the
   * global face list.  All edges of fZap will have a NULL pointer as their
   * left face.  Any edges which also have a NULL pointer as their right face
   * are deleted entirely (along with any isolated vertices this produces).
   * An entire mesh can be deleted by zapping its faces, one at a time,
   * in any order.  Zapped faces cannot be used in further mesh operations!
   */
  zapFace(e) {
    var n = e.anEdge, s, r, a, o, h;
    r = n.Lnext;
    do
      s = r, r = s.Lnext, s.Lface = null, s.Rface === null && (s.Onext === s ? this.killVertex_(s.Org, null) : (s.Org.anEdge = s.Onext, this.splice_(s, s.Oprev)), a = s.Sym, a.Onext === a ? this.killVertex_(a.Org, null) : (a.Org.anEdge = a.Onext, this.splice_(a, a.Oprev)), this.killEdge_(s));
    while (s != n);
    o = e.prev, h = e.next, h.prev = o, o.next = h;
  }
  countFaceVerts_(e) {
    var n = e.anEdge, s = 0;
    do
      s++, n = n.Lnext;
    while (n !== e.anEdge);
    return s;
  }
  //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
  mergeConvexFaces(e) {
    var n, s, r, a, o, h, c;
    for (n = this.fHead.next; n !== this.fHead; n = n.next)
      if (n.inside)
        for (s = n.anEdge, o = s.Org; r = s.Lnext, a = s.Sym, a && a.Lface && a.Lface.inside && (h = this.countFaceVerts_(n), c = this.countFaceVerts_(a.Lface), h + c - 2 <= e && dt.vertCCW(
          s.Lprev.Org,
          s.Org,
          a.Lnext.Lnext.Org
        ) && dt.vertCCW(
          a.Lprev.Org,
          a.Org,
          s.Lnext.Lnext.Org
        ) && (r = a.Lnext, this.delete(a), s = null, a = null)), !(s && s.Lnext.Org === o); )
          s = r;
    return !0;
  }
  /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
   */
  check() {
    var e = this.fHead, n = this.vHead, s = this.eHead, r, a, o, h, c, l;
    for (a = e, a = e; (r = a.next) !== e; a = r) {
      pt(r.prev === a), c = r.anEdge;
      do
        pt(c.Sym !== c), pt(c.Sym.Sym === c), pt(c.Lnext.Onext.Sym === c), pt(c.Onext.Sym.Lnext === c), pt(c.Lface === r), c = c.Lnext;
      while (c !== r.anEdge);
    }
    for (pt(r.prev === a && r.anEdge === null), h = n, h = n; (o = h.next) !== n; h = o) {
      pt(o.prev === h), c = o.anEdge;
      do
        pt(c.Sym !== c), pt(c.Sym.Sym === c), pt(c.Lnext.Onext.Sym === c), pt(c.Onext.Sym.Lnext === c), pt(c.Org === o), c = c.Onext;
      while (c !== o.anEdge);
    }
    for (pt(o.prev === h && o.anEdge === null), l = s, l = s; (c = l.next) !== s; l = c)
      pt(c.Sym.next === l.Sym), pt(c.Sym !== c), pt(c.Sym.Sym === c), pt(c.Org !== null), pt(c.Dst !== null), pt(c.Lnext.Onext.Sym === c), pt(c.Onext.Sym.Lnext === c);
    pt(
      c.Sym.next === l.Sym && c.Sym === this.eHeadSym && c.Sym.Sym === c && c.Org === null && c.Dst === null && c.Lface === null && c.Rface === null
    );
  }
}
class bx {
  handle = null;
}
class _x {
  key = null;
  node = 0;
}
class c5 {
  constructor(e, n) {
    this.leq = n, this.max = e, this.nodes = [], this.handles = [];
    for (let s = 0; s < e + 1; s++)
      this.nodes[s] = new bx(), this.handles[s] = new _x();
    this.initialized = !1, this.nodes[1].handle = 1, this.handles[1].key = null;
  }
  max = 0;
  nodes = [];
  handles = [];
  initialized = !1;
  freeList = 0;
  size = 0;
  floatDown_(e) {
    var n = this.nodes, s = this.handles, r, a, o;
    for (r = n[e].handle; ; ) {
      if (o = e << 1, o < this.size && this.leq(s[n[o + 1].handle].key, s[n[o].handle].key) && ++o, pt(o <= this.max), a = n[o].handle, o > this.size || this.leq(s[r].key, s[a].key)) {
        n[e].handle = r, s[r].node = e;
        break;
      }
      n[e].handle = a, s[a].node = e, e = o;
    }
  }
  floatUp_(e) {
    var n = this.nodes, s = this.handles, r, a, o;
    for (r = n[e].handle; ; ) {
      if (o = e >> 1, a = n[o].handle, o === 0 || this.leq(s[a].key, s[r].key)) {
        n[e].handle = r, s[r].node = e;
        break;
      }
      n[e].handle = a, s[a].node = e, e = o;
    }
  }
  init() {
    for (let e = this.size; e >= 1; --e)
      this.floatDown_(e);
    this.initialized = !0;
  }
  min() {
    return this.handles[this.nodes[1].handle].key;
  }
  /* really pqHeapInsert */
  /* returns INV_HANDLE iff out of memory */
  //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
  insert(e) {
    var n, s;
    if (n = ++this.size, n * 2 > this.max) {
      this.max *= 2;
      var r, a;
      for (a = this.nodes.length, this.nodes.length = this.max + 1, r = a; r < this.nodes.length; r++)
        this.nodes[r] = new bx();
      for (a = this.handles.length, this.handles.length = this.max + 1, r = a; r < this.handles.length; r++)
        this.handles[r] = new _x();
    }
    return this.freeList === 0 ? s = n : (s = this.freeList, this.freeList = this.handles[s].node), this.nodes[n].handle = s, this.handles[s].node = n, this.handles[s].key = e, this.initialized && this.floatUp_(n), s;
  }
  //PQkey pqHeapExtractMin( PriorityQHeap *pq )
  extractMin() {
    var e = this.nodes, n = this.handles, s = e[1].handle, r = n[s].key;
    return this.size > 0 && (e[1].handle = e[this.size].handle, n[e[1].handle].node = 1, n[s].key = null, n[s].node = this.freeList, this.freeList = s, --this.size, this.size > 0 && this.floatDown_(1)), r;
  }
  delete(e) {
    var n = this.nodes, s = this.handles, r;
    pt(e >= 1 && e <= this.max && s[e].key !== null), r = s[e].node, n[r].handle = n[this.size].handle, s[n[r].handle].node = r, --this.size, r <= this.size && (r <= 1 || this.leq(s[n[r >> 1].handle].key, s[n[r].handle].key) ? this.floatDown_(r) : this.floatUp_(r)), s[e].key = null, s[e].node = this.freeList, this.freeList = e;
  }
}
class Ku {
  eUp = null;
  /* upper edge, directed right to left */
  nodeUp = null;
  /* dictionary node corresponding to eUp */
  windingNumber = 0;
  /* used to determine which regions are
   * inside the polygon */
  inside = !1;
  /* is this region inside the polygon? */
  sentinel = !1;
  /* marks fake edges at t = +/-infinity */
  dirty = !1;
  /* marks regions where the upper or lower
   * edge has changed, but we haven't checked
   * whether they intersect yet */
  fixUpperEdge = !1;
  /* marks temporary edges introduced when
   * we process a "right vertex" (one without
   * any edges leaving to the right) */
}
class Sx {
  key = null;
  next = null;
  prev = null;
}
class l5 {
  constructor(e, n) {
    this.frame = e, this.leq = n, this.head.next = this.head, this.head.prev = this.head;
  }
  head = new Sx();
  min() {
    return this.head.next;
  }
  max() {
    return this.head.prev;
  }
  insert(e) {
    return this.insertBefore(this.head, e);
  }
  search(e) {
    let n = this.head;
    do
      n = n.next;
    while (n.key !== null && !this.leq(this.frame, e, n.key));
    return n;
  }
  insertBefore(e, n) {
    do
      e = e.prev;
    while (e.key !== null && !this.leq(this.frame, e.key, n));
    const s = new Sx();
    return s.key = n, s.next = e.next, e.next.prev = s, s.prev = e, e.next = s, s;
  }
  delete(e) {
    e.next.prev = e.prev, e.prev.next = e.next;
  }
}
class X {
  static regionBelow(e) {
    return e.nodeUp.prev.key;
  }
  static regionAbove(e) {
    return e.nodeUp.next.key;
  }
  static debugEvent(e) {
  }
  /*
   * Invariants for the Edge Dictionary.
   * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
   *   at any valid location of the sweep event
   * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
   *   share a common endpoint
   * - for each e, e->Dst has been processed, but not e->Org
   * - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
   *   where "event" is the current sweep line event.
   * - no edge e has zero length
   *
   * Invariants for the Mesh (the processed portion).
   * - the portion of the mesh left of the sweep line is a planar graph,
   *   ie. there is *some* way to embed it in the plane
   * - no processed edge has zero length
   * - no two processed vertices have identical coordinates
   * - each "inside" region is monotone, ie. can be broken into two chains
   *   of monotonically increasing vertices according to VertLeq(v1,v2)
   *   - a non-invariant: these chains may intersect (very slightly)
   *
   * Invariants for the Sweep.
   * - if none of the edges incident to the event vertex have an activeRegion
   *   (ie. none of these edges are in the edge dictionary), then the vertex
   *   has only right-going edges.
   * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
   *   by ConnectRightVertex), then it is the only right-going edge from
   *   its associated vertex.  (This says that these edges exist only
   *   when it is necessary.)
   */
  /* When we merge two edges into one, we need to compute the combined
   * winding of the new edge.
   */
  static addWinding(e, n) {
    e.winding += n.winding, e.Sym.winding += n.Sym.winding;
  }
  //static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )
  static edgeLeq(e, n, s) {
    var r = e.event, a = n.eUp, o = s.eUp;
    if (a.Dst === r)
      return o.Dst === r ? dt.vertLeq(a.Org, o.Org) ? dt.edgeSign(o.Dst, a.Org, o.Org) <= 0 : dt.edgeSign(a.Dst, o.Org, a.Org) >= 0 : dt.edgeSign(o.Dst, r, o.Org) <= 0;
    if (o.Dst === r)
      return dt.edgeSign(a.Dst, r, a.Org) >= 0;
    const h = dt.edgeEval(a.Dst, r, a.Org), c = dt.edgeEval(o.Dst, r, o.Org);
    return h >= c;
  }
  //static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )
  static deleteRegion(e, n) {
    n.fixUpperEdge && pt(n.eUp.winding === 0), n.eUp.activeRegion = null, e.dict.delete(n.nodeUp);
  }
  //static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )
  static fixUpperEdge(e, n, s) {
    pt(n.fixUpperEdge), e.mesh.delete(n.eUp), n.fixUpperEdge = !1, n.eUp = s, s.activeRegion = n;
  }
  //static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )
  static topLeftRegion(e, n) {
    var s = n.eUp.Org, r;
    do
      n = X.regionAbove(n);
    while (n.eUp.Org === s);
    if (n.fixUpperEdge) {
      if (r = e.mesh.connect(
        X.regionBelow(n).eUp.Sym,
        n.eUp.Lnext
      ), r === null) return null;
      X.fixUpperEdge(e, n, r), n = X.regionAbove(n);
    }
    return n;
  }
  //static ActiveRegion *TopRightRegion( ActiveRegion *reg )
  static topRightRegion(e) {
    var n = e.eUp.Dst;
    do
      e = X.regionAbove(e);
    while (e.eUp.Dst === n);
    return e;
  }
  //static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )
  static addRegionBelow(e, n, s) {
    var r = new Ku();
    return r.eUp = s, r.nodeUp = e.dict.insertBefore(n.nodeUp, r), r.fixUpperEdge = !1, r.sentinel = !1, r.dirty = !1, s.activeRegion = r, r;
  }
  //static int IsWindingInside( TESStesselator *tess, int n )
  static isWindingInside(e, n) {
    switch (e.windingRule) {
      case Qe.ODD:
        return (n & 1) !== 0;
      case Qe.NONZERO:
        return n !== 0;
      case Qe.POSITIVE:
        return n > 0;
      case Qe.NEGATIVE:
        return n < 0;
      case Qe.ABS_GEQ_TWO:
        return n >= 2 || n <= -2;
    }
    throw new Error("Invalid winding rulle");
  }
  //static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )
  static computeWinding(e, n) {
    n.windingNumber = X.regionAbove(n).windingNumber + n.eUp.winding, n.inside = X.isWindingInside(e, n.windingNumber);
  }
  //static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )
  static finishRegion(e, n) {
    var s = n.eUp, r = s.Lface;
    r.inside = n.inside, r.anEdge = s, X.deleteRegion(e, n);
  }
  //static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )
  static finishLeftRegions(e, n, s) {
    for (var r, a = null, o = n, h = n.eUp; o !== s; ) {
      if (o.fixUpperEdge = !1, a = X.regionBelow(o), r = a.eUp, r.Org != h.Org) {
        if (!a.fixUpperEdge) {
          X.finishRegion(e, o);
          break;
        }
        r = e.mesh.connect(h.Lprev, r.Sym), X.fixUpperEdge(e, a, r);
      }
      h.Onext !== r && (e.mesh.splice(r.Oprev, r), e.mesh.splice(h, r)), X.finishRegion(e, o), h = a.eUp, o = a;
    }
    return h;
  }
  //static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )
  static addRightEdges(e, n, s, r, a, o) {
    var h, c, l, u, f = !0;
    l = s;
    do
      pt(dt.vertLeq(l.Org, l.Dst)), X.addRegionBelow(e, n, l.Sym), l = l.Onext;
    while (l !== r);
    for (a === null && (a = X.regionBelow(n).eUp.Rprev), c = n, u = a; h = X.regionBelow(c), l = h.eUp.Sym, l.Org === u.Org; )
      l.Onext !== u && (e.mesh.splice(l.Oprev, l), e.mesh.splice(u.Oprev, l)), h.windingNumber = c.windingNumber - l.winding, h.inside = X.isWindingInside(e, h.windingNumber), c.dirty = !0, !f && X.checkForRightSplice(e, c) && (X.addWinding(l, u), X.deleteRegion(e, c), e.mesh.delete(u)), f = !1, c = h, u = l;
    c.dirty = !0, pt(c.windingNumber - l.winding === h.windingNumber), o && X.walkDirtyRegions(e, c);
  }
  //static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )
  static spliceMergeVertices(e, n, s) {
    e.mesh.splice(n, s);
  }
  //static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )
  static vertexWeights(e, n, s) {
    var r = dt.vertL1dist(n, e), a = dt.vertL1dist(s, e), o = 0.5 * a / (r + a), h = 0.5 * r / (r + a);
    e.coords[0] += o * n.coords[0] + h * s.coords[0], e.coords[1] += o * n.coords[1] + h * s.coords[1], e.coords[2] += o * n.coords[2] + h * s.coords[2];
  }
  //static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )
  static getIntersectData(e, n, s, r, a, o) {
    n.coords[0] = n.coords[1] = n.coords[2] = 0, n.idx = -1, X.vertexWeights(n, s, r), X.vertexWeights(n, a, o);
  }
  //static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )
  static checkForRightSplice(e, n) {
    var s = X.regionBelow(n), r = n.eUp, a = s.eUp;
    if (dt.vertLeq(r.Org, a.Org)) {
      if (dt.edgeSign(a.Dst, r.Org, a.Org) > 0) return !1;
      dt.vertEq(r.Org, a.Org) ? r.Org !== a.Org && (e.pq.delete(r.Org.pqHandle), X.spliceMergeVertices(e, a.Oprev, r)) : (e.mesh.splitEdge(a.Sym), e.mesh.splice(r, a.Oprev), n.dirty = s.dirty = !0);
    } else {
      if (dt.edgeSign(r.Dst, a.Org, r.Org) < 0) return !1;
      X.regionAbove(n).dirty = n.dirty = !0, e.mesh.splitEdge(r.Sym), e.mesh.splice(a.Oprev, r);
    }
    return !0;
  }
  //static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )
  static checkForLeftSplice(e, n) {
    var s = X.regionBelow(n), r = n.eUp, a = s.eUp, o;
    if (pt(!dt.vertEq(r.Dst, a.Dst)), dt.vertLeq(r.Dst, a.Dst)) {
      if (dt.edgeSign(r.Dst, a.Dst, r.Org) < 0) return !1;
      X.regionAbove(n).dirty = n.dirty = !0, o = e.mesh.splitEdge(r), e.mesh.splice(a.Sym, o), o.Lface.inside = n.inside;
    } else {
      if (dt.edgeSign(a.Dst, r.Dst, a.Org) > 0) return !1;
      n.dirty = s.dirty = !0, o = e.mesh.splitEdge(a), e.mesh.splice(r.Lnext, a.Sym), o.Rface.inside = n.inside;
    }
    return !0;
  }
  //static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )
  static checkForIntersect(e, n) {
    var s = X.regionBelow(n), r = n.eUp, a = s.eUp, o = r.Org, h = a.Org, c = r.Dst, l = a.Dst, u, f, d = new na(), p, y;
    if (pt(!dt.vertEq(l, c)), pt(dt.edgeSign(c, e.event, o) <= 0), pt(dt.edgeSign(l, e.event, h) >= 0), pt(o !== e.event && h !== e.event), pt(!n.fixUpperEdge && !s.fixUpperEdge), o === h || (u = Math.min(o.t, c.t), f = Math.max(h.t, l.t), u > f)) return !1;
    if (dt.vertLeq(o, h)) {
      if (dt.edgeSign(l, o, h) > 0) return !1;
    } else if (dt.edgeSign(c, h, o) < 0) return !1;
    return dt.intersect(c, o, l, h, d), pt(Math.min(o.t, c.t) <= d.t), pt(d.t <= Math.max(h.t, l.t)), pt(Math.min(l.s, c.s) <= d.s), pt(d.s <= Math.max(h.s, o.s)), dt.vertLeq(d, e.event) && (d.s = e.event.s, d.t = e.event.t), p = dt.vertLeq(o, h) ? o : h, dt.vertLeq(p, d) && (d.s = p.s, d.t = p.t), dt.vertEq(d, o) || dt.vertEq(d, h) ? (X.checkForRightSplice(e, n), !1) : !dt.vertEq(c, e.event) && dt.edgeSign(c, e.event, d) >= 0 || !dt.vertEq(l, e.event) && dt.edgeSign(l, e.event, d) <= 0 ? l === e.event ? (e.mesh.splitEdge(r.Sym), e.mesh.splice(a.Sym, r), n = X.topLeftRegion(e, n), r = X.regionBelow(n).eUp, X.finishLeftRegions(e, X.regionBelow(n), s), X.addRightEdges(e, n, r.Oprev, r, r, !0), !0) : c === e.event ? (e.mesh.splitEdge(a.Sym), e.mesh.splice(r.Lnext, a.Oprev), s = n, n = X.topRightRegion(n), y = X.regionBelow(n).eUp.Rprev, s.eUp = a.Oprev, a = X.finishLeftRegions(e, s, null), X.addRightEdges(e, n, a.Onext, r.Rprev, y, !0), !0) : (dt.edgeSign(c, e.event, d) >= 0 && (X.regionAbove(n).dirty = n.dirty = !0, e.mesh.splitEdge(r.Sym), r.Org.s = e.event.s, r.Org.t = e.event.t), dt.edgeSign(l, e.event, d) <= 0 && (n.dirty = s.dirty = !0, e.mesh.splitEdge(a.Sym), a.Org.s = e.event.s, a.Org.t = e.event.t), !1) : (e.mesh.splitEdge(r.Sym), e.mesh.splitEdge(a.Sym), e.mesh.splice(a.Oprev, r), r.Org.s = d.s, r.Org.t = d.t, r.Org.pqHandle = e.pq.insert(r.Org), X.getIntersectData(e, r.Org, o, c, h, l), X.regionAbove(n).dirty = n.dirty = s.dirty = !0, !1);
  }
  //static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )
  static walkDirtyRegions(e, n) {
    for (var s = X.regionBelow(n), r, a; ; ) {
      for (; s.dirty; )
        n = s, s = X.regionBelow(s);
      if (!n.dirty && (s = n, n = X.regionAbove(n), n === null || !n.dirty))
        return;
      if (n.dirty = !1, r = n.eUp, a = s.eUp, r.Dst !== a.Dst && X.checkForLeftSplice(e, n) && (s.fixUpperEdge ? (X.deleteRegion(e, s), e.mesh.delete(a), s = X.regionBelow(n), a = s.eUp) : n.fixUpperEdge && (X.deleteRegion(e, n), e.mesh.delete(r), n = X.regionAbove(s), r = n.eUp)), r.Org !== a.Org)
        if (r.Dst !== a.Dst && !n.fixUpperEdge && !s.fixUpperEdge && (r.Dst === e.event || a.Dst === e.event)) {
          if (X.checkForIntersect(e, n))
            return;
        } else
          X.checkForRightSplice(e, n);
      r.Org === a.Org && r.Dst === a.Dst && (X.addWinding(a, r), X.deleteRegion(e, n), e.mesh.delete(r), n = X.regionAbove(s));
    }
  }
  //static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )
  static connectRightVertex(e, n, s) {
    var r, a = s.Onext, o = X.regionBelow(n), h = n.eUp, c = o.eUp, l = !1;
    if (h.Dst !== c.Dst && X.checkForIntersect(e, n), dt.vertEq(h.Org, e.event) && (e.mesh.splice(a.Oprev, h), n = X.topLeftRegion(e, n), a = X.regionBelow(n).eUp, X.finishLeftRegions(e, X.regionBelow(n), o), l = !0), dt.vertEq(c.Org, e.event) && (e.mesh.splice(s, c.Oprev), s = X.finishLeftRegions(e, o, null), l = !0), l) {
      X.addRightEdges(
        e,
        n,
        s.Onext,
        a,
        a,
        !0
      );
      return;
    }
    dt.vertLeq(c.Org, h.Org) ? r = c.Oprev : r = h, r = e.mesh.connect(s.Lprev, r), X.addRightEdges(e, n, r, r.Onext, r.Onext, !1), r.Sym.activeRegion.fixUpperEdge = !0, X.walkDirtyRegions(e, n);
  }
  /* Because vertices at exactly the same location are merged together
   * before we process the sweep event, some degenerate cases can't occur.
   * However if someone eventually makes the modifications required to
   * merge features which are close together, the cases below marked
   * TOLERANCE_NONZERO will be useful.  They were debugged before the
   * code to merge identical vertices in the main loop was added.
   */
  //#define TOLERANCE_NONZERO	FALSE
  //static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )
  static connectLeftDegenerate(e, n, s) {
    var r, a, o, h, c;
    if (r = n.eUp, dt.vertEq(r.Org, s)) {
      pt(
        !1
        /*TOLERANCE_NONZERO*/
      ), X.spliceMergeVertices(e, r, s.anEdge);
      return;
    }
    if (!dt.vertEq(r.Dst, s)) {
      e.mesh.splitEdge(r.Sym), n.fixUpperEdge && (e.mesh.delete(r.Onext), n.fixUpperEdge = !1), e.mesh.splice(s.anEdge, r), X.sweepEvent(e, s);
      return;
    }
    pt(
      !1
      /*TOLERANCE_NONZERO*/
    ), n = X.topRightRegion(n), c = X.regionBelow(n), o = c.eUp.Sym, a = h = o.Onext, c.fixUpperEdge && (pt(a !== o), X.deleteRegion(e, c), e.mesh.delete(o), o = a.Oprev), e.mesh.splice(s.anEdge, o), dt.edgeGoesLeft(a) || (a = null), X.addRightEdges(
      e,
      n,
      o.Onext,
      h,
      a,
      !0
    );
  }
  //static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )
  static connectLeftVertex(e, n) {
    var s, r, a, o, h, c, l = new Ku();
    if (l.eUp = n.anEdge.Sym, s = e.dict.search(l).key, r = X.regionBelow(s), !!r) {
      if (o = s.eUp, h = r.eUp, dt.edgeSign(o.Dst, n, o.Org) === 0) {
        X.connectLeftDegenerate(e, s, n);
        return;
      }
      if (a = dt.vertLeq(h.Dst, o.Dst) ? s : r, s.inside || a.fixUpperEdge) {
        if (a === s)
          c = e.mesh.connect(n.anEdge.Sym, o.Lnext);
        else {
          var u = e.mesh.connect(h.Dnext, n.anEdge);
          c = u.Sym;
        }
        a.fixUpperEdge ? X.fixUpperEdge(e, a, c) : X.computeWinding(
          e,
          X.addRegionBelow(e, s, c)
        ), X.sweepEvent(e, n);
      } else
        X.addRightEdges(
          e,
          s,
          n.anEdge,
          n.anEdge,
          null,
          !0
        );
    }
  }
  //static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )
  static sweepEvent(e, n) {
    e.event = n;
    for (var s = n.anEdge; s.activeRegion === null; )
      if (s = s.Onext, s === n.anEdge) {
        X.connectLeftVertex(e, n);
        return;
      }
    var r = X.topLeftRegion(e, s.activeRegion);
    pt(r !== null);
    var a = X.regionBelow(r), o = a.eUp, h = X.finishLeftRegions(e, a, null);
    h.Onext === o ? X.connectRightVertex(e, r, h) : X.addRightEdges(
      e,
      r,
      h.Onext,
      o,
      o,
      !0
    );
  }
  /* Make the sentinel coordinates big enough that they will never be
   * merged with real input features.
   */
  //static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )
  static addSentinel(e, n, s, r) {
    var a = new Ku(), o = e.mesh.makeEdge();
    o.Org.s = s, o.Org.t = r, o.Dst.s = n, o.Dst.t = r, e.event = o.Dst, a.eUp = o, a.windingNumber = 0, a.inside = !1, a.fixUpperEdge = !1, a.sentinel = !0, a.dirty = !1, a.nodeUp = e.dict.insert(a);
  }
  //static void InitEdgeDict( TESStesselator *tess )
  static initEdgeDict(e) {
    e.dict = new l5(e, X.edgeLeq);
    var n = e.bmax[0] - e.bmin[0], s = e.bmax[1] - e.bmin[1], r = e.bmin[0] - n, a = e.bmax[0] + n, o = e.bmin[1] - s, h = e.bmax[1] + s;
    X.addSentinel(e, r, a, o), X.addSentinel(e, r, a, h);
  }
  static doneEdgeDict(e) {
    for (var n, s = 0; (n = e.dict.min().key) !== null; )
      n.sentinel || (pt(n.fixUpperEdge), pt(++s === 1)), pt(n.windingNumber === 0), X.deleteRegion(e, n);
  }
  static removeDegenerateEdges(e) {
    var n, s, r, a = e.mesh.eHead;
    for (n = a.next; n !== a; n = s)
      s = n.next, r = n.Lnext, dt.vertEq(n.Org, n.Dst) && n.Lnext.Lnext !== n && (X.spliceMergeVertices(e, r, n), e.mesh.delete(n), n = r, r = n.Lnext), r.Lnext === n && (r !== n && ((r === s || r === s.Sym) && (s = s.next), e.mesh.delete(r)), (n === s || n === s.Sym) && (s = s.next), e.mesh.delete(n));
  }
  static initPriorityQ(e) {
    var n, s, r, a = 0;
    for (r = e.mesh.vHead, s = r.next; s !== r; s = s.next)
      a++;
    for (a += 8, n = e.pq = new c5(a, dt.vertLeq), r = e.mesh.vHead, s = r.next; s !== r; s = s.next)
      s.pqHandle = n.insert(s);
    return s !== r ? !1 : (n.init(), !0);
  }
  static donePriorityQ(e) {
    e.pq = null;
  }
  static removeDegenerateFaces(e, n) {
    var s, r, a;
    for (s = n.fHead.next; s !== n.fHead; s = r)
      r = s.next, a = s.anEdge, pt(a.Lnext !== a), a.Lnext.Lnext === a && (X.addWinding(a.Onext, a), e.mesh.delete(a));
    return !0;
  }
  static computeInterior(e, n = !0) {
    var s, r;
    if (X.removeDegenerateEdges(e), !X.initPriorityQ(e))
      return !1;
    for (X.initEdgeDict(e); (s = e.pq.extractMin()) !== null; ) {
      for (; r = e.pq.min(), !(r === null || !dt.vertEq(r, s)); )
        r = e.pq.extractMin(), X.spliceMergeVertices(e, s.anEdge, r.anEdge);
      X.sweepEvent(e, s);
    }
    return e.event = e.dict.min().key.eUp.Org, X.doneEdgeDict(e), X.donePriorityQ(e), X.removeDegenerateFaces(e, e.mesh), n && e.mesh.check(), !0;
  }
}
class f2 {
  /*** state needed for collecting the input data ***/
  /* stores the input contours, and eventually the tessellation itself */
  mesh = new Mx();
  /*** state needed for projecting onto the sweep plane ***/
  normal = [0, 0, 0];
  /* user-specified normal (if provided) */
  sUnit = [0, 0, 0];
  /* unit vector in s-direction (debugging) */
  tUnit = [0, 0, 0];
  /* unit vector in t-direction (debugging) */
  bmin = [0, 0];
  bmax = [0, 0];
  /*** state needed for the line sweep ***/
  /* rule for determining polygon interior */
  windingRule = Qe.ODD;
  dict = null;
  /* edge dictionary for sweep line */
  pq = null;
  /* priority queue of vertex events */
  event = null;
  /* current sweep event being processed */
  vertexIndexCounter = 0;
  vertices = [];
  vertexIndices = [];
  vertexCount = 0;
  elements = [];
  elementCount = 0;
  dot_(e, n) {
    return e[0] * n[0] + e[1] * n[1] + e[2] * n[2];
  }
  normalize_(e) {
    let n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2];
    if (!n)
      throw "Zero-size vector!";
    n = Math.sqrt(n), e[0] /= n, e[1] /= n, e[2] /= n;
  }
  longAxis_(e) {
    let n = 0;
    return Math.abs(e[1]) > Math.abs(e[0]) && (n = 1), Math.abs(e[2]) > Math.abs(e[n]) && (n = 2), n;
  }
  computeNormal_(e) {
    let n, s, r, a, o, h, c = [0, 0, 0], l = [0, 0, 0], u = [0, 0, 0], f = [0, 0, 0], d = [0, 0, 0];
    const p = [null, null, null], y = [null, null, null], x = this.mesh.vHead;
    n = x.next;
    for (let m = 0; m < 3; ++m)
      a = n.coords[m], l[m] = a, y[m] = n, c[m] = a, p[m] = n;
    for (n = x.next; n !== x; n = n.next)
      for (let m = 0; m < 3; ++m)
        a = n.coords[m], a < l[m] && (l[m] = a, y[m] = n), a > c[m] && (c[m] = a, p[m] = n);
    let g = 0;
    if (c[1] - l[1] > c[0] - l[0] && (g = 1), c[2] - l[2] > c[g] - l[g] && (g = 2), l[g] >= c[g]) {
      e[0] = 0, e[1] = 0, e[2] = 1;
      return;
    }
    for (h = 0, s = y[g], r = p[g], u[0] = s.coords[0] - r.coords[0], u[1] = s.coords[1] - r.coords[1], u[2] = s.coords[2] - r.coords[2], n = x.next; n !== x; n = n.next)
      f[0] = n.coords[0] - r.coords[0], f[1] = n.coords[1] - r.coords[1], f[2] = n.coords[2] - r.coords[2], d[0] = u[1] * f[2] - u[2] * f[1], d[1] = u[2] * f[0] - u[0] * f[2], d[2] = u[0] * f[1] - u[1] * f[0], o = d[0] * d[0] + d[1] * d[1] + d[2] * d[2], o > h && (h = o, e[0] = d[0], e[1] = d[1], e[2] = d[2]);
    h <= 0 && (e[0] = e[1] = e[2] = 0, e[this.longAxis_(u)] = 1);
  }
  checkOrientation_() {
    var e = this.mesh.fHead, n, s = this.mesh.vHead, r;
    let a = 0;
    for (let o = e.next; o !== e; o = o.next)
      if (r = o.anEdge, !(r.winding <= 0))
        do
          a += (r.Org.s - r.Dst.s) * (r.Org.t + r.Dst.t), r = r.Lnext;
        while (r !== o.anEdge);
    if (a < 0) {
      for (n = s.next; n !== s; n = n.next)
        n.t = -n.t;
      this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
    }
  }
  /*	#ifdef FOR_TRITE_TEST_PROGRAM
  	#include <stdlib.h>
  	extern int RandomSweep;
  	#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
  	#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
  	#else
  	#if defined(SLANTED_SWEEP) */
  /* The "feature merging" is not intended to be complete.  There are
   * special cases where edges are nearly parallel to the sweep line
   * which are not implemented.  The algorithm should still behave
   * robustly (ie. produce a reasonable tesselation) in the presence
   * of such edges, however it may miss features which could have been
   * merged.  We could minimize this effect by choosing the sweep line
   * direction to be something unusual (ie. not parallel to one of the
   * coordinate axes).
   */
  /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
  	#define S_UNIT_Y	(TESSreal)0.86052074622010633
  	#else
  	#define S_UNIT_X	(TESSreal)1.0
  	#define S_UNIT_Y	(TESSreal)0.0
  	#endif
  	#endif*/
  /* Determine the polygon normal and project vertices onto the plane
   * of the polygon.
   */
  projectPolygon_() {
    let e = this.mesh.vHead, n = [0, 0, 0], s, r, a = !1;
    n[0] = this.normal[0], n[1] = this.normal[1], n[2] = this.normal[2], !n[0] && !n[1] && !n[2] && (this.computeNormal_(n), a = !0), s = this.sUnit, r = this.tUnit;
    let o = this.longAxis_(n);
    s[o] = 0, s[(o + 1) % 3] = 1, s[(o + 2) % 3] = 0, r[o] = 0, r[(o + 1) % 3] = 0, r[(o + 2) % 3] = n[o] > 0 ? 1 : -1;
    for (let c = e.next; c !== e; c = c.next)
      c.s = this.dot_(c.coords, s), c.t = this.dot_(c.coords, r);
    a && this.checkOrientation_();
    let h = !0;
    for (let c = e.next; c !== e; c = c.next)
      h ? (this.bmin[0] = this.bmax[0] = c.s, this.bmin[1] = this.bmax[1] = c.t, h = !1) : (c.s < this.bmin[0] && (this.bmin[0] = c.s), c.s > this.bmax[0] && (this.bmax[0] = c.s), c.t < this.bmin[1] && (this.bmin[1] = c.t), c.t > this.bmax[1] && (this.bmax[1] = c.t));
  }
  addWinding_(e, n) {
    e.winding += n.winding, e.Sym.winding += n.Sym.winding;
  }
  /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
   * (what else would it do??)  The region must consist of a single
   * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
   * case means that any vertical line intersects the interior of the
   * region in a single interval.
   *
   * Tessellation consists of adding interior edges (actually pairs of
   * half-edges), to split the region into non-overlapping triangles.
   *
   * The basic idea is explained in Preparata and Shamos (which I don''t
   * have handy right now), although their implementation is more
   * complicated than this one.  The are two edge chains, an upper chain
   * and a lower chain.  We process all vertices from both chains in order,
   * from right to left.
   *
   * The algorithm ensures that the following invariant holds after each
   * vertex is processed: the untessellated region consists of two
   * chains, where one chain (say the upper) is a single edge, and
   * the other chain is concave.  The left vertex of the single edge
   * is always to the left of all vertices in the concave chain.
   *
   * Each step consists of adding the rightmost unprocessed vertex to one
   * of the two chains, and forming a fan of triangles from the rightmost
   * of two chain endpoints.  Determining whether we can add each triangle
   * to the fan is a simple orientation test.  By making the fan as large
   * as possible, we restore the invariant (check it yourself).
   */
  //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
  tessellateMonoRegion_(e, n) {
    let s, r;
    if (s = n.anEdge, !(s.Lnext !== s && s.Lnext.Lnext !== s))
      throw "Mono region invalid";
    for (; dt.vertLeq(s.Dst, s.Org); s = s.Lprev) ;
    for (; dt.vertLeq(s.Org, s.Dst); s = s.Lnext) ;
    r = s.Lprev;
    let a;
    for (; s.Lnext !== r; )
      if (dt.vertLeq(s.Dst, r.Org)) {
        for (; r.Lnext !== s && (dt.edgeGoesLeft(r.Lnext) || dt.edgeSign(r.Org, r.Dst, r.Lnext.Dst) <= 0); )
          a = e.connect(r.Lnext, r), r = a.Sym;
        r = r.Lprev;
      } else {
        for (; r.Lnext !== s && (dt.edgeGoesRight(s.Lprev) || dt.edgeSign(s.Dst, s.Org, s.Lprev.Org) >= 0); )
          a = e.connect(s, s.Lprev), s = a.Sym;
        s = s.Lnext;
      }
    if (r.Lnext === s)
      throw "Mono region invalid";
    for (; r.Lnext.Lnext !== s; )
      a = e.connect(r.Lnext, r), r = a.Sym;
    return !0;
  }
  /* tessMeshTessellateInterior( mesh ) tessellates each region of
   * the mesh which is marked "inside" the polygon.  Each such region
   * must be monotone.
   */
  //int tessMeshTessellateInterior( TESSmesh *mesh )
  tessellateInterior_(e) {
    let n;
    for (let s = e.fHead.next; s !== e.fHead; s = n)
      if (n = s.next, s.inside && !this.tessellateMonoRegion_(e, s))
        return !1;
    return !0;
  }
  /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
   * which are not marked "inside" the polygon.  Since further mesh operations
   * on NULL faces are not allowed, the main purpose is to clean up the
   * mesh so that exterior loops are not represented in the data structure.
   */
  //void tessMeshDiscardExterior( TESSmesh *mesh )
  discardExterior_(e) {
    let n;
    for (let s = e.fHead.next; s !== e.fHead; s = n)
      n = s.next, s.inside || e.zapFace(s);
  }
  /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
   * winding numbers on all edges so that regions marked "inside" the
   * polygon have a winding number of "value", and regions outside
   * have a winding number of 0.
   *
   * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
   * separate an interior region from an exterior one.
   */
  //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
  setWindingNumber_(e, n, s) {
    let r;
    for (let a = e.eHead.next; a !== e.eHead; a = r)
      r = a.next, a.Rface.inside !== a.Lface.inside ? a.winding = a.Lface.inside ? n : -n : s ? e.delete(a) : a.winding = 0;
  }
  getNeighbourFace_(e) {
    return !e.Rface || !e.Rface.inside ? -1 : e.Rface.n;
  }
  outputPolymesh_(e, n, s, r) {
    let a, o = 0, h = 0, c;
    s > 3 && e.mergeConvexFaces(s);
    for (let f = e.vHead.next; f !== e.vHead; f = f.next)
      f.n = -1;
    for (let f = e.fHead.next; f !== e.fHead; f = f.next)
      if (f.n = -1, !!f.inside) {
        a = f.anEdge, c = 0;
        do {
          let d = a.Org;
          d.n === -1 && (d.n = h, h++), c++, a = a.Lnext;
        } while (a !== f.anEdge);
        if (c > s)
          throw "Face vertex greater that support polygon";
        f.n = o, ++o;
      }
    this.elementCount = o, n === Jn.CONNECTED_POLYGONS && (o *= 2), this.elements = [], this.elements.length = o * s, this.vertexCount = h, this.vertices = [], this.vertices.length = h * r, this.vertexIndices = [], this.vertexIndices.length = h;
    for (let f = e.vHead.next; f !== e.vHead; f = f.next)
      if (f.n !== -1) {
        var l = f.n * r;
        this.vertices[l + 0] = f.coords[0], this.vertices[l + 1] = f.coords[1], r > 2 && (this.vertices[l + 2] = f.coords[2]), this.vertexIndices[f.n] = f.idx;
      }
    let u = 0;
    for (let f = e.fHead.next; f !== e.fHead; f = f.next)
      if (f.inside) {
        a = f.anEdge, c = 0;
        do {
          let d = a.Org;
          this.elements[u++] = d.n, c++, a = a.Lnext;
        } while (a !== f.anEdge);
        for (let d = c; d < s; ++d)
          this.elements[u++] = -1;
        if (n === Jn.CONNECTED_POLYGONS) {
          a = f.anEdge;
          do
            this.elements[u++] = this.getNeighbourFace_(a), a = a.Lnext;
          while (a !== f.anEdge);
          for (let d = c; d < s; ++d)
            this.elements[u++] = -1;
        }
      }
  }
  //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
  outputContours_(e, n) {
    let s, r, a = 0, o = 0;
    this.vertexCount = 0, this.elementCount = 0;
    for (let u = e.fHead.next; u !== e.fHead; u = u.next)
      if (u.inside) {
        r = s = u.anEdge;
        do
          this.vertexCount++, s = s.Lnext;
        while (s !== r);
        this.elementCount++;
      }
    this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * n, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
    let h = 0, c = 0, l = 0;
    a = 0;
    for (let u = e.fHead.next; u !== e.fHead; u = u.next)
      if (u.inside) {
        o = 0, r = s = u.anEdge;
        do
          this.vertices[h++] = s.Org.coords[0], this.vertices[h++] = s.Org.coords[1], n > 2 && (this.vertices[h++] = s.Org.coords[2]), this.vertexIndices[c++] = s.Org.idx, o++, s = s.Lnext;
        while (s !== r);
        this.elements[l++] = a, this.elements[l++] = o, a += o;
      }
  }
  addContour(e, n) {
    this.mesh === null && (this.mesh = new Mx()), e < 2 && (e = 2), e > 3 && (e = 3);
    let s = null;
    for (let r = 0; r < n.length; r += e)
      s === null ? (s = this.mesh.makeEdge(), this.mesh.splice(s, s.Sym)) : (this.mesh.splitEdge(s), s = s.Lnext), s.Org.coords[0] = n[r + 0], s.Org.coords[1] = n[r + 1], e > 2 ? s.Org.coords[2] = n[r + 2] : s.Org.coords[2] = 0, s.Org.idx = this.vertexIndexCounter++, s.winding = 1, s.Sym.winding = -1;
  }
  //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
  /**
   * Run tesselation
   * @param windingRule 
   * @param elementType 
   * @param polySize 
   * @param vertexSize 
   * @param normal 
   * @param validate UNSAFE! Skip mesh validation pass, may throw any error.
   */
  tesselate(e = Qe.ODD, n = Jn.POLYGONS, s, r, a, o = !0) {
    if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, a && (this.normal[0] = a[0], this.normal[1] = a[1], this.normal[2] = a[2]), this.windingRule = e, r < 2 && (r = 2), r > 3 && (r = 3), !this.mesh)
      return !1;
    this.projectPolygon_(), X.computeInterior(this, o);
    var h = this.mesh;
    return n === Jn.BOUNDARY_CONTOURS ? this.setWindingNumber_(h, 1, !0) : this.tessellateInterior_(h), o && h.check(), n === Jn.BOUNDARY_CONTOURS ? this.outputContours_(h, r) : this.outputPolymesh_(
      h,
      n,
      s,
      r
    ), !0;
  }
}
function u5({
  windingRule: i = Qe.ODD,
  elementType: e = Jn.POLYGONS,
  polySize: n = 3,
  vertexSize: s = 2,
  normal: r = [0, 0, 1],
  contours: a = [],
  strict: o = !0,
  debug: h = !1
}) {
  if (!a && o)
    throw new Error("Contours can't be empty");
  if (!a)
    return;
  const c = new f2();
  for (let l = 0; l < a.length; l++)
    c.addContour(s || 2, a[l]);
  return c.tesselate(
    i,
    e,
    n,
    s,
    r,
    o
  ), {
    vertices: c.vertices,
    vertexIndices: c.vertexIndices,
    vertexCount: c.vertexCount,
    elements: c.elements,
    elementCount: c.elementCount,
    mesh: h ? c.mesh : void 0
  };
}
const f5 = Qe.ODD, d5 = Qe.NONZERO, p5 = Qe.POSITIVE, y5 = Qe.NEGATIVE, x5 = Qe.ABS_GEQ_TWO, g5 = Jn.POLYGONS, m5 = Jn.CONNECTED_POLYGONS, v5 = Jn.BOUNDARY_CONTOURS, w5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOUNDARY_CONTOURS: v5,
  CONNECTED_POLYGONS: m5,
  ELEMENT: Jn,
  POLYGONS: g5,
  Tesselator: f2,
  WINDING: Qe,
  WINDING_ABS_GEQ_TWO: x5,
  WINDING_NEGATIVE: y5,
  WINDING_NONZERO: d5,
  WINDING_ODD: f5,
  WINDING_POSITIVE: p5,
  tesselate: u5
}, Symbol.toStringTag, { value: "Module" }));
function d2(i = 10) {
  return Math.random().toString(36).substr(2, i);
}
function M5(i, ...e) {
  return i instanceof Function ? i(...e) : i;
}
function Ho(i, ...e) {
  return e.includes(i);
}
const b5 = (i, e) => i.concat(e);
function p2(i, e, n = b5) {
  for (const s of Object.keys(e))
    s in i && Array.isArray(i[s]) && Array.isArray(e[s]) ? i[s] = n(i[s], e[s]) : s in i && i[s] instanceof Object && e[s] instanceof Object ? p2(i[s], e[s]) : i[s] = e[s];
}
function _5(i, e = 0) {
  return e ? +setTimeout(i, e) : (i(), 0);
}
function S5(i) {
  return new Promise((e) => setTimeout(e, i));
}
function T5() {
  let i = () => {
  }, e = () => {
  };
  const n = new Promise((s, r) => {
    i = s, e = r;
  });
  return n.catch((s) => s), { promise: n, resolve: i, reject: e };
}
class Tx extends Error {
  constructor(e) {
    super("[Cache Error]"), this.data = e;
  }
}
function E5(i) {
  const e = /* @__PURE__ */ new Map();
  return function(...n) {
    const s = n.join("--");
    if (!e.has(s))
      try {
        e.set(s, i(...n));
      } catch (a) {
        e.set(s, new Tx(a));
      }
    const r = e.get(s);
    if (r instanceof Tx) throw r.data;
    return r;
  };
}
function z5(i, e = 0, n = !1) {
  let s = !1, r = !1;
  return (...a) => {
    s ? r = !0 : (n ? r = !0 : i(...a), s = !0, setTimeout(() => {
      r && i(...a), s = r = !1;
    }, e));
  };
}
function C5(i) {
  return function(e, n) {
    if (!e || Array.isArray(this) || i.includes(e)) return n;
  };
}
function A5(i, e, n) {
  if (!i) return e;
  try {
    return JSON.parse(i, n ? C5(n) : void 0) || e;
  } catch {
    return e;
  }
}
function $d(i, e) {
  return new Array(e).fill(i);
}
function Vd(i, e, n) {
  const s = [];
  for (let r = 0; r < e; ++r)
    s.push($d(i, n));
  return s;
}
function Il(i, e) {
  const n = [];
  for (let s = 0; s < e; ++s)
    n.push(i(s));
  return n;
}
function y2(i, e, n) {
  const s = [];
  for (let r = 0; r < e; ++r) {
    const a = [];
    for (let o = 0; o < n; ++o)
      a.push(i(r, o));
    s.push(a);
  }
  return s;
}
function x2(i, e, n = 1) {
  const s = [];
  if (e === void 0 && i >= 0)
    for (let r = 0; r < i; r += n) s.push(r);
  else if (e === void 0)
    for (let r = 0; r > i; r -= n) s.push(r);
  else if (i <= e)
    for (let r = i; r <= e; r += n) s.push(r);
  else
    for (let r = i; r >= e; r -= n) s.push(r);
  return s;
}
function Gd(i, e = 0) {
  return i[i.length - 1 - e];
}
function Ge(i) {
  return i.reduce((e, n) => e + n, 0);
}
function g2(i, e, n = !1) {
  return i.slice(0).sort((s, r) => {
    const a = e(s), o = e(r);
    return a < o ? n ? 1 : -1 : a > o ? n ? -1 : 1 : 0;
  });
}
function P5(i) {
  let e = 0;
  return () => i[e++ % i.length];
}
function m2(i) {
  return i.filter((e, n) => i.indexOf(e) === n);
}
function Ud(i) {
  return i.reduce((e, n) => e.concat(Array.isArray(n) ? Ud(n) : n), []);
}
function I5(i) {
  let e = 0;
  return i.map((n) => e += n);
}
function R5(i, e) {
  const n = [];
  for (let s = 0; s < i.length; s += e)
    n.push(i.slice(s, s + e));
  return n;
}
function O5(i, e = 1) {
  const n = i.length;
  e = (e % n + n) % n;
  const s = i.slice(0, e);
  return i.slice(e).concat(s);
}
function k5(i, e) {
  return i.filter((n) => e.includes(n));
}
function L5(i, e) {
  const n = e.filter((r) => !i.includes(r)), s = i.filter((r) => !e.includes(r));
  return [...n, ...s];
}
function F5(...i) {
  return i.reduce((e, n) => e.concat(n), []);
}
function N5(i) {
  return i.map((e) => e.map((n) => {
    let s = n ? `${n}` : "";
    return s.match(/[,\n"']/) && (s = `"${s.replace(/"/g, '""')}"`), s;
  }).join(",")).join(`
`);
}
class B5 {
  root;
  constructor(e) {
    const n = e.length, s = e.map((r) => ({ val: r }));
    for (const [r, a] of s.entries())
      a.next = s[(r + 1) % n], a.prev = s[(r - 1 + n) % n];
    this.root = s[0];
  }
  *traverse() {
    let e = this.root;
    for (; e; )
      if (yield e, e = e.next, e === this.root) return;
  }
  get array() {
    return Array.from(this.traverse());
  }
  delete(e) {
    if (e === this.root) {
      if (e.next === e) return this.root = void 0;
      this.root = e.next;
    }
    e.prev.next = e.next, e.next.prev = e.prev;
  }
}
var v2 = /* @__PURE__ */ ((i) => (i[i.first = 0] = "first", i[i.firstGreater = 1] = "firstGreater", i))(v2 || {});
function w2(i, e, n) {
  let s = 0, r = i.length - 1, a = -1;
  for (; s <= r; ) {
    const o = Math.floor((s + r) / 2), h = i[o].val;
    h < e ? s = o + 1 : h > e ? (n === 1 && (a = o), r = o - 1) : n === 0 ? (a = o, r = o - 1) : n === 1 && (s = o + 1);
  }
  return a;
}
function D5(i, e, n) {
  let s = w2(
    i,
    n,
    0
    /* first */
  );
  if (s < 0) return -1;
  for (; i[s].val === n; ) {
    if (i[s].item === e) return s;
    s += 1;
  }
  return -1;
}
function tl(i, e = /\s+/) {
  return i ? i.trim().split(e) : [];
}
function q5(i) {
  return i.replace(/\S+/g, (e) => e.charAt(0).toUpperCase() + e.slice(1));
}
function $5(i) {
  return i.toLowerCase().replace(/^-/, "").replace(/-(.)/g, (e, n) => n.toUpperCase());
}
function V5(i) {
  return i === i.split("").reverse().join("");
}
function M2(i, e, n = !1) {
  const s = Vd(0, i.length + 1, e.length + 1);
  for (let r = 0; r <= i.length; r++) s[r][0] = r;
  for (let r = 0; r <= e.length; r++) s[0][r] = r;
  for (let r = 1; r <= i.length; r++)
    for (let a = 1; a <= e.length; a++)
      s[r][a] = Math.min(
        s[r - 1][a - 1] + (i.charAt(r - 1) === e.charAt(a - 1) ? 0 : 1),
        s[r - 1][a] + 1,
        s[r][a - 1] + 1
      );
  return n ? Math.min(...s[i.length]) : s[i.length][e.length];
}
function G5(i, e) {
  const n = i.length / 2, s = e.map((a) => ({ w: a, d: M2(i, a) })).filter(({ d: a }) => a < n), r = g2(s, (a) => a.d)[0];
  return r ? r.w : void 0;
}
class U5 {
  events = /* @__PURE__ */ new Map();
  /** Adds an event listener for one or more events. */
  on(e, n) {
    for (const s of tl(e))
      this.events.has(s) || this.events.set(s, []), this.events.get(s).push(n);
  }
  /** Adds a one-time event listener to one or more events. */
  one(e, n) {
    const s = (r) => {
      this.off(e, s), n(r);
    };
    this.on(e, s);
  }
  /** Removes an event listener from one or more events. */
  off(e, n) {
    for (const s of tl(e))
      this.events.has(s) && this.events.set(s, this.events.get(s).filter((r) => r !== n));
  }
  /** Triggers one or more events, and executes all bound event listeners. */
  trigger(e, n) {
    for (const s of tl(e))
      if (this.events.has(s))
        for (const r of this.events.get(s))
          r(n);
  }
}
const W5 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, Y5 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, j5 = /rgba?\(([0-9.]+), ?([0-9.]+), ?([0-9.]+)(, ?([0-9.]+))?\)/, H5 = [
  "#22ab24",
  "#009ea6",
  "#0f82f2",
  "#6d3bbf",
  "#cd0e66",
  "#eb4726",
  "#fd8c00"
];
function Ex(i) {
  return i.length === 1 ? `0${i}` : i;
}
function zx(i, e) {
  if (e <= 0) return el.from(i[0]);
  if (e >= 1) return el.from(Gd(i));
  const n = Math.floor(e * (i.length - 1)), s = e * (i.length - 1) - n;
  return el.mix(i[n + 1], i[n], s);
}
function tf(i, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? i + (e - i) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? i + (e - i) * (2 / 3 - n) * 6 : i;
}
let el = class ke {
  constructor(e, n, s, r = 1) {
    this.r = e, this.g = n, this.b = s, this.a = r;
  }
  /** Converts this color to a hex string. */
  get hex() {
    const e = [this.r, this.g, this.b].map((s) => Ex(Math.round(s).toString(16))), n = this.a >= 1 ? "" : Ex(Math.round(this.a * 255).toString(16));
    return `#${e.join("")}${n}`;
  }
  /** Converts this color to an rgba string. */
  get rgb() {
    return `rgba(${[this.r, this.g, this.b].map((n) => Math.round(n)).join(",")},${this.a})`;
  }
  /** Get the brightness of this color. */
  get brightness() {
    return (this.r * 299 + this.g * 587 + this.g * 114) / 1e3;
  }
  /** Converts this color to an HSL array. */
  get hsl() {
    const e = this.r / 255, n = this.g / 255, s = this.b / 255, r = Math.max(e, n, s), a = Math.min(e, n, s), o = (a + r) / 2, h = r - a;
    if (r === a) return [0, 0, Math.round(o * 100)];
    let c = e === r ? (n - s) / h : n === r ? 2 + (s - e) / h : 4 + (e - n) / h;
    c = Math.min(c * 60, 360), c < 0 && (c += 360);
    const l = o <= 0.5 ? h / (r + a) : h / (2 - r - a);
    return [Math.round(c), Math.round(l * 100), Math.round(o * 100)];
  }
  get chroma() {
    return Math.max(this.r, this.g, this.b) - Math.min(this.r, this.g, this.b);
  }
  toString() {
    return this.rgb;
  }
  /** Creates a copy of this color. */
  copy() {
    return new ke(this.r, this.g, this.b, this.a);
  }
  // ---------------------------------------------------------------------------
  static from(e) {
    return typeof e != "string" ? e : e.startsWith("#") ? ke.fromHex(e) : ke.fromRgb(e);
  }
  static fromRgb(e) {
    const n = e.match(j5);
    if (!n) return new ke(0, 0, 0);
    const s = n[4] ? +n[5] || 0 : 1;
    return new ke(+n[1], +n[2], +n[3], s);
  }
  /** Creates a Color instance from a hex string. */
  static fromHex(e) {
    e = e.replace(W5, (s, r, a, o) => r + r + a + a + o + o);
    const n = Y5.exec(e);
    return n ? new ke(
      parseInt(n[1], 16),
      parseInt(n[2], 16),
      parseInt(n[3], 16),
      n[4] ? parseInt(n[4], 16) / 255 : 1
    ) : new ke(0, 0, 0);
  }
  static fromHsl(e, n, s) {
    if (e /= 360, n /= 100, s /= 100, n === 0) {
      const l = Math.round(s * 255);
      return new ke(l, l, l);
    }
    const r = s < 0.5 ? s * (1 + n) : s + n - s * n, a = 2 * s - r, o = tf(a, r, e + 1 / 3), h = tf(a, r, e), c = tf(a, r, e - 1 / 3);
    return new ke(Math.round(o * 255), Math.round(h * 255), Math.round(c * 255));
  }
  /** Generates a rainbow gradient with a given number of steps. */
  static rainbow(e) {
    return Il((n) => zx(H5, n / (e - 1)), e);
  }
  /** Generates a rainbow gradient with a given number of steps. */
  static gradient(e, n) {
    return Il((s) => zx(e, s / (n - 1)), n);
  }
  static shades(e, n, s = 0.5) {
    const r = ke.mix("#fff", e, s), a = ke.mix("#000", e, s);
    return ke.gradient([r, e, a], n);
  }
  /** Linearly interpolates two colors or hex strings. */
  static mix(e, n, s = 0.5) {
    return e = ke.from(e), n = ke.from(n), new ke(
      s * e.r + (1 - s) * n.r,
      s * e.g + (1 - s) * n.g,
      s * e.b + (1 - s) * n.b,
      s * e.a + (1 - s) * n.a
    );
  }
  static mixMany(e, n) {
    n || (n = e.map(() => 1));
    const s = Ge(n), r = e.map((g) => g.hsl), a = r.map((g) => g[0]), o = a.map((g) => g < 180 ? g + 360 : g), h = n.map((g, m) => g * Math.sqrt(e[m].chroma)), c = Ge(h), l = Ge(a.map((g, m) => g * h[m])) / c, u = Ge(o.map((g, m) => g * h[m])) / c, f = Ge(a.map((g, m) => Math.abs(g - l) * h[m])), d = Ge(o.map((g, m) => Math.abs(g - u) * h[m])), p = f <= d ? l : u % 360, y = Ge(r.map((g, m) => n[m] * g[1])) / s, x = Ge(r.map((g, m) => n[m] * g[2])) / s;
    return ke.fromHsl(p, y, x);
  }
};
class X5 {
  constructor(e) {
    this.maxSize = e;
  }
  store = /* @__PURE__ */ new Map();
  list = [];
  has(e) {
    return this.store.has(e);
  }
  get(e) {
    const n = this.store.get(e);
    return n && this.touch(e, n), n ? n.val : void 0;
  }
  set(e, n) {
    const s = this.store.get(e);
    if (s) {
      s.val = n, this.touch(e, s);
      return;
    }
    if (this.list.push(e), this.store.set(e, { val: n, i: this.list.length }), this.list.length > this.maxSize) {
      const r = this.list.shift();
      this.store.delete(r);
    }
  }
  getOrSet(e, n) {
    const s = this.get(e);
    if (s) return s;
    const r = n(e);
    return this.set(e, r), r;
  }
  touch(e, n) {
    this.list.splice(n.i, 1).push(e), n.i = this.list.length;
  }
}
function Z5(i) {
  return i[Symbol.iterator]().next().value;
}
function* J5(...i) {
  for (const e of i) yield* e;
}
function Q5(i, e) {
  for (const n of i)
    if (!e(n)) return !1;
  return !0;
}
function K5(i, e) {
  for (const n of i)
    if (e(n)) return !0;
  return !1;
}
function* tA(i, e) {
  let n = 0;
  for (const s of i)
    e(s, n) && (yield s), n += 1;
}
function* eA(i, e) {
  let n = 0;
  for (const s of i)
    yield e(s, n), n += 1;
}
function* nA(i, e) {
  for (const n of i)
    for (const s of e(n))
      yield s;
}
function* iA(i, e) {
  for (const n of i)
    for (const s of e)
      yield [n, s];
}
function* sA(i) {
  const e = i.length;
  for (let n = 0; n < e; ++n)
    for (let s = n + 1; s < e; ++s)
      yield [i[n], i[s]];
}
function rA(i, e, n = 1 / 0, s) {
  let r, a = n;
  for (const o of i) {
    const h = e(o);
    if (h < a && (r = o, a = h, s !== void 0 && a < s))
      return r;
  }
  return r;
}
const aA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BinarySearchType: v2,
  Cache: X5,
  Color: el,
  EventTarget: U5,
  LinkedList: B5,
  autoCorrect: G5,
  binaryIndexOf: D5,
  binarySearch: w2,
  cache: E5,
  chunk: R5,
  concat: J5,
  cumulative: I5,
  deepExtend: p2,
  defer: T5,
  delay: _5,
  difference: L5,
  every: Q5,
  filter: tA,
  findMin: rA,
  first: Z5,
  flatMap: nA,
  flatten: Ud,
  intersect: k5,
  isOneOf: Ho,
  isPalindrome: V5,
  join: F5,
  last: Gd,
  list: x2,
  listPairs: sA,
  loop: P5,
  map: eA,
  pairs: iA,
  repeat: $d,
  repeat2D: Vd,
  rotate: O5,
  run: M5,
  safeToJSON: A5,
  some: K5,
  sortBy: g2,
  stringDistance: M2,
  tabulate: Il,
  tabulate2D: y2,
  throttle: z5,
  toCSV: N5,
  toCamelCase: $5,
  toTitleCase: q5,
  total: Ge,
  uid: d2,
  unique: m2,
  wait: S5,
  words: tl
}, Symbol.toStringTag, { value: "Module" })), iu = 1e-6;
function Tt(i, e, n = iu) {
  return isNaN(i) || isNaN(e) ? !1 : Math.abs(i - e) < n;
}
function ki(i, e = iu) {
  return Tt(i, Math.round(i), e);
}
function ii(i, e, n, s = iu) {
  return e > n && ([e, n] = [n, e]), i > e + s && i < n - s;
}
function b2(i, e = iu) {
  return Tt(i, 0, e) ? 0 : i > 0 ? 1 : -1;
}
const Cx = /(\d+)(\d{3})/, oA = ["", "k", "m", "b", "t", "q"];
function hA(i) {
  let [e, n] = i.split(".");
  for (; Cx.test(e); )
    e = e.replace(Cx, "$1,$2");
  return e + (n ? `.${n}` : "");
}
function cA(i, e = 6) {
  if (!e) return `${i}`;
  const n = `${Math.abs(Math.floor(i))}`.length, s = n + (i < 0 ? 1 : 0);
  if (s <= e) return `${Xo(i, e - s)}`;
  const r = Math.floor(Math.log10(Math.abs(i)) / 3), a = oA[r], o = e - (n % 3 || 3) - (a ? 1 : 0) - (i < 0 ? 1 : 0);
  return Xo(i / Math.pow(10, 3 * r), o) + a;
}
function Lo(i, e = 0, n = !0) {
  const s = cA(i, e).replace("-", "–");
  return n ? hA(s) : s;
}
function lA(i, e = 6) {
  const n = Math.abs(i);
  if (ii(n, Math.pow(10, -e), Math.pow(10, e)))
    return Lo(i, e);
  if (n > Number.MAX_VALUE) return `${Math.sign(i) < 0 ? "–" : ""}∞`;
  if (n < Number.MIN_VALUE) return "0";
  const [s, r] = i.toExponential().split("e"), a = r.replace("+", "").replace("-", "–"), o = a.startsWith("–");
  return `${s.slice(0, 5)} × 10^${(o ? "(" : "") + a + (o ? ")" : "")}`;
}
const uA = /^-?0,[0-9]+$/, fA = /^-?([0-9]+(,[0-9]{3})*)?\.?[0-9]*$/, dA = /^-?[0-9]+(\.[0-9]{3})*,?[0-9]*$/;
function pA(i) {
  return i = i.replace(/^–/, "-").trim(), !i || i.match(/[^0-9.,-]/) ? NaN : uA.test(i) ? parseFloat(i.replace(/,/, ".")) : fA.test(i) ? parseFloat(i.replace(/,/g, "")) : dA.test(i) ? parseFloat(i.replace(/\./g, "").replace(/,/, ".")) : NaN;
}
function yA(i) {
  if (Math.abs(i) % 100 >= 11 && Math.abs(i) % 100 <= 13)
    return `${i}th`;
  switch (i % 10) {
    case 1:
      return `${i}st`;
    case 2:
      return `${i}nd`;
    case 3:
      return `${i}rd`;
    default:
      return `${i}th`;
  }
}
const ef = [
  "",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen"
], Ax = [
  "",
  "",
  "twenty",
  "thirty",
  "forty",
  "fifty",
  "sixty",
  "seventy",
  "eighty",
  "ninety"
], xA = [
  "",
  " thousand",
  " million",
  " billion",
  " trillion",
  " quadrillion",
  " quintillion",
  " sextillion"
];
function gA(i) {
  const [e, n, s] = i.split(""), r = e === "0" ? "" : ` ${ef[+e]} hundred`;
  return n + s === "00" ? r : +n < 2 ? `${r} ${ef[+(n + s)]}` : s === "0" ? `${r} ${Ax[+n]}` : `${r} ${Ax[+n]}-${ef[+s]}`;
}
function mA(i) {
  if (i === 0) return "zero";
  const e = Math.round(Math.abs(i)).toString(), n = Math.ceil(e.length / 3), s = e.padStart(3 * n, "0");
  let r = "";
  for (let a = 0; a < n; a += 1) {
    const o = s.substr(a * 3, 3);
    o !== "000" && (r += gA(o) + xA[n - 1 - a]);
  }
  return r.trim();
}
function vA(i) {
  return `${Math.abs(i)}`.split("").reverse().map((n) => +n);
}
function Xo(i, e = 0) {
  const n = Math.pow(10, e);
  return Math.round(i * n) / n;
}
function M0(i, e = 1) {
  return Math.round(i / e) * e;
}
function ti(i, e = -1 / 0, n = 1 / 0) {
  return Math.min(n, Math.max(e, i));
}
function Rl(i, e, n = 0.5) {
  return i + (e - i) * n;
}
function Fn(i) {
  return i * i;
}
function wA(i) {
  return i * i * i;
}
function _2(i, e) {
  return (i % e + e) % e;
}
function MA(i, e) {
  return e === void 0 ? Math.log(i) : Math.log(i) / Math.log(e);
}
function S2(i, e, n) {
  if (Tt(i, 0) && Tt(e, 0)) return [];
  if (Tt(i, 0)) return [-n / e];
  const s = -e / 2 / i, r = Math.sqrt(e * e - 4 * i * n) / 2 / i;
  return [s + r, s - r];
}
function bA(i, e) {
  let n = 0, s = 1;
  for (const r of e)
    n += s * r, s *= i;
  return n;
}
function _A(i) {
  if (i === 0) return 1;
  if (i < 0) return NaN;
  let e = 1;
  for (let n = 2; n <= i; ++n) e *= n;
  return e;
}
function T2(i, e) {
  if (e < 0 || e > i) return 0;
  if (e === 0) return 1;
  if (2 * e > i) return T2(i, i - e);
  let n = 1;
  for (let s = 1; s <= e; ++s) n *= (i - s + 1) / s;
  return Math.round(n);
}
function SA(i) {
  const e = [];
  return E2(i, e, []), e;
}
function E2(i, e, n) {
  for (let s = 0; s < i.length; s++) {
    const r = i.splice(s, 1)[0];
    n.push(r), i.length === 0 && e.push(n.slice()), E2(i, e, n), i.splice(s, 0, r), n.pop();
  }
}
function z2(i, e = 0) {
  const n = i.slice(0), s = C2(n);
  return e ? s.filter((r) => r.length === e) : s;
}
function C2(i) {
  if (i.length === 1) return [[], i];
  const e = i.pop(), n = C2(i), s = [];
  for (const r of n)
    s.push(r, [...r, e]);
  return s;
}
const hc = (i, e) => {
  const n = i < 0 ? "–" : "";
  return Math.abs(i) === 1 && e ? n + e : n + Math.abs(i) + (e || "");
};
class ae {
  constructor(e = 0, n = 0) {
    this.re = e, this.im = n;
  }
  get modulus() {
    return Math.sqrt(this.re * this.re + this.im * this.im);
  }
  get argument() {
    return Math.atan2(this.im, this.re);
  }
  get conjugate() {
    return new ae(this.re, -this.im);
  }
  /** Returns the ith nth-root of this complex number. */
  root(e, n = 0) {
    const s = Math.pow(this.modulus, 1 / e), r = (this.argument + n * 2 * Math.PI) / e;
    return new ae(s * Math.cos(r), s * Math.sin(r));
  }
  toString(e = 2) {
    const n = Xo(this.re, e), s = Xo(this.im, e);
    return s === 0 ? hc(n) : n === 0 ? hc(s, "i") : [hc(n), s < 0 ? "–" : "+", hc(Math.abs(s), "i")].join(" ");
  }
  // ---------------------------------------------------------------------------
  add(e) {
    return ae.sum(this, e);
  }
  subtract(e) {
    return ae.difference(this, e);
  }
  multiply(e) {
    return ae.product(this, e);
  }
  divide(e) {
    return ae.quotient(this, e);
  }
  /** Calculates the sum of two complex numbers c1 and c2. */
  static sum(e, n) {
    return typeof e == "number" && (e = new ae(e, 0)), typeof n == "number" && (n = new ae(n, 0)), new ae(e.re + n.re, e.im + n.im);
  }
  /** Calculates the difference of two complex numbers c1 and c2. */
  static difference(e, n) {
    return typeof e == "number" && (e = new ae(e, 0)), typeof n == "number" && (n = new ae(n, 0)), new ae(e.re - n.re, e.im - n.im);
  }
  /** Calculates the product of two complex numbers c1 and c2. */
  static product(e, n) {
    typeof e == "number" && (e = new ae(e, 0)), typeof n == "number" && (n = new ae(n, 0));
    const s = e.re * n.re - e.im * n.im, r = e.im * n.re + e.re * n.im;
    return new ae(s, r);
  }
  /** Calculates the quotient of two complex numbers c1 and c2. */
  static quotient(e, n) {
    if (typeof e == "number" && (e = new ae(e, 0)), typeof n == "number" && (n = new ae(n, 0)), Math.abs(n.re) < Number.EPSILON || Math.abs(n.im) < Number.EPSILON)
      return new ae(1 / 0, 1 / 0);
    const s = n.re * n.re + n.im * n.im, r = (e.re * n.re + e.im * n.im) / s, a = (e.im * n.re - e.re * n.im) / s;
    return new ae(r, a);
  }
  /** Calculates e^c for a complex number c. */
  static exp(e) {
    typeof e == "number" && (e = new ae(e, 0));
    const n = Math.exp(e.re);
    return new ae(n * Math.cos(e.im), n * Math.sin(e.im));
  }
}
function Zo(...i) {
  const [e, ...n] = i;
  if (n.length > 1) return Zo(e, Zo(...n));
  let s = Math.abs(e), r = Math.abs(n[0]);
  for (; r; ) [s, r] = [r, s % r];
  return s;
}
function Ol(...i) {
  const [e, ...n] = i;
  return n.length > 1 ? Ol(e, Ol(...n)) : Math.abs(e * n[0]) / Zo(e, n[0]);
}
function Jo(i) {
  if (i % 1 !== 0 || i < 2) return !1;
  if (i % 2 === 0) return i === 2;
  if (i % 3 === 0) return i === 3;
  const e = Math.sqrt(i);
  for (let n = 5; n <= e; n += 6)
    if (i % n === 0 || i % (n + 2) === 0) return !1;
  return !0;
}
function kl(i) {
  if (i === 1) return [];
  if (Jo(i)) return [i];
  const e = Math.sqrt(i);
  for (let n = 2; n <= e; ++n)
    if (i % n === 0)
      return kl(n).concat(kl(i / n));
  return [];
}
function A2(i) {
  return m2(kl(i));
}
function TA(i = 100) {
  if (i < 2) return [];
  const e = [2];
  for (let n = 3; n <= i; n++) {
    let s = !1;
    for (const r of e)
      s = s || n % r === 0;
    s || e.push(n);
  }
  return e;
}
function EA(i) {
  if (i < 2 || i > 16) throw new Error("Invalid number of digits.");
  const e = [1, 3, 7, 9], n = Math.pow(10, i - 2);
  for (; ; ) {
    const r = 10 * (Math.floor(Math.random() * 9 * n) + n) + e[Math.floor(4 * Math.random())];
    if (Jo(r)) return r;
  }
}
function zA(i) {
  if (i === 4) return [2, 2];
  let e = i / 2, n = i / 2;
  for (e % 2 === 0 && (e--, n++); e >= 3; ) {
    if (Jo(e) && Jo(n)) return [e, n];
    e -= 2, n += 2;
  }
  return [-1, -1];
}
function CA(i) {
  if (i <= 0) throw Error("Number should be greater than zero");
  let e = i;
  for (const n of A2(i)) e *= (n - 1) / n;
  return e;
}
const AA = /^([0-9\-.]*)([%πkmbtq]?)(\/([0-9\-.]+))?([%π]?)$/, Px = (i) => i >= Number.MAX_SAFE_INTEGER;
class qt {
  /** Only used for fractions and always ≥ 0. */
  constructor(e, n, s) {
    this.unit = s, this.num = n !== void 0 && n < 0 ? -e : e, n !== void 0 && Math.abs(n) !== 1 && e !== 0 && (this.den = Math.abs(n));
  }
  num;
  /** Used for all number types (decimals, fractions, units, ...). */
  den;
  valueOf() {
    return this.value;
  }
  toMixed() {
    if (!this.den || this.unit) return this.toString();
    const e = Math.abs(this.num) % this.den, n = Math.abs(Math.trunc(this.value));
    return n ? `${this.sign < 0 ? "–" : ""}${n} ${e}/${this.den}` : this.toString();
  }
  toExpr(e, n = 4) {
    const s = this.value;
    if (Math.abs(s) >= Number.MAX_VALUE) return "∞";
    if ((Px(this.num) || this.den && Px(this.den)) && (e = "decimal"), e === "scientific" || Math.abs(s) >= Number.MAX_SAFE_INTEGER) {
      const [r, a] = this.value.toExponential(n - 1).split("e");
      if (Math.abs(+a) >= n) {
        const o = a.startsWith("-"), h = `${o ? "(" : ""}${o ? a : a.slice(1)}${o ? ")" : ""}`;
        return `${r.replace(/\.?0+$/, "")} × 10^${h}${this.unit || ""}`;
      }
    }
    if (!this.unit && !this.den || e === "decimal" || e === "scientific") {
      const r = Lo(this.value, n);
      return r.match(/^[\d.]+$/g) ? r : `"${r}"`;
    } else
      return e === "mixed" ? this.toMixed() : this.toString();
  }
  toString(e = 4) {
    const n = !this.den && !this.unit;
    let s = Lo(this.num, this.den ? 0 : e, n), r = this.unit || "";
    const a = this.den ? `/${Lo(this.den, 0, n)}` : "";
    return s === "0" && (r = ""), r === "π" && !this.den && (s === "1" || s === "–1") && (s = s.replace("1", "")), `${s}${a}${r}`;
  }
  toMathML() {
    let e = `<mn>${this.num}</mn>`;
    return this.den !== void 0 && (e = `<mfrac>${e}<mn>${this.den}</mn></mfrac>`), this.unit && (e += this.unit === "π" ? "<mi>π</mi>" : "<mo>%</mo>"), e;
  }
  // ---------------------------------------------------------------------------
  /**
   * Returns the value of this number as a decimal. For example, 2/5 and 40%
   * would both return 0.4.
   */
  get value() {
    const e = this.unit === "%" ? 0.01 : this.unit === "π" ? Math.PI : 1;
    return this.num * e / (this.den || 1);
  }
  get sign() {
    return Math.sign(this.num);
  }
  /** Simplifies fractions, e.g. 4/8 would become 1/2. */
  get simplified() {
    if (!this.den) return this;
    const e = Zo(Math.abs(this.num), this.den);
    return new qt(this.num / e, this.den / e, this.unit);
  }
  /** Returns 1/x of this number. */
  get inverse() {
    return this.den ? new qt(1 / this.num, void 0, this.unit) : new qt(this.den, this.num);
  }
  /** Returns -x of this number. */
  get negative() {
    return new qt(-this.num, this.den, this.unit);
  }
  get fraction() {
    if (!(this.unit || !ki(this.num)))
      return [this.num, this.den || 1];
  }
  // ---------------------------------------------------------------------------
  /** Parses a number string, e.g. '1/2' or '20.7%'. */
  static fromString(e) {
    e = e.toLowerCase().replace(/[\s,"]/g, "").replace("–", "-").replace("pi", "π");
    const n = e.match(AA);
    if (!n) return;
    let s = n[2] || n[5] || void 0, r = n[1] ? +n[1] : void 0;
    const a = n[4] ? +n[4] : void 0;
    if (s === "π" && (!n[1] || n[1] === "-") && (r = n[1] ? -1 : 1), r === void 0 || isNaN(r)) return;
    const o = s ? "kmbtq".indexOf(s) : -1;
    if (o >= 0 && (r *= 1e3 ** (o + 1), s = void 0), a === void 0) return new qt(r, void 0, s);
    if (!(isNaN(a) || Tt(a, 0)))
      return !ki(r) || !ki(a) ? new qt(r / a, void 0, s) : new qt(r, a, s);
  }
  /** Converts a decimal into the closest fraction with a given maximum denominator. */
  static fractionFromDecimal(e, n = 1e3, s = 1e-12) {
    let r = [1, 0], a = [0, 1];
    const o = Math.abs(e);
    let h = o;
    for (; Math.abs(r[0] / a[0] - o) > s; ) {
      const c = Math.floor(h);
      if (r = [c * r[0] + r[1], r[0]], a = [c * a[0] + a[1], a[0]], a[0] > n) return new qt(e);
      h = 1 / (h - c);
    }
    return Tt(r[0] / a[0], o, s) ? new qt(b2(e) * r[0], a[0] === 1 ? void 0 : a[0]) : new qt(e);
  }
  // ---------------------------------------------------------------------------
  clamp(e, n) {
    const s = this.value;
    return e !== void 0 && s < e ? new qt(e) : n !== void 0 && s > n ? new qt(n) : this;
  }
  add(e) {
    return qt.sum(this, e);
  }
  subtract(e) {
    return qt.difference(this, e);
  }
  multiply(e) {
    return qt.product(this, e);
  }
  divide(e) {
    return qt.quotient(this, e);
  }
  /** Calculates the sum of two fractions a and b. */
  static sum(e, n) {
    if (typeof n == "number" && (n = new qt(n)), e.num === 0) return n;
    if (e.unit !== n.unit) return new qt(e.value + n.value);
    if (!e.den && !n.den) return new qt(e.num + n.num, void 0, e.unit);
    if (e.den || ([e, n] = [n, e]), !ki(n.num)) return new qt(e.value + n.value, void 0, e.unit);
    const s = Ol(e.den, n.den || 1), r = s / e.den, a = s / (n.den || 1);
    return new qt(e.num * r + n.num * a, s, e.unit);
  }
  /** Calculates the difference of two numbers a and b. */
  static difference(e, n) {
    return typeof n == "number" && (n = new qt(n)), qt.sum(e, n.negative);
  }
  /** Calculates the product of two numbers a and b. */
  static product(e, n) {
    if (typeof n == "number" && (n = new qt(n)), !e.unit && !e.den && ki(e.num)) return new qt(e.num * n.num, n.den, n.unit);
    if (!n.unit && !n.den && ki(n.num)) return new qt(e.num * n.num, e.den, e.unit);
    if (e.unit === "π" || n.unit === "π" || !ki(e.num) || !ki(n.num)) return new qt(e.value * n.value);
    const s = (e.unit === "%" ? 100 : 1) * (n.unit === "%" ? 100 : 1);
    return new qt(e.num * n.num, (e.den || 1) * (n.den || 1) * s);
  }
  /** Calculates the quotient of two fractions a and b. */
  static quotient(e, n) {
    return typeof n == "number" && (n = new qt(n)), qt.product(e, n.inverse);
  }
}
function P2(i, e, n) {
  return Vd(i, e, n);
}
function I2(i = 2) {
  const e = P2(0, i, i);
  for (let n = 0; n < i; ++n) e[n][n] = 1;
  return e;
}
function PA(i) {
  const e = Math.sin(i), n = Math.cos(i);
  return [[n, -e], [e, n]];
}
function IA(i) {
  return [[1, i], [0, 1]];
}
function RA(i) {
  const e = Math.sin(2 * i), n = Math.cos(2 * i);
  return [[n, e], [e, -n]];
}
function R2(...i) {
  const [e, ...n] = i, s = n.length > 1 ? R2(...n) : n[0];
  if (e.length !== s.length || e[0].length !== s[0].length)
    throw new Error("Matrix sizes don’t match");
  const r = [];
  for (let a = 0; a < e.length; ++a) {
    const o = [];
    for (let h = 0; h < e[a].length; ++h)
      o.push(e[a][h] + s[a][h]);
    r.push(o);
  }
  return r;
}
function OA(i, e) {
  return i.map((n) => n.map((s) => s * e));
}
function Ll(...i) {
  const [e, ...n] = i, s = n.length > 1 ? Ll(...n) : n[0];
  if (e[0].length !== s.length)
    throw new Error("Matrix sizes don’t match.");
  const r = [];
  for (let a = 0; a < e.length; ++a) {
    const o = [];
    for (let h = 0; h < s[0].length; ++h) {
      let c = 0;
      for (let l = 0; l < s.length; ++l)
        c += e[a][l] * s[l][h];
      o.push(c);
    }
    r.push(o);
  }
  return r;
}
function O2(i) {
  const e = [];
  for (let n = 0; n < i[0].length; ++n) {
    const s = [];
    for (let r = 0; r < i.length; ++r)
      s.push(i[r][n]);
    e.push(s);
  }
  return e;
}
function kA(i) {
  if (i.length !== i[0].length) throw new Error("Not a square matrix.");
  const e = i.length;
  if (e === 1) return i[0][0];
  if (e === 2) return i[0][0] * i[1][1] - i[0][1] * i[1][0];
  let n = 0;
  for (let s = 0; s < e; ++s) {
    let r = i[0][s], a = i[0][s];
    for (let o = 1; o < e; ++o)
      a *= i[o][(s + o) % e], r *= i[o][(s - o + e) % e];
    n += a - r;
  }
  return n;
}
function k2(i) {
  const e = i.length;
  if (e !== i[0].length) throw new Error("Not a square matrix.");
  const n = I2(e), s = y2((r, a) => i[r][a], e, e);
  for (let r = 0; r < e; ++r) {
    let a = s[r][r];
    if (Tt(a, 0)) {
      for (let o = r + 1; o < e; ++o)
        if (s[o][r] !== 0) {
          for (let h = 0; h < e; ++h)
            [s[o][h], s[r][h]] = [s[r][h], s[o][h]], [n[o][h], n[r][h]] = [n[r][h], n[o][h]];
          break;
        }
      if (a = s[r][r], Tt(a, 0)) throw new Error("Matrix not invertible.");
    }
    for (let o = 0; o < e; ++o)
      s[r][o] = s[r][o] / a, n[r][o] = n[r][o] / a;
    for (let o = 0; o < e; ++o) {
      if (o === r) continue;
      const h = s[o][r];
      for (let c = 0; c < e; ++c)
        s[o][c] -= h * s[r][c], n[o][c] -= h * n[r][c];
    }
  }
  return n;
}
const LA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  determinant: kA,
  fill: P2,
  identity: I2,
  inverse: k2,
  product: Ll,
  reflection: RA,
  rotation: PA,
  scalarProduct: OA,
  shear: IA,
  sum: R2,
  transpose: O2
}, Symbol.toStringTag, { value: "Module" }));
function FA(i) {
  i = i.slice(0);
  for (let e = i.length - 1; e > 0; --e) {
    const n = Math.floor(Math.random() * (e + 1));
    [i[e], i[n]] = [i[n], i[e]];
  }
  return i;
}
function NA(i, e) {
  const n = e === void 0 ? 0 : i, s = e === void 0 ? i : e - i + 1;
  return n + Math.floor(s * Math.random());
}
function L2(i) {
  const e = Math.random() * Ge(i);
  let n = 0;
  return i.findIndex((s) => (n += s) >= e);
}
function BA(i) {
  return i[Math.floor(i.length * Math.random())];
}
const cc = /* @__PURE__ */ new Map();
function DA(i, e) {
  e || (e = d2()), cc.has(e) || cc.set(e, $d(1, i));
  const n = cc.get(e), s = L2(n.map((r) => r * r));
  return n[s] -= 1, n[s] <= 0 && cc.set(e, n.map((r) => r + 1)), s;
}
function F2(i = 0.5) {
  return Math.random() < i ? 1 : 0;
}
function qA(i = 1, e = 0.5) {
  let n = 0;
  for (let s = 0; s < i; ++s) n += F2(e);
  return n;
}
function $A(i = 1) {
  if (i <= 0) return 0;
  const e = Math.exp(-i);
  let n = 1, s = 0;
  for (; n > e; ++s) n *= Math.random();
  return s - 1;
}
function b0(i = 0, e = 1) {
  return i + (e - i) * Math.random();
}
function VA(i = 0, e = 1) {
  const n = Math.random(), s = Math.random();
  return Math.sqrt(-2 * Math.log(n)) * Math.cos(2 * Math.PI * s) * Math.sqrt(e) + i;
}
function GA(i = 1) {
  return i <= 0 ? 0 : -Math.log(Math.random()) / i;
}
function UA(i = 0.5) {
  if (!(i <= 0 || i > 1))
    return Math.floor(Math.log(Math.random()) / Math.log(1 - i));
}
function WA() {
  let i, e, n;
  do
    e = 2 * Math.random() - 1, n = 2 * Math.random() - 1, i = e * e + n * n;
  while (i >= 1);
  return e / n;
}
function YA(i, e = 1, n = 0) {
  return Math.exp(-((i - e) ** 2) / (2 * n)) / Math.sqrt(2 * Math.PI * n);
}
const Ix = 7, Rx = [
  0.9999999999998099,
  676.5203681218851,
  -1259.1392167224028,
  771.3234287776531,
  -176.6150291621406,
  12.507343278686905,
  -0.13857109526572012,
  9984369578019572e-21,
  15056327351493116e-23
];
function N2(i) {
  if (i < 0.5) return Math.PI / (Math.sin(Math.PI * i) * N2(1 - i));
  i -= 1;
  let e = Rx[0];
  for (let s = 1; s < Ix + 2; s++) e += Rx[s] / (i + s);
  const n = i + Ix + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(n, i + 0.5) * Math.exp(-n) * e;
}
function B2(i, e, n, s = 1) {
  let r = 0;
  for (let a = e; a < n; a += s)
    r += i(a) * s || 0;
  return r;
}
function jA(i, e) {
  return 1 - B2((s) => Math.pow(s, (e - 2) / 2) * Math.exp(-s / 2), 0, i) / Math.pow(2, e / 2) / N2(e / 2);
}
const HA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bernoulli: F2,
  binomial: qA,
  cauchy: WA,
  chiCDF: jA,
  exponential: GA,
  find: BA,
  geometric: UA,
  integer: NA,
  integrate: B2,
  normal: VA,
  normalPDF: YA,
  poisson: $A,
  shuffle: FA,
  smart: DA,
  uniform: b0,
  weighted: L2
}, Symbol.toStringTag, { value: "Module" }));
function XA(i, e) {
  let n = 1, s = i[0];
  for (let r = 1; r < i.length; ++r)
    n *= e, s += n * i[r];
  return s;
}
function ZA(i, e = !1) {
  let n = 0, s = 0, r = 0, a = 0;
  const o = i.length;
  for (let l = 0; l < o; l++)
    n += i[l][0], s += i[l][1], r += i[l][0] * i[l][0], a += i[l][0] * i[l][1];
  if (e)
    return [0, a / r];
  const h = (o * a - n * s) / (o * r - n * n);
  return [s / o - h * n / o, h];
}
function JA(i) {
  const e = [0, 0, 0, 0, 0, 0];
  for (const a of i)
    e[0] += a[0], e[1] += a[1], e[2] += a[0] * a[0] * a[1], e[3] += a[1] * Math.log(a[1]), e[4] += a[0] * a[1] * Math.log(a[1]), e[5] += a[0] * a[1];
  const n = e[1] * e[2] - e[5] * e[5], s = Math.exp((e[2] * e[3] - e[5] * e[4]) / n), r = (e[1] * e[4] - e[5] * e[3]) / n;
  return [s, r];
}
function QA(i) {
  const e = [0, 0, 0, 0], n = i.length;
  for (const a of i)
    e[0] += Math.log(a[0]), e[1] += a[1] * Math.log(a[0]), e[2] += a[1], e[3] += Math.pow(Math.log(a[0]), 2);
  const s = (n * e[1] - e[2] * e[0]) / (n * e[3] - e[0] * e[0]);
  return [(e[2] - s * e[0]) / n, s];
}
function KA(i) {
  const e = [0, 0, 0, 0], n = i.length;
  for (const a of i)
    e[0] += Math.log(a[0]), e[1] += Math.log(a[1]) * Math.log(a[0]), e[2] += Math.log(a[1]), e[3] += Math.pow(Math.log(a[0]), 2);
  const s = (n * e[1] - e[2] * e[0]) / (n * e[3] - e[0] * e[0]);
  return [Math.exp((e[2] - s * e[0]) / n), s];
}
function D2(i, e = 2) {
  const n = i.map((c) => x2(e + 1).map((l) => Math.pow(c[0], l))), s = O2(n), r = i.map((c) => [c[1]]), a = Ll(s, n), o = k2(a);
  return Ll(o, s, r).map((c) => c[0]);
}
function q2(i, e) {
  const s = i.reduce((o, h) => o + h[1], 0) / i.length, r = i.reduce((o, h) => o + (h[1] - s) ** 2, 0);
  return 1 - i.reduce((o, h) => o + (h[1] - e(h[0])) ** 2, 0) / r;
}
function tP(i, e = 0.85, n = 8) {
  if (!(i.length <= 1))
    for (let s = 1; s < n; ++s) {
      const r = D2(i, s), a = (h) => XA(r, h);
      if (q2(i, a) >= e) return { order: s, coefficients: r, fn: a };
    }
}
const eP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bestPolynomial: tP,
  coefficient: q2,
  exponential: JA,
  linear: ZA,
  logarithmic: QA,
  polynomial: D2,
  power: KA
}, Symbol.toStringTag, { value: "Module" }));
function $2(i) {
  return i.length ? Ge(i) / i.length : 0;
}
function V2(i, e, n = 1) {
  const s = i.length;
  if (!s) return 0;
  const r = i.slice(0).sort((h, c) => h - c);
  if (e === 0) return r[0];
  if (e === 1) return r[s - 1];
  if (![1, 2, 3].includes(n)) throw new RangeError("Invalid quantile method.");
  const a = n === 1 ? s * e - 0.5 : (
    // Matlab, Mathematica
    n === 2 ? (s - 1) * e : (
      // Excel, NumPy, Google Docs, R, Python (option)
      (s + 1) * e - 1
    )
  );
  if (Number.isInteger(a)) return r[a];
  const o = Math.floor(a);
  return Rl(r[o], r[o + 1], a - o);
}
function nP(i, e = 1) {
  return V2(i, 0.5, e);
}
function iP(i) {
  const e = /* @__PURE__ */ new Map();
  let n = -1, s;
  for (const r of i) {
    e.has(r) || e.set(r, 0);
    const a = e.get(r) + 1;
    e.set(r, a), a === n ? s = void 0 : a > n && (n = a, s = r);
  }
  return s;
}
function G2(i) {
  if (!i.length) return;
  const e = $2(i);
  return i.reduce((s, r) => s + (r - e) ** 2, 0) / (i.length - 1);
}
function _0(i) {
  const e = G2(i);
  return e ? Math.sqrt(e) : 0;
}
function U2(i, e) {
  if (i.length !== e.length) throw new Error("Array length mismatch.");
  return (i.reduce((s, r, a) => s + r * e[a], 0) - Ge(i) * Ge(e) / i.length) / i.length;
}
function sP(i, e) {
  if (i.length !== e.length) throw new Error("Array length mismatch.");
  const n = U2(i, e), s = _0(i), r = _0(e);
  return n / (s * r);
}
class Fl extends Array {
  constructor(...e) {
    super();
    for (const n of e) this.push(n);
  }
  /** Returns the magnitude of the Vector */
  get magnitude() {
    let e = 0;
    for (let n = 0; n < this.length; ++n) e += this[n] ** 2;
    return Math.sqrt(e);
  }
  /** Returns the unitVector of the Vector */
  get unitVector() {
    return this.scale(1 / this.magnitude);
  }
  /** Scales this vector by a factor q. */
  scale(e) {
    return this.map((n) => e * n);
  }
  // -------------------------------------------------------------------------
  /** Calculates the sum of two vectors v1 and v2. */
  static sum(e, n) {
    if (e.length !== n.length) throw new Error("Mismatched vector sizes.");
    return e.map((s, r) => s + n[r]);
  }
  /** Calculates the difference of two vectors v1 and v2. */
  static difference(e, n) {
    if (e.length !== n.length) throw new Error("Mismatched vector sizes.");
    return e.map((s, r) => s - n[r]);
  }
  /** Calculates the element-wise product of two vectors v1 and v2. */
  static product(e, n) {
    if (e.length !== n.length) throw new Error("Mismatched vector sizes.");
    return e.map((s, r) => s * n[r]);
  }
  /** Calculates the dot product of two vectors v1 and v2. */
  static dot(e, n) {
    return Ge(Fl.product(e, n));
  }
  /** Finds the cross product of two 3-dimensional vectors v1 and v2. */
  static cross(e, n) {
    if (e.length !== 3 || n.length !== 3)
      throw new Error("Cross product requires vectors of size 3.");
    return new Fl(
      e[1] * n[2] - e[2] * n[1],
      e[2] * n[0] - e[0] * n[2],
      e[0] * n[1] - e[1] * n[0]
    );
  }
  /** Checks if two vectors are equal. */
  static equals(e, n) {
    const s = e.length;
    if (s !== n.length) return !1;
    for (let r = 0; r < s; ++r) if (!Tt(e[r], n[r])) return !1;
    return !0;
  }
}
const rP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Complex: ae,
  Matrix: LA,
  Random: HA,
  Regression: eP,
  Vector: Fl,
  XNumber: qt,
  binomial: T2,
  clamp: ti,
  correlation: sP,
  covariance: U2,
  cube: wA,
  digits: vA,
  eulerPhi: CA,
  factorial: _A,
  gcd: Zo,
  generatePrime: EA,
  goldbach: zA,
  isBetween: ii,
  isInteger: ki,
  isPrime: Jo,
  lcm: Ol,
  lerp: Rl,
  listPrimes: TA,
  log: MA,
  mean: $2,
  median: nP,
  mod: _2,
  mode: iP,
  nearlyEquals: Tt,
  numberFormat: Lo,
  parseNumber: pA,
  permutations: SA,
  polynomial: bA,
  primeFactorisation: kl,
  primeFactors: A2,
  quadratic: S2,
  quantile: V2,
  round: Xo,
  roundTo: M0,
  scientificFormat: lA,
  sign: b2,
  square: Fn,
  stdDev: _0,
  subsets: z2,
  toOrdinal: yA,
  toWord: mA,
  variance: G2
}, Symbol.toStringTag, { value: "Module" })), Le = 2 * Math.PI;
function Ra(i, e) {
  const n = Math.atan2(i.y - (e ? e.y : 0), i.x - (e ? e.x : 0));
  return _2(n, Le);
}
function Ox(i, e) {
  let n, s = 1 / 0, r = -1;
  for (const [a, o] of e.entries()) {
    const h = o.project(i), c = st.distance(i, h);
    c < s && (n = h, s = c, r = a);
  }
  return n ? [n, r] : void 0;
}
let st = class Jt {
  constructor(e = 0, n = 0) {
    this.x = e, this.y = n;
  }
  type = "point";
  get unitVector() {
    return Tt(this.length, 0) ? new Jt(1, 0) : this.scale(1 / this.length);
  }
  get length() {
    return Math.sqrt(this.x ** 2 + this.y ** 2);
  }
  get inverse() {
    return new Jt(-this.x, -this.y);
  }
  get flip() {
    return new Jt(this.y, this.x);
  }
  get perpendicular() {
    return new Jt(-this.y, this.x);
  }
  get array() {
    return [this.x, this.y];
  }
  /** Finds the perpendicular distance between this point and a line. */
  distanceFromLine(e) {
    return Jt.distance(this, e.project(this));
  }
  /** Clamps this point to specific bounds. */
  clamp(e, n = 0) {
    const s = ti(this.x, e.xMin + n, e.xMax - n), r = ti(this.y, e.yMin + n, e.yMax - n);
    return new Jt(s, r);
  }
  changeCoordinates(e, n) {
    const s = n.xMin + (this.x - e.xMin) / e.dx * n.dx, r = n.yMin + (this.y - e.yMin) / e.dy * n.dy;
    return new Jt(s, r);
  }
  add(e) {
    return Jt.sum(this, e);
  }
  subtract(e) {
    return Jt.difference(this, e);
  }
  round(e = 1) {
    return new Jt(M0(this.x, e), M0(this.y, e));
  }
  floor() {
    return new Jt(Math.floor(this.x), Math.floor(this.y));
  }
  mod(e, n = e) {
    return new Jt(this.x % e, this.y % n);
  }
  angle(e = _n) {
    return Ra(this, e);
  }
  // Snap to the x or y values of another point
  snap(e, n = 5) {
    return Tt(this.x, e.x, n) ? new Jt(e.x, this.y) : Tt(this.y, e.y, n) ? new Jt(this.x, e.y) : this;
  }
  /** Calculates the average of multiple points. */
  static average(...e) {
    const n = Ge(e.map((r) => r.x)) / e.length, s = Ge(e.map((r) => r.y)) / e.length;
    return new Jt(n, s);
  }
  /** Calculates the dot product of two points p1 and p2. */
  static dot(e, n) {
    return e.x * n.x + e.y * n.y;
  }
  static sum(e, n) {
    return new Jt(e.x + n.x, e.y + n.y);
  }
  static difference(e, n) {
    return new Jt(e.x - n.x, e.y - n.y);
  }
  /** Returns the Euclidean distance between two points p1 and p2. */
  static distance(e, n) {
    return Math.sqrt(Fn(e.x - n.x) + Fn(e.y - n.y));
  }
  /** Returns the Manhattan distance between two points p1 and p2. */
  static manhattan(e, n) {
    return Math.abs(e.x - n.x) + Math.abs(e.y - n.y);
  }
  /** Interpolates two points p1 and p2 by a factor of t. */
  static interpolate(e, n, s = 0.5) {
    return new Jt(Rl(e.x, n.x, s), Rl(e.y, n.y, s));
  }
  /** Interpolates a list of multiple points. */
  static interpolateList(e, n = 0.5) {
    const s = e.length - 1, r = Math.floor(ti(n, 0, 1) * s);
    return Jt.interpolate(e[r], e[r + 1], s * n - r);
  }
  /** Creates a point from polar coordinates. */
  static fromPolar(e, n = 1) {
    return new Jt(n * Math.cos(e), n * Math.sin(e));
  }
  static random(e) {
    const n = b0(e.xMin, e.xMax), s = b0(e.yMin, e.yMax);
    return new Jt(n, s);
  }
  static equals(e, n, s) {
    return Tt(e.x, n.x, s) && Tt(e.y, n.y, s);
  }
  /** Check if p1, p2 and p3 lie on a straight line. */
  static colinear(e, n, s, r) {
    const a = e.x - n.x, o = e.y - n.y, h = n.x - s.x, c = n.y - s.y;
    return Tt(a * c, h * o, r);
  }
  // ---------------------------------------------------------------------------
  /** Transforms this point using a 2x3 matrix m. */
  transform(e) {
    const n = e[0][0] * this.x + e[0][1] * this.y + e[0][2], s = e[1][0] * this.x + e[1][1] * this.y + e[1][2];
    return new Jt(n, s);
  }
  /** Rotates this point by a given angle (in radians) around point `c`. */
  rotate(e, n = _n) {
    if (Tt(e, 0)) return this;
    const s = this.x - n.x, r = this.y - n.y, a = Math.cos(e), o = Math.sin(e), h = s * a - r * o + n.x, c = s * o + r * a + n.y;
    return new Jt(h, c);
  }
  /** Reflects this point across a line l. */
  reflect(e) {
    const n = e.p2.x - e.p1.x, s = e.p2.y - e.p1.y, r = this.x - e.p1.x, a = this.y - e.p1.y, o = (n * a - s * r) / (n * n + s * s), h = this.x + 2 * o * s, c = this.y - 2 * o * n;
    return new Jt(h, c);
  }
  scale(e, n = e) {
    return new Jt(this.x * e, this.y * n);
  }
  shift(e, n = e) {
    return new Jt(this.x + e, this.y + n);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n) {
    return Jt.equals(this, e, n);
  }
  toString() {
    return `point(${this.x},${this.y})`;
  }
};
const _n = new st(0, 0);
function Nl(i) {
  return ["polygon", "polyline", "rectangle", "triangle"].includes(i.type);
}
function W2(i) {
  return ["polygon", "triangle"].includes(i.type);
}
function Wd(i) {
  return i.type === "polyline";
}
function S0(i) {
  return i.type === "rectangle";
}
function cr(i) {
  return ["line", "ray", "segment"].includes(i.type);
}
function Y2(i) {
  return i.type === "line";
}
function zh(i) {
  return i.type === "ray";
}
function Ch(i) {
  return i.type === "segment";
}
function lr(i) {
  return i.type === "circle";
}
function Yd(i) {
  return i.type === "ellipse";
}
function Fo(i) {
  return i.type === "arc";
}
function j2(i) {
  return i.type === "sector";
}
function Qo(i) {
  return i.type === "angle";
}
function aP(i) {
  return i.type === "point";
}
let bn = class po {
  constructor(e, n) {
    this.p1 = e, this.p2 = n;
  }
  type = "line";
  flag;
  ["constructor"];
  /* The distance between the two points defining this line. */
  get length() {
    return st.distance(this.p1, this.p2);
  }
  /* The squared distance between the two points defining this line. */
  get lengthSquared() {
    return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;
  }
  /** The midpoint of this line. */
  get midpoint() {
    return st.average(this.p1, this.p2);
  }
  /** The slope of this line. */
  get slope() {
    return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
  }
  /** The y-axis intercept of this line. */
  get intercept() {
    return this.p1.y - this.slope * this.p1.x;
  }
  /** The angle formed between this line and the x-axis. */
  get angle() {
    return Ra(this.p2, this.p1);
  }
  /** The point representing a unit vector along this line. */
  get unitVector() {
    return this.p2.subtract(this.p1).unitVector;
  }
  /** The point representing the perpendicular vector of this line. */
  get perpendicularVector() {
    return new st(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;
  }
  /** Finds the line parallel to this one, going through point p. */
  parallel(e) {
    return new po(e, e.add(this.p2).subtract(this.p1));
  }
  /** Finds the line perpendicular to this one, going through point p. */
  perpendicular(e) {
    const n = this.line.project(e);
    return st.equals(e, n) ? new po(n, n.add(this.perpendicularVector.scale(this.length / 2))) : new po(n, e);
  }
  /** The perpendicular bisector of this line. */
  get perpendicularBisector() {
    return this.perpendicular(this.midpoint);
  }
  /** Squared distance between a point and a line. */
  distanceSquared(e) {
    const n = this.project(e);
    return (e.x - n.x) ** 2 + (e.y - n.y) ** 2;
  }
  get line() {
    return this.type === "line" ? this : new po(this.p1, this.p2);
  }
  get ray() {
    return zh(this) ? this : new H2(this.p1, this.p2);
  }
  get segment() {
    return Ch(this) ? this : new zr(this.p1, this.p2);
  }
  // ---------------------------------------------------------------------------
  /** Signed distance along the line (opposite of .at()). */
  offset(e) {
    const n = st.difference(this.p2, this.p1), s = st.difference(e, this.p1);
    return st.dot(n, s) / this.lengthSquared;
  }
  /** Projects a point `p` onto this line. */
  project(e) {
    return this.at(this.offset(e));
  }
  /** Returns which side of this line a point p is on (or 0 on the line). */
  side(e, n) {
    const s = st.difference(this.p2, this.p1), r = st.difference(e, this.p1), a = r.x * s.y - r.y * s.x;
    return Tt(a, 0, n) ? 0 : Math.sign(a);
  }
  /** Checks if a point p lies on this line. */
  contains(e, n) {
    return this.side(e, n) === 0;
  }
  /** Gets the point at a specific offset along the line (opposite of .offset()). */
  at(e) {
    return st.interpolate(this.p1, this.p2, e);
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new this.constructor(this.p1.transform(e), this.p2.transform(e));
  }
  /** Rotates this line by a given angle (in radians), optionally around point `c`. */
  rotate(e, n = _n) {
    return Tt(e, 0) ? this : new this.constructor(this.p1.rotate(e, n), this.p2.rotate(e, n));
  }
  reflect(e) {
    return new this.constructor(this.p1.reflect(e), this.p2.reflect(e));
  }
  scale(e, n = e) {
    return new this.constructor(this.p1.scale(e, n), this.p2.scale(e, n));
  }
  shift(e, n = e) {
    return new this.constructor(this.p1.shift(e, n), this.p2.shift(e, n));
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n) {
    return this.contains(e.p1, n) && this.contains(e.p2, n);
  }
  toString() {
    return `line(${this.p1},${this.p2})`;
  }
}, H2 = class extends bn {
  type = "ray";
  equals(e, n) {
    return e.type !== "ray" || !this.p1.equals(e.p1, n) ? !1 : this.p2.equals(e.p2, n) ? !0 : e.contains(this.p2, n) || this.contains(e.p2, n);
  }
  contains(e, n) {
    if (!super.contains(e, n)) return !1;
    const s = this.offset(e);
    return Tt(s, 0, n) || s > 0;
  }
  toString() {
    return `ray(${this.p1},${this.p2})`;
  }
};
class zr extends bn {
  type = "segment";
  contains(e, n) {
    return super.contains(e, n) ? this.p1.equals(e, n) || this.p2.equals(e, n) ? !0 : Tt(this.p1.x, this.p2.x, n) ? ii(e.y, this.p1.y, this.p2.y) : ii(e.x, this.p1.x, this.p2.x) : !1;
  }
  project(e) {
    const n = st.difference(this.p2, this.p1), s = st.difference(e, this.p1), r = ti(st.dot(n, s) / this.lengthSquared, 0, 1);
    return this.p1.add(n.scale(r));
  }
  /** Contracts (or expands) a line by a specific ratio. */
  contract(e) {
    return new zr(this.at(e), this.at(1 - e));
  }
  equals(e, n, s = !1) {
    return e.type !== "segment" ? !1 : this.p1.equals(e.p1, n) && this.p2.equals(e.p2, n) || !s && this.p1.equals(e.p2, n) && this.p2.equals(e.p1, n);
  }
  toString() {
    return `segment(${this.p1},${this.p2})`;
  }
}
let Bl = class ia {
  constructor(e = _n, n = 1) {
    this.c = e, this.r = n;
  }
  type = "circle";
  /** The length of the circumference of this circle. */
  get circumference() {
    return Le * this.r;
  }
  /** The area of this circle. */
  get area() {
    return Math.PI * this.r ** 2;
  }
  get arc() {
    const e = this.c.shift(this.r, 0);
    return new Ko(this.c, e, Le);
  }
  tangentAt(e) {
    const n = this.at(e), s = this.c.rotate(Math.PI / 2, n);
    return new bn(n, s);
  }
  collision(e) {
    const n = this.c.x < e.p.x ? e.p.x : this.c.x > e.p.x + e.w ? e.p.x + e.w : this.c.x, s = this.c.y < e.p.y ? e.p.y : this.c.y > e.p.y + e.h ? e.p.y + e.h : this.c.y;
    return st.distance(this.c, new st(n, s)) <= this.r;
  }
  // ---------------------------------------------------------------------------
  project(e) {
    const n = e.subtract(this.c).unitVector.scale(this.r);
    return st.sum(this.c, n);
  }
  at(e) {
    const n = Le * e;
    return this.c.shift(this.r * Math.cos(n), this.r * Math.sin(n));
  }
  offset(e) {
    return Ra(e, this.c) / Le;
  }
  contains(e) {
    return st.distance(e, this.c) <= this.r;
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    const n = Math.abs(e[0][0]) + Math.abs(e[1][1]);
    return new ia(this.c.transform(e), this.r * n / 2);
  }
  rotate(e, n = _n) {
    return Tt(e, 0) ? this : new ia(this.c.rotate(e, n), this.r);
  }
  reflect(e) {
    return new ia(this.c.reflect(e), this.r);
  }
  scale(e, n = e) {
    return new ia(this.c.scale(e, n), this.r * (e + n) / 2);
  }
  shift(e, n = e) {
    return new ia(this.c.shift(e, n), this.r);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n) {
    return Tt(this.r, e.r, n) && this.c.equals(e.c, n);
  }
  toString() {
    return `circle(${this.c},${this.r})`;
  }
};
class Ko {
  constructor(e, n, s) {
    this.c = e, this.start = n, this.angle = s;
  }
  type = "arc";
  ["constructor"];
  get circle() {
    return new Bl(this.c, this.radius);
  }
  get radius() {
    return st.distance(this.c, this.start);
  }
  get end() {
    return this.start.rotate(this.angle, this.c);
  }
  get startAngle() {
    return Ra(this.start, this.c);
  }
  contract(e) {
    return new this.constructor(this.c, this.at(e / 2), this.angle * (1 - e));
  }
  get minor() {
    return this.angle <= Math.PI ? this : new this.constructor(this.c, this.end, Le - this.angle);
  }
  get major() {
    return this.angle >= Math.PI ? this : new this.constructor(this.c, this.end, Le - this.angle);
  }
  get center() {
    return this.at(0.5);
  }
  // ---------------------------------------------------------------------------
  project(e) {
    const n = this.startAngle, s = n + this.angle;
    let r = Ra(e, this.c);
    return s > Le && r < s - Le && (r += Le), r = ti(r, n, s), this.c.shift(this.radius, 0).rotate(r, this.c);
  }
  at(e) {
    return this.start.rotate(this.angle * e, this.c);
  }
  offset(e) {
    return new su(this.start, this.c, e).rad / this.angle;
  }
  contains(e) {
    return e.equals(this.project(e));
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new this.constructor(
      this.c.transform(e),
      this.start.transform(e),
      this.angle
    );
  }
  /** Rotates this arc by a given angle (in radians), optionally around point `c`. */
  rotate(e, n = _n) {
    return Tt(e, 0) ? this : new this.constructor(
      this.c.rotate(e, n),
      this.start.rotate(e, n),
      this.angle
    );
  }
  reflect(e) {
    return new this.constructor(
      this.c.reflect(e),
      this.start.reflect(e),
      this.angle
    );
  }
  scale(e, n = e) {
    return new this.constructor(
      this.c.scale(e, n),
      this.start.scale(e, n),
      this.angle
    );
  }
  shift(e, n = e) {
    return new this.constructor(
      this.c.shift(e, n),
      this.start.shift(e, n),
      this.angle
    );
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals() {
    return !1;
  }
  toString() {
    return `arc(${this.c},${this.start},${this.angle})`;
  }
}
class X2 extends Ko {
  type = "sector";
  contains(e) {
    return st.distance(e, this.c) <= this.radius && new su(this.start, this.c, e).rad <= this.angle;
  }
  toString() {
    return `sector(${this.c},${this.start},${this.angle})`;
  }
}
function oP(i, e) {
  return Tt(i.p1.x, i.p2.x) ? ii(e.y, i.p1.y, i.p2.y) : ii(e.x, i.p1.x, i.p2.x);
}
function hP(i, e) {
  return Tt(i.p1.x, i.p2.x) ? (e.y - i.p1.y) / (i.p2.y - i.p1.y) > 0 : (e.x - i.p1.x) / (i.p2.x - i.p1.x) > 0;
}
function cP(i, e) {
  return ii(i.offset(e), 0, 1);
}
function lP(i, e) {
  const n = i.p1.x - i.p2.x, s = i.p1.y - i.p2.y, r = e.p1.x - e.p2.x, a = e.p1.y - e.p2.y, o = n * a - s * r;
  if (Tt(o, 0)) return [];
  const h = i.p1.x * i.p2.y - i.p1.y * i.p2.x, c = e.p1.x * e.p2.y - e.p1.y * e.p2.x, l = h * r - n * c, u = h * a - s * c;
  return [new st(l / o, u / o)];
}
function uP(i, e) {
  const n = st.distance(i.c, e.c);
  if (n > i.r + e.r) return [];
  if (n < Math.abs(i.r - e.r)) return [];
  if (Tt(n, 0) && Tt(i.r, e.r)) return [];
  if (Tt(n, i.r + e.r)) return [new bn(i.c, e.c).midpoint];
  const s = (Fn(i.r) - Fn(e.r) + Fn(n)) / (2 * n), r = Math.sqrt(Fn(i.r) - Fn(s)), a = (e.c.x - i.c.x) * s / n + (e.c.y - i.c.y) * r / n + i.c.x, o = (e.c.y - i.c.y) * s / n - (e.c.x - i.c.x) * r / n + i.c.y, h = (e.c.x - i.c.x) * s / n - (e.c.y - i.c.y) * r / n + i.c.x, c = (e.c.y - i.c.y) * s / n + (e.c.x - i.c.x) * r / n + i.c.y;
  return [new st(a, o), new st(h, c)];
}
function kx(i, e) {
  const n = i.p2.x - i.p1.x, s = i.p2.y - i.p1.y, r = Fn(n) + Fn(s), a = e.c.x, o = e.c.y, h = (i.p1.x - a) * (i.p2.y - o) - (i.p2.x - a) * (i.p1.y - o), c = Fn(e.r) * r - Fn(h);
  if (c < 0) return [];
  const l = h * s / r, u = -h * n / r;
  if (Tt(c, 0)) return [e.c.shift(l, u)];
  const f = n * (s < 0 ? -1 : 1) * Math.sqrt(c) / r, d = Math.abs(s) * Math.sqrt(c) / r;
  return [e.c.shift(l + f, u + d), e.c.shift(l - f, u - d)];
}
function fP(i, e) {
  let n = [];
  const s = Fo(i) ? i.circle : i, r = Fo(e) ? e.circle : e;
  cr(i) && cr(e) ? n = lP(i, e) : cr(s) && lr(r) ? n = kx(s, r) : lr(s) && cr(r) ? n = kx(r, s) : lr(s) && lr(r) && (n = uP(s, r));
  for (const a of [i, e])
    Ch(a) && (n = n.filter((o) => oP(a, o))), zh(a) && (n = n.filter((o) => hP(a, o))), Fo(a) && (n = n.filter((o) => cP(a, o)));
  return n;
}
function Ms(...i) {
  if (i.length < 2) return [];
  if (i.length > 2)
    return Ud(z2(i, 2).map((s) => Ms(...s)));
  let [e, n] = i;
  if (Qo(e) && (e = e.shape(!0)), Qo(n) && (n = n.shape(!0)), Nl(n) && ([e, n] = [n, e]), Nl(e)) {
    const s = cr(n) ? e.points.filter((r) => n.contains(r)) : [];
    for (const r of e.edges) s.push(...Ms(r, n));
    return s;
  }
  return fP(e, n);
}
let Oa = class yo {
  type = "polygon";
  points;
  ["constructor"];
  constructor(...e) {
    this.points = e;
  }
  get circumference() {
    if (this.points.length <= 1) return 0;
    let e = st.distance(this.points[0], Gd(this.points));
    for (let n = 1; n < this.points.length; ++n)
      e += st.distance(this.points[n - 1], this.points[n]);
    return e;
  }
  /**
   * The (signed) area of this polygon. The result is positive if the vertices
   * are ordered clockwise, and negative otherwise.
   */
  get signedArea() {
    const e = this.points, n = e.length;
    let s = e[n - 1].x * e[0].y - e[0].x * e[n - 1].y;
    for (let r = 1; r < n; ++r)
      s += e[r - 1].x * e[r].y - e[r].x * e[r - 1].y;
    return s / 2;
  }
  get area() {
    return Math.abs(this.signedArea);
  }
  get centroid() {
    const e = this.points, n = e.length;
    let s = 0;
    for (let a = 0; a < n; ++a) s += e[a].x;
    let r = 0;
    for (let a = 0; a < n; ++a) r += e[a].y;
    return new st(s / n, r / n);
  }
  get edges() {
    const e = this.points.length, n = [];
    for (let s = 0; s < e; ++s)
      n.push(new zr(this.points[s], this.points[(s + 1) % e]));
    return n;
  }
  get radius() {
    const e = this.centroid, n = this.points.map((s) => st.distance(s, e));
    return Math.max(...n);
  }
  /** The oriented version of this polygon (vertices in clockwise order). */
  get oriented() {
    if (this.signedArea >= 0) return this;
    const e = [...this.points].reverse();
    return new this.constructor(...e);
  }
  /** Checks if two polygons p1 and p2 collide. */
  static collision(e, n, s) {
    if (e.points.some((r) => n.contains(r)) || n.points.some((r) => e.contains(r))) return !0;
    for (const r of e.edges)
      for (const a of n.edges)
        if (Ms(r, a)[0]) return !0;
    return e.equals(n, s);
  }
  /** Creates a regular polygon. */
  static regular(e, n = 1) {
    const s = Le / e, r = Math.PI / 2 - s / 2, a = Il((o) => st.fromPolar(r + s * o, n), e);
    return new yo(...a);
  }
  /** Interpolates the points of two polygons */
  static interpolate(e, n, s = 0.5) {
    const r = e.points.map(
      (a, o) => st.interpolate(a, n.points[o], s)
    );
    return new yo(...r);
  }
  static convexHull(...e) {
    if (e.length <= 3) return new yo(...e);
    const n = e.sort((o, h) => o.x !== h.x ? o.x - h.x : o.y - h.y), s = n.slice(0).reverse(), r = [], a = [];
    for (const [o, h] of [[n, r], [s, a]]) {
      for (const c of o) {
        for (; h.length >= 2; ) {
          const l = h[h.length - 1], u = h[h.length - 2];
          if ((l.x - u.x) * (c.y - u.y) >= (c.x - u.x) * (l.y - u.y))
            h.pop();
          else
            break;
        }
        h.push(c);
      }
      h.pop();
    }
    return new yo(...r.concat(a));
  }
  // ---------------------------------------------------------------------------
  /**
   * Checks if a point p lies inside this polygon, by using a ray-casting
   * algorithm and calculating the number of intersections.
   */
  contains(e) {
    let n = !1;
    for (const s of this.edges) {
      if (s.p1.equals(e) || s.contains(e)) return !1;
      if (s.p1.y > e.y == s.p2.y > e.y) continue;
      const r = (s.p2.x - s.p1.x) / (s.p2.y - s.p1.y);
      e.x < r * (e.y - s.p1.y) + s.p1.x && (n = !n);
    }
    return n;
  }
  at(e) {
    e < 0 && (e += Math.floor(e));
    const n = e * this.circumference;
    let s = 0;
    for (const r of this.edges) {
      const a = r.length;
      if (s + a > n) return r.at((n - s) / a);
      s += a;
    }
    return this.points[0];
  }
  offset(e) {
    const n = this.edges, s = Ox(e, this.edges) || [this.points[0], 0];
    let r = 0;
    for (let a = 0; a < s[1]; ++a) r += n[a].length;
    return r += n[s[1]].offset(e) * n[s[1]].length, r / this.circumference;
  }
  project(e) {
    const n = Ox(e, this.edges);
    return n ? n[0] : this.points[0];
  }
  /** Center this polygon on a given point or the origin */
  centerAt(e = _n) {
    return this.translate(e.subtract(this.centroid));
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new this.constructor(...this.points.map((n) => n.transform(e)));
  }
  /** Rotates this polygon by a given angle (in radians), optionally around point `center`. */
  rotate(e, n = _n) {
    if (Tt(e, 0)) return this;
    const s = this.points.map((r) => r.rotate(e, n));
    return new this.constructor(...s);
  }
  reflect(e) {
    const n = this.points.map((s) => s.reflect(e));
    return new this.constructor(...n);
  }
  scale(e, n = e) {
    const s = this.points.map((r) => r.scale(e, n));
    return new this.constructor(...s);
  }
  shift(e, n = e) {
    const s = this.points.map((r) => r.shift(e, n));
    return new this.constructor(...s);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e, n, s) {
    const r = this.points.length;
    if (r !== e.points.length) return !1;
    const a = s ? this : this.oriented, o = s ? e : e.oriented;
    for (let h = 0; h < r; ++h)
      if (a.points.every((c, l) => c.equals(o.points[(l + h) % r], n)))
        return !0;
    return !1;
  }
  toString() {
    return `polygon(${this.points.join(",")})`;
  }
};
class Z2 extends Oa {
  type = "polyline";
  get circumference() {
    return this.length;
  }
  get length() {
    let e = 0;
    for (let n = 1; n < this.points.length; ++n)
      e += st.distance(this.points[n - 1], this.points[n]);
    return e;
  }
  /** @returns {Segment[]} */
  get edges() {
    const e = [];
    for (let n = 0; n < this.points.length - 1; ++n)
      e.push(new zr(this.points[n], this.points[n + 1]));
    return e;
  }
  toString() {
    return `polyline(${this.points.join(",")})`;
  }
}
let dP = class extends Oa {
  type = "triangle";
  get circumcircle() {
    const [e, n, s] = this.points, r = 2 * (e.x * (n.y - s.y) + n.x * (s.y - e.y) + s.x * (e.y - n.y)), a = (e.x ** 2 + e.y ** 2) * (n.y - s.y) + (n.x ** 2 + n.y ** 2) * (s.y - e.y) + (s.x ** 2 + s.y ** 2) * (e.y - n.y), o = (e.x ** 2 + e.y ** 2) * (s.x - n.x) + (n.x ** 2 + n.y ** 2) * (e.x - s.x) + (s.x ** 2 + s.y ** 2) * (n.x - e.x), h = new st(a / r, o / r), c = st.distance(h, this.points[0]);
    if (!(isNaN(c) || c > Number.MAX_SAFE_INTEGER))
      return new Bl(h, c);
  }
  get incircle() {
    const e = this.edges, n = e.map((f) => f.length), s = n[0] + n[1] + n[2], [r, a, o] = this.points, h = n[1] * r.x + n[2] * a.x + n[0] * o.x, c = n[1] * r.y + n[2] * a.y + n[0] * o.y, l = new st(h / s, c / s), u = l.distanceFromLine(e[0]);
    return isNaN(u) ? void 0 : new Bl(l, u);
  }
  get orthocenter() {
    const [e, n, s] = this.points, r = new bn(e, n).perpendicular(s), a = new bn(e, s).perpendicular(n);
    return Ms(r, a)[0];
  }
};
const pP = 180 / Math.PI, yP = Math.PI / 180;
function J2(i) {
  return i * pP;
}
function xP(i) {
  return i * yP;
}
let su = class Wn {
  constructor(e, n, s) {
    this.a = e, this.b = n, this.c = s;
  }
  type = "angle";
  static fromDegrees(e) {
    return Wn.fromRadians(e * (Math.PI / 180));
  }
  static fromRadians(e) {
    const n = new st(1, 0), s = n.rotate(e);
    return new Wn(n, _n, s);
  }
  /** Checks if `a` and `b` are roughly equivalent (by default, within one degree of eachother) */
  static equals(e, n, s = Math.PI / 360) {
    return Tt(e.rad, n.rad, s);
  }
  /** The size, in radians, of this angle. */
  get rad() {
    const e = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
    let s = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x) - e;
    return s < 0 && (s += Le), s;
  }
  /** The size, in degrees, of this angle. */
  get deg() {
    return this.rad * 180 / Math.PI;
  }
  /** Checks if this angle is right-angled. */
  get isRight() {
    return Tt(this.rad, Math.PI / 2, Math.PI / 360);
  }
  /** The bisector of this angle. */
  get bisector() {
    if (this.b.equals(this.a) || this.b.equals(this.c)) return;
    const e = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x), n = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
    let s = (e + n) / 2;
    e > n && (s += Math.PI);
    const r = Math.cos(s) + this.b.x, a = Math.sin(s) + this.b.y;
    return new bn(this.b, new st(r, a));
  }
  /** Returns the smaller one of this and its supplementary angle. */
  get sup() {
    return this.rad < Math.PI ? this : new Wn(this.c, this.b, this.a);
  }
  /** Returns the Arc element corresponding to this angle. */
  get arc() {
    return new Ko(this.b, this.a, this.rad);
  }
  // ---------------------------------------------------------------------------
  /** Radius of the arc or sector representing this angle. */
  get radius() {
    return 24 + 20 * (1 - ti(this.rad, 0, Math.PI) / Math.PI);
  }
  /** Shape object that can be used to draw this angle. */
  shape(e = !0, n, s) {
    if (this.a.equals(this.b) || this.c.equals(this.b)) return new Oa(_n);
    const r = this.isRight && !s;
    n || (n = r ? 20 : this.radius);
    const a = new zr(this.b, this.a), o = a.at(n / a.length);
    if (r) {
      const h = st.difference(this.c, this.b).unitVector.scale(n);
      return e ? new Oa(this.b, o, o.add(h), this.b.add(h)) : new Z2(o, o.add(h), this.b.add(h));
    }
    return e ? new X2(this.b, o, this.rad) : new Ko(this.b, o, this.rad);
  }
  // ---------------------------------------------------------------------------
  // These functions are just included for compatibility with GeoPath
  project(e) {
    return this.contains(e) ? e : this.shape(!0).project(e);
  }
  at() {
    return this.c;
  }
  offset() {
    return 0;
  }
  contains(e) {
    return this.shape(!0).contains(e);
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return new Wn(this.a.transform(e), this.b.transform(e), this.c.transform(e));
  }
  rotate(e, n) {
    return Tt(e, 0) ? this : new Wn(this.a.rotate(e, n), this.b.rotate(e, n), this.c.rotate(e, n));
  }
  reflect(e) {
    return new Wn(this.a.reflect(e), this.b.reflect(e), this.c.reflect(e));
  }
  scale(e, n = e) {
    return new Wn(this.a.scale(e, n), this.b.scale(e, n), this.c.scale(e, n));
  }
  shift(e, n = e) {
    return new Wn(this.a.shift(e, n), this.b.shift(e, n), this.c.shift(e, n));
  }
  translate(e) {
    return new Wn(this.a.translate(e), this.b.translate(e), this.c.translate(e));
  }
  equals(e, n) {
    return Wn.equals(e, this, n);
  }
  toString() {
    return `angle(${this.a},${this.b},${this.c})`;
  }
}, Q2 = class sa {
  constructor(e, n = 1, s = n) {
    this.p = e, this.w = n, this.h = s;
  }
  type = "rectangle";
  /** Creates the smallest rectangle containing all given points. */
  static aroundPoints(e) {
    let n = 1 / 0, s = -1 / 0, r = 1 / 0, a = -1 / 0;
    for (const o of e)
      n = n < o.x ? n : o.x, s = s > o.x ? s : o.x, r = r < o.y ? r : o.y, a = a > o.y ? a : o.y;
    return new sa(new st(n, r), s - n, a - r);
  }
  get center() {
    return new st(this.p.x + this.w / 2, this.p.y + this.h / 2);
  }
  get centroid() {
    return this.center;
  }
  get circumference() {
    return 2 * Math.abs(this.w) + 2 * Math.abs(this.h);
  }
  get area() {
    return Math.abs(this.signedArea);
  }
  get signedArea() {
    return this.w * this.h;
  }
  /** @returns {Segment[]} */
  get edges() {
    return this.polygon.edges;
  }
  /** @returns {Point[]} */
  get points() {
    return this.polygon.points;
  }
  /** A polygon class representing this rectangle. */
  get polygon() {
    const e = new st(this.p.x + this.w, this.p.y), n = new st(this.p.x + this.w, this.p.y + this.h), s = new st(this.p.x, this.p.y + this.h);
    return new Oa(this.p, e, n, s);
  }
  get bounds() {
    return new _a(this.p.x, this.p.x + this.w, this.p.y, this.p.y + this.h);
  }
  collision(e) {
    return this.p.x < e.p.x + e.w && this.p.x + this.w > e.p.x && this.p.y < e.p.y + e.h && this.p.y + this.h > e.p.y || this.equals(e.polygon);
  }
  padding(e, n, s, r) {
    return new sa(this.p.shift(-r, -e), this.w + r + n, this.h + e + s);
  }
  get unsigned() {
    if (this.w > 0 && this.h > 0) return this;
    const e = this.p.shift(this.w < 0 ? this.w : 0, this.h < 0 ? this.h : 0);
    return new sa(e, Math.abs(this.w), Math.abs(this.h));
  }
  // ---------------------------------------------------------------------------
  contains(e, n) {
    return ii(e.x, this.p.x, this.p.x + this.w, n) && ii(e.y, this.p.y, this.p.y + this.h, n);
  }
  project(e) {
    let n;
    for (const s of this.edges) {
      const r = s.project(e);
      (!n || st.distance(e, r) < st.distance(e, n)) && (n = r);
    }
    return n;
  }
  at(e) {
    return this.polygon.at(e);
  }
  offset(e) {
    return this.polygon.offset(e);
  }
  get oriented() {
    return this.polygon.oriented;
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return this.polygon.transform(e);
  }
  /** Rotates this rectangle by a given angle (in radians), optionally around point `c`. */
  rotate(e, n = _n) {
    return Tt(e, 0) ? this : this.polygon.rotate(e, n);
  }
  reflect(e) {
    return this.polygon.reflect(e);
  }
  scale(e, n = e) {
    return new sa(this.p.scale(e, n), this.w * e, this.h * n);
  }
  shift(e, n = e) {
    return new sa(this.p.shift(e, n), this.w, this.h);
  }
  translate(e) {
    return this.shift(e.x, e.y);
  }
  equals(e) {
    return this.polygon.equals(e);
  }
  toString() {
    return `rectangle(${this.p},${this.w},${this.h})`;
  }
};
class _a {
  /**
   * Use the `errorHandling` option to decide how to deal with cases where the
   * min and max values are in the wrong order.
   */
  constructor(e, n, s, r, a) {
    this.xMin = e, this.xMax = n, this.yMin = s, this.yMax = r, a === "swap" ? (this.dx < 0 && ([this.xMin, this.xMax] = [n, e]), this.dy < 0 && ([this.yMin, this.yMax] = [r, s])) : a === "center" && (this.dx < 0 && (this.xMin = this.xMax = (e + n) / 2), this.dy < 0 && (this.yMin = this.yMax = (s + r) / 2));
  }
  contains(e) {
    return this.containsX(e) && this.containsY(e);
  }
  containsX(e) {
    return ii(e.x, this.xMin, this.xMax);
  }
  containsY(e) {
    return ii(e.y, this.yMin, this.yMax);
  }
  resize(e, n) {
    return new _a(this.xMin, this.xMax + e, this.yMin, this.yMax + n);
  }
  get dx() {
    return this.xMax - this.xMin;
  }
  get dy() {
    return this.yMax - this.yMin;
  }
  get xRange() {
    return [this.xMin, this.xMax];
  }
  get yRange() {
    return [this.yMin, this.yMax];
  }
  extend(e, n = e, s = e, r = n) {
    return new _a(this.xMin - r, this.xMax + n, this.yMin - e, this.yMax + s);
  }
  get rect() {
    return new Q2(new st(this.xMin, this.yMin), this.dx, this.dy);
  }
  get center() {
    return new st(this.xMin + this.dx / 2, this.yMin + this.dy / 2);
  }
  get flip() {
    return new _a(this.yMin, this.yMax, this.xMin, this.xMax);
  }
}
function K2(i, e, n = {}) {
  if (Qo(e)) return K2(i, e.shape(!!n.fill), n);
  if (n.fill && (i.fillStyle = n.fill), n.opacity && (i.globalAlpha = n.opacity), n.stroke && (i.strokeStyle = n.stroke, i.lineWidth = n.strokeWidth || 1, n.lineCap && (i.lineCap = n.lineCap), n.lineJoin && (i.lineJoin = n.lineJoin)), i.beginPath(), Ch(e))
    i.moveTo(e.p1.x, e.p1.y), i.lineTo(e.p2.x, e.p2.y);
  else if (cr(e)) {
    if (!n.box) return;
    let [s, r] = Ms(e, n.box);
    if (zh(e) && (r = e.p1), !s || !r) return;
    i.moveTo(s.x, s.y), i.lineTo(r.x, r.y);
  } else if (lr(e))
    i.arc(e.c.x, e.c.y, e.r, 0, Le);
  else if (Nl(e)) {
    const s = e.points;
    i.moveTo(s[0].x, s[0].y);
    for (const r of s.slice(1)) i.lineTo(r.x, r.y);
    i.closePath();
  } else if (Wd(e)) {
    i.moveTo(e.points[0].x, e.points[0].y);
    for (const s of e.points.slice(1)) i.lineTo(s.x, s.y);
  } else Yd(e) && i.ellipse(e.c.x, e.c.y, e.a, e.b, e.angle, 0, Le);
  n.fill && i.fill(), n.stroke && i.stroke();
}
const gP = 4 * (Math.sqrt(2) - 1) / 3;
function Lx(i, e, n) {
  const r = e.x * (n.y - i.y) + i.x * (e.y - n.y) + n.x * (i.y - e.y) > 0 ? 1 : 0, a = st.distance(e, i);
  return [i.x, `${i.y}A${a}`, a, 0, r, 1, n.x, n.y].join(",");
}
function wn(...i) {
  return `M${i.map((e) => `${e.x},${e.y}`).join("L")}`;
}
function nf(i, e) {
  const n = i.perpendicularVector.scale(6), s = i.unitVector.scale(3), r = i.midpoint;
  switch (e) {
    case "bar":
      return wn(r.add(n), r.add(n.inverse));
    case "bar2":
      return wn(r.add(s).add(n), r.add(s).add(n.inverse)) + wn(r.add(s.inverse).add(n), r.add(s.inverse).add(n.inverse));
    case "arrow":
      return wn(
        r.add(s.inverse).add(n),
        r.add(s),
        r.add(s.inverse).add(n.inverse)
      );
    case "arrow2":
      return wn(
        r.add(s.scale(-2)).add(n),
        r,
        r.add(s.scale(-2)).add(n.inverse)
      ) + wn(r.add(n), r.add(s.scale(2)), r.add(n.inverse));
    default:
      return "";
  }
}
function Dl(i, e) {
  if (!i || !e) return "";
  const n = e.perpendicular, s = i.add(e.scale(9)).add(n.scale(9)), r = i.add(e.scale(9)).add(n.scale(-9));
  return wn(s, i, r);
}
function mP(i, e) {
  let n = "";
  return Ho(e, "start", "both") && (n += Dl(i.p1, i.unitVector)), Ho(e, "end", "both") && (n += Dl(i.p2, i.unitVector.inverse)), n;
}
function vP(i, e) {
  let n = "";
  if (Ho(e, "start", "both")) {
    const s = new bn(i.c, i.start).perpendicularVector.inverse;
    n += Dl(i.start, s);
  }
  if (Ho(e, "end", "both")) {
    const s = new bn(i.c, i.end).perpendicularVector;
    n += Dl(i.end, s);
  }
  return n;
}
function T0(i, e) {
  const n = st.distance(i[0], i[1]), s = st.distance(i[1], i[2]), r = Math.max(0.1, n / 2), a = Math.max(0.1, s / 2), o = Math.min(e, r, a), h = o / n, c = o / s, l = 1 - gP, u = st.interpolate(i[0], i[1], ti(1 - h, 0, 1)), f = st.interpolate(i[0], i[1], ti(1 - h * l, 0, 1)), d = st.interpolate(i[1], i[2], ti(c * l, 0, 1)), p = st.interpolate(i[1], i[2], ti(c, 0, 1));
  return [u, f, d, p];
}
function Fx(i, e, n = !1) {
  e < 0 && (e = 0);
  let s = "M";
  if (!n)
    s += `${i[0].x} ${i[0].y}`;
  else {
    const r = i[i.length - 1], a = i[0], o = i[1], h = T0([r, a, o], e);
    s += `${h[3].x} ${h[3].y}`;
  }
  for (let r = 0; r < i.length; r++)
    if (r < i.length - 2 || n) {
      const a = i[r], o = i[(r + 1) % i.length], h = i[(r + 2) % i.length], c = T0([a, o, h], e).map((l) => `${l.x} ${l.y}`);
      s += `L${c[0]}C${c[1]} ${c[2]} ${c[3]}`;
    } else r === i.length - 2 && !n && (s += `L${i[r + 1].x} ${i[r + 1].y}`);
  return s;
}
function wP(i, e, n = e, s = e, r = n) {
  const { p: a, w: o, h } = i;
  return `M${a.x} ${a.y + e}a${e} ${e} 0 0 1 ${e} ${-e}h${o - e - n}a${n} ${n} 0 0 1 ${n} ${n}v${h - n - s}a${s} ${s} 0 0 1 ${-s} ${s}h${-o + r + s}a${r} ${r} 0 0 1 ${-r} ${-r}Z`;
}
function tw(i, e = {}) {
  if (Qo(i)) {
    const n = i.shape(!!e.fill, e.size, e.round);
    return tw(n, e);
  }
  if (Ch(i)) {
    if (i.p1.equals(i.p2)) return "";
    let n = wn(i.p1, i.p2);
    return e.mark && (n += nf(i, e.mark)), e.arrows && (n += mP(i, e.arrows)), n;
  }
  if (zh(i)) {
    if (!e.box) return "";
    const n = Ms(i, e.box)[0];
    if (!n) return "";
    let s = wn(i.p1, n);
    return e.mark && (s += nf(i, e.mark)), s;
  }
  if (Y2(i)) {
    if (!e.box) return "";
    const n = Ms(i, e.box);
    if (n.length < 2) return "";
    let s = wn(n[0], n[1]);
    return e.mark && (s += nf(i, e.mark)), s;
  }
  if (lr(i))
    return `M${i.c.x - i.r} ${i.c.y}a${i.r},${i.r} 0 1 0 ${2 * i.r} 0a${i.r} ${i.r} 0 1 0 ${-2 * i.r} 0Z`;
  if (Yd(i)) {
    const [n, s] = i.majorVertices, r = J2(i.angle);
    return `M${n.x} ${n.y}A${i.a} ${i.b} ${r} 0 0 ${s.x} ${s.y}A${i.a} ${i.b} ${r} 0 0 ${n.x} ${n.y}Z`;
  }
  if (Fo(i)) {
    let n = `M${Lx(i.start, i.c, i.end)}`;
    return e.arrows && (n += vP(i, e.arrows)), n;
  }
  return j2(i) ? `M${i.c.x} ${i.c.y} L ${Lx(i.start, i.c, i.end)}Z` : Wd(i) ? e.cornerRadius ? Fx(i.points, e.cornerRadius, !1) : wn(...i.points) : W2(i) || S0(i) && e.cornerRadius ? e.cornerRadius ? Fx(i.points, e.cornerRadius, !0) : `${wn(...i.points)}Z` : S0(i) ? `${wn(...i.polygon.points)}Z` : "";
}
let MP = class Ks {
  /**
   * @param c Center of the ellipse
   * @param a Major axis
   * @param b Minor axis
   * @param angle The rotation of the major axis of the ellipse.
   */
  constructor(e, n, s, r = 0) {
    this.c = e, n < s && ([n, s] = [s, n], r += Math.PI / 2), this.a = n, this.b = s, this.angle = r;
    const a = Math.sqrt(n ** 2 - s ** 2);
    this.f1 = this.c.add(new st(-a, 0).rotate(r)), this.f2 = this.c.add(new st(a, 0).rotate(r));
  }
  type = "ellipse";
  a;
  b;
  angle;
  f1;
  f2;
  get rx() {
    return Tt(this.angle, 0) ? this.a : Tt(this.angle, Math.PI / 2) ? this.b : void 0;
  }
  get ry() {
    return Tt(this.angle, 0) ? this.b : Tt(this.angle, Math.PI / 2) ? this.a : void 0;
  }
  normalAt(e) {
    return new su(this.f1, e, this.f2).bisector;
  }
  /** Intersection between an ellipse and a line. */
  intersect(e) {
    e = e.rotate(-this.angle, this.c);
    const n = e.p1.x - e.p2.x, s = e.p1.y - e.p2.y, r = this.c.x - e.p1.x, a = this.c.y - e.p1.y, o = (n / this.a) ** 2 + (s / this.b) ** 2, h = 2 * r * n / this.a ** 2 + 2 * a * s / this.b ** 2, c = (r / this.a) ** 2 + (a / this.b) ** 2 - 1;
    return S2(o, h, c).map((u) => e.at(u).rotate(this.angle, this.c));
  }
  /**
   * Creates a new Ellipse. StringLength is the length of string from one foci
   * to a point on the circumference, to the other foci.
   */
  static fromFoci(e, n, s) {
    const r = st.distance(e, n) / 2, a = s / 2, o = Math.sqrt(a ** 2 - r ** 2), h = new bn(e, n).angle;
    return new Ks(st.interpolate(e, n), a, o, h);
  }
  // ---------------------------------------------------------------------------
  get majorVertices() {
    return [
      this.c.add(new st(-this.a, 0).rotate(this.angle)),
      this.c.add(new st(this.a, 0).rotate(this.angle))
    ];
  }
  get minorVertices() {
    return [
      this.c.add(new st(0, -this.b).rotate(this.angle)),
      this.c.add(new st(0, this.b).rotate(this.angle))
    ];
  }
  get extremes() {
    const { a: e, b: n, angle: s } = this, r = Math.cos(s), a = Math.sin(s), o = e ** 2 + n ** 2, h = (e ** 2 - n ** 2) * Math.cos(2 * s), c = Math.sqrt((o - h) / 2), l = c * o * a * r / (e ** 2 * a ** 2 + n ** 2 * r ** 2), u = Math.sqrt((o + h) / 2), f = u * o * a * r / (e ** 2 * r ** 2 + n ** 2 * a ** 2);
    return [
      new st(l, c).add(this.c),
      new st(l, c).inverse.add(this.c),
      new st(u, f).add(this.c),
      new st(u, f).inverse.add(this.c)
    ];
  }
  project(e) {
    e = e.rotate(-this.angle, this.c);
    const n = e.angle(this.c);
    return this.at(n / Le);
  }
  at(e) {
    const n = Le * e;
    return this.c.shift(this.a * Math.cos(n), this.b * Math.sin(n)).rotate(this.angle, this.c);
  }
  offset(e) {
    return 0.5;
  }
  contains(e) {
    const n = Math.cos(this.angle), s = Math.sin(this.angle), r = n ** 2 / this.a ** 2 + s ** 2 / this.b ** 2, a = 2 * n * s * (1 / this.a ** 2 - 1 / this.b ** 2), o = s ** 2 / this.a ** 2 + n ** 2 / this.b ** 2;
    return r * e.x ** 2 + a * e.x * e.y + o * e.y ** 2 <= 1;
  }
  // ---------------------------------------------------------------------------
  transform(e) {
    return this;
  }
  rotate(e, n = _n) {
    const s = new bn(this.f1, this.f2).rotate(e, n);
    return Ks.fromFoci(s.p1, s.p2, this.a * 2);
  }
  reflect(e) {
    const n = new bn(this.f1, this.f2).reflect(e);
    return Ks.fromFoci(n.p1, n.p2, this.a * 2);
  }
  scale(e, n = e) {
    return new Ks(this.c.scale(e, n), this.a * e, this.b * n, this.angle);
  }
  shift(e, n = e) {
    return new Ks(this.c.shift(e, n), this.a, this.b, this.angle);
  }
  translate(e) {
    return new Ks(this.c.translate(e), this.a, this.b, this.angle);
  }
  equals(e, n) {
    return Tt(this.a, e.a, n) && Tt(this.b, e.b, n) && Tt(this.angle, e.angle, n) && this.c.equals(e.c, n);
  }
  toString() {
    return `ellipse(${this.c},${this.a},${this.b},${this.angle})`;
  }
};
const bP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Angle: su,
  Arc: Ko,
  Bounds: _a,
  Circle: Bl,
  Ellipse: MP,
  Line: bn,
  ORIGIN: _n,
  Point: st,
  Polygon: Oa,
  Polyline: Z2,
  Ray: H2,
  Rectangle: Q2,
  Sector: X2,
  Segment: zr,
  TWO_PI: Le,
  Triangle: dP,
  drawCanvas: K2,
  drawRoundedRect: wP,
  drawSVG: tw,
  getBezierPoints: T0,
  intersections: Ms,
  isAngle: Qo,
  isArc: Fo,
  isCircle: lr,
  isEllipse: Yd,
  isLine: Y2,
  isLineLike: cr,
  isPoint: aP,
  isPolygon: W2,
  isPolygonLike: Nl,
  isPolyline: Wd,
  isRay: zh,
  isRectangle: S0,
  isSector: j2,
  isSegment: Ch,
  rad: Ra,
  toDeg: J2,
  toRad: xP
}, Symbol.toStringTag, { value: "Module" })), _P = {
  core: aA,
  fermat: rP,
  euclid: bP
}, SP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  mathigon: _P
}, Symbol.toStringTag, { value: "Module" }));
var TP = 20, EP = 1, Mr = 1e6, Nx = 1e6, zP = -7, CP = 21, AP = !1, Ah = "[big.js] ", Cr = Ah + "Invalid ", ru = Cr + "decimal places", PP = Cr + "rounding mode", ew = Ah + "Division by zero", Ht = {}, wi = void 0, IP = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function nw() {
  function i(e) {
    var n = this;
    if (!(n instanceof i))
      return e === wi && arguments.length === 0 ? nw() : new i(e);
    if (e instanceof i)
      n.s = e.s, n.e = e.e, n.c = e.c.slice();
    else {
      if (typeof e != "string") {
        if (i.strict === !0 && typeof e != "bigint")
          throw TypeError(Cr + "value");
        e = e === 0 && 1 / e < 0 ? "-0" : String(e);
      }
      RP(n, e);
    }
    n.constructor = i;
  }
  return i.prototype = Ht, i.DP = TP, i.RM = EP, i.NE = zP, i.PE = CP, i.strict = AP, i.roundDown = 0, i.roundHalfUp = 1, i.roundHalfEven = 2, i.roundUp = 3, i;
}
function RP(i, e) {
  var n, s, r;
  if (!IP.test(e))
    throw Error(Cr + "number");
  for (i.s = e.charAt(0) == "-" ? (e = e.slice(1), -1) : 1, (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (s = e.search(/e/i)) > 0 ? (n < 0 && (n = s), n += +e.slice(s + 1), e = e.substring(0, s)) : n < 0 && (n = e.length), r = e.length, s = 0; s < r && e.charAt(s) == "0"; ) ++s;
  if (s == r)
    i.c = [i.e = 0];
  else {
    for (; r > 0 && e.charAt(--r) == "0"; ) ;
    for (i.e = n - s - 1, i.c = [], n = 0; s <= r; ) i.c[n++] = +e.charAt(s++);
  }
  return i;
}
function Ar(i, e, n, s) {
  var r = i.c;
  if (n === wi && (n = i.constructor.RM), n !== 0 && n !== 1 && n !== 2 && n !== 3)
    throw Error(PP);
  if (e < 1)
    s = n === 3 && (s || !!r[0]) || e === 0 && (n === 1 && r[0] >= 5 || n === 2 && (r[0] > 5 || r[0] === 5 && (s || r[1] !== wi))), r.length = 1, s ? (i.e = i.e - e + 1, r[0] = 1) : r[0] = i.e = 0;
  else if (e < r.length) {
    if (s = n === 1 && r[e] >= 5 || n === 2 && (r[e] > 5 || r[e] === 5 && (s || r[e + 1] !== wi || r[e - 1] & 1)) || n === 3 && (s || !!r[0]), r.length = e, s) {
      for (; ++r[--e] > 9; )
        if (r[e] = 0, e === 0) {
          ++i.e, r.unshift(1);
          break;
        }
    }
    for (e = r.length; !r[--e]; ) r.pop();
  }
  return i;
}
function Pr(i, e, n) {
  var s = i.e, r = i.c.join(""), a = r.length;
  if (e)
    r = r.charAt(0) + (a > 1 ? "." + r.slice(1) : "") + (s < 0 ? "e" : "e+") + s;
  else if (s < 0) {
    for (; ++s; ) r = "0" + r;
    r = "0." + r;
  } else if (s > 0)
    if (++s > a)
      for (s -= a; s--; ) r += "0";
    else s < a && (r = r.slice(0, s) + "." + r.slice(s));
  else a > 1 && (r = r.charAt(0) + "." + r.slice(1));
  return i.s < 0 && n ? "-" + r : r;
}
Ht.abs = function() {
  var i = new this.constructor(this);
  return i.s = 1, i;
};
Ht.cmp = function(i) {
  var e, n = this, s = n.c, r = (i = new n.constructor(i)).c, a = n.s, o = i.s, h = n.e, c = i.e;
  if (!s[0] || !r[0]) return s[0] ? a : r[0] ? -o : 0;
  if (a != o) return a;
  if (e = a < 0, h != c) return h > c ^ e ? 1 : -1;
  for (o = (h = s.length) < (c = r.length) ? h : c, a = -1; ++a < o; )
    if (s[a] != r[a]) return s[a] > r[a] ^ e ? 1 : -1;
  return h == c ? 0 : h > c ^ e ? 1 : -1;
};
Ht.div = function(i) {
  var e = this, n = e.constructor, s = e.c, r = (i = new n(i)).c, a = e.s == i.s ? 1 : -1, o = n.DP;
  if (o !== ~~o || o < 0 || o > Mr)
    throw Error(ru);
  if (!r[0])
    throw Error(ew);
  if (!s[0])
    return i.s = a, i.c = [i.e = 0], i;
  var h, c, l, u, f, d = r.slice(), p = h = r.length, y = s.length, x = s.slice(0, h), g = x.length, m = i, v = m.c = [], w = 0, b = o + (m.e = e.e - i.e) + 1;
  for (m.s = a, a = b < 0 ? 0 : b, d.unshift(0); g++ < h; ) x.push(0);
  do {
    for (l = 0; l < 10; l++) {
      if (h != (g = x.length))
        u = h > g ? 1 : -1;
      else
        for (f = -1, u = 0; ++f < h; )
          if (r[f] != x[f]) {
            u = r[f] > x[f] ? 1 : -1;
            break;
          }
      if (u < 0) {
        for (c = g == h ? r : d; g; ) {
          if (x[--g] < c[g]) {
            for (f = g; f && !x[--f]; ) x[f] = 9;
            --x[f], x[g] += 10;
          }
          x[g] -= c[g];
        }
        for (; !x[0]; ) x.shift();
      } else
        break;
    }
    v[w++] = u ? l : ++l, x[0] && u ? x[g] = s[p] || 0 : x = [s[p]];
  } while ((p++ < y || x[0] !== wi) && a--);
  return !v[0] && w != 1 && (v.shift(), m.e--, b--), w > b && Ar(m, b, n.RM, x[0] !== wi), m;
};
Ht.eq = function(i) {
  return this.cmp(i) === 0;
};
Ht.gt = function(i) {
  return this.cmp(i) > 0;
};
Ht.gte = function(i) {
  return this.cmp(i) > -1;
};
Ht.lt = function(i) {
  return this.cmp(i) < 0;
};
Ht.lte = function(i) {
  return this.cmp(i) < 1;
};
Ht.minus = Ht.sub = function(i) {
  var e, n, s, r, a = this, o = a.constructor, h = a.s, c = (i = new o(i)).s;
  if (h != c)
    return i.s = -c, a.plus(i);
  var l = a.c.slice(), u = a.e, f = i.c, d = i.e;
  if (!l[0] || !f[0])
    return f[0] ? i.s = -c : l[0] ? i = new o(a) : i.s = 1, i;
  if (h = u - d) {
    for ((r = h < 0) ? (h = -h, s = l) : (d = u, s = f), s.reverse(), c = h; c--; ) s.push(0);
    s.reverse();
  } else
    for (n = ((r = l.length < f.length) ? l : f).length, h = c = 0; c < n; c++)
      if (l[c] != f[c]) {
        r = l[c] < f[c];
        break;
      }
  if (r && (s = l, l = f, f = s, i.s = -i.s), (c = (n = f.length) - (e = l.length)) > 0) for (; c--; ) l[e++] = 0;
  for (c = e; n > h; ) {
    if (l[--n] < f[n]) {
      for (e = n; e && !l[--e]; ) l[e] = 9;
      --l[e], l[n] += 10;
    }
    l[n] -= f[n];
  }
  for (; l[--c] === 0; ) l.pop();
  for (; l[0] === 0; )
    l.shift(), --d;
  return l[0] || (i.s = 1, l = [d = 0]), i.c = l, i.e = d, i;
};
Ht.mod = function(i) {
  var e, n = this, s = n.constructor, r = n.s, a = (i = new s(i)).s;
  if (!i.c[0])
    throw Error(ew);
  return n.s = i.s = 1, e = i.cmp(n) == 1, n.s = r, i.s = a, e ? new s(n) : (r = s.DP, a = s.RM, s.DP = s.RM = 0, n = n.div(i), s.DP = r, s.RM = a, this.minus(n.times(i)));
};
Ht.neg = function() {
  var i = new this.constructor(this);
  return i.s = -i.s, i;
};
Ht.plus = Ht.add = function(i) {
  var e, n, s, r = this, a = r.constructor;
  if (i = new a(i), r.s != i.s)
    return i.s = -i.s, r.minus(i);
  var o = r.e, h = r.c, c = i.e, l = i.c;
  if (!h[0] || !l[0])
    return l[0] || (h[0] ? i = new a(r) : i.s = r.s), i;
  if (h = h.slice(), e = o - c) {
    for (e > 0 ? (c = o, s = l) : (e = -e, s = h), s.reverse(); e--; ) s.push(0);
    s.reverse();
  }
  for (h.length - l.length < 0 && (s = l, l = h, h = s), e = l.length, n = 0; e; h[e] %= 10) n = (h[--e] = h[e] + l[e] + n) / 10 | 0;
  for (n && (h.unshift(n), ++c), e = h.length; h[--e] === 0; ) h.pop();
  return i.c = h, i.e = c, i;
};
Ht.pow = function(i) {
  var e = this, n = new e.constructor("1"), s = n, r = i < 0;
  if (i !== ~~i || i < -Nx || i > Nx)
    throw Error(Cr + "exponent");
  for (r && (i = -i); i & 1 && (s = s.times(e)), i >>= 1, !!i; )
    e = e.times(e);
  return r ? n.div(s) : s;
};
Ht.prec = function(i, e) {
  if (i !== ~~i || i < 1 || i > Mr)
    throw Error(Cr + "precision");
  return Ar(new this.constructor(this), i, e);
};
Ht.round = function(i, e) {
  if (i === wi) i = 0;
  else if (i !== ~~i || i < -Mr || i > Mr)
    throw Error(ru);
  return Ar(new this.constructor(this), i + this.e + 1, e);
};
Ht.sqrt = function() {
  var i, e, n, s = this, r = s.constructor, a = s.s, o = s.e, h = new r("0.5");
  if (!s.c[0]) return new r(s);
  if (a < 0)
    throw Error(Ah + "No square root");
  a = Math.sqrt(+Pr(s, !0, !0)), a === 0 || a === 1 / 0 ? (e = s.c.join(""), e.length + o & 1 || (e += "0"), a = Math.sqrt(e), o = ((o + 1) / 2 | 0) - (o < 0 || o & 1), i = new r((a == 1 / 0 ? "5e" : (a = a.toExponential()).slice(0, a.indexOf("e") + 1)) + o)) : i = new r(a + ""), o = i.e + (r.DP += 4);
  do
    n = i, i = h.times(n.plus(s.div(n)));
  while (n.c.slice(0, o).join("") !== i.c.slice(0, o).join(""));
  return Ar(i, (r.DP -= 4) + i.e + 1, r.RM);
};
Ht.times = Ht.mul = function(i) {
  var e, n = this, s = n.constructor, r = n.c, a = (i = new s(i)).c, o = r.length, h = a.length, c = n.e, l = i.e;
  if (i.s = n.s == i.s ? 1 : -1, !r[0] || !a[0])
    return i.c = [i.e = 0], i;
  for (i.e = c + l, o < h && (e = r, r = a, a = e, l = o, o = h, h = l), e = new Array(l = o + h); l--; ) e[l] = 0;
  for (c = h; c--; ) {
    for (h = 0, l = o + c; l > c; )
      h = e[l] + a[c] * r[l - c - 1] + h, e[l--] = h % 10, h = h / 10 | 0;
    e[l] = h;
  }
  for (h ? ++i.e : e.shift(), c = e.length; !e[--c]; ) e.pop();
  return i.c = e, i;
};
Ht.toExponential = function(i, e) {
  var n = this, s = n.c[0];
  if (i !== wi) {
    if (i !== ~~i || i < 0 || i > Mr)
      throw Error(ru);
    for (n = Ar(new n.constructor(n), ++i, e); n.c.length < i; ) n.c.push(0);
  }
  return Pr(n, !0, !!s);
};
Ht.toFixed = function(i, e) {
  var n = this, s = n.c[0];
  if (i !== wi) {
    if (i !== ~~i || i < 0 || i > Mr)
      throw Error(ru);
    for (n = Ar(new n.constructor(n), i + n.e + 1, e), i = i + n.e + 1; n.c.length < i; ) n.c.push(0);
  }
  return Pr(n, !1, !!s);
};
Ht.toJSON = Ht.toString = function() {
  var i = this, e = i.constructor;
  return Pr(i, i.e <= e.NE || i.e >= e.PE, !!i.c[0]);
};
typeof Symbol < "u" && (Ht[Symbol.for("nodejs.util.inspect.custom")] = Ht.toJSON);
Ht.toNumber = function() {
  var i = +Pr(this, !0, !0);
  if (this.constructor.strict === !0 && !this.eq(i.toString()))
    throw Error(Ah + "Imprecise conversion");
  return i;
};
Ht.toPrecision = function(i, e) {
  var n = this, s = n.constructor, r = n.c[0];
  if (i !== wi) {
    if (i !== ~~i || i < 1 || i > Mr)
      throw Error(Cr + "precision");
    for (n = Ar(new s(n), i, e); n.c.length < i; ) n.c.push(0);
  }
  return Pr(n, i <= n.e || n.e <= s.NE || n.e >= s.PE, !!r);
};
Ht.valueOf = function() {
  var i = this, e = i.constructor;
  if (e.strict === !0)
    throw Error(Ah + "valueOf disallowed");
  return Pr(i, i.e <= e.NE || i.e >= e.PE, !0);
};
var OP = nw(), ze = function(i) {
  var e = 1e7, n = 7, s = 9007199254740992, r = d(s), a = "0123456789abcdefghijklmnopqrstuvwxyz", o = typeof BigInt == "function";
  function h(z, O, D, q) {
    return typeof z > "u" ? h[0] : typeof O < "u" ? +O == 10 && !D ? nt(z) : Z(z, O, D, q) : nt(z);
  }
  function c(z, O) {
    this.value = z, this.sign = O, this.isSmall = !1;
  }
  c.prototype = Object.create(h.prototype);
  function l(z) {
    this.value = z, this.sign = z < 0, this.isSmall = !0;
  }
  l.prototype = Object.create(h.prototype);
  function u(z) {
    this.value = z;
  }
  u.prototype = Object.create(h.prototype);
  function f(z) {
    return -s < z && z < s;
  }
  function d(z) {
    return z < 1e7 ? [z] : z < 1e14 ? [z % 1e7, Math.floor(z / 1e7)] : [z % 1e7, Math.floor(z / 1e7) % 1e7, Math.floor(z / 1e14)];
  }
  function p(z) {
    y(z);
    var O = z.length;
    if (O < 4 && B(z, r) < 0)
      switch (O) {
        case 0:
          return 0;
        case 1:
          return z[0];
        case 2:
          return z[0] + z[1] * e;
        default:
          return z[0] + (z[1] + z[2] * e) * e;
      }
    return z;
  }
  function y(z) {
    for (var O = z.length; z[--O] === 0; ) ;
    z.length = O + 1;
  }
  function x(z) {
    for (var O = new Array(z), D = -1; ++D < z; )
      O[D] = 0;
    return O;
  }
  function g(z) {
    return z > 0 ? Math.floor(z) : Math.ceil(z);
  }
  function m(z, O) {
    var D = z.length, q = O.length, U = new Array(D), G = 0, W = e, Y, Q;
    for (Q = 0; Q < q; Q++)
      Y = z[Q] + O[Q] + G, G = Y >= W ? 1 : 0, U[Q] = Y - G * W;
    for (; Q < D; )
      Y = z[Q] + G, G = Y === W ? 1 : 0, U[Q++] = Y - G * W;
    return G > 0 && U.push(G), U;
  }
  function v(z, O) {
    return z.length >= O.length ? m(z, O) : m(O, z);
  }
  function w(z, O) {
    var D = z.length, q = new Array(D), U = e, G, W;
    for (W = 0; W < D; W++)
      G = z[W] - U + O, O = Math.floor(G / U), q[W] = G - O * U, O += 1;
    for (; O > 0; )
      q[W++] = O % U, O = Math.floor(O / U);
    return q;
  }
  c.prototype.add = function(z) {
    var O = nt(z);
    if (this.sign !== O.sign)
      return this.subtract(O.negate());
    var D = this.value, q = O.value;
    return O.isSmall ? new c(w(D, Math.abs(q)), this.sign) : new c(v(D, q), this.sign);
  }, c.prototype.plus = c.prototype.add, l.prototype.add = function(z) {
    var O = nt(z), D = this.value;
    if (D < 0 !== O.sign)
      return this.subtract(O.negate());
    var q = O.value;
    if (O.isSmall) {
      if (f(D + q)) return new l(D + q);
      q = d(Math.abs(q));
    }
    return new c(w(q, Math.abs(D)), D < 0);
  }, l.prototype.plus = l.prototype.add, u.prototype.add = function(z) {
    return new u(this.value + nt(z).value);
  }, u.prototype.plus = u.prototype.add;
  function b(z, O) {
    var D = z.length, q = O.length, U = new Array(D), G = 0, W = e, Y, Q;
    for (Y = 0; Y < q; Y++)
      Q = z[Y] - G - O[Y], Q < 0 ? (Q += W, G = 1) : G = 0, U[Y] = Q;
    for (Y = q; Y < D; Y++) {
      if (Q = z[Y] - G, Q < 0) Q += W;
      else {
        U[Y++] = Q;
        break;
      }
      U[Y] = Q;
    }
    for (; Y < D; Y++)
      U[Y] = z[Y];
    return y(U), U;
  }
  function S(z, O, D) {
    var q;
    return B(z, O) >= 0 ? q = b(z, O) : (q = b(O, z), D = !D), q = p(q), typeof q == "number" ? (D && (q = -q), new l(q)) : new c(q, D);
  }
  function E(z, O, D) {
    var q = z.length, U = new Array(q), G = -O, W = e, Y, Q;
    for (Y = 0; Y < q; Y++)
      Q = z[Y] + G, G = Math.floor(Q / W), Q %= W, U[Y] = Q < 0 ? Q + W : Q;
    return U = p(U), typeof U == "number" ? (D && (U = -U), new l(U)) : new c(U, D);
  }
  c.prototype.subtract = function(z) {
    var O = nt(z);
    if (this.sign !== O.sign)
      return this.add(O.negate());
    var D = this.value, q = O.value;
    return O.isSmall ? E(D, Math.abs(q), this.sign) : S(D, q, this.sign);
  }, c.prototype.minus = c.prototype.subtract, l.prototype.subtract = function(z) {
    var O = nt(z), D = this.value;
    if (D < 0 !== O.sign)
      return this.add(O.negate());
    var q = O.value;
    return O.isSmall ? new l(D - q) : E(q, Math.abs(D), D >= 0);
  }, l.prototype.minus = l.prototype.subtract, u.prototype.subtract = function(z) {
    return new u(this.value - nt(z).value);
  }, u.prototype.minus = u.prototype.subtract, c.prototype.negate = function() {
    return new c(this.value, !this.sign);
  }, l.prototype.negate = function() {
    var z = this.sign, O = new l(-this.value);
    return O.sign = !z, O;
  }, u.prototype.negate = function() {
    return new u(-this.value);
  }, c.prototype.abs = function() {
    return new c(this.value, !1);
  }, l.prototype.abs = function() {
    return new l(Math.abs(this.value));
  }, u.prototype.abs = function() {
    return new u(this.value >= 0 ? this.value : -this.value);
  };
  function A(z, O) {
    var D = z.length, q = O.length, U = D + q, G = x(U), W = e, Y, Q, Mt, Lt, Ct;
    for (Mt = 0; Mt < D; ++Mt) {
      Lt = z[Mt];
      for (var Yt = 0; Yt < q; ++Yt)
        Ct = O[Yt], Y = Lt * Ct + G[Mt + Yt], Q = Math.floor(Y / W), G[Mt + Yt] = Y - Q * W, G[Mt + Yt + 1] += Q;
    }
    return y(G), G;
  }
  function M(z, O) {
    var D = z.length, q = new Array(D), U = e, G = 0, W, Y;
    for (Y = 0; Y < D; Y++)
      W = z[Y] * O + G, G = Math.floor(W / U), q[Y] = W - G * U;
    for (; G > 0; )
      q[Y++] = G % U, G = Math.floor(G / U);
    return q;
  }
  function _(z, O) {
    for (var D = []; O-- > 0; ) D.push(0);
    return D.concat(z);
  }
  function T(z, O) {
    var D = Math.max(z.length, O.length);
    if (D <= 30) return A(z, O);
    D = Math.ceil(D / 2);
    var q = z.slice(D), U = z.slice(0, D), G = O.slice(D), W = O.slice(0, D), Y = T(U, W), Q = T(q, G), Mt = T(v(U, q), v(W, G)), Lt = v(v(Y, _(b(b(Mt, Y), Q), D)), _(Q, 2 * D));
    return y(Lt), Lt;
  }
  function C(z, O) {
    return -0.012 * z - 0.012 * O + 15e-6 * z * O > 0;
  }
  c.prototype.multiply = function(z) {
    var O = nt(z), D = this.value, q = O.value, U = this.sign !== O.sign, G;
    if (O.isSmall) {
      if (q === 0) return h[0];
      if (q === 1) return this;
      if (q === -1) return this.negate();
      if (G = Math.abs(q), G < e)
        return new c(M(D, G), U);
      q = d(G);
    }
    return C(D.length, q.length) ? new c(T(D, q), U) : new c(A(D, q), U);
  }, c.prototype.times = c.prototype.multiply;
  function P(z, O, D) {
    return z < e ? new c(M(O, z), D) : new c(A(O, d(z)), D);
  }
  l.prototype._multiplyBySmall = function(z) {
    return f(z.value * this.value) ? new l(z.value * this.value) : P(Math.abs(z.value), d(Math.abs(this.value)), this.sign !== z.sign);
  }, c.prototype._multiplyBySmall = function(z) {
    return z.value === 0 ? h[0] : z.value === 1 ? this : z.value === -1 ? this.negate() : P(Math.abs(z.value), this.value, this.sign !== z.sign);
  }, l.prototype.multiply = function(z) {
    return nt(z)._multiplyBySmall(this);
  }, l.prototype.times = l.prototype.multiply, u.prototype.multiply = function(z) {
    return new u(this.value * nt(z).value);
  }, u.prototype.times = u.prototype.multiply;
  function R(z) {
    var O = z.length, D = x(O + O), q = e, U, G, W, Y, Q;
    for (W = 0; W < O; W++) {
      Y = z[W], G = 0 - Y * Y;
      for (var Mt = W; Mt < O; Mt++)
        Q = z[Mt], U = 2 * (Y * Q) + D[W + Mt] + G, G = Math.floor(U / q), D[W + Mt] = U - G * q;
      D[W + O] = G;
    }
    return y(D), D;
  }
  c.prototype.square = function() {
    return new c(R(this.value), !1);
  }, l.prototype.square = function() {
    var z = this.value * this.value;
    return f(z) ? new l(z) : new c(R(d(Math.abs(this.value))), !1);
  }, u.prototype.square = function(z) {
    return new u(this.value * this.value);
  };
  function k(z, O) {
    var D = z.length, q = O.length, U = e, G = x(O.length), W = O[q - 1], Y = Math.ceil(U / (2 * W)), Q = M(z, Y), Mt = M(O, Y), Lt, Ct, Yt, yn, sn, _u, Su;
    for (Q.length <= D && Q.push(0), Mt.push(0), W = Mt[q - 1], Ct = D - q; Ct >= 0; Ct--) {
      for (Lt = U - 1, Q[Ct + q] !== W && (Lt = Math.floor((Q[Ct + q] * U + Q[Ct + q - 1]) / W)), Yt = 0, yn = 0, _u = Mt.length, sn = 0; sn < _u; sn++)
        Yt += Lt * Mt[sn], Su = Math.floor(Yt / U), yn += Q[Ct + sn] - (Yt - Su * U), Yt = Su, yn < 0 ? (Q[Ct + sn] = yn + U, yn = -1) : (Q[Ct + sn] = yn, yn = 0);
      for (; yn !== 0; ) {
        for (Lt -= 1, Yt = 0, sn = 0; sn < _u; sn++)
          Yt += Q[Ct + sn] - U + Mt[sn], Yt < 0 ? (Q[Ct + sn] = Yt + U, Yt = 0) : (Q[Ct + sn] = Yt, Yt = 1);
        yn += Yt;
      }
      G[Ct] = Lt;
    }
    return Q = L(Q, Y)[0], [p(G), p(Q)];
  }
  function I(z, O) {
    for (var D = z.length, q = O.length, U = [], G = [], W = e, Y, Q, Mt, Lt, Ct; D; ) {
      if (G.unshift(z[--D]), y(G), B(G, O) < 0) {
        U.push(0);
        continue;
      }
      Q = G.length, Mt = G[Q - 1] * W + G[Q - 2], Lt = O[q - 1] * W + O[q - 2], Q > q && (Mt = (Mt + 1) * W), Y = Math.ceil(Mt / Lt);
      do {
        if (Ct = M(O, Y), B(Ct, G) <= 0) break;
        Y--;
      } while (Y);
      U.push(Y), G = b(G, Ct);
    }
    return U.reverse(), [p(U), p(G)];
  }
  function L(z, O) {
    var D = z.length, q = x(D), U = e, G, W, Y, Q;
    for (Y = 0, G = D - 1; G >= 0; --G)
      Q = Y * U + z[G], W = g(Q / O), Y = Q - W * O, q[G] = W | 0;
    return [q, Y | 0];
  }
  function F(z, O) {
    var D, q = nt(O);
    if (o)
      return [new u(z.value / q.value), new u(z.value % q.value)];
    var U = z.value, G = q.value, W;
    if (G === 0) throw new Error("Cannot divide by zero");
    if (z.isSmall)
      return q.isSmall ? [new l(g(U / G)), new l(U % G)] : [h[0], z];
    if (q.isSmall) {
      if (G === 1) return [z, h[0]];
      if (G == -1) return [z.negate(), h[0]];
      var Y = Math.abs(G);
      if (Y < e) {
        D = L(U, Y), W = p(D[0]);
        var Q = D[1];
        return z.sign && (Q = -Q), typeof W == "number" ? (z.sign !== q.sign && (W = -W), [new l(W), new l(Q)]) : [new c(W, z.sign !== q.sign), new l(Q)];
      }
      G = d(Y);
    }
    var Mt = B(U, G);
    if (Mt === -1) return [h[0], z];
    if (Mt === 0) return [h[z.sign === q.sign ? 1 : -1], h[0]];
    U.length + G.length <= 200 ? D = k(U, G) : D = I(U, G), W = D[0];
    var Lt = z.sign !== q.sign, Ct = D[1], Yt = z.sign;
    return typeof W == "number" ? (Lt && (W = -W), W = new l(W)) : W = new c(W, Lt), typeof Ct == "number" ? (Yt && (Ct = -Ct), Ct = new l(Ct)) : Ct = new c(Ct, Yt), [W, Ct];
  }
  c.prototype.divmod = function(z) {
    var O = F(this, z);
    return {
      quotient: O[0],
      remainder: O[1]
    };
  }, u.prototype.divmod = l.prototype.divmod = c.prototype.divmod, c.prototype.divide = function(z) {
    return F(this, z)[0];
  }, u.prototype.over = u.prototype.divide = function(z) {
    return new u(this.value / nt(z).value);
  }, l.prototype.over = l.prototype.divide = c.prototype.over = c.prototype.divide, c.prototype.mod = function(z) {
    return F(this, z)[1];
  }, u.prototype.mod = u.prototype.remainder = function(z) {
    return new u(this.value % nt(z).value);
  }, l.prototype.remainder = l.prototype.mod = c.prototype.remainder = c.prototype.mod, c.prototype.pow = function(z) {
    var O = nt(z), D = this.value, q = O.value, U, G, W;
    if (q === 0) return h[1];
    if (D === 0) return h[0];
    if (D === 1) return h[1];
    if (D === -1) return O.isEven() ? h[1] : h[-1];
    if (O.sign)
      return h[0];
    if (!O.isSmall) throw new Error("The exponent " + O.toString() + " is too large.");
    if (this.isSmall && f(U = Math.pow(D, q)))
      return new l(g(U));
    for (G = this, W = h[1]; q & !0 && (W = W.times(G), --q), q !== 0; )
      q /= 2, G = G.square();
    return W;
  }, l.prototype.pow = c.prototype.pow, u.prototype.pow = function(z) {
    var O = nt(z), D = this.value, q = O.value, U = BigInt(0), G = BigInt(1), W = BigInt(2);
    if (q === U) return h[1];
    if (D === U) return h[0];
    if (D === G) return h[1];
    if (D === BigInt(-1)) return O.isEven() ? h[1] : h[-1];
    if (O.isNegative()) return new u(U);
    for (var Y = this, Q = h[1]; (q & G) === G && (Q = Q.times(Y), --q), q !== U; )
      q /= W, Y = Y.square();
    return Q;
  }, c.prototype.modPow = function(z, O) {
    if (z = nt(z), O = nt(O), O.isZero()) throw new Error("Cannot take modPow with modulus 0");
    var D = h[1], q = this.mod(O);
    for (z.isNegative() && (z = z.multiply(h[-1]), q = q.modInv(O)); z.isPositive(); ) {
      if (q.isZero()) return h[0];
      z.isOdd() && (D = D.multiply(q).mod(O)), z = z.divide(2), q = q.square().mod(O);
    }
    return D;
  }, u.prototype.modPow = l.prototype.modPow = c.prototype.modPow;
  function B(z, O) {
    if (z.length !== O.length)
      return z.length > O.length ? 1 : -1;
    for (var D = z.length - 1; D >= 0; D--)
      if (z[D] !== O[D]) return z[D] > O[D] ? 1 : -1;
    return 0;
  }
  c.prototype.compareAbs = function(z) {
    var O = nt(z), D = this.value, q = O.value;
    return O.isSmall ? 1 : B(D, q);
  }, l.prototype.compareAbs = function(z) {
    var O = nt(z), D = Math.abs(this.value), q = O.value;
    return O.isSmall ? (q = Math.abs(q), D === q ? 0 : D > q ? 1 : -1) : -1;
  }, u.prototype.compareAbs = function(z) {
    var O = this.value, D = nt(z).value;
    return O = O >= 0 ? O : -O, D = D >= 0 ? D : -D, O === D ? 0 : O > D ? 1 : -1;
  }, c.prototype.compare = function(z) {
    if (z === 1 / 0)
      return -1;
    if (z === -1 / 0)
      return 1;
    var O = nt(z), D = this.value, q = O.value;
    return this.sign !== O.sign ? O.sign ? 1 : -1 : O.isSmall ? this.sign ? -1 : 1 : B(D, q) * (this.sign ? -1 : 1);
  }, c.prototype.compareTo = c.prototype.compare, l.prototype.compare = function(z) {
    if (z === 1 / 0)
      return -1;
    if (z === -1 / 0)
      return 1;
    var O = nt(z), D = this.value, q = O.value;
    return O.isSmall ? D == q ? 0 : D > q ? 1 : -1 : D < 0 !== O.sign ? D < 0 ? -1 : 1 : D < 0 ? 1 : -1;
  }, l.prototype.compareTo = l.prototype.compare, u.prototype.compare = function(z) {
    if (z === 1 / 0)
      return -1;
    if (z === -1 / 0)
      return 1;
    var O = this.value, D = nt(z).value;
    return O === D ? 0 : O > D ? 1 : -1;
  }, u.prototype.compareTo = u.prototype.compare, c.prototype.equals = function(z) {
    return this.compare(z) === 0;
  }, u.prototype.eq = u.prototype.equals = l.prototype.eq = l.prototype.equals = c.prototype.eq = c.prototype.equals, c.prototype.notEquals = function(z) {
    return this.compare(z) !== 0;
  }, u.prototype.neq = u.prototype.notEquals = l.prototype.neq = l.prototype.notEquals = c.prototype.neq = c.prototype.notEquals, c.prototype.greater = function(z) {
    return this.compare(z) > 0;
  }, u.prototype.gt = u.prototype.greater = l.prototype.gt = l.prototype.greater = c.prototype.gt = c.prototype.greater, c.prototype.lesser = function(z) {
    return this.compare(z) < 0;
  }, u.prototype.lt = u.prototype.lesser = l.prototype.lt = l.prototype.lesser = c.prototype.lt = c.prototype.lesser, c.prototype.greaterOrEquals = function(z) {
    return this.compare(z) >= 0;
  }, u.prototype.geq = u.prototype.greaterOrEquals = l.prototype.geq = l.prototype.greaterOrEquals = c.prototype.geq = c.prototype.greaterOrEquals, c.prototype.lesserOrEquals = function(z) {
    return this.compare(z) <= 0;
  }, u.prototype.leq = u.prototype.lesserOrEquals = l.prototype.leq = l.prototype.lesserOrEquals = c.prototype.leq = c.prototype.lesserOrEquals, c.prototype.isEven = function() {
    return (this.value[0] & 1) === 0;
  }, l.prototype.isEven = function() {
    return (this.value & 1) === 0;
  }, u.prototype.isEven = function() {
    return (this.value & BigInt(1)) === BigInt(0);
  }, c.prototype.isOdd = function() {
    return (this.value[0] & 1) === 1;
  }, l.prototype.isOdd = function() {
    return (this.value & 1) === 1;
  }, u.prototype.isOdd = function() {
    return (this.value & BigInt(1)) === BigInt(1);
  }, c.prototype.isPositive = function() {
    return !this.sign;
  }, l.prototype.isPositive = function() {
    return this.value > 0;
  }, u.prototype.isPositive = l.prototype.isPositive, c.prototype.isNegative = function() {
    return this.sign;
  }, l.prototype.isNegative = function() {
    return this.value < 0;
  }, u.prototype.isNegative = l.prototype.isNegative, c.prototype.isUnit = function() {
    return !1;
  }, l.prototype.isUnit = function() {
    return Math.abs(this.value) === 1;
  }, u.prototype.isUnit = function() {
    return this.abs().value === BigInt(1);
  }, c.prototype.isZero = function() {
    return !1;
  }, l.prototype.isZero = function() {
    return this.value === 0;
  }, u.prototype.isZero = function() {
    return this.value === BigInt(0);
  }, c.prototype.isDivisibleBy = function(z) {
    var O = nt(z);
    return O.isZero() ? !1 : O.isUnit() ? !0 : O.compareAbs(2) === 0 ? this.isEven() : this.mod(O).isZero();
  }, u.prototype.isDivisibleBy = l.prototype.isDivisibleBy = c.prototype.isDivisibleBy;
  function V(z) {
    var O = z.abs();
    if (O.isUnit()) return !1;
    if (O.equals(2) || O.equals(3) || O.equals(5)) return !0;
    if (O.isEven() || O.isDivisibleBy(3) || O.isDivisibleBy(5)) return !1;
    if (O.lesser(49)) return !0;
  }
  function J(z, O) {
    for (var D = z.prev(), q = D, U = 0, G, W, Y; q.isEven(); ) q = q.divide(2), U++;
    t: for (W = 0; W < O.length; W++)
      if (!z.lesser(O[W]) && (Y = ze(O[W]).modPow(q, z), !(Y.isUnit() || Y.equals(D)))) {
        for (G = U - 1; G != 0; G--) {
          if (Y = Y.square().mod(z), Y.isUnit()) return !1;
          if (Y.equals(D)) continue t;
        }
        return !1;
      }
    return !0;
  }
  c.prototype.isPrime = function(z) {
    var O = V(this);
    if (O !== i) return O;
    var D = this.abs(), q = D.bitLength();
    if (q <= 64)
      return J(D, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
    for (var U = Math.log(2) * q.toJSNumber(), G = Math.ceil(z === !0 ? 2 * Math.pow(U, 2) : U), W = [], Y = 0; Y < G; Y++)
      W.push(ze(Y + 2));
    return J(D, W);
  }, u.prototype.isPrime = l.prototype.isPrime = c.prototype.isPrime, c.prototype.isProbablePrime = function(z, O) {
    var D = V(this);
    if (D !== i) return D;
    for (var q = this.abs(), U = z === i ? 5 : z, G = [], W = 0; W < U; W++)
      G.push(ze.randBetween(2, q.minus(2), O));
    return J(q, G);
  }, u.prototype.isProbablePrime = l.prototype.isProbablePrime = c.prototype.isProbablePrime, c.prototype.modInv = function(z) {
    for (var O = ze.zero, D = ze.one, q = nt(z), U = this.abs(), G, W, Y; !U.isZero(); )
      G = q.divide(U), W = O, Y = q, O = D, q = U, D = W.subtract(G.multiply(D)), U = Y.subtract(G.multiply(U));
    if (!q.isUnit()) throw new Error(this.toString() + " and " + z.toString() + " are not co-prime");
    return O.compare(0) === -1 && (O = O.add(z)), this.isNegative() ? O.negate() : O;
  }, u.prototype.modInv = l.prototype.modInv = c.prototype.modInv, c.prototype.next = function() {
    var z = this.value;
    return this.sign ? E(z, 1, this.sign) : new c(w(z, 1), this.sign);
  }, l.prototype.next = function() {
    var z = this.value;
    return z + 1 < s ? new l(z + 1) : new c(r, !1);
  }, u.prototype.next = function() {
    return new u(this.value + BigInt(1));
  }, c.prototype.prev = function() {
    var z = this.value;
    return this.sign ? new c(w(z, 1), !0) : E(z, 1, this.sign);
  }, l.prototype.prev = function() {
    var z = this.value;
    return z - 1 > -s ? new l(z - 1) : new c(r, !0);
  }, u.prototype.prev = function() {
    return new u(this.value - BigInt(1));
  };
  for (var j = [1]; 2 * j[j.length - 1] <= e; ) j.push(2 * j[j.length - 1]);
  var ht = j.length, rt = j[ht - 1];
  function ft(z) {
    return Math.abs(z) <= e;
  }
  c.prototype.shiftLeft = function(z) {
    var O = nt(z).toJSNumber();
    if (!ft(O))
      throw new Error(String(O) + " is too large for shifting.");
    if (O < 0) return this.shiftRight(-O);
    var D = this;
    if (D.isZero()) return D;
    for (; O >= ht; )
      D = D.multiply(rt), O -= ht - 1;
    return D.multiply(j[O]);
  }, u.prototype.shiftLeft = l.prototype.shiftLeft = c.prototype.shiftLeft, c.prototype.shiftRight = function(z) {
    var O, D = nt(z).toJSNumber();
    if (!ft(D))
      throw new Error(String(D) + " is too large for shifting.");
    if (D < 0) return this.shiftLeft(-D);
    for (var q = this; D >= ht; ) {
      if (q.isZero() || q.isNegative() && q.isUnit()) return q;
      O = F(q, rt), q = O[1].isNegative() ? O[0].prev() : O[0], D -= ht - 1;
    }
    return O = F(q, j[D]), O[1].isNegative() ? O[0].prev() : O[0];
  }, u.prototype.shiftRight = l.prototype.shiftRight = c.prototype.shiftRight;
  function lt(z, O, D) {
    O = nt(O);
    for (var q = z.isNegative(), U = O.isNegative(), G = q ? z.not() : z, W = U ? O.not() : O, Y = 0, Q = 0, Mt = null, Lt = null, Ct = []; !G.isZero() || !W.isZero(); )
      Mt = F(G, rt), Y = Mt[1].toJSNumber(), q && (Y = rt - 1 - Y), Lt = F(W, rt), Q = Lt[1].toJSNumber(), U && (Q = rt - 1 - Q), G = Mt[0], W = Lt[0], Ct.push(D(Y, Q));
    for (var Yt = D(q ? 1 : 0, U ? 1 : 0) !== 0 ? ze(-1) : ze(0), yn = Ct.length - 1; yn >= 0; yn -= 1)
      Yt = Yt.multiply(rt).add(ze(Ct[yn]));
    return Yt;
  }
  c.prototype.not = function() {
    return this.negate().prev();
  }, u.prototype.not = l.prototype.not = c.prototype.not, c.prototype.and = function(z) {
    return lt(this, z, function(O, D) {
      return O & D;
    });
  }, u.prototype.and = l.prototype.and = c.prototype.and, c.prototype.or = function(z) {
    return lt(this, z, function(O, D) {
      return O | D;
    });
  }, u.prototype.or = l.prototype.or = c.prototype.or, c.prototype.xor = function(z) {
    return lt(this, z, function(O, D) {
      return O ^ D;
    });
  }, u.prototype.xor = l.prototype.xor = c.prototype.xor;
  var wt = 1 << 30, Ut = (e & -e) * (e & -e) | wt;
  function fe(z) {
    var O = z.value, D = typeof O == "number" ? O | wt : typeof O == "bigint" ? O | BigInt(wt) : O[0] + O[1] * e | Ut;
    return D & -D;
  }
  function ie(z, O) {
    if (O.compareTo(z) <= 0) {
      var D = ie(z, O.square(O)), q = D.p, U = D.e, G = q.multiply(O);
      return G.compareTo(z) <= 0 ? { p: G, e: U * 2 + 1 } : { p: q, e: U * 2 };
    }
    return { p: ze(1), e: 0 };
  }
  c.prototype.bitLength = function() {
    var z = this;
    return z.compareTo(ze(0)) < 0 && (z = z.negate().subtract(ze(1))), z.compareTo(ze(0)) === 0 ? ze(0) : ze(ie(z, ze(2)).e).add(ze(1));
  }, u.prototype.bitLength = l.prototype.bitLength = c.prototype.bitLength;
  function be(z, O) {
    return z = nt(z), O = nt(O), z.greater(O) ? z : O;
  }
  function de(z, O) {
    return z = nt(z), O = nt(O), z.lesser(O) ? z : O;
  }
  function Qt(z, O) {
    if (z = nt(z).abs(), O = nt(O).abs(), z.equals(O)) return z;
    if (z.isZero()) return O;
    if (O.isZero()) return z;
    for (var D = h[1], q, U; z.isEven() && O.isEven(); )
      q = de(fe(z), fe(O)), z = z.divide(q), O = O.divide(q), D = D.multiply(q);
    for (; z.isEven(); )
      z = z.divide(fe(z));
    do {
      for (; O.isEven(); )
        O = O.divide(fe(O));
      z.greater(O) && (U = O, O = z, z = U), O = O.subtract(z);
    } while (!O.isZero());
    return D.isUnit() ? z : z.multiply(D);
  }
  function Xt(z, O) {
    return z = nt(z).abs(), O = nt(O).abs(), z.divide(Qt(z, O)).multiply(O);
  }
  function H(z, O, D) {
    z = nt(z), O = nt(O);
    var q = D || Math.random, U = de(z, O), G = be(z, O), W = G.subtract(U).add(1);
    if (W.isSmall) return U.add(Math.floor(q() * W));
    for (var Y = at(W, e).value, Q = [], Mt = !0, Lt = 0; Lt < Y.length; Lt++) {
      var Ct = Mt ? Y[Lt] + (Lt + 1 < Y.length ? Y[Lt + 1] / e : 0) : e, Yt = g(q() * Ct);
      Q.push(Yt), Yt < Y[Lt] && (Mt = !1);
    }
    return U.add(h.fromArray(Q, e, !1));
  }
  var Z = function(z, O, D, q) {
    D = D || a, z = String(z), q || (z = z.toLowerCase(), D = D.toLowerCase());
    var U = z.length, G, W = Math.abs(O), Y = {};
    for (G = 0; G < D.length; G++)
      Y[D[G]] = G;
    for (G = 0; G < U; G++) {
      var Q = z[G];
      if (Q !== "-" && Q in Y && Y[Q] >= W) {
        if (Q === "1" && W === 1) continue;
        throw new Error(Q + " is not a valid digit in base " + O + ".");
      }
    }
    O = nt(O);
    var Mt = [], Lt = z[0] === "-";
    for (G = Lt ? 1 : 0; G < z.length; G++) {
      var Q = z[G];
      if (Q in Y) Mt.push(nt(Y[Q]));
      else if (Q === "<") {
        var Ct = G;
        do
          G++;
        while (z[G] !== ">" && G < z.length);
        Mt.push(nt(z.slice(Ct + 1, G)));
      } else throw new Error(Q + " is not a valid character");
    }
    return et(Mt, O, Lt);
  };
  function et(z, O, D) {
    var q = h[0], U = h[1], G;
    for (G = z.length - 1; G >= 0; G--)
      q = q.add(z[G].times(U)), U = U.times(O);
    return D ? q.negate() : q;
  }
  function ut(z, O) {
    return O = O || a, z < O.length ? O[z] : "<" + z + ">";
  }
  function at(z, O) {
    if (O = ze(O), O.isZero()) {
      if (z.isZero()) return { value: [0], isNegative: !1 };
      throw new Error("Cannot convert nonzero numbers to base 0.");
    }
    if (O.equals(-1)) {
      if (z.isZero()) return { value: [0], isNegative: !1 };
      if (z.isNegative())
        return {
          value: [].concat.apply(
            [],
            Array.apply(null, Array(-z.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
          ),
          isNegative: !1
        };
      var D = Array.apply(null, Array(z.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
      return D.unshift([1]), {
        value: [].concat.apply([], D),
        isNegative: !1
      };
    }
    var q = !1;
    if (z.isNegative() && O.isPositive() && (q = !0, z = z.abs()), O.isUnit())
      return z.isZero() ? { value: [0], isNegative: !1 } : {
        value: Array.apply(null, Array(z.toJSNumber())).map(Number.prototype.valueOf, 1),
        isNegative: q
      };
    for (var U = [], G = z, W; G.isNegative() || G.compareAbs(O) >= 0; ) {
      W = G.divmod(O), G = W.quotient;
      var Y = W.remainder;
      Y.isNegative() && (Y = O.minus(Y).abs(), G = G.next()), U.push(Y.toJSNumber());
    }
    return U.push(G.toJSNumber()), { value: U.reverse(), isNegative: q };
  }
  function Ot(z, O, D) {
    var q = at(z, O);
    return (q.isNegative ? "-" : "") + q.value.map(function(U) {
      return ut(U, D);
    }).join("");
  }
  c.prototype.toArray = function(z) {
    return at(this, z);
  }, l.prototype.toArray = function(z) {
    return at(this, z);
  }, u.prototype.toArray = function(z) {
    return at(this, z);
  }, c.prototype.toString = function(z, O) {
    if (z === i && (z = 10), z !== 10 || O) return Ot(this, z, O);
    for (var D = this.value, q = D.length, U = String(D[--q]), G = "0000000", W; --q >= 0; )
      W = String(D[q]), U += G.slice(W.length) + W;
    var Y = this.sign ? "-" : "";
    return Y + U;
  }, l.prototype.toString = function(z, O) {
    return z === i && (z = 10), z != 10 || O ? Ot(this, z, O) : String(this.value);
  }, u.prototype.toString = l.prototype.toString, u.prototype.toJSON = c.prototype.toJSON = l.prototype.toJSON = function() {
    return this.toString();
  }, c.prototype.valueOf = function() {
    return parseInt(this.toString(), 10);
  }, c.prototype.toJSNumber = c.prototype.valueOf, l.prototype.valueOf = function() {
    return this.value;
  }, l.prototype.toJSNumber = l.prototype.valueOf, u.prototype.valueOf = u.prototype.toJSNumber = function() {
    return parseInt(this.toString(), 10);
  };
  function bt(z) {
    if (f(+z)) {
      var O = +z;
      if (O === g(O))
        return o ? new u(BigInt(O)) : new l(O);
      throw new Error("Invalid integer: " + z);
    }
    var D = z[0] === "-";
    D && (z = z.slice(1));
    var q = z.split(/e/i);
    if (q.length > 2) throw new Error("Invalid integer: " + q.join("e"));
    if (q.length === 2) {
      var U = q[1];
      if (U[0] === "+" && (U = U.slice(1)), U = +U, U !== g(U) || !f(U)) throw new Error("Invalid integer: " + U + " is not a valid exponent.");
      var G = q[0], W = G.indexOf(".");
      if (W >= 0 && (U -= G.length - W - 1, G = G.slice(0, W) + G.slice(W + 1)), U < 0) throw new Error("Cannot include negative exponent part for integers");
      G += new Array(U + 1).join("0"), z = G;
    }
    var Y = /^([0-9][0-9]*)$/.test(z);
    if (!Y) throw new Error("Invalid integer: " + z);
    if (o)
      return new u(BigInt(D ? "-" + z : z));
    for (var Q = [], Mt = z.length, Lt = n, Ct = Mt - Lt; Mt > 0; )
      Q.push(+z.slice(Ct, Mt)), Ct -= Lt, Ct < 0 && (Ct = 0), Mt -= Lt;
    return y(Q), new c(Q, D);
  }
  function Wt(z) {
    if (o)
      return new u(BigInt(z));
    if (f(z)) {
      if (z !== g(z)) throw new Error(z + " is not an integer.");
      return new l(z);
    }
    return bt(z.toString());
  }
  function nt(z) {
    return typeof z == "number" ? Wt(z) : typeof z == "string" ? bt(z) : typeof z == "bigint" ? new u(z) : z;
  }
  for (var Kt = 0; Kt < 1e3; Kt++)
    h[Kt] = nt(Kt), Kt > 0 && (h[-Kt] = nt(-Kt));
  return h.one = h[1], h.zero = h[0], h.minusOne = h[-1], h.max = be, h.min = de, h.gcd = Qt, h.lcm = Xt, h.isInstance = function(z) {
    return z instanceof c || z instanceof l || z instanceof u;
  }, h.randBetween = H, h.fromArray = function(z, O, D) {
    return et(z.map(nt), nt(O || 10), D);
  }, h;
}();
function kP(i, e, n = 2) {
  const s = e && e.length, r = s ? e[0] * n : i.length;
  let a = iw(i, 0, r, n, !0);
  const o = [];
  if (!a || a.next === a.prev) return o;
  let h, c, l;
  if (s && (a = DP(i, e, a, n)), i.length > 80 * n) {
    h = 1 / 0, c = 1 / 0;
    let u = -1 / 0, f = -1 / 0;
    for (let d = n; d < r; d += n) {
      const p = i[d], y = i[d + 1];
      p < h && (h = p), y < c && (c = y), p > u && (u = p), y > f && (f = y);
    }
    l = Math.max(u - h, f - c), l = l !== 0 ? 32767 / l : 0;
  }
  return th(a, o, n, h, c, l, 0), o;
}
function iw(i, e, n, s, r) {
  let a;
  if (r === C0(i, e, n, s) > 0)
    for (let o = e; o < n; o += s) a = Bx(o / s | 0, i[o], i[o + 1], a);
  else
    for (let o = n - s; o >= e; o -= s) a = Bx(o / s | 0, i[o], i[o + 1], a);
  return a && ka(a, a.next) && (nh(a), a = a.next), a;
}
function br(i, e) {
  if (!i) return i;
  e || (e = i);
  let n = i, s;
  do
    if (s = !1, !n.steiner && (ka(n, n.next) || he(n.prev, n, n.next) === 0)) {
      if (nh(n), n = e = n.prev, n === n.next) break;
      s = !0;
    } else
      n = n.next;
  while (s || n !== e);
  return e;
}
function th(i, e, n, s, r, a, o) {
  if (!i) return;
  !o && a && UP(i, s, r, a);
  let h = i;
  for (; i.prev !== i.next; ) {
    const c = i.prev, l = i.next;
    if (a ? FP(i, s, r, a) : LP(i)) {
      e.push(c.i, i.i, l.i), nh(i), i = l.next, h = l.next;
      continue;
    }
    if (i = l, i === h) {
      o ? o === 1 ? (i = NP(br(i), e), th(i, e, n, s, r, a, 2)) : o === 2 && BP(i, e, n, s, r, a) : th(br(i), e, n, s, r, a, 1);
      break;
    }
  }
}
function LP(i) {
  const e = i.prev, n = i, s = i.next;
  if (he(e, n, s) >= 0) return !1;
  const r = e.x, a = n.x, o = s.x, h = e.y, c = n.y, l = s.y, u = Math.min(r, a, o), f = Math.min(h, c, l), d = Math.max(r, a, o), p = Math.max(h, c, l);
  let y = s.next;
  for (; y !== e; ) {
    if (y.x >= u && y.x <= d && y.y >= f && y.y <= p && xo(r, h, a, c, o, l, y.x, y.y) && he(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function FP(i, e, n, s) {
  const r = i.prev, a = i, o = i.next;
  if (he(r, a, o) >= 0) return !1;
  const h = r.x, c = a.x, l = o.x, u = r.y, f = a.y, d = o.y, p = Math.min(h, c, l), y = Math.min(u, f, d), x = Math.max(h, c, l), g = Math.max(u, f, d), m = E0(p, y, e, n, s), v = E0(x, g, e, n, s);
  let w = i.prevZ, b = i.nextZ;
  for (; w && w.z >= m && b && b.z <= v; ) {
    if (w.x >= p && w.x <= x && w.y >= y && w.y <= g && w !== r && w !== o && xo(h, u, c, f, l, d, w.x, w.y) && he(w.prev, w, w.next) >= 0 || (w = w.prevZ, b.x >= p && b.x <= x && b.y >= y && b.y <= g && b !== r && b !== o && xo(h, u, c, f, l, d, b.x, b.y) && he(b.prev, b, b.next) >= 0)) return !1;
    b = b.nextZ;
  }
  for (; w && w.z >= m; ) {
    if (w.x >= p && w.x <= x && w.y >= y && w.y <= g && w !== r && w !== o && xo(h, u, c, f, l, d, w.x, w.y) && he(w.prev, w, w.next) >= 0) return !1;
    w = w.prevZ;
  }
  for (; b && b.z <= v; ) {
    if (b.x >= p && b.x <= x && b.y >= y && b.y <= g && b !== r && b !== o && xo(h, u, c, f, l, d, b.x, b.y) && he(b.prev, b, b.next) >= 0) return !1;
    b = b.nextZ;
  }
  return !0;
}
function NP(i, e) {
  let n = i;
  do {
    const s = n.prev, r = n.next.next;
    !ka(s, r) && rw(s, n, n.next, r) && eh(s, r) && eh(r, s) && (e.push(s.i, n.i, r.i), nh(n), nh(n.next), n = i = r), n = n.next;
  } while (n !== i);
  return br(n);
}
function BP(i, e, n, s, r, a) {
  let o = i;
  do {
    let h = o.next.next;
    for (; h !== o.prev; ) {
      if (o.i !== h.i && jP(o, h)) {
        let c = aw(o, h);
        o = br(o, o.next), c = br(c, c.next), th(o, e, n, s, r, a, 0), th(c, e, n, s, r, a, 0);
        return;
      }
      h = h.next;
    }
    o = o.next;
  } while (o !== i);
}
function DP(i, e, n, s) {
  const r = [];
  for (let a = 0, o = e.length; a < o; a++) {
    const h = e[a] * s, c = a < o - 1 ? e[a + 1] * s : i.length, l = iw(i, h, c, s, !1);
    l === l.next && (l.steiner = !0), r.push(YP(l));
  }
  r.sort(qP);
  for (let a = 0; a < r.length; a++)
    n = $P(r[a], n);
  return n;
}
function qP(i, e) {
  let n = i.x - e.x;
  if (n === 0 && (n = i.y - e.y, n === 0)) {
    const s = (i.next.y - i.y) / (i.next.x - i.x), r = (e.next.y - e.y) / (e.next.x - e.x);
    n = s - r;
  }
  return n;
}
function $P(i, e) {
  const n = VP(i, e);
  if (!n)
    return e;
  const s = aw(n, i);
  return br(s, s.next), br(n, n.next);
}
function VP(i, e) {
  let n = e;
  const s = i.x, r = i.y;
  let a = -1 / 0, o;
  if (ka(i, n)) return n;
  do {
    if (ka(i, n.next)) return n.next;
    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
      const f = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (f <= s && f > a && (a = f, o = n.x < n.next.x ? n : n.next, f === s))
        return o;
    }
    n = n.next;
  } while (n !== e);
  if (!o) return null;
  const h = o, c = o.x, l = o.y;
  let u = 1 / 0;
  n = o;
  do {
    if (s >= n.x && n.x >= c && s !== n.x && sw(r < l ? s : a, r, c, l, r < l ? a : s, r, n.x, n.y)) {
      const f = Math.abs(r - n.y) / (s - n.x);
      eh(n, i) && (f < u || f === u && (n.x > o.x || n.x === o.x && GP(o, n))) && (o = n, u = f);
    }
    n = n.next;
  } while (n !== h);
  return o;
}
function GP(i, e) {
  return he(i.prev, i, e.prev) < 0 && he(e.next, i, i.next) < 0;
}
function UP(i, e, n, s) {
  let r = i;
  do
    r.z === 0 && (r.z = E0(r.x, r.y, e, n, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, WP(r);
}
function WP(i) {
  let e, n = 1;
  do {
    let s = i, r;
    i = null;
    let a = null;
    for (e = 0; s; ) {
      e++;
      let o = s, h = 0;
      for (let l = 0; l < n && (h++, o = o.nextZ, !!o); l++)
        ;
      let c = n;
      for (; h > 0 || c > 0 && o; )
        h !== 0 && (c === 0 || !o || s.z <= o.z) ? (r = s, s = s.nextZ, h--) : (r = o, o = o.nextZ, c--), a ? a.nextZ = r : i = r, r.prevZ = a, a = r;
      s = o;
    }
    a.nextZ = null, n *= 2;
  } while (e > 1);
  return i;
}
function E0(i, e, n, s, r) {
  return i = (i - n) * r | 0, e = (e - s) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function YP(i) {
  let e = i, n = i;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== i);
  return n;
}
function sw(i, e, n, s, r, a, o, h) {
  return (r - o) * (e - h) >= (i - o) * (a - h) && (i - o) * (s - h) >= (n - o) * (e - h) && (n - o) * (a - h) >= (r - o) * (s - h);
}
function xo(i, e, n, s, r, a, o, h) {
  return !(i === o && e === h) && sw(i, e, n, s, r, a, o, h);
}
function jP(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !HP(i, e) && // doesn't intersect other edges
  (eh(i, e) && eh(e, i) && XP(i, e) && // locally visible
  (he(i.prev, i, e.prev) || he(i, e.prev, e)) || // does not create opposite-facing sectors
  ka(i, e) && he(i.prev, i, i.next) > 0 && he(e.prev, e, e.next) > 0);
}
function he(i, e, n) {
  return (e.y - i.y) * (n.x - e.x) - (e.x - i.x) * (n.y - e.y);
}
function ka(i, e) {
  return i.x === e.x && i.y === e.y;
}
function rw(i, e, n, s) {
  const r = uc(he(i, e, n)), a = uc(he(i, e, s)), o = uc(he(n, s, i)), h = uc(he(n, s, e));
  return !!(r !== a && o !== h || r === 0 && lc(i, n, e) || a === 0 && lc(i, s, e) || o === 0 && lc(n, i, s) || h === 0 && lc(n, e, s));
}
function lc(i, e, n) {
  return e.x <= Math.max(i.x, n.x) && e.x >= Math.min(i.x, n.x) && e.y <= Math.max(i.y, n.y) && e.y >= Math.min(i.y, n.y);
}
function uc(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function HP(i, e) {
  let n = i;
  do {
    if (n.i !== i.i && n.next.i !== i.i && n.i !== e.i && n.next.i !== e.i && rw(n, n.next, i, e)) return !0;
    n = n.next;
  } while (n !== i);
  return !1;
}
function eh(i, e) {
  return he(i.prev, i, i.next) < 0 ? he(i, e, i.next) >= 0 && he(i, i.prev, e) >= 0 : he(i, e, i.prev) < 0 || he(i, i.next, e) < 0;
}
function XP(i, e) {
  let n = i, s = !1;
  const r = (i.x + e.x) / 2, a = (i.y + e.y) / 2;
  do
    n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;
  while (n !== i);
  return s;
}
function aw(i, e) {
  const n = z0(i.i, i.x, i.y), s = z0(e.i, e.x, e.y), r = i.next, a = e.prev;
  return i.next = e, e.prev = i, n.next = r, r.prev = n, s.next = n, n.prev = s, a.next = s, s.prev = a, s;
}
function Bx(i, e, n, s) {
  const r = z0(i, e, n);
  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;
}
function nh(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function z0(i, e, n) {
  return {
    i,
    // vertex index in coordinates array
    x: e,
    y: n,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function ZP(i, e, n, s) {
  const r = e && e.length, a = r ? e[0] * n : i.length;
  let o = Math.abs(C0(i, 0, a, n));
  if (r)
    for (let c = 0, l = e.length; c < l; c++) {
      const u = e[c] * n, f = c < l - 1 ? e[c + 1] * n : i.length;
      o -= Math.abs(C0(i, u, f, n));
    }
  let h = 0;
  for (let c = 0; c < s.length; c += 3) {
    const l = s[c] * n, u = s[c + 1] * n, f = s[c + 2] * n;
    h += Math.abs(
      (i[l] - i[f]) * (i[u + 1] - i[l + 1]) - (i[l] - i[u]) * (i[f + 1] - i[l + 1])
    );
  }
  return o === 0 && h === 0 ? 0 : Math.abs((h - o) / o);
}
function C0(i, e, n, s) {
  let r = 0;
  for (let a = e, o = n - s; a < n; a += s)
    r += (i[o] - i[a]) * (i[a + 1] + i[o + 1]), o = a;
  return r;
}
function JP(i) {
  const e = [], n = [], s = i[0][0].length;
  let r = 0, a = 0;
  for (const o of i) {
    for (const h of o)
      for (let c = 0; c < s; c++) e.push(h[c]);
    a && (r += a, n.push(r)), a = o.length;
  }
  return { vertices: e, holes: n, dimensions: s };
}
const Ui = 11102230246251565e-32, Be = 134217729, QP = (3 + 8 * Ui) * Ui;
function sf(i, e, n, s, r) {
  let a, o, h, c, l = e[0], u = s[0], f = 0, d = 0;
  u > l == u > -l ? (a = l, l = e[++f]) : (a = u, u = s[++d]);
  let p = 0;
  if (f < i && d < n)
    for (u > l == u > -l ? (o = l + a, h = a - (o - l), l = e[++f]) : (o = u + a, h = a - (o - u), u = s[++d]), a = o, h !== 0 && (r[p++] = h); f < i && d < n; )
      u > l == u > -l ? (o = a + l, c = o - a, h = a - (o - c) + (l - c), l = e[++f]) : (o = a + u, c = o - a, h = a - (o - c) + (u - c), u = s[++d]), a = o, h !== 0 && (r[p++] = h);
  for (; f < i; )
    o = a + l, c = o - a, h = a - (o - c) + (l - c), l = e[++f], a = o, h !== 0 && (r[p++] = h);
  for (; d < n; )
    o = a + u, c = o - a, h = a - (o - c) + (u - c), u = s[++d], a = o, h !== 0 && (r[p++] = h);
  return (a !== 0 || p === 0) && (r[p++] = a), p;
}
function KP(i, e) {
  let n = e[0];
  for (let s = 1; s < i; s++) n += e[s];
  return n;
}
function Ph(i) {
  return new Float64Array(i);
}
const t4 = (3 + 16 * Ui) * Ui, e4 = (2 + 12 * Ui) * Ui, n4 = (9 + 64 * Ui) * Ui * Ui, Br = Ph(4), Dx = Ph(8), qx = Ph(12), $x = Ph(16), We = Ph(4);
function i4(i, e, n, s, r, a, o) {
  let h, c, l, u, f, d, p, y, x, g, m, v, w, b, S, E, A, M;
  const _ = i - r, T = n - r, C = e - a, P = s - a;
  b = _ * P, d = Be * _, p = d - (d - _), y = _ - p, d = Be * P, x = d - (d - P), g = P - x, S = y * g - (b - p * x - y * x - p * g), E = C * T, d = Be * C, p = d - (d - C), y = C - p, d = Be * T, x = d - (d - T), g = T - x, A = y * g - (E - p * x - y * x - p * g), m = S - A, f = S - m, Br[0] = S - (m + f) + (f - A), v = b + m, f = v - b, w = b - (v - f) + (m - f), m = w - E, f = w - m, Br[1] = w - (m + f) + (f - E), M = v + m, f = M - v, Br[2] = v - (M - f) + (m - f), Br[3] = M;
  let R = KP(4, Br), k = e4 * o;
  if (R >= k || -R >= k || (f = i - _, h = i - (_ + f) + (f - r), f = n - T, l = n - (T + f) + (f - r), f = e - C, c = e - (C + f) + (f - a), f = s - P, u = s - (P + f) + (f - a), h === 0 && c === 0 && l === 0 && u === 0) || (k = n4 * o + QP * Math.abs(R), R += _ * u + P * h - (C * l + T * c), R >= k || -R >= k)) return R;
  b = h * P, d = Be * h, p = d - (d - h), y = h - p, d = Be * P, x = d - (d - P), g = P - x, S = y * g - (b - p * x - y * x - p * g), E = c * T, d = Be * c, p = d - (d - c), y = c - p, d = Be * T, x = d - (d - T), g = T - x, A = y * g - (E - p * x - y * x - p * g), m = S - A, f = S - m, We[0] = S - (m + f) + (f - A), v = b + m, f = v - b, w = b - (v - f) + (m - f), m = w - E, f = w - m, We[1] = w - (m + f) + (f - E), M = v + m, f = M - v, We[2] = v - (M - f) + (m - f), We[3] = M;
  const I = sf(4, Br, 4, We, Dx);
  b = _ * u, d = Be * _, p = d - (d - _), y = _ - p, d = Be * u, x = d - (d - u), g = u - x, S = y * g - (b - p * x - y * x - p * g), E = C * l, d = Be * C, p = d - (d - C), y = C - p, d = Be * l, x = d - (d - l), g = l - x, A = y * g - (E - p * x - y * x - p * g), m = S - A, f = S - m, We[0] = S - (m + f) + (f - A), v = b + m, f = v - b, w = b - (v - f) + (m - f), m = w - E, f = w - m, We[1] = w - (m + f) + (f - E), M = v + m, f = M - v, We[2] = v - (M - f) + (m - f), We[3] = M;
  const L = sf(I, Dx, 4, We, qx);
  b = h * u, d = Be * h, p = d - (d - h), y = h - p, d = Be * u, x = d - (d - u), g = u - x, S = y * g - (b - p * x - y * x - p * g), E = c * l, d = Be * c, p = d - (d - c), y = c - p, d = Be * l, x = d - (d - l), g = l - x, A = y * g - (E - p * x - y * x - p * g), m = S - A, f = S - m, We[0] = S - (m + f) + (f - A), v = b + m, f = v - b, w = b - (v - f) + (m - f), m = w - E, f = w - m, We[1] = w - (m + f) + (f - E), M = v + m, f = M - v, We[2] = v - (M - f) + (m - f), We[3] = M;
  const F = sf(L, qx, 4, We, $x);
  return $x[F - 1];
}
function fc(i, e, n, s, r, a) {
  const o = (e - a) * (n - r), h = (i - r) * (s - a), c = o - h, l = Math.abs(o + h);
  return Math.abs(c) >= t4 * l ? c : -i4(i, e, n, s, r, a, l);
}
const Vx = Math.pow(2, -52), dc = new Uint32Array(512);
class jd {
  static from(e, n = h4, s = c4) {
    const r = e.length, a = new Float64Array(r * 2);
    for (let o = 0; o < r; o++) {
      const h = e[o];
      a[2 * o] = n(h), a[2 * o + 1] = s(h);
    }
    return new jd(a);
  }
  constructor(e) {
    const n = e.length >> 1;
    if (n > 0 && typeof e[0] != "number") throw new Error("Expected coords to contain numbers.");
    this.coords = e;
    const s = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(s * 3), this._halfedges = new Int32Array(s * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
  }
  update() {
    const { coords: e, _hullPrev: n, _hullNext: s, _hullTri: r, _hullHash: a } = this, o = e.length >> 1;
    let h = 1 / 0, c = 1 / 0, l = -1 / 0, u = -1 / 0;
    for (let _ = 0; _ < o; _++) {
      const T = e[2 * _], C = e[2 * _ + 1];
      T < h && (h = T), C < c && (c = C), T > l && (l = T), C > u && (u = C), this._ids[_] = _;
    }
    const f = (h + l) / 2, d = (c + u) / 2;
    let p, y, x;
    for (let _ = 0, T = 1 / 0; _ < o; _++) {
      const C = rf(f, d, e[2 * _], e[2 * _ + 1]);
      C < T && (p = _, T = C);
    }
    const g = e[2 * p], m = e[2 * p + 1];
    for (let _ = 0, T = 1 / 0; _ < o; _++) {
      if (_ === p) continue;
      const C = rf(g, m, e[2 * _], e[2 * _ + 1]);
      C < T && C > 0 && (y = _, T = C);
    }
    let v = e[2 * y], w = e[2 * y + 1], b = 1 / 0;
    for (let _ = 0; _ < o; _++) {
      if (_ === p || _ === y) continue;
      const T = a4(g, m, v, w, e[2 * _], e[2 * _ + 1]);
      T < b && (x = _, b = T);
    }
    let S = e[2 * x], E = e[2 * x + 1];
    if (b === 1 / 0) {
      for (let C = 0; C < o; C++)
        this._dists[C] = e[2 * C] - e[0] || e[2 * C + 1] - e[1];
      ya(this._ids, this._dists, 0, o - 1);
      const _ = new Uint32Array(o);
      let T = 0;
      for (let C = 0, P = -1 / 0; C < o; C++) {
        const R = this._ids[C], k = this._dists[R];
        k > P && (_[T++] = R, P = k);
      }
      this.hull = _.subarray(0, T), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (fc(g, m, v, w, S, E) < 0) {
      const _ = y, T = v, C = w;
      y = x, v = S, w = E, x = _, S = T, E = C;
    }
    const A = o4(g, m, v, w, S, E);
    this._cx = A.x, this._cy = A.y;
    for (let _ = 0; _ < o; _++)
      this._dists[_] = rf(e[2 * _], e[2 * _ + 1], A.x, A.y);
    ya(this._ids, this._dists, 0, o - 1), this._hullStart = p;
    let M = 3;
    s[p] = n[x] = y, s[y] = n[p] = x, s[x] = n[y] = p, r[p] = 0, r[y] = 1, r[x] = 2, a.fill(-1), a[this._hashKey(g, m)] = p, a[this._hashKey(v, w)] = y, a[this._hashKey(S, E)] = x, this.trianglesLen = 0, this._addTriangle(p, y, x, -1, -1, -1);
    for (let _ = 0, T, C; _ < this._ids.length; _++) {
      const P = this._ids[_], R = e[2 * P], k = e[2 * P + 1];
      if (_ > 0 && Math.abs(R - T) <= Vx && Math.abs(k - C) <= Vx || (T = R, C = k, P === p || P === y || P === x)) continue;
      let I = 0;
      for (let J = 0, j = this._hashKey(R, k); J < this._hashSize && (I = a[(j + J) % this._hashSize], !(I !== -1 && I !== s[I])); J++)
        ;
      I = n[I];
      let L = I, F;
      for (; F = s[L], fc(R, k, e[2 * L], e[2 * L + 1], e[2 * F], e[2 * F + 1]) >= 0; )
        if (L = F, L === I) {
          L = -1;
          break;
        }
      if (L === -1) continue;
      let B = this._addTriangle(L, P, s[L], -1, -1, r[L]);
      r[P] = this._legalize(B + 2), r[L] = B, M++;
      let V = s[L];
      for (; F = s[V], fc(R, k, e[2 * V], e[2 * V + 1], e[2 * F], e[2 * F + 1]) < 0; )
        B = this._addTriangle(V, P, F, r[P], -1, r[V]), r[P] = this._legalize(B + 2), s[V] = V, M--, V = F;
      if (L === I)
        for (; F = n[L], fc(R, k, e[2 * F], e[2 * F + 1], e[2 * L], e[2 * L + 1]) < 0; )
          B = this._addTriangle(F, P, L, -1, r[L], r[F]), this._legalize(B + 2), r[F] = B, s[L] = L, M--, L = F;
      this._hullStart = n[P] = L, s[L] = n[V] = P, s[P] = V, a[this._hashKey(R, k)] = P, a[this._hashKey(e[2 * L], e[2 * L + 1])] = L;
    }
    this.hull = new Uint32Array(M);
    for (let _ = 0, T = this._hullStart; _ < M; _++)
      this.hull[_] = T, T = s[T];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(e, n) {
    return Math.floor(s4(e - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(e) {
    const { _triangles: n, _halfedges: s, coords: r } = this;
    let a = 0, o = 0;
    for (; ; ) {
      const h = s[e], c = e - e % 3;
      if (o = c + (e + 2) % 3, h === -1) {
        if (a === 0) break;
        e = dc[--a];
        continue;
      }
      const l = h - h % 3, u = c + (e + 1) % 3, f = l + (h + 2) % 3, d = n[o], p = n[e], y = n[u], x = n[f];
      if (r4(
        r[2 * d],
        r[2 * d + 1],
        r[2 * p],
        r[2 * p + 1],
        r[2 * y],
        r[2 * y + 1],
        r[2 * x],
        r[2 * x + 1]
      )) {
        n[e] = x, n[h] = d;
        const m = s[f];
        if (m === -1) {
          let w = this._hullStart;
          do {
            if (this._hullTri[w] === f) {
              this._hullTri[w] = e;
              break;
            }
            w = this._hullPrev[w];
          } while (w !== this._hullStart);
        }
        this._link(e, m), this._link(h, s[o]), this._link(o, f);
        const v = l + (h + 1) % 3;
        a < dc.length && (dc[a++] = v);
      } else {
        if (a === 0) break;
        e = dc[--a];
      }
    }
    return o;
  }
  _link(e, n) {
    this._halfedges[e] = n, n !== -1 && (this._halfedges[n] = e);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(e, n, s, r, a, o) {
    const h = this.trianglesLen;
    return this._triangles[h] = e, this._triangles[h + 1] = n, this._triangles[h + 2] = s, this._link(h, r), this._link(h + 1, a), this._link(h + 2, o), this.trianglesLen += 3, h;
  }
}
function s4(i, e) {
  const n = i / (Math.abs(i) + Math.abs(e));
  return (e > 0 ? 3 - n : 1 + n) / 4;
}
function rf(i, e, n, s) {
  const r = i - n, a = e - s;
  return r * r + a * a;
}
function r4(i, e, n, s, r, a, o, h) {
  const c = i - o, l = e - h, u = n - o, f = s - h, d = r - o, p = a - h, y = c * c + l * l, x = u * u + f * f, g = d * d + p * p;
  return c * (f * g - x * p) - l * (u * g - x * d) + y * (u * p - f * d) < 0;
}
function a4(i, e, n, s, r, a) {
  const o = n - i, h = s - e, c = r - i, l = a - e, u = o * o + h * h, f = c * c + l * l, d = 0.5 / (o * l - h * c), p = (l * u - h * f) * d, y = (o * f - c * u) * d;
  return p * p + y * y;
}
function o4(i, e, n, s, r, a) {
  const o = n - i, h = s - e, c = r - i, l = a - e, u = o * o + h * h, f = c * c + l * l, d = 0.5 / (o * l - h * c), p = i + (l * u - h * f) * d, y = e + (o * f - c * u) * d;
  return { x: p, y };
}
function ya(i, e, n, s) {
  if (s - n <= 20)
    for (let r = n + 1; r <= s; r++) {
      const a = i[r], o = e[a];
      let h = r - 1;
      for (; h >= n && e[i[h]] > o; ) i[h + 1] = i[h--];
      i[h + 1] = a;
    }
  else {
    const r = n + s >> 1;
    let a = n + 1, o = s;
    Ka(i, r, a), e[i[n]] > e[i[s]] && Ka(i, n, s), e[i[a]] > e[i[s]] && Ka(i, a, s), e[i[n]] > e[i[a]] && Ka(i, n, a);
    const h = i[a], c = e[h];
    for (; ; ) {
      do
        a++;
      while (e[i[a]] < c);
      do
        o--;
      while (e[i[o]] > c);
      if (o < a) break;
      Ka(i, a, o);
    }
    i[n + 1] = i[o], i[o] = h, s - a + 1 >= o - n ? (ya(i, e, a, s), ya(i, e, n, o - 1)) : (ya(i, e, n, o - 1), ya(i, e, a, s));
  }
}
function Ka(i, e, n) {
  const s = i[e];
  i[e] = i[n], i[n] = s;
}
function h4(i) {
  return i[0];
}
function c4(i) {
  return i[1];
}
const No = 1e20;
class l4 {
  constructor({
    fontSize: e = 24,
    buffer: n = 3,
    radius: s = 8,
    cutoff: r = 0.25,
    fontFamily: a = "sans-serif",
    fontWeight: o = "normal",
    fontStyle: h = "normal"
  } = {}) {
    this.buffer = n, this.cutoff = r, this.radius = s;
    const c = this.size = e + n * 4, l = this._createCanvas(c), u = this.ctx = l.getContext("2d", { willReadFrequently: !0 });
    u.font = `${h} ${o} ${e}px ${a}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(c * c), this.gridInner = new Float64Array(c * c), this.f = new Float64Array(c), this.z = new Float64Array(c + 1), this.v = new Uint16Array(c);
  }
  _createCanvas(e) {
    const n = document.createElement("canvas");
    return n.width = n.height = e, n;
  }
  draw(e) {
    const {
      width: n,
      actualBoundingBoxAscent: s,
      actualBoundingBoxDescent: r,
      actualBoundingBoxLeft: a,
      actualBoundingBoxRight: o
    } = this.ctx.measureText(e), h = Math.ceil(s), c = 0, l = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - a))), u = Math.min(this.size - this.buffer, h + Math.ceil(r)), f = l + 2 * this.buffer, d = u + 2 * this.buffer, p = Math.max(f * d, 0), y = new Uint8ClampedArray(p), x = { data: y, width: f, height: d, glyphWidth: l, glyphHeight: u, glyphTop: h, glyphLeft: c, glyphAdvance: n };
    if (l === 0 || u === 0) return x;
    const { ctx: g, buffer: m, gridInner: v, gridOuter: w } = this;
    g.clearRect(m, m, l, u), g.fillText(e, m, m + h);
    const b = g.getImageData(m, m, l, u);
    w.fill(No, 0, p), v.fill(0, 0, p);
    for (let S = 0; S < u; S++)
      for (let E = 0; E < l; E++) {
        const A = b.data[4 * (S * l + E) + 3] / 255;
        if (A === 0) continue;
        const M = (S + m) * f + E + m;
        if (A === 1)
          w[M] = 0, v[M] = No;
        else {
          const _ = 0.5 - A;
          w[M] = _ > 0 ? _ * _ : 0, v[M] = _ < 0 ? _ * _ : 0;
        }
      }
    Gx(w, 0, 0, f, d, f, this.f, this.v, this.z), Gx(v, m, m, l, u, f, this.f, this.v, this.z);
    for (let S = 0; S < p; S++) {
      const E = Math.sqrt(w[S]) - Math.sqrt(v[S]);
      y[S] = Math.round(255 - 255 * (E / this.radius + this.cutoff));
    }
    return x;
  }
}
function Gx(i, e, n, s, r, a, o, h, c) {
  for (let l = e; l < e + s; l++) Ux(i, n * a + l, a, r, o, h, c);
  for (let l = n; l < n + r; l++) Ux(i, l * a + e, 1, s, o, h, c);
}
function Ux(i, e, n, s, r, a, o) {
  a[0] = 0, o[0] = -No, o[1] = No, r[0] = i[e];
  for (let h = 1, c = 0, l = 0; h < s; h++) {
    r[h] = i[e + h * n];
    const u = h * h;
    do {
      const f = a[c];
      l = (r[h] - r[f] + u - f * f) / (h - f) / 2;
    } while (l <= o[c] && --c > -1);
    c++, a[c] = h, o[c] = l, o[c + 1] = No;
  }
  for (let h = 0, c = 0; h < s; h++) {
    for (; o[c + 1] < h; ) c++;
    const l = a[c], u = h - l;
    i[e + h * n] = r[l] + u * u;
  }
}
class ow {
  constructor(e = [], n = (s, r) => s < r ? -1 : s > r ? 1 : 0) {
    if (this.data = e, this.length = this.data.length, this.compare = n, this.length > 0)
      for (let s = (this.length >> 1) - 1; s >= 0; s--) this._down(s);
  }
  push(e) {
    this.data.push(e), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    const e = this.data[0], n = this.data.pop();
    return --this.length > 0 && (this.data[0] = n, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    const { data: n, compare: s } = this, r = n[e];
    for (; e > 0; ) {
      const a = e - 1 >> 1, o = n[a];
      if (s(r, o) >= 0) break;
      n[e] = o, e = a;
    }
    n[e] = r;
  }
  _down(e) {
    const { data: n, compare: s } = this, r = this.length >> 1, a = n[e];
    for (; e < r; ) {
      let o = (e << 1) + 1;
      const h = o + 1;
      if (h < this.length && s(n[h], n[o]) < 0 && (o = h), s(n[o], a) >= 0) break;
      n[e] = n[o], e = o;
    }
    n[e] = a;
  }
}
function u4(i, e = 1, n = !1) {
  let s = 1 / 0, r = 1 / 0, a = -1 / 0, o = -1 / 0;
  for (const [m, v] of i[0])
    m < s && (s = m), v < r && (r = v), m > a && (a = m), v > o && (o = v);
  const h = a - s, c = o - r, l = Math.max(e, Math.min(h, c));
  if (l === e) {
    const m = [s, r];
    return m.distance = 0, m;
  }
  const u = new ow([], (m, v) => v.max - m.max);
  let f = d4(i);
  const d = new ql(s + h / 2, r + c / 2, 0, i);
  d.d > f.d && (f = d);
  let p = 2;
  function y(m, v, w) {
    const b = new ql(m, v, w, i);
    p++, b.max > f.d + e && u.push(b), b.d > f.d && (f = b, n && console.log(`found best ${Math.round(1e4 * b.d) / 1e4} after ${p} probes`));
  }
  let x = l / 2;
  for (let m = s; m < a; m += l)
    for (let v = r; v < o; v += l)
      y(m + x, v + x, x);
  for (; u.length; ) {
    const { max: m, x: v, y: w, h: b } = u.pop();
    if (m - f.d <= e) break;
    x = b / 2, y(v - x, w - x, x), y(v + x, w - x, x), y(v - x, w + x, x), y(v + x, w + x, x);
  }
  n && console.log(`num probes: ${p}
best distance: ${f.d}`);
  const g = [f.x, f.y];
  return g.distance = f.d, g;
}
function ql(i, e, n, s) {
  this.x = i, this.y = e, this.h = n, this.d = f4(i, e, s), this.max = this.d + this.h * Math.SQRT2;
}
function f4(i, e, n) {
  let s = !1, r = 1 / 0;
  for (const a of n)
    for (let o = 0, h = a.length, c = h - 1; o < h; c = o++) {
      const l = a[o], u = a[c];
      l[1] > e != u[1] > e && i < (u[0] - l[0]) * (e - l[1]) / (u[1] - l[1]) + l[0] && (s = !s), r = Math.min(r, p4(i, e, l, u));
    }
  return r === 0 ? 0 : (s ? 1 : -1) * Math.sqrt(r);
}
function d4(i) {
  let e = 0, n = 0, s = 0;
  const r = i[0];
  for (let o = 0, h = r.length, c = h - 1; o < h; c = o++) {
    const l = r[o], u = r[c], f = l[0] * u[1] - u[0] * l[1];
    n += (l[0] + u[0]) * f, s += (l[1] + u[1]) * f, e += f * 3;
  }
  const a = new ql(n / e, s / e, 0, i);
  return e === 0 || a.d < 0 ? new ql(r[0][0], r[0][1], 0, i) : a;
}
function p4(i, e, n, s) {
  let r = n[0], a = n[1], o = s[0] - r, h = s[1] - a;
  if (o !== 0 || h !== 0) {
    const c = ((i - r) * o + (e - a) * h) / (o * o + h * h);
    c > 1 ? (r = s[0], a = s[1]) : c > 0 && (r += o * c, a += h * c);
  }
  return o = i - r, h = e - a, o * o + h * h;
}
const y4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Delaunator: jd,
  TinySDF: l4,
  deviation: ZP,
  earcut: kP,
  flatten: JP,
  polylabel: u4
}, Symbol.toStringTag, { value: "Module" })), hw = Math.PI * 2, x4 = 180 / Math.PI, g4 = Math.PI / 180;
var Ir = /* @__PURE__ */ ((i) => (i[i.POLY = 0] = "POLY", i[i.RECT = 1] = "RECT", i[i.CIRC = 2] = "CIRC", i[i.ELIP = 3] = "ELIP", i[i.RREC = 4] = "RREC", i))(Ir || {});
let ds = class cw {
  /** Position of the point on the x axis */
  x = 0;
  /** Position of the point on the y axis */
  y = 0;
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e = 0, n = 0) {
    this.x = e, this.y = n;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new cw(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(e) {
    return this.set(e.x, e.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(e) {
    return e.set(this.x, this.y), e;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(e = 0, n = e) {
    return this.x = e, this.y = n, this;
  }
};
process.env.DEBUG && (ds.prototype.toString = function() {
  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
});
const pc = [new ds(), new ds(), new ds(), new ds()];
let au = class A0 {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  width;
  /** @default 0 */
  height;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.RECT
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(e = 0, n = 0, s = 0, r = 0) {
    this.x = Number(e), this.y = Number(n), this.width = Number(s), this.height = Number(r), this.type = Ir.RECT;
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** A constant empty rectangle. */
  static get EMPTY() {
    return new A0(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new A0(this.x, this.y, this.width, this.height);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(e) {
    return e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(e, n) {
    return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height;
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(e, n) {
    if (!n) {
      const M = this.x < e.x ? e.x : this.x;
      if ((this.right > e.right ? e.right : this.right) <= M)
        return !1;
      const T = this.y < e.y ? e.y : this.y;
      return (this.bottom > e.bottom ? e.bottom : this.bottom) > T;
    }
    const s = this.left, r = this.right, a = this.top, o = this.bottom;
    if (r <= s || o <= a)
      return !1;
    const h = pc[0].set(e.left, e.top), c = pc[1].set(e.left, e.bottom), l = pc[2].set(e.right, e.top), u = pc[3].set(e.right, e.bottom);
    if (l.x <= h.x || c.y <= h.y)
      return !1;
    const f = Math.sign(n.a * n.d - n.b * n.c);
    if (f === 0 || (n.apply(h, h), n.apply(c, c), n.apply(l, l), n.apply(u, u), Math.max(h.x, c.x, l.x, u.x) <= s || Math.min(h.x, c.x, l.x, u.x) >= r || Math.max(h.y, c.y, l.y, u.y) <= a || Math.min(h.y, c.y, l.y, u.y) >= o))
      return !1;
    const d = f * (c.y - h.y), p = f * (h.x - c.x), y = d * s + p * a, x = d * r + p * a, g = d * s + p * o, m = d * r + p * o;
    if (Math.max(y, x, g, m) <= d * h.x + p * h.y || Math.min(y, x, g, m) >= d * u.x + p * u.y)
      return !1;
    const v = f * (h.y - l.y), w = f * (l.x - h.x), b = v * s + w * a, S = v * r + w * a, E = v * s + w * o, A = v * r + w * o;
    return !(Math.max(b, S, E, A) <= v * h.x + w * h.y || Math.min(b, S, E, A) >= v * u.x + w * u.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(e = 0, n = e) {
    return this.x -= e, this.y -= n, this.width += e * 2, this.height += n * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(e) {
    const n = Math.max(this.x, e.x), s = Math.min(this.x + this.width, e.x + e.width), r = Math.max(this.y, e.y), a = Math.min(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = Math.max(s - n, 0), this.y = r, this.height = Math.max(a - r, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(e = 1, n = 1e-3) {
    const s = Math.ceil((this.x + this.width - n) * e) / e, r = Math.ceil((this.y + this.height - n) * e) / e;
    return this.x = Math.floor((this.x + n) * e) / e, this.y = Math.floor((this.y + n) * e) / e, this.width = s - this.x, this.height = r - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(e) {
    const n = Math.min(this.x, e.x), s = Math.max(this.x + this.width, e.x + e.width), r = Math.min(this.y, e.y), a = Math.max(this.y + this.height, e.y + e.height);
    return this.x = n, this.width = s - n, this.y = r, this.height = a - r, this;
  }
};
process.env.DEBUG && (au.prototype.toString = function() {
  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
});
let lw = class uw {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.CIRC
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(e = 0, n = 0, s = 0) {
    this.x = e, this.y = n, this.radius = s, this.type = Ir.CIRC;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new uw(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(e, n) {
    if (this.radius <= 0)
      return !1;
    const s = this.radius * this.radius;
    let r = this.x - e, a = this.y - n;
    return r *= r, a *= a, r + a <= s;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new au(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
};
process.env.DEBUG && (lw.prototype.toString = function() {
  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
});
let fw = class dw {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  width;
  /** @default 0 */
  height;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.ELIP
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(e = 0, n = 0, s = 0, r = 0) {
    this.x = e, this.y = n, this.width = s, this.height = r, this.type = Ir.ELIP;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {PIXI.Ellipse} A copy of the ellipse
   */
  clone() {
    return new dw(this.x, this.y, this.width, this.height);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(e, n) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    let s = (e - this.x) / this.width, r = (n - this.y) / this.height;
    return s *= s, r *= r, s + r <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new au(this.x - this.width, this.y - this.height, this.width, this.height);
  }
};
process.env.DEBUG && (fw.prototype.toString = function() {
  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
});
let pw = class yw {
  /** An array of the points of this polygon. */
  points;
  /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */
  closeStroke;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.POLY
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...e) {
    let n = Array.isArray(e[0]) ? e[0] : e;
    if (typeof n[0] != "number") {
      const s = [];
      for (let r = 0, a = n.length; r < a; r++)
        s.push(n[r].x, n[r].y);
      n = s;
    }
    this.points = n, this.type = Ir.POLY, this.closeStroke = !0;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const e = this.points.slice(), n = new yw(e);
    return n.closeStroke = this.closeStroke, n;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(e, n) {
    let s = !1;
    const r = this.points.length / 2;
    for (let a = 0, o = r - 1; a < r; o = a++) {
      const h = this.points[a * 2], c = this.points[a * 2 + 1], l = this.points[o * 2], u = this.points[o * 2 + 1];
      c > n != u > n && e < (l - h) * ((n - c) / (u - c)) + h && (s = !s);
    }
    return s;
  }
};
process.env.DEBUG && (pw.prototype.toString = function() {
  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((e, n) => `${e}, ${n}`, "")}]`;
});
class ou {
  /** @default 0 */
  x;
  /** @default 0 */
  y;
  /** @default 0 */
  width;
  /** @default 0 */
  height;
  /** @default 20 */
  radius;
  /**
   * The type of the object, mainly used to avoid `instanceof` checks
   * @default PIXI.SHAPES.RREC
   * @see PIXI.SHAPES
   */
  type;
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(e = 0, n = 0, s = 0, r = 0, a = 20) {
    this.x = e, this.y = n, this.width = s, this.height = r, this.radius = a, this.type = Ir.RREC;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new ou(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(e, n) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (e >= this.x && e <= this.x + this.width && n >= this.y && n <= this.y + this.height) {
      const s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (n >= this.y + s && n <= this.y + this.height - s || e >= this.x + s && e <= this.x + this.width - s)
        return !0;
      let r = e - (this.x + s), a = n - (this.y + s);
      const o = s * s;
      if (r * r + a * a <= o || (r = e - (this.x + this.width - s), r * r + a * a <= o) || (a = n - (this.y + this.height - s), r * r + a * a <= o) || (r = e - (this.x + s), r * r + a * a <= o))
        return !0;
    }
    return !1;
  }
}
process.env.DEBUG && (ou.prototype.toString = function() {
  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
});
let ih = class nl {
  /** @default 1 */
  a;
  /** @default 0 */
  b;
  /** @default 0 */
  c;
  /** @default 1 */
  d;
  /** @default 0 */
  tx;
  /** @default 0 */
  ty;
  array = null;
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(e = 1, n = 0, s = 0, r = 1, a = 0, o = 0) {
    this.a = e, this.b = n, this.c = s, this.d = r, this.tx = a, this.ty = o;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(e) {
    this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(e, n, s, r, a, o) {
    return this.a = e, this.b = n, this.c = s, this.d = r, this.tx = a, this.ty = o, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(e, n) {
    this.array || (this.array = new Float32Array(9));
    const s = n || this.array;
    return e ? (s[0] = this.a, s[1] = this.b, s[2] = 0, s[3] = this.c, s[4] = this.d, s[5] = 0, s[6] = this.tx, s[7] = this.ty, s[8] = 1) : (s[0] = this.a, s[1] = this.c, s[2] = this.tx, s[3] = this.b, s[4] = this.d, s[5] = this.ty, s[6] = 0, s[7] = 0, s[8] = 1), s;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, transformed through this matrix
   */
  apply(e, n) {
    n = n || new ds();
    const s = e.x, r = e.y;
    return n.x = this.a * s + this.c * r + this.tx, n.y = this.b * s + this.d * r + this.ty, n;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(e, n) {
    n = n || new ds();
    const s = 1 / (this.a * this.d + this.c * -this.b), r = e.x, a = e.y;
    return n.x = this.d * s * r + -this.c * s * a + (this.ty * this.c - this.tx * this.d) * s, n.y = this.a * s * a + -this.b * s * r + (-this.ty * this.a + this.tx * this.b) * s, n;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(e, n) {
    return this.tx += e, this.ty += n, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(e, n) {
    return this.a *= e, this.d *= n, this.c *= e, this.b *= n, this.tx *= e, this.ty *= n, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(e) {
    const n = Math.cos(e), s = Math.sin(e), r = this.a, a = this.c, o = this.tx;
    return this.a = r * n - this.b * s, this.b = r * s + this.b * n, this.c = a * n - this.d * s, this.d = a * s + this.d * n, this.tx = o * n - this.ty * s, this.ty = o * s + this.ty * n, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(e) {
    const n = this.a, s = this.b, r = this.c, a = this.d;
    return this.a = e.a * n + e.b * r, this.b = e.a * s + e.b * a, this.c = e.c * n + e.d * r, this.d = e.c * s + e.d * a, this.tx = e.tx * n + e.ty * r + this.tx, this.ty = e.tx * s + e.ty * a + this.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(e, n, s, r, a, o, h, c, l) {
    return this.a = Math.cos(h + l) * a, this.b = Math.sin(h + l) * a, this.c = -Math.sin(h - c) * o, this.d = Math.cos(h - c) * o, this.tx = e - (s * this.a + r * this.c), this.ty = n - (s * this.b + r * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(e) {
    const n = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const s = this.a, r = this.c;
      this.a = s * e.a + this.b * e.c, this.b = s * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d;
    }
    return this.tx = n * e.a + this.ty * e.c + e.tx, this.ty = n * e.b + this.ty * e.d + e.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(e) {
    const n = this.a, s = this.b, r = this.c, a = this.d, o = e.pivot, h = -Math.atan2(-r, a), c = Math.atan2(s, n), l = Math.abs(h + c);
    return l < 1e-5 || Math.abs(hw - l) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = h, e.skew.y = c), e.scale.x = Math.sqrt(n * n + s * s), e.scale.y = Math.sqrt(r * r + a * a), e.position.x = this.tx + (o.x * n + o.y * r), e.position.y = this.ty + (o.x * s + o.y * a), e;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const e = this.a, n = this.b, s = this.c, r = this.d, a = this.tx, o = e * r - n * s;
    return this.a = r / o, this.b = -n / o, this.c = -s / o, this.d = e / o, this.tx = (s * this.ty - r * a) / o, this.ty = -(e * this.ty - n * a) / o, this;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const e = new nl();
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(e) {
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param {PIXI.Matrix} matrix - The matrix to copy from.
   * @returns {PIXI.Matrix} this
   */
  copyFrom(e) {
    return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
  }
  /**
   * A default (identity) matrix
   * @readonly
   */
  static get IDENTITY() {
    return new nl();
  }
  /**
   * A temp matrix
   * @readonly
   */
  static get TEMP_MATRIX() {
    return new nl();
  }
};
process.env.DEBUG && (ih.prototype.toString = function() {
  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
});
const tr = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], er = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], nr = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], ir = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], P0 = [], xw = [], yc = Math.sign;
function m4() {
  for (let i = 0; i < 16; i++) {
    const e = [];
    P0.push(e);
    for (let n = 0; n < 16; n++) {
      const s = yc(tr[i] * tr[n] + nr[i] * er[n]), r = yc(er[i] * tr[n] + ir[i] * er[n]), a = yc(tr[i] * nr[n] + nr[i] * ir[n]), o = yc(er[i] * nr[n] + ir[i] * ir[n]);
      for (let h = 0; h < 16; h++)
        if (tr[h] === s && er[h] === r && nr[h] === a && ir[h] === o) {
          e.push(h);
          break;
        }
    }
  }
  for (let i = 0; i < 16; i++) {
    const e = new ih();
    e.set(tr[i], er[i], nr[i], ir[i], 0, 0), xw.push(e);
  }
}
m4();
const Yn = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @readonly
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @readonly
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @readonly
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @readonly
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @readonly
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @readonly
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @readonly
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @readonly
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @readonly
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @readonly
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @readonly
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @readonly
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (i) => tr[i],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (i) => er[i],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (i) => nr[i],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (i) => ir[i],
  /**
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (i) => i & 8 ? i & 15 : -i & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: (i, e) => P0[i][e],
  /**
   * Reverse of `add`.
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: (i, e) => P0[i][Yn.inv(e)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (i) => i ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (i) => (i & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (i, e) => Math.abs(i) * 2 <= Math.abs(e) ? e >= 0 ? Yn.S : Yn.N : Math.abs(e) * 2 <= Math.abs(i) ? i > 0 ? Yn.E : Yn.W : e > 0 ? i > 0 ? Yn.SE : Yn.SW : i > 0 ? Yn.NE : Yn.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (i, e, n = 0, s = 0) => {
    const r = xw[Yn.inv(e)];
    r.tx = n, r.ty = s, i.append(r);
  }
};
class ur {
  /** The callback function triggered when `x` and/or `y` are changed */
  cb;
  /** The owner of the callback */
  scope;
  _x;
  _y;
  /**
   * Creates a new `ObservablePoint`
   * @param cb - callback function triggered when `x` and/or `y` are changed
   * @param scope - owner of callback
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e, n, s = 0, r = 0) {
    this._x = s, this._y = r, this.cb = e, this.scope = n;
  }
  /**
   * Creates a clone of this point.
   * The callback and scope params can be overridden otherwise they will default
   * to the clone object's values.
   * @override
   * @param cb - The callback function triggered when `x` and/or `y` are changed
   * @param scope - The owner of the callback
   * @returns a copy of this observable point
   */
  clone(e = this.cb, n = this.scope) {
    return new ur(e, n, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(e = 0, n = e) {
    return (this._x !== e || this._y !== n) && (this._x = e, this._y = n, this.cb.call(this.scope)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `IPointData`
   * @returns The observable point instance itself
   */
  copyFrom(e) {
    return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this.cb.call(this.scope)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(e) {
    return e.set(this._x, this._y), e;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(e) {
    return e.x === this._x && e.y === this._y;
  }
  // #if _DEBUG
  toString() {
    return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`;
  }
  // #endif
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x !== e && (this._x = e, this.cb.call(this.scope));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y !== e && (this._y = e, this.cb.call(this.scope));
  }
}
class Hd {
  /**
   * A default (identity) transform.
   * @static
   * @type {PIXI.Transform}
   */
  static IDENTITY = new Hd();
  /** The world transformation matrix. */
  worldTransform;
  /** The local transformation matrix. */
  localTransform;
  /** The coordinate of the object relative to the local coordinates of the parent. */
  position;
  /** The scale factor of the object. */
  scale;
  /** The pivot point of the displayObject that it rotates around. */
  pivot;
  /** The skew amount, on the x and y axis. */
  skew;
  /** The locally unique ID of the parent's world transform used to calculate the current world transformation matrix. */
  _parentID;
  /** The locally unique ID of the world transform. */
  _worldID;
  /** The rotation amount. */
  _rotation;
  /**
   * The X-coordinate value of the normalized local X axis,
   * the first column of the local transformation matrix without a scale.
   */
  _cx;
  /**
   * The Y-coordinate value of the normalized local X axis,
   * the first column of the local transformation matrix without a scale.
   */
  _sx;
  /**
   * The X-coordinate value of the normalized local Y axis,
   * the second column of the local transformation matrix without a scale.
   */
  _cy;
  /**
   * The Y-coordinate value of the normalized local Y axis,
   * the second column of the local transformation matrix without a scale.
   */
  _sy;
  /** The locally unique ID of the local transform. */
  _localID;
  /** The locally unique ID of the local transform used to calculate the current local transformation matrix. */
  _currentLocalID;
  constructor() {
    this.worldTransform = new ih(), this.localTransform = new ih(), this.position = new ur(this.onChange, this, 0, 0), this.scale = new ur(this.onChange, this, 1, 1), this.pivot = new ur(this.onChange, this, 0, 0), this.skew = new ur(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  /** Called when a value changes. */
  onChange() {
    this._localID++;
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }
  /** Updates the local transformation matrix. */
  updateLocalTransform() {
    const e = this.localTransform;
    this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1);
  }
  /**
   * Updates the local and the world transformation matrices.
   * @param parentTransform - The parent transform
   */
  updateTransform(e) {
    const n = this.localTransform;
    if (this._localID !== this._currentLocalID && (n.a = this._cx * this.scale.x, n.b = this._sx * this.scale.x, n.c = this._cy * this.scale.y, n.d = this._sy * this.scale.y, n.tx = this.position.x - (this.pivot.x * n.a + this.pivot.y * n.c), n.ty = this.position.y - (this.pivot.x * n.b + this.pivot.y * n.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
      const s = e.worldTransform, r = this.worldTransform;
      r.a = n.a * s.a + n.b * s.c, r.b = n.a * s.b + n.b * s.d, r.c = n.c * s.a + n.d * s.c, r.d = n.c * s.b + n.d * s.d, r.tx = n.tx * s.a + n.ty * s.c + s.tx, r.ty = n.tx * s.b + n.ty * s.d + s.ty, this._parentID = e._worldID, this._worldID++;
    }
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(e) {
    e.decompose(this), this._localID++;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation !== e && (this._rotation = e, this.updateSkew());
  }
}
const v4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: lw,
  DEG_TO_RAD: g4,
  Ellipse: fw,
  Matrix: ih,
  ObservablePoint: ur,
  PI_2: hw,
  Point: ds,
  Polygon: pw,
  RAD_TO_DEG: x4,
  Rectangle: au,
  RoundedRectangle: ou,
  SHAPES: Ir,
  Transform: Hd,
  groupD8: Yn
}, Symbol.toStringTag, { value: "Module" }));
function gw(i, e, n = 0, s = i.length - 1, r = w4) {
  for (; s > n; ) {
    if (s - n > 600) {
      const c = s - n + 1, l = e - n + 1, u = Math.log(c), f = 0.5 * Math.exp(2 * u / 3), d = 0.5 * Math.sqrt(u * f * (c - f) / c) * (l - c / 2 < 0 ? -1 : 1), p = Math.max(n, Math.floor(e - l * f / c + d)), y = Math.min(s, Math.floor(e + (c - l) * f / c + d));
      gw(i, e, p, y, r);
    }
    const a = i[e];
    let o = n, h = s;
    for (to(i, n, e), r(i[s], a) > 0 && to(i, n, s); o < h; ) {
      for (to(i, o, h), o++, h--; r(i[o], a) < 0; ) o++;
      for (; r(i[h], a) > 0; ) h--;
    }
    r(i[n], a) === 0 ? to(i, n, h) : (h++, to(i, h, s)), h <= e && (n = h + 1), e <= h && (s = h - 1);
  }
}
function to(i, e, n) {
  const s = i[e];
  i[e] = i[n], i[n] = s;
}
function w4(i, e) {
  return i < e ? -1 : i > e ? 1 : 0;
}
class M4 {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let n = this.data;
    const s = [];
    if (!gc(e, n)) return s;
    const r = this.toBBox, a = [];
    for (; n; ) {
      for (let o = 0; o < n.children.length; o++) {
        const h = n.children[o], c = n.leaf ? r(h) : h;
        gc(e, c) && (n.leaf ? s.push(h) : of(e, c) ? this._all(h, s) : a.push(h));
      }
      n = a.pop();
    }
    return s;
  }
  collides(e) {
    let n = this.data;
    if (!gc(e, n)) return !1;
    const s = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const a = n.children[r], o = n.leaf ? this.toBBox(a) : a;
        if (gc(e, o)) {
          if (n.leaf || of(e, o)) return !0;
          s.push(a);
        }
      }
      n = s.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let s = 0; s < e.length; s++)
        this.insert(e[s]);
      return this;
    }
    let n = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const s = this.data;
        this.data = n, n = s;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = ra([]), this;
  }
  remove(e, n) {
    if (!e) return this;
    let s = this.data;
    const r = this.toBBox(e), a = [], o = [];
    let h, c, l;
    for (; s || a.length; ) {
      if (s || (s = a.pop(), c = a[a.length - 1], h = o.pop(), l = !0), s.leaf) {
        const u = b4(e, s.children, n);
        if (u !== -1)
          return s.children.splice(u, 1), a.push(s), this._condense(a), this;
      }
      !l && !s.leaf && of(s, r) ? (a.push(s), o.push(h), h = 0, c = s, s = s.children[0]) : c ? (h++, s = c.children[h], l = !1) : s = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, n) {
    return e.minX - n.minX;
  }
  compareMinY(e, n) {
    return e.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, n) {
    const s = [];
    for (; e; )
      e.leaf ? n.push(...e.children) : s.push(...e.children), e = s.pop();
    return n;
  }
  _build(e, n, s, r) {
    const a = s - n + 1;
    let o = this._maxEntries, h;
    if (a <= o)
      return h = ra(e.slice(n, s + 1)), Dr(h, this.toBBox), h;
    r || (r = Math.ceil(Math.log(a) / Math.log(o)), o = Math.ceil(a / Math.pow(o, r - 1))), h = ra([]), h.leaf = !1, h.height = r;
    const c = Math.ceil(a / o), l = c * Math.ceil(Math.sqrt(o));
    Wx(e, n, s, l, this.compareMinX);
    for (let u = n; u <= s; u += l) {
      const f = Math.min(u + l - 1, s);
      Wx(e, u, f, c, this.compareMinY);
      for (let d = u; d <= f; d += c) {
        const p = Math.min(d + c - 1, f);
        h.children.push(this._build(e, d, p, r - 1));
      }
    }
    return Dr(h, this.toBBox), h;
  }
  _chooseSubtree(e, n, s, r) {
    for (; r.push(n), !(n.leaf || r.length - 1 === s); ) {
      let a = 1 / 0, o = 1 / 0, h;
      for (let c = 0; c < n.children.length; c++) {
        const l = n.children[c], u = af(l), f = T4(e, l) - u;
        f < o ? (o = f, a = u < a ? u : a, h = l) : f === o && u < a && (a = u, h = l);
      }
      n = h || n.children[0];
    }
    return n;
  }
  _insert(e, n, s) {
    const r = s ? e : this.toBBox(e), a = [], o = this._chooseSubtree(r, this.data, n, a);
    for (o.children.push(e), mo(o, r); n >= 0 && a[n].children.length > this._maxEntries; )
      this._split(a, n), n--;
    this._adjustParentBBoxes(r, a, n);
  }
  // split overflowed node into two
  _split(e, n) {
    const s = e[n], r = s.children.length, a = this._minEntries;
    this._chooseSplitAxis(s, a, r);
    const o = this._chooseSplitIndex(s, a, r), h = ra(s.children.splice(o, s.children.length - o));
    h.height = s.height, h.leaf = s.leaf, Dr(s, this.toBBox), Dr(h, this.toBBox), n ? e[n - 1].children.push(h) : this._splitRoot(s, h);
  }
  _splitRoot(e, n) {
    this.data = ra([e, n]), this.data.height = e.height + 1, this.data.leaf = !1, Dr(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, n, s) {
    let r, a = 1 / 0, o = 1 / 0;
    for (let h = n; h <= s - n; h++) {
      const c = go(e, 0, h, this.toBBox), l = go(e, h, s, this.toBBox), u = E4(c, l), f = af(c) + af(l);
      u < a ? (a = u, r = h, o = f < o ? f : o) : u === a && f < o && (o = f, r = h);
    }
    return r || s - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, n, s) {
    const r = e.leaf ? this.compareMinX : _4, a = e.leaf ? this.compareMinY : S4, o = this._allDistMargin(e, n, s, r), h = this._allDistMargin(e, n, s, a);
    o < h && e.children.sort(r);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, n, s, r) {
    e.children.sort(r);
    const a = this.toBBox, o = go(e, 0, n, a), h = go(e, s - n, s, a);
    let c = xc(o) + xc(h);
    for (let l = n; l < s - n; l++) {
      const u = e.children[l];
      mo(o, e.leaf ? a(u) : u), c += xc(o);
    }
    for (let l = s - n - 1; l >= n; l--) {
      const u = e.children[l];
      mo(h, e.leaf ? a(u) : u), c += xc(h);
    }
    return c;
  }
  _adjustParentBBoxes(e, n, s) {
    for (let r = s; r >= 0; r--)
      mo(n[r], e);
  }
  _condense(e) {
    for (let n = e.length - 1, s; n >= 0; n--)
      e[n].children.length === 0 ? n > 0 ? (s = e[n - 1].children, s.splice(s.indexOf(e[n]), 1)) : this.clear() : Dr(e[n], this.toBBox);
  }
}
function b4(i, e, n) {
  if (!n) return e.indexOf(i);
  for (let s = 0; s < e.length; s++)
    if (n(i, e[s])) return s;
  return -1;
}
function Dr(i, e) {
  go(i, 0, i.children.length, e, i);
}
function go(i, e, n, s, r) {
  r || (r = ra(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let a = e; a < n; a++) {
    const o = i.children[a];
    mo(r, i.leaf ? s(o) : o);
  }
  return r;
}
function mo(i, e) {
  return i.minX = Math.min(i.minX, e.minX), i.minY = Math.min(i.minY, e.minY), i.maxX = Math.max(i.maxX, e.maxX), i.maxY = Math.max(i.maxY, e.maxY), i;
}
function _4(i, e) {
  return i.minX - e.minX;
}
function S4(i, e) {
  return i.minY - e.minY;
}
function af(i) {
  return (i.maxX - i.minX) * (i.maxY - i.minY);
}
function xc(i) {
  return i.maxX - i.minX + (i.maxY - i.minY);
}
function T4(i, e) {
  return (Math.max(e.maxX, i.maxX) - Math.min(e.minX, i.minX)) * (Math.max(e.maxY, i.maxY) - Math.min(e.minY, i.minY));
}
function E4(i, e) {
  const n = Math.max(i.minX, e.minX), s = Math.max(i.minY, e.minY), r = Math.min(i.maxX, e.maxX), a = Math.min(i.maxY, e.maxY);
  return Math.max(0, r - n) * Math.max(0, a - s);
}
function of(i, e) {
  return i.minX <= e.minX && i.minY <= e.minY && e.maxX <= i.maxX && e.maxY <= i.maxY;
}
function gc(i, e) {
  return e.minX <= i.maxX && e.minY <= i.maxY && e.maxX >= i.minX && e.maxY >= i.minY;
}
function ra(i) {
  return {
    children: i,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Wx(i, e, n, s, r) {
  const a = [e, n];
  for (; a.length; ) {
    if (n = a.pop(), e = a.pop(), n - e <= s) continue;
    const o = e + Math.ceil((n - e) / s / 2) * s;
    gw(i, o, e, n, r), a.push(e, o, o, n);
  }
}
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ss = {
  /**
   * A Circle Geometry object type.
   *
   * @name Phaser.Geom.CIRCLE
   * @type {number}
   * @since 3.19.0
   */
  CIRCLE: 0,
  /**
   * An Ellipse Geometry object type.
   *
   * @name Phaser.Geom.ELLIPSE
   * @type {number}
   * @since 3.19.0
   */
  ELLIPSE: 1,
  /**
   * A Line Geometry object type.
   *
   * @name Phaser.Geom.LINE
   * @type {number}
   * @since 3.19.0
   */
  LINE: 2,
  /**
   * A Point Geometry object type.
   *
   * @name Phaser.Geom.POINT
   * @type {number}
   * @since 3.19.0
   */
  POINT: 3,
  /**
   * A Polygon Geometry object type.
   *
   * @name Phaser.Geom.POLYGON
   * @type {number}
   * @since 3.19.0
   */
  POLYGON: 4,
  /**
   * A Rectangle Geometry object type.
   *
   * @name Phaser.Geom.RECTANGLE
   * @type {number}
   * @since 3.19.0
   */
  RECTANGLE: 5,
  /**
   * A Triangle Geometry object type.
   *
   * @name Phaser.Geom.TRIANGLE
   * @type {number}
   * @since 3.19.0
   */
  TRIANGLE: 6
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function z4(i) {
  return !!i.get && typeof i.get == "function" || !!i.set && typeof i.set == "function";
}
function C4(i, e, n) {
  var s = n ? i[e] : Object.getOwnPropertyDescriptor(i, e);
  return !n && s.value && typeof s.value == "object" && (s = s.value), s && z4(s) ? (typeof s.enumerable > "u" && (s.enumerable = !0), typeof s.configurable > "u" && (s.configurable = !0), s) : !1;
}
function A4(i, e) {
  var n = Object.getOwnPropertyDescriptor(i, e);
  return n ? (n.value && typeof n.value == "object" && (n = n.value), n.configurable === !1) : !1;
}
function Xd(i, e, n, s) {
  for (var r in e)
    if (e.hasOwnProperty(r)) {
      var a = C4(e, r, n);
      if (a !== !1) {
        var o = s || i;
        if (A4(o.prototype, r)) {
          if (Gt.ignoreFinals)
            continue;
          throw new Error("cannot override final property '" + r + "', set Class.ignoreFinals = true to skip");
        }
        Object.defineProperty(i.prototype, r, a);
      } else
        i.prototype[r] = e[r];
    }
}
function mw(i, e) {
  if (e) {
    Array.isArray(e) || (e = [e]);
    for (var n = 0; n < e.length; n++)
      Xd(i, e[n].prototype || e[n]);
  }
}
function Gt(i) {
  i || (i = {});
  var e, n;
  if (i.initialize) {
    if (typeof i.initialize != "function")
      throw new Error("initialize must be a function");
    e = i.initialize, delete i.initialize;
  } else if (i.Extends) {
    var s = i.Extends;
    e = function() {
      s.apply(this, arguments);
    };
  } else
    e = function() {
    };
  i.Extends ? (e.prototype = Object.create(i.Extends.prototype), e.prototype.constructor = e, n = i.Extends, delete i.Extends) : e.prototype.constructor = e;
  var r = null;
  return i.Mixins && (r = i.Mixins, delete i.Mixins), mw(e, r), Xd(e, i, !0, n), e;
}
Gt.extend = Xd;
Gt.mixin = mw;
Gt.ignoreFinals = !1;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xi = function(i, e, n) {
  if (i.radius > 0 && e >= i.left && e <= i.right && n >= i.top && n <= i.bottom) {
    var s = (i.x - e) * (i.x - e), r = (i.y - n) * (i.y - n);
    return s + r <= i.radius * i.radius;
  } else
    return !1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ot = new Gt({
  initialize: function(e, n) {
    e === void 0 && (e = 0), n === void 0 && (n = e), this.type = Ss.POINT, this.x = e, this.y = n;
  },
  /**
   * Set the x and y coordinates of the point to the given values.
   *
   * @method Phaser.Geom.Point#setTo
   * @since 3.0.0
   *
   * @param {number} [x=0] - The x coordinate of this Point.
   * @param {number} [y=x] - The y coordinate of this Point.
   *
   * @return {this} This Point object.
   */
  setTo: function(i, e) {
    return i === void 0 && (i = 0), e === void 0 && (e = i), this.x = i, this.y = e, this;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Zd = function(i, e, n) {
  return n === void 0 && (n = new ot()), n.x = i.x + i.radius * Math.cos(e), n.y = i.y + i.radius * Math.sin(e), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Zn = function(i, e, n) {
  return Math.max(e, Math.min(n, i));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ih = function(i, e, n) {
  return i = Zn(i, 0, 1), (n - e) * i + e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ce = {
  /**
   * The value of PI * 2.
   *
   * @name Phaser.Math.PI2
   * @type {number}
   * @since 3.0.0
   */
  PI2: Math.PI * 2,
  /**
   * The value of PI * 0.5.
   *
   * Yes, we understand that this should actually be PI * 2, but
   * it has been like this for so long we can't change it now.
   * If you need PI * 2, use the PI2 constant instead.
   *
   * @name Phaser.Math.TAU
   * @type {number}
   * @since 3.0.0
   */
  TAU: Math.PI * 0.5,
  /**
   * An epsilon value (1.0e-6)
   *
   * @name Phaser.Math.EPSILON
   * @type {number}
   * @since 3.0.0
   */
  EPSILON: 1e-6,
  /**
   * For converting degrees to radians (PI / 180)
   *
   * @name Phaser.Math.DEG_TO_RAD
   * @type {number}
   * @since 3.0.0
   */
  DEG_TO_RAD: Math.PI / 180,
  /**
   * For converting radians to degrees (180 / PI)
   *
   * @name Phaser.Math.RAD_TO_DEG
   * @type {number}
   * @since 3.0.0
   */
  RAD_TO_DEG: 180 / Math.PI,
  /**
   * An instance of the Random Number Generator.
   * This is not set until the Game boots.
   *
   * @name Phaser.Math.RND
   * @type {Phaser.Math.RandomDataGenerator}
   * @since 3.0.0
   */
  RND: null,
  /**
   * The minimum safe integer this browser supports.
   * We use a const for backward compatibility with Internet Explorer.
   *
   * @name Phaser.Math.MIN_SAFE_INTEGER
   * @type {number}
   * @since 3.21.0
   */
  MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
  /**
   * The maximum safe integer this browser supports.
   * We use a const for backward compatibility with Internet Explorer.
   *
   * @name Phaser.Math.MAX_SAFE_INTEGER
   * @type {number}
   * @since 3.21.0
   */
  MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vw = function(i, e, n) {
  n === void 0 && (n = new ot());
  var s = Ih(e, 0, ce.PI2);
  return Zd(i, s, n);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ww = function(i) {
  return 2 * (Math.PI * i.radius);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Mw = function(i, e, n, s) {
  s === void 0 && (s = []), !e && n > 0 && (e = ww(i) / n);
  for (var r = 0; r < e; r++) {
    var a = Ih(r / e, 0, ce.PI2);
    s.push(Zd(i, a));
  }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var bw = function(i, e) {
  e === void 0 && (e = new ot());
  var n = 2 * Math.PI * Math.random(), s = Math.random() + Math.random(), r = s > 1 ? 2 - s : s, a = r * Math.cos(n), o = r * Math.sin(n);
  return e.x = i.x + a * i.radius, e.y = i.y + o * i.radius, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Oe = new Gt({
  initialize: function(e, n, s) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), this.type = Ss.CIRCLE, this.x = e, this.y = n, this._radius = s, this._diameter = s * 2;
  },
  /**
   * Check to see if the Circle contains the given x / y coordinates.
   *
   * @method Phaser.Geom.Circle#contains
   * @since 3.0.0
   *
   * @param {number} x - The x coordinate to check within the circle.
   * @param {number} y - The y coordinate to check within the circle.
   *
   * @return {boolean} True if the coordinates are within the circle, otherwise false.
   */
  contains: function(i, e) {
    return xi(this, i, e);
  },
  /**
   * Returns a Point object containing the coordinates of a point on the circumference of the Circle
   * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
   * at 180 degrees around the circle.
   *
   * @method Phaser.Geom.Circle#getPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [out,$return]
   *
   * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.
   * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.
   *
   * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.
   */
  getPoint: function(i, e) {
    return vw(this, i, e);
  },
  /**
   * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,
   * based on the given quantity or stepRate values.
   *
   * @method Phaser.Geom.Circle#getPoints
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point[]} O - [output,$return]
   *
   * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
   * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.
   * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.
   *
   * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the circle.
   */
  getPoints: function(i, e, n) {
    return Mw(this, i, e, n);
  },
  /**
   * Returns a uniformly distributed random point from anywhere within the Circle.
   *
   * @method Phaser.Geom.Circle#getRandomPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [point,$return]
   *
   * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.
   *
   * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.
   */
  getRandomPoint: function(i) {
    return bw(this, i);
  },
  /**
   * Sets the x, y and radius of this circle.
   *
   * @method Phaser.Geom.Circle#setTo
   * @since 3.0.0
   *
   * @param {number} [x=0] - The x position of the center of the circle.
   * @param {number} [y=0] - The y position of the center of the circle.
   * @param {number} [radius=0] - The radius of the circle.
   *
   * @return {this} This Circle object.
   */
  setTo: function(i, e, n) {
    return this.x = i, this.y = e, this._radius = n, this._diameter = n * 2, this;
  },
  /**
   * Sets this Circle to be empty with a radius of zero.
   * Does not change its position.
   *
   * @method Phaser.Geom.Circle#setEmpty
   * @since 3.0.0
   *
   * @return {this} This Circle object.
   */
  setEmpty: function() {
    return this._radius = 0, this._diameter = 0, this;
  },
  /**
   * Sets the position of this Circle.
   *
   * @method Phaser.Geom.Circle#setPosition
   * @since 3.0.0
   *
   * @param {number} [x=0] - The x position of the center of the circle.
   * @param {number} [y=0] - The y position of the center of the circle.
   *
   * @return {this} This Circle object.
   */
  setPosition: function(i, e) {
    return e === void 0 && (e = i), this.x = i, this.y = e, this;
  },
  /**
   * Checks to see if the Circle is empty: has a radius of zero.
   *
   * @method Phaser.Geom.Circle#isEmpty
   * @since 3.0.0
   *
   * @return {boolean} True if the Circle is empty, otherwise false.
   */
  isEmpty: function() {
    return this._radius <= 0;
  },
  /**
   * The radius of the Circle.
   *
   * @name Phaser.Geom.Circle#radius
   * @type {number}
   * @since 3.0.0
   */
  radius: {
    get: function() {
      return this._radius;
    },
    set: function(i) {
      this._radius = i, this._diameter = i * 2;
    }
  },
  /**
   * The diameter of the Circle.
   *
   * @name Phaser.Geom.Circle#diameter
   * @type {number}
   * @since 3.0.0
   */
  diameter: {
    get: function() {
      return this._diameter;
    },
    set: function(i) {
      this._diameter = i, this._radius = i * 0.5;
    }
  },
  /**
   * The left position of the Circle.
   *
   * @name Phaser.Geom.Circle#left
   * @type {number}
   * @since 3.0.0
   */
  left: {
    get: function() {
      return this.x - this._radius;
    },
    set: function(i) {
      this.x = i + this._radius;
    }
  },
  /**
   * The right position of the Circle.
   *
   * @name Phaser.Geom.Circle#right
   * @type {number}
   * @since 3.0.0
   */
  right: {
    get: function() {
      return this.x + this._radius;
    },
    set: function(i) {
      this.x = i - this._radius;
    }
  },
  /**
   * The top position of the Circle.
   *
   * @name Phaser.Geom.Circle#top
   * @type {number}
   * @since 3.0.0
   */
  top: {
    get: function() {
      return this.y - this._radius;
    },
    set: function(i) {
      this.y = i + this._radius;
    }
  },
  /**
   * The bottom position of the Circle.
   *
   * @name Phaser.Geom.Circle#bottom
   * @type {number}
   * @since 3.0.0
   */
  bottom: {
    get: function() {
      return this.y + this._radius;
    },
    set: function(i) {
      this.y = i - this._radius;
    }
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var P4 = function(i) {
  return i.radius > 0 ? Math.PI * i.radius * i.radius : 0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var I4 = function(i) {
  return new Oe(i.x, i.y, i.radius);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var R4 = function(i, e) {
  return xi(i, e.x, e.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var O4 = function(i, e) {
  return xi(i, e.x, e.y) && xi(i, e.right, e.y) && xi(i, e.x, e.bottom) && xi(i, e.right, e.bottom);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var k4 = function(i, e) {
  return e.setTo(i.x, i.y, i.radius);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var L4 = function(i, e) {
  return i.x === e.x && i.y === e.y && i.radius === e.radius;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Bi = function(i, e, n) {
  return i.width <= 0 || i.height <= 0 ? !1 : i.x <= e && i.x + i.width >= e && i.y <= n && i.y + i.height >= n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sh = function(i) {
  return 2 * (i.width + i.height);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Jd = function(i, e, n) {
  if (n === void 0 && (n = new ot()), e <= 0 || e >= 1)
    return n.x = i.x, n.y = i.y, n;
  var s = sh(i) * e;
  return e > 0.5 ? (s -= i.width + i.height, s <= i.width ? (n.x = i.right - s, n.y = i.bottom) : (n.x = i.x, n.y = i.bottom - (s - i.width))) : s <= i.width ? (n.x = i.x + s, n.y = i.y) : (n.x = i.right, n.y = i.y + (s - i.width)), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var _w = function(i, e, n, s) {
  s === void 0 && (s = []), !e && n > 0 && (e = sh(i) / n);
  for (var r = 0; r < e; r++) {
    var a = r / e;
    s.push(Jd(i, a));
  }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Sw = function(i, e, n) {
  return n === void 0 && (n = new ot()), n.x = i.x1 + (i.x2 - i.x1) * e, n.y = i.y1 + (i.y2 - i.y1) * e, n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var un = function(i) {
  return Math.sqrt((i.x2 - i.x1) * (i.x2 - i.x1) + (i.y2 - i.y1) * (i.y2 - i.y1));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Tw = function(i, e, n, s) {
  s === void 0 && (s = []), !e && n > 0 && (e = un(i) / n);
  for (var r = i.x1, a = i.y1, o = i.x2, h = i.y2, c = 0; c < e; c++) {
    var l = c / e, u = r + (o - r) * l, f = a + (h - a) * l;
    s.push(new ot(u, f));
  }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ew = function(i, e) {
  e === void 0 && (e = new ot());
  var n = Math.random();
  return e.x = i.x1 + n * (i.x2 - i.x1), e.y = i.y1 + n * (i.y2 - i.y1), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var I0 = function(i, e, n) {
  return n === void 0 && (n = 1e-4), Math.abs(i - e) < n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var we = new Gt({
  initialize: function(e, n) {
    this.x = 0, this.y = 0, typeof e == "object" ? (this.x = e.x || 0, this.y = e.y || 0) : (n === void 0 && (n = e), this.x = e || 0, this.y = n || 0);
  },
  /**
   * Make a clone of this Vector2.
   *
   * @method Phaser.Math.Vector2#clone
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector2} A clone of this Vector2.
   */
  clone: function() {
    return new we(this.x, this.y);
  },
  /**
   * Copy the components of a given Vector into this Vector.
   *
   * @method Phaser.Math.Vector2#copy
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector to copy the components from.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  copy: function(i) {
    return this.x = i.x || 0, this.y = i.y || 0, this;
  },
  /**
   * Set the component values of this Vector from a given Vector2Like object.
   *
   * @method Phaser.Math.Vector2#setFromObject
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  setFromObject: function(i) {
    return this.x = i.x || 0, this.y = i.y || 0, this;
  },
  /**
   * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.
   *
   * @method Phaser.Math.Vector2#set
   * @since 3.0.0
   *
   * @param {number} x - The x value to set for this Vector.
   * @param {number} [y=x] - The y value to set for this Vector.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  set: function(i, e) {
    return e === void 0 && (e = i), this.x = i, this.y = e, this;
  },
  /**
   * This method is an alias for `Vector2.set`.
   *
   * @method Phaser.Math.Vector2#setTo
   * @since 3.4.0
   *
   * @param {number} x - The x value to set for this Vector.
   * @param {number} [y=x] - The y value to set for this Vector.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  setTo: function(i, e) {
    return this.set(i, e);
  },
  /**
   * Sets the `x` and `y` values of this object from a given polar coordinate.
   *
   * @method Phaser.Math.Vector2#setToPolar
   * @since 3.0.0
   *
   * @param {number} azimuth - The angular coordinate, in radians.
   * @param {number} [radius=1] - The radial coordinate (length).
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  setToPolar: function(i, e) {
    return e == null && (e = 1), this.x = Math.cos(i) * e, this.y = Math.sin(i) * e, this;
  },
  /**
   * Check whether this Vector is equal to a given Vector.
   *
   * Performs a strict equality check against each Vector's components.
   *
   * @method Phaser.Math.Vector2#equals
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} v - The vector to compare with this Vector.
   *
   * @return {boolean} Whether the given Vector is equal to this Vector.
   */
  equals: function(i) {
    return this.x === i.x && this.y === i.y;
  },
  /**
   * Check whether this Vector is approximately equal to a given Vector.
   *
   * @method Phaser.Math.Vector2#fuzzyEquals
   * @since 3.23.0
   *
   * @param {Phaser.Types.Math.Vector2Like} v - The vector to compare with this Vector.
   * @param {number} [epsilon=0.0001] - The tolerance value.
   *
   * @return {boolean} Whether both absolute differences of the x and y components are smaller than `epsilon`.
   */
  fuzzyEquals: function(i, e) {
    return I0(this.x, i.x, e) && I0(this.y, i.y, e);
  },
  /**
   * Calculate the angle between this Vector and the positive x-axis, in radians.
   *
   * @method Phaser.Math.Vector2#angle
   * @since 3.0.0
   *
   * @return {number} The angle between this Vector, and the positive x-axis, given in radians.
   */
  angle: function() {
    var i = Math.atan2(this.y, this.x);
    return i < 0 && (i += 2 * Math.PI), i;
  },
  /**
   * Set the angle of this Vector.
   *
   * @method Phaser.Math.Vector2#setAngle
   * @since 3.23.0
   *
   * @param {number} angle - The angle, in radians.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  setAngle: function(i) {
    return this.setToPolar(i, this.length());
  },
  /**
   * Add a given Vector to this Vector. Addition is component-wise.
   *
   * @method Phaser.Math.Vector2#add
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector to add to this Vector.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  add: function(i) {
    return this.x += i.x, this.y += i.y, this;
  },
  /**
   * Subtract the given Vector from this Vector. Subtraction is component-wise.
   *
   * @method Phaser.Math.Vector2#subtract
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector to subtract from this Vector.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  subtract: function(i) {
    return this.x -= i.x, this.y -= i.y, this;
  },
  /**
   * Perform a component-wise multiplication between this Vector and the given Vector.
   *
   * Multiplies this Vector by the given Vector.
   *
   * @method Phaser.Math.Vector2#multiply
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector to multiply this Vector by.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  multiply: function(i) {
    return this.x *= i.x, this.y *= i.y, this;
  },
  /**
   * Scale this Vector by the given value.
   *
   * @method Phaser.Math.Vector2#scale
   * @since 3.0.0
   *
   * @param {number} value - The value to scale this Vector by.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  scale: function(i) {
    return isFinite(i) ? (this.x *= i, this.y *= i) : (this.x = 0, this.y = 0), this;
  },
  /**
   * Perform a component-wise division between this Vector and the given Vector.
   *
   * Divides this Vector by the given Vector.
   *
   * @method Phaser.Math.Vector2#divide
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector to divide this Vector by.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  divide: function(i) {
    return this.x /= i.x, this.y /= i.y, this;
  },
  /**
   * Negate the `x` and `y` components of this Vector.
   *
   * @method Phaser.Math.Vector2#negate
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this;
  },
  /**
   * Calculate the distance between this Vector and the given Vector.
   *
   * @method Phaser.Math.Vector2#distance
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector to calculate the distance to.
   *
   * @return {number} The distance from this Vector to the given Vector.
   */
  distance: function(i) {
    var e = i.x - this.x, n = i.y - this.y;
    return Math.sqrt(e * e + n * n);
  },
  /**
   * Calculate the distance between this Vector and the given Vector, squared.
   *
   * @method Phaser.Math.Vector2#distanceSq
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector to calculate the distance to.
   *
   * @return {number} The distance from this Vector to the given Vector, squared.
   */
  distanceSq: function(i) {
    var e = i.x - this.x, n = i.y - this.y;
    return e * e + n * n;
  },
  /**
   * Calculate the length (or magnitude) of this Vector.
   *
   * @method Phaser.Math.Vector2#length
   * @since 3.0.0
   *
   * @return {number} The length of this Vector.
   */
  length: function() {
    var i = this.x, e = this.y;
    return Math.sqrt(i * i + e * e);
  },
  /**
   * Set the length (or magnitude) of this Vector.
   *
   * @method Phaser.Math.Vector2#setLength
   * @since 3.23.0
   *
   * @param {number} length
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  setLength: function(i) {
    return this.normalize().scale(i);
  },
  /**
   * Calculate the length of this Vector squared.
   *
   * @method Phaser.Math.Vector2#lengthSq
   * @since 3.0.0
   *
   * @return {number} The length of this Vector, squared.
   */
  lengthSq: function() {
    var i = this.x, e = this.y;
    return i * i + e * e;
  },
  /**
   * Normalize this Vector.
   *
   * Makes the vector a unit length vector (magnitude of 1) in the same direction.
   *
   * @method Phaser.Math.Vector2#normalize
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  normalize: function() {
    var i = this.x, e = this.y, n = i * i + e * e;
    return n > 0 && (n = 1 / Math.sqrt(n), this.x = i * n, this.y = e * n), this;
  },
  /**
   * Rotate this Vector to its perpendicular, in the positive direction.
   *
   * @method Phaser.Math.Vector2#normalizeRightHand
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  normalizeRightHand: function() {
    var i = this.x;
    return this.x = this.y * -1, this.y = i, this;
  },
  /**
   * Rotate this Vector to its perpendicular, in the negative direction.
   *
   * @method Phaser.Math.Vector2#normalizeLeftHand
   * @since 3.23.0
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  normalizeLeftHand: function() {
    var i = this.x;
    return this.x = this.y, this.y = i * -1, this;
  },
  /**
   * Calculate the dot product of this Vector and the given Vector.
   *
   * @method Phaser.Math.Vector2#dot
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to dot product with this Vector2.
   *
   * @return {number} The dot product of this Vector and the given Vector.
   */
  dot: function(i) {
    return this.x * i.x + this.y * i.y;
  },
  /**
   * Calculate the cross product of this Vector and the given Vector.
   *
   * @method Phaser.Math.Vector2#cross
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to cross with this Vector2.
   *
   * @return {number} The cross product of this Vector and the given Vector.
   */
  cross: function(i) {
    return this.x * i.y - this.y * i.x;
  },
  /**
   * Linearly interpolate between this Vector and the given Vector.
   *
   * Interpolates this Vector towards the given Vector.
   *
   * @method Phaser.Math.Vector2#lerp
   * @since 3.0.0
   *
   * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to interpolate towards.
   * @param {number} [t=0] - The interpolation percentage, between 0 and 1.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  lerp: function(i, e) {
    e === void 0 && (e = 0);
    var n = this.x, s = this.y;
    return this.x = n + e * (i.x - n), this.y = s + e * (i.y - s), this;
  },
  /**
   * Transform this Vector with the given Matrix.
   *
   * @method Phaser.Math.Vector2#transformMat3
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  transformMat3: function(i) {
    var e = this.x, n = this.y, s = i.val;
    return this.x = s[0] * e + s[3] * n + s[6], this.y = s[1] * e + s[4] * n + s[7], this;
  },
  /**
   * Transform this Vector with the given Matrix.
   *
   * @method Phaser.Math.Vector2#transformMat4
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  transformMat4: function(i) {
    var e = this.x, n = this.y, s = i.val;
    return this.x = s[0] * e + s[4] * n + s[12], this.y = s[1] * e + s[5] * n + s[13], this;
  },
  /**
   * Make this Vector the zero vector (0, 0).
   *
   * @method Phaser.Math.Vector2#reset
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  reset: function() {
    return this.x = 0, this.y = 0, this;
  },
  /**
   * Limit the length (or magnitude) of this Vector.
   *
   * @method Phaser.Math.Vector2#limit
   * @since 3.23.0
   *
   * @param {number} max - The maximum length.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  limit: function(i) {
    var e = this.length();
    return e && e > i && this.scale(i / e), this;
  },
  /**
   * Reflect this Vector off a line defined by a normal.
   *
   * @method Phaser.Math.Vector2#reflect
   * @since 3.23.0
   *
   * @param {Phaser.Math.Vector2} normal - A vector perpendicular to the line.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  reflect: function(i) {
    return i = i.clone().normalize(), this.subtract(i.scale(2 * this.dot(i)));
  },
  /**
   * Reflect this Vector across another.
   *
   * @method Phaser.Math.Vector2#mirror
   * @since 3.23.0
   *
   * @param {Phaser.Math.Vector2} axis - A vector to reflect across.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  mirror: function(i) {
    return this.reflect(i).negate();
  },
  /**
   * Rotate this Vector by an angle amount.
   *
   * @method Phaser.Math.Vector2#rotate
   * @since 3.23.0
   *
   * @param {number} delta - The angle to rotate by, in radians.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  rotate: function(i) {
    var e = Math.cos(i), n = Math.sin(i);
    return this.set(e * this.x - n * this.y, n * this.x + e * this.y);
  },
  /**
   * Project this Vector onto another.
   *
   * @method Phaser.Math.Vector2#project
   * @since 3.60.0
   *
   * @param {Phaser.Math.Vector2} src - The vector to project onto.
   *
   * @return {Phaser.Math.Vector2} This Vector2.
   */
  project: function(i) {
    var e = this.dot(i) / i.dot(i);
    return this.copy(i).scale(e);
  }
});
we.ZERO = new we();
we.RIGHT = new we(1, 0);
we.LEFT = new we(-1, 0);
we.UP = new we(0, -1);
we.DOWN = new we(0, 1);
we.ONE = new we(1, 1);
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Pt = new Gt({
  initialize: function(e, n, s, r) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), r === void 0 && (r = 0), this.type = Ss.LINE, this.x1 = e, this.y1 = n, this.x2 = s, this.y2 = r;
  },
  /**
   * Get a point on a line that's a given percentage along its length.
   *
   * @method Phaser.Geom.Line#getPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [output,$return]
   *
   * @param {number} position - A value between 0 and 1, where 0 is the start, 0.5 is the middle and 1 is the end of the line.
   * @param {(Phaser.Geom.Point|object)} [output] - An optional point, or point-like object, to store the coordinates of the point on the line.
   *
   * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point on the line.
   */
  getPoint: function(i, e) {
    return Sw(this, i, e);
  },
  /**
   * Get a number of points along a line's length.
   *
   * Provide a `quantity` to get an exact number of points along the line.
   *
   * Provide a `stepRate` to ensure a specific distance between each point on the line. Set `quantity` to `0` when
   * providing a `stepRate`.
   *
   * @method Phaser.Geom.Line#getPoints
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point[]} O - [output,$return]
   *
   * @param {number} quantity - The number of points to place on the line. Set to `0` to use `stepRate` instead.
   * @param {number} [stepRate] - The distance between each point on the line. When set, `quantity` is implied and should be set to `0`.
   * @param {(array|Phaser.Geom.Point[])} [output] - An optional array of Points, or point-like objects, to store the coordinates of the points on the line.
   *
   * @return {(array|Phaser.Geom.Point[])} An array of Points, or point-like objects, containing the coordinates of the points on the line.
   */
  getPoints: function(i, e, n) {
    return Tw(this, i, e, n);
  },
  /**
   * Get a random Point on the Line.
   *
   * @method Phaser.Geom.Line#getRandomPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [point,$return]
   *
   * @param {(Phaser.Geom.Point|object)} [point] - An instance of a Point to be modified.
   *
   * @return {Phaser.Geom.Point} A random Point on the Line.
   */
  getRandomPoint: function(i) {
    return Ew(this, i);
  },
  /**
   * Set new coordinates for the line endpoints.
   *
   * @method Phaser.Geom.Line#setTo
   * @since 3.0.0
   *
   * @param {number} [x1=0] - The x coordinate of the lines starting point.
   * @param {number} [y1=0] - The y coordinate of the lines starting point.
   * @param {number} [x2=0] - The x coordinate of the lines ending point.
   * @param {number} [y2=0] - The y coordinate of the lines ending point.
   *
   * @return {this} This Line object.
   */
  setTo: function(i, e, n, s) {
    return i === void 0 && (i = 0), e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), this.x1 = i, this.y1 = e, this.x2 = n, this.y2 = s, this;
  },
  /**
   * Sets this Line to match the x/y coordinates of the two given Vector2Like objects.
   *
   * @method Phaser.Geom.Line#setFromObjects
   * @since 3.70.0
   *
   * @param {Phaser.Types.Math.Vector2Like} start - Any object with public `x` and `y` properties, whose values will be assigned to the x1/y1 components of this Line.
   * @param {Phaser.Types.Math.Vector2Like} end - Any object with public `x` and `y` properties, whose values will be assigned to the x2/y2 components of this Line.
   *
   * @return {this} This Line object.
   */
  setFromObjects: function(i, e) {
    return this.x1 = i.x, this.y1 = i.y, this.x2 = e.x, this.y2 = e.y, this;
  },
  /**
   * Returns a Vector2 object that corresponds to the start of this Line.
   *
   * @method Phaser.Geom.Line#getPointA
   * @since 3.0.0
   *
   * @generic {Phaser.Math.Vector2} O - [vec2,$return]
   *
   * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
   *
   * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the start of this Line.
   */
  getPointA: function(i) {
    return i === void 0 && (i = new we()), i.set(this.x1, this.y1), i;
  },
  /**
   * Returns a Vector2 object that corresponds to the end of this Line.
   *
   * @method Phaser.Geom.Line#getPointB
   * @since 3.0.0
   *
   * @generic {Phaser.Math.Vector2} O - [vec2,$return]
   *
   * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
   *
   * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the end of this Line.
   */
  getPointB: function(i) {
    return i === void 0 && (i = new we()), i.set(this.x2, this.y2), i;
  },
  /**
   * The left position of the Line.
   *
   * @name Phaser.Geom.Line#left
   * @type {number}
   * @since 3.0.0
   */
  left: {
    get: function() {
      return Math.min(this.x1, this.x2);
    },
    set: function(i) {
      this.x1 <= this.x2 ? this.x1 = i : this.x2 = i;
    }
  },
  /**
   * The right position of the Line.
   *
   * @name Phaser.Geom.Line#right
   * @type {number}
   * @since 3.0.0
   */
  right: {
    get: function() {
      return Math.max(this.x1, this.x2);
    },
    set: function(i) {
      this.x1 > this.x2 ? this.x1 = i : this.x2 = i;
    }
  },
  /**
   * The top position of the Line.
   *
   * @name Phaser.Geom.Line#top
   * @type {number}
   * @since 3.0.0
   */
  top: {
    get: function() {
      return Math.min(this.y1, this.y2);
    },
    set: function(i) {
      this.y1 <= this.y2 ? this.y1 = i : this.y2 = i;
    }
  },
  /**
   * The bottom position of the Line.
   *
   * @name Phaser.Geom.Line#bottom
   * @type {number}
   * @since 3.0.0
   */
  bottom: {
    get: function() {
      return Math.max(this.y1, this.y2);
    },
    set: function(i) {
      this.y1 > this.y2 ? this.y1 = i : this.y2 = i;
    }
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var zw = function(i, e) {
  return e === void 0 && (e = new ot()), e.x = i.x + Math.random() * i.width, e.y = i.y + Math.random() * i.height, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var mt = new Gt({
  initialize: function(e, n, s, r) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), r === void 0 && (r = 0), this.type = Ss.RECTANGLE, this.x = e, this.y = n, this.width = s, this.height = r;
  },
  /**
   * Checks if the given point is inside the Rectangle's bounds.
   *
   * @method Phaser.Geom.Rectangle#contains
   * @since 3.0.0
   *
   * @param {number} x - The X coordinate of the point to check.
   * @param {number} y - The Y coordinate of the point to check.
   *
   * @return {boolean} `true` if the point is within the Rectangle's bounds, otherwise `false`.
   */
  contains: function(i, e) {
    return Bi(this, i, e);
  },
  /**
   * Calculates the coordinates of a point at a certain `position` on the Rectangle's perimeter.
   *
   * The `position` is a fraction between 0 and 1 which defines how far into the perimeter the point is.
   *
   * A value of 0 or 1 returns the point at the top left corner of the rectangle, while a value of 0.5 returns the point at the bottom right corner of the rectangle. Values between 0 and 0.5 are on the top or the right side and values between 0.5 and 1 are on the bottom or the left side.
   *
   * @method Phaser.Geom.Rectangle#getPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [output,$return]
   *
   * @param {number} position - The normalized distance into the Rectangle's perimeter to return.
   * @param {(Phaser.Geom.Point|object)} [output] - An object to update with the `x` and `y` coordinates of the point.
   *
   * @return {(Phaser.Geom.Point|object)} The updated `output` object, or a new Point if no `output` object was given.
   */
  getPoint: function(i, e) {
    return Jd(this, i, e);
  },
  /**
   * Returns an array of points from the perimeter of the Rectangle, each spaced out based on the quantity or step required.
   *
   * @method Phaser.Geom.Rectangle#getPoints
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point[]} O - [output,$return]
   *
   * @param {number} quantity - The number of points to return. Set to `false` or 0 to return an arbitrary number of points (`perimeter / stepRate`) evenly spaced around the Rectangle based on the `stepRate`.
   * @param {number} [stepRate] - If `quantity` is 0, determines the normalized distance between each returned point.
   * @param {(array|Phaser.Geom.Point[])} [output] - An array to which to append the points.
   *
   * @return {(array|Phaser.Geom.Point[])} The modified `output` array, or a new array if none was provided.
   */
  getPoints: function(i, e, n) {
    return _w(this, i, e, n);
  },
  /**
   * Returns a random point within the Rectangle's bounds.
   *
   * @method Phaser.Geom.Rectangle#getRandomPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [point,$return]
   *
   * @param {Phaser.Geom.Point} [point] - The object in which to store the `x` and `y` coordinates of the point.
   *
   * @return {Phaser.Geom.Point} The updated `point`, or a new Point if none was provided.
   */
  getRandomPoint: function(i) {
    return zw(this, i);
  },
  /**
   * Sets the position, width, and height of the Rectangle.
   *
   * @method Phaser.Geom.Rectangle#setTo
   * @since 3.0.0
   *
   * @param {number} x - The X coordinate of the top left corner of the Rectangle.
   * @param {number} y - The Y coordinate of the top left corner of the Rectangle.
   * @param {number} width - The width of the Rectangle.
   * @param {number} height - The height of the Rectangle.
   *
   * @return {this} This Rectangle object.
   */
  setTo: function(i, e, n, s) {
    return this.x = i, this.y = e, this.width = n, this.height = s, this;
  },
  /**
   * Resets the position, width, and height of the Rectangle to 0.
   *
   * @method Phaser.Geom.Rectangle#setEmpty
   * @since 3.0.0
   *
   * @return {this} This Rectangle object.
   */
  setEmpty: function() {
    return this.setTo(0, 0, 0, 0);
  },
  /**
   * Sets the position of the Rectangle.
   *
   * @method Phaser.Geom.Rectangle#setPosition
   * @since 3.0.0
   *
   * @param {number} x - The X coordinate of the top left corner of the Rectangle.
   * @param {number} [y=x] - The Y coordinate of the top left corner of the Rectangle.
   *
   * @return {this} This Rectangle object.
   */
  setPosition: function(i, e) {
    return e === void 0 && (e = i), this.x = i, this.y = e, this;
  },
  /**
   * Sets the width and height of the Rectangle.
   *
   * @method Phaser.Geom.Rectangle#setSize
   * @since 3.0.0
   *
   * @param {number} width - The width to set the Rectangle to.
   * @param {number} [height=width] - The height to set the Rectangle to.
   *
   * @return {this} This Rectangle object.
   */
  setSize: function(i, e) {
    return e === void 0 && (e = i), this.width = i, this.height = e, this;
  },
  /**
   * Determines if the Rectangle is empty. A Rectangle is empty if its width or height is less than or equal to 0.
   *
   * @method Phaser.Geom.Rectangle#isEmpty
   * @since 3.0.0
   *
   * @return {boolean} `true` if the Rectangle is empty. A Rectangle object is empty if its width or height is less than or equal to 0.
   */
  isEmpty: function() {
    return this.width <= 0 || this.height <= 0;
  },
  /**
   * Returns a Line object that corresponds to the top of this Rectangle.
   *
   * @method Phaser.Geom.Rectangle#getLineA
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Line} O - [line,$return]
   *
   * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
   *
   * @return {Phaser.Geom.Line} A Line object that corresponds to the top of this Rectangle.
   */
  getLineA: function(i) {
    return i === void 0 && (i = new Pt()), i.setTo(this.x, this.y, this.right, this.y), i;
  },
  /**
   * Returns a Line object that corresponds to the right of this Rectangle.
   *
   * @method Phaser.Geom.Rectangle#getLineB
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Line} O - [line,$return]
   *
   * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
   *
   * @return {Phaser.Geom.Line} A Line object that corresponds to the right of this Rectangle.
   */
  getLineB: function(i) {
    return i === void 0 && (i = new Pt()), i.setTo(this.right, this.y, this.right, this.bottom), i;
  },
  /**
   * Returns a Line object that corresponds to the bottom of this Rectangle.
   *
   * @method Phaser.Geom.Rectangle#getLineC
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Line} O - [line,$return]
   *
   * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
   *
   * @return {Phaser.Geom.Line} A Line object that corresponds to the bottom of this Rectangle.
   */
  getLineC: function(i) {
    return i === void 0 && (i = new Pt()), i.setTo(this.right, this.bottom, this.x, this.bottom), i;
  },
  /**
   * Returns a Line object that corresponds to the left of this Rectangle.
   *
   * @method Phaser.Geom.Rectangle#getLineD
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Line} O - [line,$return]
   *
   * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
   *
   * @return {Phaser.Geom.Line} A Line object that corresponds to the left of this Rectangle.
   */
  getLineD: function(i) {
    return i === void 0 && (i = new Pt()), i.setTo(this.x, this.bottom, this.x, this.y), i;
  },
  /**
   * The x coordinate of the left of the Rectangle.
   * Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
   *
   * @name Phaser.Geom.Rectangle#left
   * @type {number}
   * @since 3.0.0
   */
  left: {
    get: function() {
      return this.x;
    },
    set: function(i) {
      i >= this.right ? this.width = 0 : this.width = this.right - i, this.x = i;
    }
  },
  /**
   * The sum of the x and width properties.
   * Changing the right property of a Rectangle object has no effect on the x, y and height properties, however it does affect the width property.
   *
   * @name Phaser.Geom.Rectangle#right
   * @type {number}
   * @since 3.0.0
   */
  right: {
    get: function() {
      return this.x + this.width;
    },
    set: function(i) {
      i <= this.x ? this.width = 0 : this.width = i - this.x;
    }
  },
  /**
   * The y coordinate of the top of the Rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties.
   * However it does affect the height property, whereas changing the y value does not affect the height property.
   *
   * @name Phaser.Geom.Rectangle#top
   * @type {number}
   * @since 3.0.0
   */
  top: {
    get: function() {
      return this.y;
    },
    set: function(i) {
      i >= this.bottom ? this.height = 0 : this.height = this.bottom - i, this.y = i;
    }
  },
  /**
   * The sum of the y and height properties.
   * Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.
   *
   * @name Phaser.Geom.Rectangle#bottom
   * @type {number}
   * @since 3.0.0
   */
  bottom: {
    get: function() {
      return this.y + this.height;
    },
    set: function(i) {
      i <= this.y ? this.height = 0 : this.height = i - this.y;
    }
  },
  /**
   * The x coordinate of the center of the Rectangle.
   *
   * @name Phaser.Geom.Rectangle#centerX
   * @type {number}
   * @since 3.0.0
   */
  centerX: {
    get: function() {
      return this.x + this.width / 2;
    },
    set: function(i) {
      this.x = i - this.width / 2;
    }
  },
  /**
   * The y coordinate of the center of the Rectangle.
   *
   * @name Phaser.Geom.Rectangle#centerY
   * @type {number}
   * @since 3.0.0
   */
  centerY: {
    get: function() {
      return this.y + this.height / 2;
    },
    set: function(i) {
      this.y = i - this.height / 2;
    }
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var F4 = function(i, e) {
  return e === void 0 && (e = new mt()), e.x = i.left, e.y = i.top, e.width = i.diameter, e.height = i.diameter, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var N4 = function(i, e, n) {
  return i.x += e, i.y += n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var B4 = function(i, e) {
  return i.x += e.x, i.y += e.y, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
Oe.Area = P4;
Oe.Circumference = ww;
Oe.CircumferencePoint = Zd;
Oe.Clone = I4;
Oe.Contains = xi;
Oe.ContainsPoint = R4;
Oe.ContainsRect = O4;
Oe.CopyFrom = k4;
Oe.Equals = L4;
Oe.GetBounds = F4;
Oe.GetPoint = vw;
Oe.GetPoints = Mw;
Oe.Offset = N4;
Oe.OffsetPoint = B4;
Oe.Random = bw;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var fr = function(i, e, n) {
  if (i.width <= 0 || i.height <= 0)
    return !1;
  var s = (e - i.x) / i.width, r = (n - i.y) / i.height;
  return s *= s, r *= r, s + r < 0.25;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Qd = function(i, e, n) {
  n === void 0 && (n = new ot());
  var s = i.width / 2, r = i.height / 2;
  return n.x = i.x + s * Math.cos(e), n.y = i.y + r * Math.sin(e), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Cw = function(i, e, n) {
  n === void 0 && (n = new ot());
  var s = Ih(e, 0, ce.PI2);
  return Qd(i, s, n);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Aw = function(i) {
  var e = i.width / 2, n = i.height / 2, s = Math.pow(e - n, 2) / Math.pow(e + n, 2);
  return Math.PI * (e + n) * (1 + 3 * s / (10 + Math.sqrt(4 - 3 * s)));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Pw = function(i, e, n, s) {
  s === void 0 && (s = []), !e && n > 0 && (e = Aw(i) / n);
  for (var r = 0; r < e; r++) {
    var a = Ih(r / e, 0, ce.PI2);
    s.push(Qd(i, a));
  }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Iw = function(i, e) {
  e === void 0 && (e = new ot());
  var n = Math.random() * Math.PI * 2, s = Math.sqrt(Math.random());
  return e.x = i.x + s * Math.cos(n) * i.width / 2, e.y = i.y + s * Math.sin(n) * i.height / 2, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ne = new Gt({
  initialize: function(e, n, s, r) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), r === void 0 && (r = 0), this.type = Ss.ELLIPSE, this.x = e, this.y = n, this.width = s, this.height = r;
  },
  /**
   * Check to see if the Ellipse contains the given x / y coordinates.
   *
   * @method Phaser.Geom.Ellipse#contains
   * @since 3.0.0
   *
   * @param {number} x - The x coordinate to check within the ellipse.
   * @param {number} y - The y coordinate to check within the ellipse.
   *
   * @return {boolean} True if the coordinates are within the ellipse, otherwise false.
   */
  contains: function(i, e) {
    return fr(this, i, e);
  },
  /**
   * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse
   * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
   * at 180 degrees around the circle.
   *
   * @method Phaser.Geom.Ellipse#getPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [out,$return]
   *
   * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.
   * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.
   *
   * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the ellipse.
   */
  getPoint: function(i, e) {
    return Cw(this, i, e);
  },
  /**
   * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,
   * based on the given quantity or stepRate values.
   *
   * @method Phaser.Geom.Ellipse#getPoints
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point[]} O - [output,$return]
   *
   * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
   * @param {number} [stepRate] - Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.
   * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.
   *
   * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the ellipse.
   */
  getPoints: function(i, e, n) {
    return Pw(this, i, e, n);
  },
  /**
   * Returns a uniformly distributed random point from anywhere within the given Ellipse.
   *
   * @method Phaser.Geom.Ellipse#getRandomPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [point,$return]
   *
   * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.
   *
   * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.
   */
  getRandomPoint: function(i) {
    return Iw(this, i);
  },
  /**
   * Sets the x, y, width and height of this ellipse.
   *
   * @method Phaser.Geom.Ellipse#setTo
   * @since 3.0.0
   *
   * @param {number} x - The x position of the center of the ellipse.
   * @param {number} y - The y position of the center of the ellipse.
   * @param {number} width - The width of the ellipse.
   * @param {number} height - The height of the ellipse.
   *
   * @return {this} This Ellipse object.
   */
  setTo: function(i, e, n, s) {
    return this.x = i, this.y = e, this.width = n, this.height = s, this;
  },
  /**
   * Sets this Ellipse to be empty with a width and height of zero.
   * Does not change its position.
   *
   * @method Phaser.Geom.Ellipse#setEmpty
   * @since 3.0.0
   *
   * @return {this} This Ellipse object.
   */
  setEmpty: function() {
    return this.width = 0, this.height = 0, this;
  },
  /**
   * Sets the position of this Ellipse.
   *
   * @method Phaser.Geom.Ellipse#setPosition
   * @since 3.0.0
   *
   * @param {number} x - The x position of the center of the ellipse.
   * @param {number} y - The y position of the center of the ellipse.
   *
   * @return {this} This Ellipse object.
   */
  setPosition: function(i, e) {
    return e === void 0 && (e = i), this.x = i, this.y = e, this;
  },
  /**
   * Sets the size of this Ellipse.
   * Does not change its position.
   *
   * @method Phaser.Geom.Ellipse#setSize
   * @since 3.0.0
   *
   * @param {number} width - The width of the ellipse.
   * @param {number} [height=width] - The height of the ellipse.
   *
   * @return {this} This Ellipse object.
   */
  setSize: function(i, e) {
    return e === void 0 && (e = i), this.width = i, this.height = e, this;
  },
  /**
   * Checks to see if the Ellipse is empty: has a width or height equal to zero.
   *
   * @method Phaser.Geom.Ellipse#isEmpty
   * @since 3.0.0
   *
   * @return {boolean} True if the Ellipse is empty, otherwise false.
   */
  isEmpty: function() {
    return this.width <= 0 || this.height <= 0;
  },
  /**
   * Returns the minor radius of the ellipse. Also known as the Semi Minor Axis.
   *
   * @method Phaser.Geom.Ellipse#getMinorRadius
   * @since 3.0.0
   *
   * @return {number} The minor radius.
   */
  getMinorRadius: function() {
    return Math.min(this.width, this.height) / 2;
  },
  /**
   * Returns the major radius of the ellipse. Also known as the Semi Major Axis.
   *
   * @method Phaser.Geom.Ellipse#getMajorRadius
   * @since 3.0.0
   *
   * @return {number} The major radius.
   */
  getMajorRadius: function() {
    return Math.max(this.width, this.height) / 2;
  },
  /**
   * The left position of the Ellipse.
   *
   * @name Phaser.Geom.Ellipse#left
   * @type {number}
   * @since 3.0.0
   */
  left: {
    get: function() {
      return this.x - this.width / 2;
    },
    set: function(i) {
      this.x = i + this.width / 2;
    }
  },
  /**
   * The right position of the Ellipse.
   *
   * @name Phaser.Geom.Ellipse#right
   * @type {number}
   * @since 3.0.0
   */
  right: {
    get: function() {
      return this.x + this.width / 2;
    },
    set: function(i) {
      this.x = i - this.width / 2;
    }
  },
  /**
   * The top position of the Ellipse.
   *
   * @name Phaser.Geom.Ellipse#top
   * @type {number}
   * @since 3.0.0
   */
  top: {
    get: function() {
      return this.y - this.height / 2;
    },
    set: function(i) {
      this.y = i + this.height / 2;
    }
  },
  /**
   * The bottom position of the Ellipse.
   *
   * @name Phaser.Geom.Ellipse#bottom
   * @type {number}
   * @since 3.0.0
   */
  bottom: {
    get: function() {
      return this.y + this.height / 2;
    },
    set: function(i) {
      this.y = i - this.height / 2;
    }
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var D4 = function(i) {
  return i.isEmpty() ? 0 : i.getMajorRadius() * i.getMinorRadius() * Math.PI;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var q4 = function(i) {
  return new Ne(i.x, i.y, i.width, i.height);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $4 = function(i, e) {
  return fr(i, e.x, e.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var V4 = function(i, e) {
  return fr(i, e.x, e.y) && fr(i, e.right, e.y) && fr(i, e.x, e.bottom) && fr(i, e.right, e.bottom);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var G4 = function(i, e) {
  return e.setTo(i.x, i.y, i.width, i.height);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var U4 = function(i, e) {
  return i.x === e.x && i.y === e.y && i.width === e.width && i.height === e.height;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var W4 = function(i, e) {
  return e === void 0 && (e = new mt()), e.x = i.left, e.y = i.top, e.width = i.width, e.height = i.height, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Y4 = function(i, e, n) {
  return i.x += e, i.y += n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var j4 = function(i, e) {
  return i.x += e.x, i.y += e.y, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
Ne.Area = D4;
Ne.Circumference = Aw;
Ne.CircumferencePoint = Qd;
Ne.Clone = q4;
Ne.Contains = fr;
Ne.ContainsPoint = $4;
Ne.ContainsRect = V4;
Ne.CopyFrom = G4;
Ne.Equals = U4;
Ne.GetBounds = W4;
Ne.GetPoint = Cw;
Ne.GetPoints = Pw;
Ne.Offset = Y4;
Ne.OffsetPoint = j4;
Ne.Random = Iw;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Rw = function(i, e, n, s) {
  var r = i - n, a = e - s;
  return Math.sqrt(r * r + a * a);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ow = function(i, e) {
  return Rw(i.x, i.y, e.x, e.y) <= i.radius + e.radius;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var kw = function(i, e) {
  var n = e.width / 2, s = e.height / 2, r = Math.abs(i.x - e.x - n), a = Math.abs(i.y - e.y - s), o = n + i.radius, h = s + i.radius;
  if (r > o || a > h)
    return !1;
  if (r <= n || a <= s)
    return !0;
  var c = r - n, l = a - s, u = c * c, f = l * l, d = i.radius * i.radius;
  return u + f <= d;
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var H4 = function(i, e, n) {
  if (n === void 0 && (n = []), Ow(i, e)) {
    var s = i.x, r = i.y, a = i.radius, o = e.x, h = e.y, c = e.radius, l, u, f, d, p;
    if (r === h)
      p = (c * c - a * a - o * o + s * s) / (2 * (s - o)), l = 1, u = -2 * h, f = o * o + p * p - 2 * o * p + h * h - c * c, d = u * u - 4 * l * f, d === 0 ? n.push(new ot(p, -u / (2 * l))) : d > 0 && (n.push(new ot(p, (-u + Math.sqrt(d)) / (2 * l))), n.push(new ot(p, (-u - Math.sqrt(d)) / (2 * l))));
    else {
      var y = (s - o) / (r - h), x = (c * c - a * a - o * o + s * s - h * h + r * r) / (2 * (r - h));
      l = y * y + 1, u = 2 * r * y - 2 * x * y - 2 * s, f = s * s + r * r + x * x - a * a - 2 * r * x, d = u * u - 4 * l * f, d === 0 ? (p = -u / (2 * l), n.push(new ot(p, x - p * y))) : d > 0 && (p = (-u + Math.sqrt(d)) / (2 * l), n.push(new ot(p, x - p * y)), p = (-u - Math.sqrt(d)) / (2 * l), n.push(new ot(p, x - p * y)));
    }
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var X4 = new ot(), Bo = function(i, e, n) {
  if (n === void 0 && (n = X4), xi(e, i.x1, i.y1))
    return n.x = i.x1, n.y = i.y1, !0;
  if (xi(e, i.x2, i.y2))
    return n.x = i.x2, n.y = i.y2, !0;
  var s = i.x2 - i.x1, r = i.y2 - i.y1, a = e.x - i.x1, o = e.y - i.y1, h = s * s + r * r, c = s, l = r;
  if (h > 0) {
    var u = (a * s + o * r) / h;
    c *= u, l *= u;
  }
  n.x = i.x1 + c, n.y = i.y1 + l;
  var f = c * c + l * l;
  return f <= h && c * s + l * r >= 0 && xi(e, n.x, n.y);
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ps = function(i, e, n) {
  if (n === void 0 && (n = []), Bo(i, e)) {
    var s = i.x1, r = i.y1, a = i.x2, o = i.y2, h = e.x, c = e.y, l = e.radius, u = a - s, f = o - r, d = s - h, p = r - c, y = u * u + f * f, x = 2 * (u * d + f * p), g = d * d + p * p - l * l, m = x * x - 4 * y * g, v, w;
    if (m === 0) {
      var b = -x / (2 * y);
      v = s + b * u, w = r + b * f, b >= 0 && b <= 1 && n.push(new ot(v, w));
    } else if (m > 0) {
      var S = (-x - Math.sqrt(m)) / (2 * y);
      v = s + S * u, w = r + S * f, S >= 0 && S <= 1 && n.push(new ot(v, w));
      var E = (-x + Math.sqrt(m)) / (2 * y);
      v = s + E * u, w = r + E * f, E >= 0 && E <= 1 && n.push(new ot(v, w));
    }
  }
  return n;
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Z4 = function(i, e, n) {
  if (n === void 0 && (n = []), kw(i, e)) {
    var s = e.getLineA(), r = e.getLineB(), a = e.getLineC(), o = e.getLineD();
    ps(s, i, n), ps(r, i, n), ps(a, i, n), ps(o, i, n);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Nt = new Gt({
  initialize: function(e, n, s) {
    this.x = 0, this.y = 0, this.z = 0, typeof e == "object" ? (this.x = e.x || 0, this.y = e.y || 0, this.z = e.z || 0) : (this.x = e || 0, this.y = n || 0, this.z = s || 0);
  },
  /**
   * Set this Vector to point up.
   *
   * Sets the y component of the vector to 1, and the others to 0.
   *
   * @method Phaser.Math.Vector3#up
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  up: function() {
    return this.x = 0, this.y = 1, this.z = 0, this;
  },
  /**
   * Sets the components of this Vector to be the `Math.min` result from the given vector.
   *
   * @method Phaser.Math.Vector3#min
   * @since 3.50.0
   *
   * @param {Phaser.Math.Vector3} v - The Vector3 to check the minimum values against.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  min: function(i) {
    return this.x = Math.min(this.x, i.x), this.y = Math.min(this.y, i.y), this.z = Math.min(this.z, i.z), this;
  },
  /**
   * Sets the components of this Vector to be the `Math.max` result from the given vector.
   *
   * @method Phaser.Math.Vector3#max
   * @since 3.50.0
   *
   * @param {Phaser.Math.Vector3} v - The Vector3 to check the maximum values against.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  max: function(i) {
    return this.x = Math.max(this.x, i.x), this.y = Math.max(this.y, i.y), this.z = Math.max(this.z, i.z), this;
  },
  /**
   * Make a clone of this Vector3.
   *
   * @method Phaser.Math.Vector3#clone
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector3} A new Vector3 object containing this Vectors values.
   */
  clone: function() {
    return new Nt(this.x, this.y, this.z);
  },
  /**
   * Adds the two given Vector3s and sets the results into this Vector3.
   *
   * @method Phaser.Math.Vector3#addVectors
   * @since 3.50.0
   *
   * @param {Phaser.Math.Vector3} a - The first Vector to add.
   * @param {Phaser.Math.Vector3} b - The second Vector to add.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  addVectors: function(i, e) {
    return this.x = i.x + e.x, this.y = i.y + e.y, this.z = i.z + e.z, this;
  },
  /**
   * Subtracts the two given Vector3s and sets the results into this Vector3.
   *
   * @method Phaser.Math.Vector3#subVectors
   * @since 3.85.0
   *
   * @param {Phaser.Math.Vector3} a - The first Vector to sub.
   * @param {Phaser.Math.Vector3} b - The second Vector to sub.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  subVectors: function(i, e) {
    return this.x = i.x - e.x, this.y = i.y - e.y, this.z = i.z - e.z, this;
  },
  /**
   * Calculate the cross (vector) product of two given Vectors.
   *
   * @method Phaser.Math.Vector3#crossVectors
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} a - The first Vector to multiply.
   * @param {Phaser.Math.Vector3} b - The second Vector to multiply.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  crossVectors: function(i, e) {
    var n = i.x, s = i.y, r = i.z, a = e.x, o = e.y, h = e.z;
    return this.x = s * h - r * o, this.y = r * a - n * h, this.z = n * o - s * a, this;
  },
  /**
   * Check whether this Vector is equal to a given Vector.
   *
   * Performs a strict equality check against each Vector's components.
   *
   * @method Phaser.Math.Vector3#equals
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} v - The Vector3 to compare against.
   *
   * @return {boolean} True if the two vectors strictly match, otherwise false.
   */
  equals: function(i) {
    return this.x === i.x && this.y === i.y && this.z === i.z;
  },
  /**
   * Copy the components of a given Vector into this Vector.
   *
   * @method Phaser.Math.Vector3#copy
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} src - The Vector to copy the components from.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  copy: function(i) {
    return this.x = i.x, this.y = i.y, this.z = i.z || 0, this;
  },
  /**
   * Set the `x`, `y`, and `z` components of this Vector to the given `x`, `y`, and `z` values.
   *
   * @method Phaser.Math.Vector3#set
   * @since 3.0.0
   *
   * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y and z components.
   * @param {number} [y] - The y value to set for this Vector.
   * @param {number} [z] - The z value to set for this Vector.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  set: function(i, e, n) {
    return typeof i == "object" ? (this.x = i.x || 0, this.y = i.y || 0, this.z = i.z || 0) : (this.x = i || 0, this.y = e || 0, this.z = n || 0), this;
  },
  /**
   * Sets the components of this Vector3 from the position of the given Matrix4.
   *
   * @method Phaser.Math.Vector3#setFromMatrixPosition
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} mat4 - The Matrix4 to get the position from.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  setFromMatrixPosition: function(i) {
    return this.fromArray(i.val, 12);
  },
  /**
   * Sets the components of this Vector3 from the Matrix4 column specified.
   *
   * @method Phaser.Math.Vector3#setFromMatrixColumn
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} mat4 - The Matrix4 to get the column from.
   * @param {number} index - The column index.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  setFromMatrixColumn: function(i, e) {
    return this.fromArray(i.val, e * 4);
  },
  /**
   * Sets the components of this Vector3 from the given array, based on the offset.
   *
   * Vector3.x = array[offset]
   * Vector3.y = array[offset + 1]
   * Vector3.z = array[offset + 2]
   *
   * @method Phaser.Math.Vector3#fromArray
   * @since 3.50.0
   *
   * @param {number[]} array - The array of values to get this Vector from.
   * @param {number} [offset=0] - The offset index into the array.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  fromArray: function(i, e) {
    return e === void 0 && (e = 0), this.x = i[e], this.y = i[e + 1], this.z = i[e + 2], this;
  },
  /**
   * Add a given Vector to this Vector. Addition is component-wise.
   *
   * @method Phaser.Math.Vector3#add
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to add to this Vector.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  add: function(i) {
    return this.x += i.x, this.y += i.y, this.z += i.z || 0, this;
  },
  /**
   * Add the given value to each component of this Vector.
   *
   * @method Phaser.Math.Vector3#addScalar
   * @since 3.50.0
   *
   * @param {number} s - The amount to add to this Vector.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  addScalar: function(i) {
    return this.x += i, this.y += i, this.z += i, this;
  },
  /**
   * Add and scale a given Vector to this Vector. Addition is component-wise.
   *
   * @method Phaser.Math.Vector3#addScale
   * @since 3.50.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to add to this Vector.
   * @param {number} scale - The amount to scale `v` by.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  addScale: function(i, e) {
    return this.x += i.x * e, this.y += i.y * e, this.z += i.z * e || 0, this;
  },
  /**
   * Subtract the given Vector from this Vector. Subtraction is component-wise.
   *
   * @method Phaser.Math.Vector3#subtract
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to subtract from this Vector.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  subtract: function(i) {
    return this.x -= i.x, this.y -= i.y, this.z -= i.z || 0, this;
  },
  /**
   * Perform a component-wise multiplication between this Vector and the given Vector.
   *
   * Multiplies this Vector by the given Vector.
   *
   * @method Phaser.Math.Vector3#multiply
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to multiply this Vector by.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  multiply: function(i) {
    return this.x *= i.x, this.y *= i.y, this.z *= i.z || 1, this;
  },
  /**
   * Scale this Vector by the given value.
   *
   * @method Phaser.Math.Vector3#scale
   * @since 3.0.0
   *
   * @param {number} scale - The value to scale this Vector by.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  scale: function(i) {
    return isFinite(i) ? (this.x *= i, this.y *= i, this.z *= i) : (this.x = 0, this.y = 0, this.z = 0), this;
  },
  /**
   * Perform a component-wise division between this Vector and the given Vector.
   *
   * Divides this Vector by the given Vector.
   *
   * @method Phaser.Math.Vector3#divide
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to divide this Vector by.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  divide: function(i) {
    return this.x /= i.x, this.y /= i.y, this.z /= i.z || 1, this;
  },
  /**
   * Negate the `x`, `y` and `z` components of this Vector.
   *
   * @method Phaser.Math.Vector3#negate
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  },
  /**
   * Calculate the distance between this Vector and the given Vector.
   *
   * @method Phaser.Math.Vector3#distance
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.
   *
   * @return {number} The distance from this Vector to the given Vector.
   */
  distance: function(i) {
    var e = i.x - this.x, n = i.y - this.y, s = i.z - this.z || 0;
    return Math.sqrt(e * e + n * n + s * s);
  },
  /**
   * Calculate the distance between this Vector and the given Vector, squared.
   *
   * @method Phaser.Math.Vector3#distanceSq
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.
   *
   * @return {number} The distance from this Vector to the given Vector, squared.
   */
  distanceSq: function(i) {
    var e = i.x - this.x, n = i.y - this.y, s = i.z - this.z || 0;
    return e * e + n * n + s * s;
  },
  /**
   * Calculate the length (or magnitude) of this Vector.
   *
   * @method Phaser.Math.Vector3#length
   * @since 3.0.0
   *
   * @return {number} The length of this Vector.
   */
  length: function() {
    var i = this.x, e = this.y, n = this.z;
    return Math.sqrt(i * i + e * e + n * n);
  },
  /**
   * Calculate the length of this Vector squared.
   *
   * @method Phaser.Math.Vector3#lengthSq
   * @since 3.0.0
   *
   * @return {number} The length of this Vector, squared.
   */
  lengthSq: function() {
    var i = this.x, e = this.y, n = this.z;
    return i * i + e * e + n * n;
  },
  /**
   * Normalize this Vector.
   *
   * Makes the vector a unit length vector (magnitude of 1) in the same direction.
   *
   * @method Phaser.Math.Vector3#normalize
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  normalize: function() {
    var i = this.x, e = this.y, n = this.z, s = i * i + e * e + n * n;
    return s > 0 && (s = 1 / Math.sqrt(s), this.x = i * s, this.y = e * s, this.z = n * s), this;
  },
  /**
   * Calculate the dot product of this Vector and the given Vector.
   *
   * @method Phaser.Math.Vector3#dot
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} v - The Vector3 to dot product with this Vector3.
   *
   * @return {number} The dot product of this Vector and `v`.
   */
  dot: function(i) {
    return this.x * i.x + this.y * i.y + this.z * i.z;
  },
  /**
   * Calculate the cross (vector) product of this Vector (which will be modified) and the given Vector.
   *
   * @method Phaser.Math.Vector3#cross
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} v - The Vector to cross product with.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  cross: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.x, a = i.y, o = i.z;
    return this.x = n * o - s * a, this.y = s * r - e * o, this.z = e * a - n * r, this;
  },
  /**
   * Linearly interpolate between this Vector and the given Vector.
   *
   * Interpolates this Vector towards the given Vector.
   *
   * @method Phaser.Math.Vector3#lerp
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} v - The Vector3 to interpolate towards.
   * @param {number} [t=0] - The interpolation percentage, between 0 and 1.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  lerp: function(i, e) {
    e === void 0 && (e = 0);
    var n = this.x, s = this.y, r = this.z;
    return this.x = n + e * (i.x - n), this.y = s + e * (i.y - s), this.z = r + e * (i.z - r), this;
  },
  /**
   * Takes a Matrix3 and applies it to this Vector3.
   *
   * @method Phaser.Math.Vector3#applyMatrix3
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix3} mat3 - The Matrix3 to apply to this Vector3.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  applyMatrix3: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.val;
    return this.x = r[0] * e + r[3] * n + r[6] * s, this.y = r[1] * e + r[4] * n + r[7] * s, this.z = r[2] * e + r[5] * n + r[8] * s, this;
  },
  /**
   * Takes a Matrix4 and applies it to this Vector3.
   *
   * @method Phaser.Math.Vector3#applyMatrix4
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} mat4 - The Matrix4 to apply to this Vector3.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  applyMatrix4: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.val, a = 1 / (r[3] * e + r[7] * n + r[11] * s + r[15]);
    return this.x = (r[0] * e + r[4] * n + r[8] * s + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * s + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * s + r[14]) * a, this;
  },
  /**
   * Transform this Vector with the given Matrix.
   *
   * @method Phaser.Math.Vector3#transformMat3
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector3 with.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  transformMat3: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.val;
    return this.x = e * r[0] + n * r[3] + s * r[6], this.y = e * r[1] + n * r[4] + s * r[7], this.z = e * r[2] + n * r[5] + s * r[8], this;
  },
  /**
   * Transform this Vector with the given Matrix4.
   *
   * @method Phaser.Math.Vector3#transformMat4
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  transformMat4: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.val;
    return this.x = r[0] * e + r[4] * n + r[8] * s + r[12], this.y = r[1] * e + r[5] * n + r[9] * s + r[13], this.z = r[2] * e + r[6] * n + r[10] * s + r[14], this;
  },
  /**
   * Transforms the coordinates of this Vector3 with the given Matrix4.
   *
   * @method Phaser.Math.Vector3#transformCoordinates
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  transformCoordinates: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.val, a = e * r[0] + n * r[4] + s * r[8] + r[12], o = e * r[1] + n * r[5] + s * r[9] + r[13], h = e * r[2] + n * r[6] + s * r[10] + r[14], c = e * r[3] + n * r[7] + s * r[11] + r[15];
    return this.x = a / c, this.y = o / c, this.z = h / c, this;
  },
  /**
   * Transform this Vector with the given Quaternion.
   *
   * @method Phaser.Math.Vector3#transformQuat
   * @since 3.0.0
   *
   * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  transformQuat: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.x, a = i.y, o = i.z, h = i.w, c = h * e + a * s - o * n, l = h * n + o * e - r * s, u = h * s + r * n - a * e, f = -r * e - a * n - o * s;
    return this.x = c * h + f * -r + l * -o - u * -a, this.y = l * h + f * -a + u * -r - c * -o, this.z = u * h + f * -o + c * -a - l * -r, this;
  },
  /**
   * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,
   * e.g. unprojecting a 2D point into 3D space.
   *
   * @method Phaser.Math.Vector3#project
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} mat - The Matrix4 to multiply this Vector3 with.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  project: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.val, a = r[0], o = r[1], h = r[2], c = r[3], l = r[4], u = r[5], f = r[6], d = r[7], p = r[8], y = r[9], x = r[10], g = r[11], m = r[12], v = r[13], w = r[14], b = r[15], S = 1 / (e * c + n * d + s * g + b);
    return this.x = (e * a + n * l + s * p + m) * S, this.y = (e * o + n * u + s * y + v) * S, this.z = (e * h + n * f + s * x + w) * S, this;
  },
  /**
   * Multiplies this Vector3 by the given view and projection matrices.
   *
   * @method Phaser.Math.Vector3#projectViewMatrix
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} viewMatrix - A View Matrix.
   * @param {Phaser.Math.Matrix4} projectionMatrix - A Projection Matrix.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  projectViewMatrix: function(i, e) {
    return this.applyMatrix4(i).applyMatrix4(e);
  },
  /**
   * Multiplies this Vector3 by the given inversed projection matrix and world matrix.
   *
   * @method Phaser.Math.Vector3#unprojectViewMatrix
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} projectionMatrix - An inversed Projection Matrix.
   * @param {Phaser.Math.Matrix4} worldMatrix - A World View Matrix.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  unprojectViewMatrix: function(i, e) {
    return this.applyMatrix4(i).applyMatrix4(e);
  },
  /**
   * Unproject this point from 2D space to 3D space.
   * The point should have its x and y properties set to
   * 2D screen space, and the z either at 0 (near plane)
   * or 1 (far plane). The provided matrix is assumed to already
   * be combined, i.e. projection * view * model.
   *
   * After this operation, this vector's (x, y, z) components will
   * represent the unprojected 3D coordinate.
   *
   * @method Phaser.Math.Vector3#unproject
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector4} viewport - Screen x, y, width and height in pixels.
   * @param {Phaser.Math.Matrix4} invProjectionView - Combined projection and view matrix.
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  unproject: function(i, e) {
    var n = i.x, s = i.y, r = i.z, a = i.w, o = this.x - n, h = a - this.y - 1 - s, c = this.z;
    return this.x = 2 * o / r - 1, this.y = 2 * h / a - 1, this.z = 2 * c - 1, this.project(e);
  },
  /**
   * Make this Vector the zero vector (0, 0, 0).
   *
   * @method Phaser.Math.Vector3#reset
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector3} This Vector3.
   */
  reset: function() {
    return this.x = 0, this.y = 0, this.z = 0, this;
  }
});
Nt.ZERO = new Nt();
Nt.RIGHT = new Nt(1, 0, 0);
Nt.LEFT = new Nt(-1, 0, 0);
Nt.UP = new Nt(0, -1, 0);
Nt.DOWN = new Nt(0, 1, 0);
Nt.FORWARD = new Nt(0, 0, 1);
Nt.BACK = new Nt(0, 0, -1);
Nt.ONE = new Nt(1, 1, 1);
/**
 * @author       Richard Davey
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Lw = function(i, e, n, s) {
  n === void 0 && (n = !1);
  var r = i.x1, a = i.y1, o = i.x2, h = i.y2, c = e.x1, l = e.y1, u = e.x2, f = e.y2, d = o - r, p = h - a, y = u - c, x = f - l, g = d * x - p * y;
  if (g === 0)
    return null;
  var m, v, w;
  if (n) {
    if (m = (d * (l - a) + p * (r - c)) / (y * p - x * d), d !== 0)
      v = (c + y * m - r) / d;
    else if (p !== 0)
      v = (l + x * m - a) / p;
    else
      return null;
    if (v < 0 || m < 0 || m > 1)
      return null;
    w = v;
  } else {
    if (m = ((c - r) * x - (l - a) * y) / g, v = ((a - l) * d - (r - c) * p) / g, m < 0 || m > 1 || v < 0 || v > 1)
      return null;
    w = m;
  }
  return s === void 0 && (s = new Nt()), s.set(
    r + d * w,
    a + p * w,
    w
  );
};
/**
 * @author       Richard Davey
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Yx = new Pt(), mc = new Nt(), Fw = function(i, e, n, s) {
  n === void 0 && (n = !1), s === void 0 && (s = new Nt());
  var r = !1;
  s.set(), mc.set();
  for (var a = e[e.length - 1], o = 0; o < e.length; o++) {
    var h = e[o];
    Yx.setTo(a.x, a.y, h.x, h.y), a = h, Lw(i, Yx, n, mc) && (!r || mc.z < s.z) && (s.copy(mc), r = !0);
  }
  return r ? s : null;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Re = new Gt({
  initialize: function(e, n, s, r) {
    this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof e == "object" ? (this.x = e.x || 0, this.y = e.y || 0, this.z = e.z || 0, this.w = e.w || 0) : (this.x = e || 0, this.y = n || 0, this.z = s || 0, this.w = r || 0);
  },
  /**
   * Make a clone of this Vector4.
   *
   * @method Phaser.Math.Vector4#clone
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector4} A clone of this Vector4.
   */
  clone: function() {
    return new Re(this.x, this.y, this.z, this.w);
  },
  /**
   * Copy the components of a given Vector into this Vector.
   *
   * @method Phaser.Math.Vector4#copy
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector4} src - The Vector to copy the components from.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  copy: function(i) {
    return this.x = i.x, this.y = i.y, this.z = i.z || 0, this.w = i.w || 0, this;
  },
  /**
   * Check whether this Vector is equal to a given Vector.
   *
   * Performs a strict quality check against each Vector's components.
   *
   * @method Phaser.Math.Vector4#equals
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector4} v - The vector to check equality with.
   *
   * @return {boolean} A boolean indicating whether the two Vectors are equal or not.
   */
  equals: function(i) {
    return this.x === i.x && this.y === i.y && this.z === i.z && this.w === i.w;
  },
  /**
   * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.
   *
   * @method Phaser.Math.Vector4#set
   * @since 3.0.0
   *
   * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y, z and w components.
   * @param {number} y - The y value to set for this Vector.
   * @param {number} z - The z value to set for this Vector.
   * @param {number} w - The z value to set for this Vector.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  set: function(i, e, n, s) {
    return typeof i == "object" ? (this.x = i.x || 0, this.y = i.y || 0, this.z = i.z || 0, this.w = i.w || 0) : (this.x = i || 0, this.y = e || 0, this.z = n || 0, this.w = s || 0), this;
  },
  /**
   * Add a given Vector to this Vector. Addition is component-wise.
   *
   * @method Phaser.Math.Vector4#add
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to add to this Vector.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  add: function(i) {
    return this.x += i.x, this.y += i.y, this.z += i.z || 0, this.w += i.w || 0, this;
  },
  /**
   * Subtract the given Vector from this Vector. Subtraction is component-wise.
   *
   * @method Phaser.Math.Vector4#subtract
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to subtract from this Vector.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  subtract: function(i) {
    return this.x -= i.x, this.y -= i.y, this.z -= i.z || 0, this.w -= i.w || 0, this;
  },
  /**
   * Scale this Vector by the given value.
   *
   * @method Phaser.Math.Vector4#scale
   * @since 3.0.0
   *
   * @param {number} scale - The value to scale this Vector by.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  scale: function(i) {
    return this.x *= i, this.y *= i, this.z *= i, this.w *= i, this;
  },
  /**
   * Calculate the length (or magnitude) of this Vector.
   *
   * @method Phaser.Math.Vector4#length
   * @since 3.0.0
   *
   * @return {number} The length of this Vector.
   */
  length: function() {
    var i = this.x, e = this.y, n = this.z, s = this.w;
    return Math.sqrt(i * i + e * e + n * n + s * s);
  },
  /**
   * Calculate the length of this Vector squared.
   *
   * @method Phaser.Math.Vector4#lengthSq
   * @since 3.0.0
   *
   * @return {number} The length of this Vector, squared.
   */
  lengthSq: function() {
    var i = this.x, e = this.y, n = this.z, s = this.w;
    return i * i + e * e + n * n + s * s;
  },
  /**
   * Normalize this Vector.
   *
   * Makes the vector a unit length vector (magnitude of 1) in the same direction.
   *
   * @method Phaser.Math.Vector4#normalize
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  normalize: function() {
    var i = this.x, e = this.y, n = this.z, s = this.w, r = i * i + e * e + n * n + s * s;
    return r > 0 && (r = 1 / Math.sqrt(r), this.x = i * r, this.y = e * r, this.z = n * r, this.w = s * r), this;
  },
  /**
   * Calculate the dot product of this Vector and the given Vector.
   *
   * @method Phaser.Math.Vector4#dot
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector4} v - The Vector4 to dot product with this Vector4.
   *
   * @return {number} The dot product of this Vector and the given Vector.
   */
  dot: function(i) {
    return this.x * i.x + this.y * i.y + this.z * i.z + this.w * i.w;
  },
  /**
   * Linearly interpolate between this Vector and the given Vector.
   *
   * Interpolates this Vector towards the given Vector.
   *
   * @method Phaser.Math.Vector4#lerp
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector4} v - The Vector4 to interpolate towards.
   * @param {number} [t=0] - The interpolation percentage, between 0 and 1.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  lerp: function(i, e) {
    e === void 0 && (e = 0);
    var n = this.x, s = this.y, r = this.z, a = this.w;
    return this.x = n + e * (i.x - n), this.y = s + e * (i.y - s), this.z = r + e * (i.z - r), this.w = a + e * (i.w - a), this;
  },
  /**
   * Perform a component-wise multiplication between this Vector and the given Vector.
   *
   * Multiplies this Vector by the given Vector.
   *
   * @method Phaser.Math.Vector4#multiply
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to multiply this Vector by.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  multiply: function(i) {
    return this.x *= i.x, this.y *= i.y, this.z *= i.z || 1, this.w *= i.w || 1, this;
  },
  /**
   * Perform a component-wise division between this Vector and the given Vector.
   *
   * Divides this Vector by the given Vector.
   *
   * @method Phaser.Math.Vector4#divide
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to divide this Vector by.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  divide: function(i) {
    return this.x /= i.x, this.y /= i.y, this.z /= i.z || 1, this.w /= i.w || 1, this;
  },
  /**
   * Calculate the distance between this Vector and the given Vector.
   *
   * @method Phaser.Math.Vector4#distance
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.
   *
   * @return {number} The distance from this Vector to the given Vector.
   */
  distance: function(i) {
    var e = i.x - this.x, n = i.y - this.y, s = i.z - this.z || 0, r = i.w - this.w || 0;
    return Math.sqrt(e * e + n * n + s * s + r * r);
  },
  /**
   * Calculate the distance between this Vector and the given Vector, squared.
   *
   * @method Phaser.Math.Vector4#distanceSq
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.
   *
   * @return {number} The distance from this Vector to the given Vector, squared.
   */
  distanceSq: function(i) {
    var e = i.x - this.x, n = i.y - this.y, s = i.z - this.z || 0, r = i.w - this.w || 0;
    return e * e + n * n + s * s + r * r;
  },
  /**
   * Negate the `x`, `y`, `z` and `w` components of this Vector.
   *
   * @method Phaser.Math.Vector4#negate
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  },
  /**
   * Transform this Vector with the given Matrix.
   *
   * @method Phaser.Math.Vector4#transformMat4
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector4 with.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  transformMat4: function(i) {
    var e = this.x, n = this.y, s = this.z, r = this.w, a = i.val;
    return this.x = a[0] * e + a[4] * n + a[8] * s + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * s + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * s + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * s + a[15] * r, this;
  },
  /**
   * Transform this Vector with the given Quaternion.
   *
   * @method Phaser.Math.Vector4#transformQuat
   * @since 3.0.0
   *
   * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  transformQuat: function(i) {
    var e = this.x, n = this.y, s = this.z, r = i.x, a = i.y, o = i.z, h = i.w, c = h * e + a * s - o * n, l = h * n + o * e - r * s, u = h * s + r * n - a * e, f = -r * e - a * n - o * s;
    return this.x = c * h + f * -r + l * -o - u * -a, this.y = l * h + f * -a + u * -r - c * -o, this.z = u * h + f * -o + c * -a - l * -r, this;
  },
  /**
   * Make this Vector the zero vector (0, 0, 0, 0).
   *
   * @method Phaser.Math.Vector4#reset
   * @since 3.0.0
   *
   * @return {Phaser.Math.Vector4} This Vector4.
   */
  reset: function() {
    return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this;
  }
});
Re.prototype.sub = Re.prototype.subtract;
Re.prototype.mul = Re.prototype.multiply;
Re.prototype.div = Re.prototype.divide;
Re.prototype.dist = Re.prototype.distance;
Re.prototype.distSq = Re.prototype.distanceSq;
Re.prototype.len = Re.prototype.length;
Re.prototype.lenSq = Re.prototype.lengthSq;
/**
 * @author       Richard Davey
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var qr = new Nt(), Nw = function(i, e, n, s) {
  s === void 0 && (s = new Re()), Array.isArray(e) || (e = [e]);
  var r = !1;
  s.set(), qr.set();
  for (var a = 0; a < e.length; a++)
    Fw(i, e[a].points, n, qr) && (!r || qr.z < s.z) && (s.set(qr.x, qr.y, qr.z, a), r = !0);
  return r ? s : null;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $t = function(i, e, n) {
  var s = i.x1, r = i.y1, a = i.x2, o = i.y2, h = e.x1, c = e.y1, l = e.x2, u = e.y2;
  if (s === a && r === o || h === l && c === u)
    return !1;
  var f = (u - c) * (a - s) - (l - h) * (o - r);
  if (f === 0)
    return !1;
  var d = ((l - h) * (r - c) - (u - c) * (s - h)) / f, p = ((a - s) * (r - c) - (o - r) * (s - h)) / f;
  return d < 0 || d > 1 || p < 0 || p > 1 ? !1 : (n && (n.x = s + d * (a - s), n.y = r + d * (o - r)), !0);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Bw = function(i, e) {
  var n = i.x1, s = i.y1, r = i.x2, a = i.y2, o = e.x, h = e.y, c = e.right, l = e.bottom, u = 0;
  if (n >= o && n <= c && s >= h && s <= l || r >= o && r <= c && a >= h && a <= l)
    return !0;
  if (n < o && r >= o) {
    if (u = s + (a - s) * (o - n) / (r - n), u > h && u <= l)
      return !0;
  } else if (n > c && r <= c && (u = s + (a - s) * (c - n) / (r - n), u >= h && u <= l))
    return !0;
  if (s < h && a >= h) {
    if (u = n + (r - n) * (h - s) / (a - s), u >= o && u <= c)
      return !0;
  } else if (s > l && a <= l && (u = n + (r - n) * (l - s) / (a - s), u >= o && u <= c))
    return !0;
  return !1;
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ys = function(i, e, n) {
  if (n === void 0 && (n = []), Bw(i, e))
    for (var s = e.getLineA(), r = e.getLineB(), a = e.getLineC(), o = e.getLineD(), h = [new ot(), new ot(), new ot(), new ot()], c = [
      $t(s, i, h[0]),
      $t(r, i, h[1]),
      $t(a, i, h[2]),
      $t(o, i, h[3])
    ], l = 0; l < 4; l++)
      c[l] && n.push(h[l]);
  return n;
};
/**
 * @author       Richard Davey
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var jx = new Pt();
function hf(i, e, n, s, r) {
  var a = Math.cos(i), o = Math.sin(i);
  jx.setTo(e, n, e + a, n + o);
  var h = Nw(jx, s, !0);
  h && r.push(new Re(h.x, h.y, i, h.w));
}
function J4(i, e) {
  return i.z - e.z;
}
var Q4 = function(i, e, n) {
  Array.isArray(n) || (n = [n]);
  for (var s = [], r = [], a = 0; a < n.length; a++)
    for (var o = n[a].points, h = 0; h < o.length; h++) {
      var c = Math.atan2(o[h].y - e, o[h].x - i);
      r.indexOf(c) === -1 && (hf(c, i, e, n, s), hf(c - 1e-5, i, e, n, s), hf(c + 1e-5, i, e, n, s), r.push(c));
    }
  return s.sort(J4);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var hu = function(i, e) {
  return i.width <= 0 || i.height <= 0 || e.width <= 0 || e.height <= 0 ? !1 : !(i.right < e.x || i.bottom < e.y || i.x > e.right || i.y > e.bottom);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var K4 = function(i, e, n) {
  return n === void 0 && (n = new mt()), hu(i, e) && (n.x = Math.max(i.x, e.x), n.y = Math.max(i.y, e.y), n.width = Math.min(i.right, e.right) - n.x, n.height = Math.min(i.bottom, e.bottom) - n.y), n;
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var tI = function(i, e, n) {
  if (n === void 0 && (n = []), hu(i, e)) {
    var s = i.getLineA(), r = i.getLineB(), a = i.getLineC(), o = i.getLineD();
    ys(s, e, n), ys(r, e, n), ys(a, e, n), ys(o, e, n);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $l = function(i, e, n, s) {
  n === void 0 && (n = !1), s === void 0 && (s = []);
  for (var r = i.x3 - i.x1, a = i.y3 - i.y1, o = i.x2 - i.x1, h = i.y2 - i.y1, c = r * r + a * a, l = r * o + a * h, u = o * o + h * h, f = c * u - l * l, d = f === 0 ? 0 : 1 / f, p, y, x, g, m, v, w = i.x1, b = i.y1, S = 0; S < e.length && (x = e[S].x - w, g = e[S].y - b, m = r * x + a * g, v = o * x + h * g, p = (u * m - l * v) * d, y = (c * v - l * m) * d, !(p >= 0 && y >= 0 && p + y < 1 && (s.push({ x: e[S].x, y: e[S].y }), n))); S++)
    ;
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Dw = function(i, e) {
  return e === void 0 && (e = []), e.push({ x: i.x, y: i.y }), e.push({ x: i.right, y: i.y }), e.push({ x: i.right, y: i.bottom }), e.push({ x: i.x, y: i.bottom }), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var qw = function(i, e) {
  if (e.left > i.right || e.right < i.left || e.top > i.bottom || e.bottom < i.top)
    return !1;
  var n = e.getLineA(), s = e.getLineB(), r = e.getLineC();
  if (Bi(i, n.x1, n.y1) || Bi(i, n.x2, n.y2) || Bi(i, s.x1, s.y1) || Bi(i, s.x2, s.y2) || Bi(i, r.x1, r.y1) || Bi(i, r.x2, r.y2))
    return !0;
  var a = i.getLineA(), o = i.getLineB(), h = i.getLineC(), c = i.getLineD();
  if ($t(n, a) || $t(n, o) || $t(n, h) || $t(n, c) || $t(s, a) || $t(s, o) || $t(s, h) || $t(s, c) || $t(r, a) || $t(r, o) || $t(r, h) || $t(r, c))
    return !0;
  var l = Dw(i), u = $l(e, l, !0);
  return u.length > 0;
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var eI = function(i, e, n) {
  if (n === void 0 && (n = []), qw(i, e)) {
    var s = e.getLineA(), r = e.getLineB(), a = e.getLineC();
    ys(s, i, n), ys(r, i, n), ys(a, i, n);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var cu = function(i, e, n) {
  var s = i.x3 - i.x1, r = i.y3 - i.y1, a = i.x2 - i.x1, o = i.y2 - i.y1, h = e - i.x1, c = n - i.y1, l = s * s + r * r, u = s * a + r * o, f = s * h + r * c, d = a * a + o * o, p = a * h + o * c, y = l * d - u * u, x = y === 0 ? 0 : 1 / y, g = (d * f - u * p) * x, m = (l * p - u * f) * x;
  return g >= 0 && m >= 0 && g + m < 1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $w = function(i, e) {
  return i.left > e.right || i.right < e.left || i.top > e.bottom || i.bottom < e.top ? !1 : !!(cu(i, e.x, e.y) || Bo(i.getLineA(), e) || Bo(i.getLineB(), e) || Bo(i.getLineC(), e));
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var nI = function(i, e, n) {
  if (n === void 0 && (n = []), $w(i, e)) {
    var s = i.getLineA(), r = i.getLineB(), a = i.getLineC();
    ps(s, e, n), ps(r, e, n), ps(a, e, n);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Vw = function(i, e) {
  return !!(i.contains(e.x1, e.y1) || i.contains(e.x2, e.y2) || $t(i.getLineA(), e) || $t(i.getLineB(), e) || $t(i.getLineC(), e));
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var il = function(i, e, n) {
  if (n === void 0 && (n = []), Vw(i, e))
    for (var s = i.getLineA(), r = i.getLineB(), a = i.getLineC(), o = [new ot(), new ot(), new ot()], h = [
      $t(s, e, o[0]),
      $t(r, e, o[1]),
      $t(a, e, o[2])
    ], c = 0; c < 3; c++)
      h[c] && n.push(o[c]);
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var R0 = function(i, e) {
  return e === void 0 && (e = []), e.push({ x: i.x1, y: i.y1 }), e.push({ x: i.x2, y: i.y2 }), e.push({ x: i.x3, y: i.y3 }), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Gw = function(i, e) {
  if (i.left > e.right || i.right < e.left || i.top > e.bottom || i.bottom < e.top)
    return !1;
  var n = i.getLineA(), s = i.getLineB(), r = i.getLineC(), a = e.getLineA(), o = e.getLineB(), h = e.getLineC();
  if ($t(n, a) || $t(n, o) || $t(n, h) || $t(s, a) || $t(s, o) || $t(s, h) || $t(r, a) || $t(r, o) || $t(r, h))
    return !0;
  var c = R0(i), l = $l(e, c, !0);
  return l.length > 0 || (c = R0(e), l = $l(i, c, !0), l.length > 0);
};
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var iI = function(i, e, n) {
  if (n === void 0 && (n = []), Gw(i, e)) {
    var s = e.getLineA(), r = e.getLineB(), a = e.getLineC();
    il(i, s, n), il(i, r, n), il(i, a, n);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @author       Florian Mertens
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Uw = function(i, e, n) {
  n === void 0 && (n = 1);
  var s = e.x1, r = e.y1, a = e.x2, o = e.y2, h = i.x, c = i.y, l = (a - s) * (a - s) + (o - r) * (o - r);
  if (l === 0)
    return !1;
  var u = ((h - s) * (a - s) + (c - r) * (o - r)) / l;
  if (u < 0)
    return Math.sqrt((s - h) * (s - h) + (r - c) * (r - c)) <= n;
  if (u >= 0 && u <= 1) {
    var f = ((r - c) * (a - s) - (s - h) * (o - r)) / l;
    return Math.abs(f) * Math.sqrt(l) <= n;
  } else
    return Math.sqrt((a - h) * (a - h) + (o - c) * (o - c)) <= n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sI = function(i, e) {
  if (!Uw(i, e))
    return !1;
  var n = Math.min(e.x1, e.x2), s = Math.max(e.x1, e.x2), r = Math.min(e.y1, e.y2), a = Math.max(e.y1, e.y2);
  return i.x >= n && i.x <= s && i.y >= r && i.y <= a;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var rI = function(i, e, n, s, r, a) {
  return a === void 0 && (a = 0), !(e > i.right + a || n < i.left - a || s > i.bottom + a || r < i.top - a);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const aI = {
  CircleToCircle: Ow,
  CircleToRectangle: kw,
  GetCircleToCircle: H4,
  GetCircleToRectangle: Z4,
  GetLineToCircle: ps,
  GetLineToLine: Lw,
  GetLineToPoints: Fw,
  GetLineToPolygon: Nw,
  GetLineToRectangle: ys,
  GetRaysFromPointToPolygon: Q4,
  GetRectangleIntersection: K4,
  GetRectangleToRectangle: tI,
  GetRectangleToTriangle: eI,
  GetTriangleToCircle: nI,
  GetTriangleToLine: il,
  GetTriangleToTriangle: iI,
  LineToCircle: Bo,
  LineToLine: $t,
  LineToRectangle: Bw,
  PointToLine: Uw,
  PointToLineSegment: sI,
  RectangleToRectangle: hu,
  RectangleToTriangle: qw,
  RectangleToValues: rI,
  TriangleToCircle: $w,
  TriangleToLine: Vw,
  TriangleToTriangle: Gw
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ba = function(i) {
  return Math.atan2(i.y2 - i.y1, i.x2 - i.x1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var oI = function(i, e, n) {
  e === void 0 && (e = 1), n === void 0 && (n = []);
  var s = Math.round(i.x1), r = Math.round(i.y1), a = Math.round(i.x2), o = Math.round(i.y2), h = Math.abs(a - s), c = Math.abs(o - r), l = s < a ? 1 : -1, u = r < o ? 1 : -1, f = h - c;
  n.push({ x: s, y: r });
  for (var d = 1; !(s === a && r === o); ) {
    var p = f << 1;
    p > -c && (f -= c, s += l), p < h && (f += h, r += u), d % e === 0 && n.push({ x: s, y: r }), d++;
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var hI = function(i, e, n) {
  var s = e - (i.x1 + i.x2) / 2, r = n - (i.y1 + i.y2) / 2;
  return i.x1 += s, i.y1 += r, i.x2 += s, i.y2 += r, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var cI = function(i) {
  return new Pt(i.x1, i.y1, i.x2, i.y2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var lI = function(i, e) {
  return e.setTo(i.x1, i.y1, i.x2, i.y2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var uI = function(i, e) {
  return i.x1 === e.x1 && i.y1 === e.y1 && i.x2 === e.x2 && i.y2 === e.y2;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var fI = function(i, e, n) {
  n === void 0 && (n = e);
  var s = un(i), r = i.x2 - i.x1, a = i.y2 - i.y1;
  return e && (i.x1 = i.x1 - r / s * e, i.y1 = i.y1 - a / s * e), n && (i.x2 = i.x2 + r / s * n, i.y2 = i.y2 + a / s * n), i;
};
/**
 * @author       samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var O0 = function(i, e) {
  var n = i.x - e.x, s = i.y - e.y;
  return Math.sqrt(n * n + s * s);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var dI = function(i, e) {
  return e === void 0 && (e = 1.70158), i * i * ((e + 1) * i - e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var pI = function(i, e) {
  return e === void 0 && (e = 1.70158), --i * i * ((e + 1) * i + e) + 1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var yI = function(i, e) {
  e === void 0 && (e = 1.70158);
  var n = e * 1.525;
  return (i *= 2) < 1 ? 0.5 * (i * i * ((n + 1) * i - n)) : 0.5 * ((i -= 2) * i * ((n + 1) * i + n) + 2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const vo = {
  In: dI,
  Out: pI,
  InOut: yI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xI = function(i) {
  return i = 1 - i, i < 1 / 2.75 ? 1 - 7.5625 * i * i : i < 2 / 2.75 ? 1 - (7.5625 * (i -= 1.5 / 2.75) * i + 0.75) : i < 2.5 / 2.75 ? 1 - (7.5625 * (i -= 2.25 / 2.75) * i + 0.9375) : 1 - (7.5625 * (i -= 2.625 / 2.75) * i + 0.984375);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var gI = function(i) {
  return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var mI = function(i) {
  var e = !1;
  return i < 0.5 ? (i = 1 - i * 2, e = !0) : i = i * 2 - 1, i < 1 / 2.75 ? i = 7.5625 * i * i : i < 2 / 2.75 ? i = 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? i = 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : i = 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375, e ? (1 - i) * 0.5 : i * 0.5 + 0.5;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const wo = {
  In: xI,
  Out: gI,
  InOut: mI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vI = function(i) {
  return 1 - Math.sqrt(1 - i * i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var wI = function(i) {
  return Math.sqrt(1 - --i * i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var MI = function(i) {
  return (i *= 2) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const Mo = {
  In: vI,
  Out: wI,
  InOut: MI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var bI = function(i) {
  return i * i * i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var _I = function(i) {
  return --i * i * i + 1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var SI = function(i) {
  return (i *= 2) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const aa = {
  In: bI,
  Out: _I,
  InOut: SI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var TI = function(i, e, n) {
  if (e === void 0 && (e = 0.1), n === void 0 && (n = 0.1), i === 0)
    return 0;
  if (i === 1)
    return 1;
  var s = n / 4;
  return e < 1 ? e = 1 : s = n * Math.asin(1 / e) / (2 * Math.PI), -(e * Math.pow(2, 10 * (i -= 1)) * Math.sin((i - s) * (2 * Math.PI) / n));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var EI = function(i, e, n) {
  if (e === void 0 && (e = 0.1), n === void 0 && (n = 0.1), i === 0)
    return 0;
  if (i === 1)
    return 1;
  var s = n / 4;
  return e < 1 ? e = 1 : s = n * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * i) * Math.sin((i - s) * (2 * Math.PI) / n) + 1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var zI = function(i, e, n) {
  if (e === void 0 && (e = 0.1), n === void 0 && (n = 0.1), i === 0)
    return 0;
  if (i === 1)
    return 1;
  var s = n / 4;
  return e < 1 ? e = 1 : s = n * Math.asin(1 / e) / (2 * Math.PI), (i *= 2) < 1 ? -0.5 * (e * Math.pow(2, 10 * (i -= 1)) * Math.sin((i - s) * (2 * Math.PI) / n)) : e * Math.pow(2, -10 * (i -= 1)) * Math.sin((i - s) * (2 * Math.PI) / n) * 0.5 + 1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const bo = {
  In: TI,
  Out: EI,
  InOut: zI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var CI = function(i) {
  return Math.pow(2, 10 * (i - 1)) - 1e-3;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var AI = function(i) {
  return 1 - Math.pow(2, -10 * i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var PI = function(i) {
  return (i *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (i - 1)) : 0.5 * (2 - Math.pow(2, -10 * (i - 1)));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const _o = {
  In: CI,
  Out: AI,
  InOut: PI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var k0 = function(i) {
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var II = function(i) {
  return i * i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var RI = function(i) {
  return i * (2 - i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var OI = function(i) {
  return (i *= 2) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const oa = {
  In: II,
  Out: RI,
  InOut: OI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var kI = function(i) {
  return i * i * i * i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var LI = function(i) {
  return 1 - --i * i * i * i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var FI = function(i) {
  return (i *= 2) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const ha = {
  In: kI,
  Out: LI,
  InOut: FI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var NI = function(i) {
  return i * i * i * i * i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var BI = function(i) {
  return --i * i * i * i * i + 1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var DI = function(i) {
  return (i *= 2) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const ca = {
  In: NI,
  Out: BI,
  InOut: DI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var qI = function(i) {
  return i === 0 ? 0 : i === 1 ? 1 : 1 - Math.cos(i * Math.PI / 2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $I = function(i) {
  return i === 0 ? 0 : i === 1 ? 1 : Math.sin(i * Math.PI / 2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var VI = function(i) {
  return i === 0 ? 0 : i === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * i));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const So = {
  In: qI,
  Out: $I,
  InOut: VI
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ww = function(i, e) {
  return e === void 0 && (e = 1), i <= 0 ? 0 : i >= 1 ? 1 : ((e * i | 0) + 1) * (1 / e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const eo = {
  Power0: k0,
  Power1: oa.Out,
  Power2: aa.Out,
  Power3: ha.Out,
  Power4: ca.Out,
  Linear: k0,
  Quad: oa.Out,
  Cubic: aa.Out,
  Quart: ha.Out,
  Quint: ca.Out,
  Sine: So.Out,
  Expo: _o.Out,
  Circ: Mo.Out,
  Elastic: bo.Out,
  Back: vo.Out,
  Bounce: wo.Out,
  Stepped: Ww,
  "Quad.easeIn": oa.In,
  "Cubic.easeIn": aa.In,
  "Quart.easeIn": ha.In,
  "Quint.easeIn": ca.In,
  "Sine.easeIn": So.In,
  "Expo.easeIn": _o.In,
  "Circ.easeIn": Mo.In,
  "Elastic.easeIn": bo.In,
  "Back.easeIn": vo.In,
  "Bounce.easeIn": wo.In,
  "Quad.easeOut": oa.Out,
  "Cubic.easeOut": aa.Out,
  "Quart.easeOut": ha.Out,
  "Quint.easeOut": ca.Out,
  "Sine.easeOut": So.Out,
  "Expo.easeOut": _o.Out,
  "Circ.easeOut": Mo.Out,
  "Elastic.easeOut": bo.Out,
  "Back.easeOut": vo.Out,
  "Bounce.easeOut": wo.Out,
  "Quad.easeInOut": oa.InOut,
  "Cubic.easeInOut": aa.InOut,
  "Quart.easeInOut": ha.InOut,
  "Quint.easeInOut": ca.InOut,
  "Sine.easeInOut": So.InOut,
  "Expo.easeInOut": _o.InOut,
  "Circ.easeInOut": Mo.InOut,
  "Elastic.easeInOut": bo.InOut,
  "Back.easeInOut": vo.InOut,
  "Bounce.easeInOut": wo.InOut
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Yw = function(i) {
  return i && i[0].toUpperCase() + i.slice(1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Rh = function(i, e) {
  var n = eo.Power0;
  if (typeof i == "string")
    if (eo.hasOwnProperty(i))
      n = eo[i];
    else {
      var s = "";
      if (i.indexOf(".")) {
        s = i.substring(i.indexOf(".") + 1);
        var r = s.toLowerCase();
        r === "in" ? s = "easeIn" : r === "out" ? s = "easeOut" : r === "inout" && (s = "easeInOut");
      }
      i = Yw(i.substring(0, i.indexOf(".") + 1) + s), eo.hasOwnProperty(i) && (n = eo[i]);
    }
  else typeof i == "function" && (n = i);
  if (!e)
    return n;
  var a = e.slice(0);
  return a.unshift(0), function(o) {
    return a[0] = o, n.apply(this, a);
  };
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var GI = function(i, e, n, s, r) {
  s === void 0 && (s = 0), r === void 0 && (r = []);
  var a = [], o = i.x1, h = i.y1, c = i.x2 - o, l = i.y2 - h, u = Rh(e, r), f, d, p = n - 1;
  for (f = 0; f < p; f++)
    d = u(f / p), a.push(new ot(o + c * d, h + l * d));
  if (d = u(1), a.push(new ot(o + c * d, h + l * d)), s > 0) {
    var y = a[0], x = [y];
    for (f = 1; f < a.length - 1; f++) {
      var g = a[f];
      O0(y, g) >= s && (x.push(g), y = g);
    }
    var m = a[a.length - 1];
    return O0(y, m) < s && x.pop(), x.push(m), x;
  } else
    return a;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var UI = function(i, e) {
  return e === void 0 && (e = new ot()), e.x = (i.x1 + i.x2) / 2, e.y = (i.y1 + i.y2) / 2, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @author       Florian Mertens
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var WI = function(i, e, n) {
  n === void 0 && (n = new ot());
  var s = i.x1, r = i.y1, a = i.x2, o = i.y2, h = (a - s) * (a - s) + (o - r) * (o - r);
  if (h === 0)
    return n;
  var c = ((e.x - s) * (a - s) + (e.y - r) * (o - r)) / h;
  return n.x = s + c * (a - s), n.y = r + c * (o - r), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var YI = function(i, e) {
  e === void 0 && (e = new ot());
  var n = Ba(i) - ce.TAU;
  return e.x = Math.cos(n), e.y = Math.sin(n), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @author       Florian Mertens
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var jI = function(i, e) {
  var n = i.x1, s = i.y1, r = i.x2, a = i.y2, o = (r - n) * (r - n) + (a - s) * (a - s);
  if (o === 0)
    return !1;
  var h = ((s - e.y) * (r - n) - (n - e.x) * (a - s)) / o;
  return Math.abs(h) * Math.sqrt(o);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var HI = function(i) {
  return Math.abs(i.y1 - i.y2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var lu = function(i, e, n) {
  var s = n - e;
  return e + ((i - e) % s + s) % s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var jw = function(i) {
  var e = Ba(i) - ce.TAU;
  return lu(e, -Math.PI, Math.PI);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var XI = function(i) {
  return Math.cos(Ba(i) - ce.TAU);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ZI = function(i) {
  return Math.sin(Ba(i) - ce.TAU);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var JI = function(i, e, n) {
  return i.x1 += e, i.y1 += n, i.x2 += e, i.y2 += n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var QI = function(i) {
  return -((i.x2 - i.x1) / (i.y2 - i.y1));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var KI = function(i, e) {
  return 2 * jw(e) - Math.PI - Ba(i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Kd = function(i, e, n, s) {
  var r = Math.cos(s), a = Math.sin(s), o = i.x1 - e, h = i.y1 - n;
  return i.x1 = o * r - h * a + e, i.y1 = o * a + h * r + n, o = i.x2 - e, h = i.y2 - n, i.x2 = o * r - h * a + e, i.y2 = o * a + h * r + n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var tR = function(i, e) {
  var n = (i.x1 + i.x2) / 2, s = (i.y1 + i.y2) / 2;
  return Kd(i, n, s, e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var eR = function(i, e, n) {
  return Kd(i, e.x, e.y, n);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var nR = function(i, e, n, s, r) {
  return i.x1 = e, i.y1 = n, i.x2 = e + Math.cos(s) * r, i.y2 = n + Math.sin(s) * r, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var iR = function(i) {
  return (i.y2 - i.y1) / (i.x2 - i.x1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sR = function(i) {
  return Math.abs(i.x1 - i.x2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
Pt.Angle = Ba;
Pt.BresenhamPoints = oI;
Pt.CenterOn = hI;
Pt.Clone = cI;
Pt.CopyFrom = lI;
Pt.Equals = uI;
Pt.Extend = fI;
Pt.GetEasedPoints = GI;
Pt.GetMidPoint = UI;
Pt.GetNearestPoint = WI;
Pt.GetNormal = YI;
Pt.GetPoint = Sw;
Pt.GetPoints = Tw;
Pt.GetShortestDistance = jI;
Pt.Height = HI;
Pt.Length = un;
Pt.NormalAngle = jw;
Pt.NormalX = XI;
Pt.NormalY = ZI;
Pt.Offset = JI;
Pt.PerpSlope = QI;
Pt.Random = Ew;
Pt.ReflectAngle = KI;
Pt.Rotate = tR;
Pt.RotateAroundPoint = eR;
Pt.RotateAroundXY = Kd;
Pt.SetToAngle = nR;
Pt.Slope = iR;
Pt.Width = sR;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function cf(i, e, n, s) {
  var r = i - n, a = e - s, o = r * r + a * a;
  return Math.sqrt(o);
}
var rh = new Gt({
  initialize: function(e, n, s) {
    this.vertex1 = e, this.vertex2 = n, this.vertex3 = s, this.bounds = new mt(), this._inCenter = new we();
  },
  /**
   * Calculates and returns the in-center position of this Face.
   *
   * @method Phaser.Geom.Mesh.Face#getInCenter
   * @since 3.50.0
   *
   * @param {boolean} [local=true] Return the in center from the un-transformed vertex positions (`true`), or transformed? (`false`)
   *
   * @return {Phaser.Math.Vector2} A Vector2 containing the in center position of this Face.
   */
  getInCenter: function(i) {
    i === void 0 && (i = !0);
    var e = this.vertex1, n = this.vertex2, s = this.vertex3, r, a, o, h, c, l;
    i ? (r = e.x, a = e.y, o = n.x, h = n.y, c = s.x, l = s.y) : (r = e.vx, a = e.vy, o = n.vx, h = n.vy, c = s.vx, l = s.vy);
    var u = cf(c, l, o, h), f = cf(r, a, c, l), d = cf(o, h, r, a), p = u + f + d;
    return this._inCenter.set(
      (r * u + o * f + c * d) / p,
      (a * u + h * f + l * d) / p
    );
  },
  /**
   * Checks if the given coordinates are within this Face.
   *
   * You can optionally provide a transform matrix. If given, the Face vertices
   * will be transformed first, before being checked against the coordinates.
   *
   * @method Phaser.Geom.Mesh.Face#contains
   * @since 3.50.0
   *
   * @param {number} x - The horizontal position to check.
   * @param {number} y - The vertical position to check.
   * @param {Phaser.GameObjects.Components.TransformMatrix} [calcMatrix] - Optional transform matrix to apply to the vertices before comparison.
   *
   * @return {boolean} `true` if the coordinates lay within this Face, otherwise `false`.
   */
  contains: function(i, e, n) {
    var s = this.vertex1, r = this.vertex2, a = this.vertex3, o = s.vx, h = s.vy, c = r.vx, l = r.vy, u = a.vx, f = a.vy;
    if (n) {
      var d = n.a, p = n.b, y = n.c, x = n.d, g = n.e, m = n.f;
      o = s.vx * d + s.vy * y + g, h = s.vx * p + s.vy * x + m, c = r.vx * d + r.vy * y + g, l = r.vx * p + r.vy * x + m, u = a.vx * d + a.vy * y + g, f = a.vx * p + a.vy * x + m;
    }
    var v = u - o, w = f - h, b = c - o, S = l - h, E = i - o, A = e - h, M = v * v + w * w, _ = v * b + w * S, T = v * E + w * A, C = b * b + S * S, P = b * E + S * A, R = M * C - _ * _, k = R === 0 ? 0 : 1 / R, I = (C * T - _ * P) * k, L = (M * P - _ * T) * k;
    return I >= 0 && L >= 0 && I + L < 1;
  },
  /**
   * Checks if the vertices in this Face are orientated counter-clockwise, or not.
   *
   * It checks the transformed position of the vertices, not the local one.
   *
   * @method Phaser.Geom.Mesh.Face#isCounterClockwise
   * @since 3.50.0
   *
   * @param {number} z - The z-axis value to test against. Typically the `Mesh.modelPosition.z`.
   *
   * @return {boolean} `true` if the vertices in this Face run counter-clockwise, otherwise `false`.
   */
  isCounterClockwise: function(i) {
    var e = this.vertex1, n = this.vertex2, s = this.vertex3, r = (n.vx - e.vx) * (s.vy - e.vy) - (n.vy - e.vy) * (s.vx - e.vx);
    return i <= 0 ? r >= 0 : r < 0;
  },
  /**
   * Loads the data from this Vertex into the given Typed Arrays.
   *
   * @method Phaser.Geom.Mesh.Face#load
   * @since 3.50.0
   *
   * @param {Float32Array} F32 - A Float32 Array to insert the position, UV and unit data in to.
   * @param {Uint32Array} U32 - A Uint32 Array to insert the color and alpha data in to.
   * @param {number} offset - The index of the array to insert this Vertex to.
   * @param {number} textureUnit - The texture unit currently in use.
   * @param {number} tintEffect - The tint effect to use.
   *
   * @return {number} The new vertex index array offset.
   */
  load: function(i, e, n, s, r) {
    return n = this.vertex1.load(i, e, n, s, r), n = this.vertex2.load(i, e, n, s, r), n = this.vertex3.load(i, e, n, s, r), n;
  },
  /**
   * Transforms all Face vertices by the given matrix, storing the results in their `vx`, `vy` and `vz` properties.
   *
   * @method Phaser.Geom.Mesh.Face#transformCoordinatesLocal
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} transformMatrix - The transform matrix to apply to this vertex.
   * @param {number} width - The width of the parent Mesh.
   * @param {number} height - The height of the parent Mesh.
   * @param {number} cameraZ - The z position of the MeshCamera.
   *
   * @return {this} This Face instance.
   */
  transformCoordinatesLocal: function(i, e, n, s) {
    return this.vertex1.transformCoordinatesLocal(i, e, n, s), this.vertex2.transformCoordinatesLocal(i, e, n, s), this.vertex3.transformCoordinatesLocal(i, e, n, s), this;
  },
  /**
   * Updates the bounds of this Face, based on the translated values of the vertices.
   *
   * Call this method prior to accessing the `Face.bounds` property.
   *
   * @method Phaser.Geom.Mesh.Face#updateBounds
   * @since 3.50.0
   *
   * @return {this} This Face instance.
   */
  updateBounds: function() {
    var i = this.vertex1, e = this.vertex2, n = this.vertex3, s = this.bounds;
    return s.x = Math.min(i.vx, e.vx, n.vx), s.y = Math.min(i.vy, e.vy, n.vy), s.width = Math.max(i.vx, e.vx, n.vx) - s.x, s.height = Math.max(i.vy, e.vy, n.vy) - s.y, this;
  },
  /**
   * Checks if this Face is within the view of the given Camera.
   *
   * This method is called in the `MeshWebGLRenderer` function. It performs the following tasks:
   *
   * First, the `Vertex.update` method is called on each of the vertices. This populates them
   * with the new translated values, updating their `tx`, `ty` and `ta` properties.
   *
   * Then it tests to see if this face is visible due to the alpha values, if not, it returns.
   *
   * After this, if `hideCCW` is set, it calls `isCounterClockwise` and returns if not.
   *
   * Finally, it will update the `Face.bounds` based on the newly translated vertex values
   * and return the results of an intersection test between the bounds and the camera world view
   * rectangle.
   *
   * @method Phaser.Geom.Mesh.Face#isInView
   * @since 3.50.0
   *
   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against.
   * @param {boolean} hideCCW - Test the counter-clockwise orientation of the verts?
   * @param {number} z - The Cameras z position, used in the CCW test.
   * @param {number} alpha - The alpha of the parent object.
   * @param {number} a - The parent transform matrix data a component.
   * @param {number} b - The parent transform matrix data b component.
   * @param {number} c - The parent transform matrix data c component.
   * @param {number} d - The parent transform matrix data d component.
   * @param {number} e - The parent transform matrix data e component.
   * @param {number} f - The parent transform matrix data f component.
   * @param {boolean} roundPixels - Round the vertex position or not?
   *
   * @return {boolean} `true` if this Face can be seen by the Camera.
   */
  isInView: function(i, e, n, s, r, a, o, h, c, l, u) {
    this.update(s, r, a, o, h, c, l, u);
    var f = this.vertex1, d = this.vertex2, p = this.vertex3;
    if (f.ta <= 0 && d.ta <= 0 && p.ta <= 0 || e && !this.isCounterClockwise(n))
      return !1;
    var y = this.bounds;
    y.x = Math.min(f.tx, d.tx, p.tx), y.y = Math.min(f.ty, d.ty, p.ty), y.width = Math.max(f.tx, d.tx, p.tx) - y.x, y.height = Math.max(f.ty, d.ty, p.ty) - y.y;
    var x = i.x + i.width, g = i.y + i.height;
    return y.width <= 0 || y.height <= 0 || i.width <= 0 || i.height <= 0 ? !1 : !(y.right < i.x || y.bottom < i.y || y.x > x || y.y > g);
  },
  /**
   * Translates the original UV positions of each vertex by the given amounts.
   *
   * The original properties `Vertex.u` and `Vertex.v`
   * remain unchanged, only the translated properties
   * `Vertex.tu` and `Vertex.tv`, as used in rendering,
   * are updated.
   *
   * @method Phaser.Geom.Mesh.Face#scrollUV
   * @since 3.60.0
   *
   * @param {number} x - The amount to scroll the UV u coordinate by.
   * @param {number} y - The amount to scroll the UV v coordinate by.
   *
   * @return {this} This Face instance.
   */
  scrollUV: function(i, e) {
    return this.vertex1.scrollUV(i, e), this.vertex2.scrollUV(i, e), this.vertex3.scrollUV(i, e), this;
  },
  /**
   * Scales the original UV values of each vertex by the given amounts.
   *
   * The original properties `Vertex.u` and `Vertex.v`
   * remain unchanged, only the translated properties
   * `Vertex.tu` and `Vertex.tv`, as used in rendering,
   * are updated.
   *
   * @method Phaser.Geom.Mesh.Face#scaleUV
   * @since 3.60.0
   *
   * @param {number} x - The amount to scale the UV u coordinate by.
   * @param {number} y - The amount to scale the UV v coordinate by.
   *
   * @return {this} This Face instance.
   */
  scaleUV: function(i, e) {
    return this.vertex1.scaleUV(i, e), this.vertex2.scaleUV(i, e), this.vertex3.scaleUV(i, e), this;
  },
  /**
   * Sets the color value for each Vertex in this Face.
   *
   * @method Phaser.Geom.Mesh.Face#setColor
   * @since 3.60.0
   *
   * @param {number} color - The color value for each vertex.
   *
   * @return {this} This Face instance.
   */
  setColor: function(i) {
    return this.vertex1.color = i, this.vertex2.color = i, this.vertex3.color = i, this;
  },
  /**
   * Calls the `Vertex.update` method on each of the vertices. This populates them
   * with the new translated values, updating their `tx`, `ty` and `ta` properties.
   *
   * @method Phaser.Geom.Mesh.Face#update
   * @since 3.60.0
   *
   * @param {number} alpha - The alpha of the parent object.
   * @param {number} a - The parent transform matrix data a component.
   * @param {number} b - The parent transform matrix data b component.
   * @param {number} c - The parent transform matrix data c component.
   * @param {number} d - The parent transform matrix data d component.
   * @param {number} e - The parent transform matrix data e component.
   * @param {number} f - The parent transform matrix data f component.
   * @param {boolean} roundPixels - Round the vertex position or not?
   *
   * @return {this} This Face instance.
   */
  update: function(i, e, n, s, r, a, o, h) {
    return this.vertex1.update(e, n, s, r, a, o, h, i), this.vertex2.update(e, n, s, r, a, o, h, i), this.vertex3.update(e, n, s, r, a, o, h, i), this;
  },
  /**
   * Translates the vertices of this Face by the given amounts.
   *
   * The actual vertex positions are adjusted, not their transformed position.
   *
   * Therefore, this updates the vertex data directly.
   *
   * @method Phaser.Geom.Mesh.Face#translate
   * @since 3.50.0
   *
   * @param {number} x - The amount to horizontally translate by.
   * @param {number} [y=0] - The amount to vertically translate by.
   *
   * @return {this} This Face instance.
   */
  translate: function(i, e) {
    e === void 0 && (e = 0);
    var n = this.vertex1, s = this.vertex2, r = this.vertex3;
    return n.x += i, n.y += e, s.x += i, s.y += e, r.x += i, r.y += e, this;
  },
  /**
   * The x coordinate of this Face, based on the in center position of the Face.
   *
   * @name Phaser.Geom.Mesh.Face#x
   * @type {number}
   * @since 3.50.0
   */
  x: {
    get: function() {
      return this.getInCenter().x;
    },
    set: function(i) {
      var e = this.getInCenter();
      this.translate(i - e.x, 0);
    }
  },
  /**
   * The y coordinate of this Face, based on the in center position of the Face.
   *
   * @name Phaser.Geom.Mesh.Face#y
   * @type {number}
   * @since 3.50.0
   */
  y: {
    get: function() {
      return this.getInCenter().y;
    },
    set: function(i) {
      var e = this.getInCenter();
      this.translate(0, i - e.y);
    }
  },
  /**
   * Set the alpha value of this Face.
   *
   * Each vertex is given the same value. If you need to adjust the alpha on a per-vertex basis
   * then use the `Vertex.alpha` property instead.
   *
   * When getting the alpha of this Face, it will return an average of the alpha
   * component of all three vertices.
   *
   * @name Phaser.Geom.Mesh.Face#alpha
   * @type {number}
   * @since 3.50.0
   */
  alpha: {
    get: function() {
      var i = this.vertex1, e = this.vertex2, n = this.vertex3;
      return (i.alpha + e.alpha + n.alpha) / 3;
    },
    set: function(i) {
      this.vertex1.alpha = i, this.vertex2.alpha = i, this.vertex3.alpha = i;
    }
  },
  /**
   * The depth of this Face, which is an average of the z component of all three vertices.
   *
   * The depth is calculated based on the transformed z value, not the local one.
   *
   * @name Phaser.Geom.Mesh.Face#depth
   * @type {number}
   * @readonly
   * @since 3.50.0
   */
  depth: {
    get: function() {
      var i = this.vertex1, e = this.vertex2, n = this.vertex3;
      return (i.vz + e.vz + n.vz) / 3;
    }
  },
  /**
   * Destroys this Face and nulls the references to the vertices.
   *
   * @method Phaser.Geom.Mesh.Face#destroy
   * @since 3.50.0
   */
  destroy: function() {
    this.vertex1 = null, this.vertex2 = null, this.vertex3 = null;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xt = function(i, e, n) {
  var s = typeof i;
  return !i || s === "number" || s === "string" ? n : i.hasOwnProperty(e) && i[e] !== void 0 ? i[e] : n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vc = 1e-6, Ts = new Gt({
  initialize: function(e) {
    this.val = new Float32Array(16), e ? this.copy(e) : this.identity();
  },
  /**
   * Make a clone of this Matrix4.
   *
   * @method Phaser.Math.Matrix4#clone
   * @since 3.0.0
   *
   * @return {Phaser.Math.Matrix4} A clone of this Matrix4.
   */
  clone: function() {
    return new Ts(this);
  },
  /**
   * This method is an alias for `Matrix4.copy`.
   *
   * @method Phaser.Math.Matrix4#set
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} src - The Matrix to set the values of this Matrix's from.
   *
   * @return {this} This Matrix4.
   */
  set: function(i) {
    return this.copy(i);
  },
  /**
   * Sets all values of this Matrix4.
   *
   * @method Phaser.Math.Matrix4#setValues
   * @since 3.50.0
   *
   * @param {number} m00 - The m00 value.
   * @param {number} m01 - The m01 value.
   * @param {number} m02 - The m02 value.
   * @param {number} m03 - The m03 value.
   * @param {number} m10 - The m10 value.
   * @param {number} m11 - The m11 value.
   * @param {number} m12 - The m12 value.
   * @param {number} m13 - The m13 value.
   * @param {number} m20 - The m20 value.
   * @param {number} m21 - The m21 value.
   * @param {number} m22 - The m22 value.
   * @param {number} m23 - The m23 value.
   * @param {number} m30 - The m30 value.
   * @param {number} m31 - The m31 value.
   * @param {number} m32 - The m32 value.
   * @param {number} m33 - The m33 value.
   *
   * @return {this} This Matrix4 instance.
   */
  setValues: function(i, e, n, s, r, a, o, h, c, l, u, f, d, p, y, x) {
    var g = this.val;
    return g[0] = i, g[1] = e, g[2] = n, g[3] = s, g[4] = r, g[5] = a, g[6] = o, g[7] = h, g[8] = c, g[9] = l, g[10] = u, g[11] = f, g[12] = d, g[13] = p, g[14] = y, g[15] = x, this;
  },
  /**
   * Copy the values of a given Matrix into this Matrix.
   *
   * @method Phaser.Math.Matrix4#copy
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} src - The Matrix to copy the values from.
   *
   * @return {this} This Matrix4.
   */
  copy: function(i) {
    var e = i.val;
    return this.setValues(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
  },
  /**
   * Set the values of this Matrix from the given array.
   *
   * @method Phaser.Math.Matrix4#fromArray
   * @since 3.0.0
   *
   * @param {number[]} a - The array to copy the values from. Must have at least 16 elements.
   *
   * @return {this} This Matrix4.
   */
  fromArray: function(i) {
    return this.setValues(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
  },
  /**
   * Reset this Matrix.
   *
   * Sets all values to `0`.
   *
   * @method Phaser.Math.Matrix4#zero
   * @since 3.0.0
   *
   * @return {Phaser.Math.Matrix4} This Matrix4.
   */
  zero: function() {
    return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  },
  /**
   * Generates a transform matrix based on the given position, scale and rotation.
   *
   * @method Phaser.Math.Matrix4#transform
   * @since 3.50.0
   *
   * @param {Phaser.Math.Vector3} position - The position vector.
   * @param {Phaser.Math.Vector3} scale - The scale vector.
   * @param {Phaser.Math.Quaternion} rotation - The rotation quaternion.
   *
   * @return {this} This Matrix4.
   */
  transform: function(i, e, n) {
    var s = $r.fromQuat(n), r = s.val, a = e.x, o = e.y, h = e.z;
    return this.setValues(
      r[0] * a,
      r[1] * a,
      r[2] * a,
      0,
      r[4] * o,
      r[5] * o,
      r[6] * o,
      0,
      r[8] * h,
      r[9] * h,
      r[10] * h,
      0,
      i.x,
      i.y,
      i.z,
      1
    );
  },
  /**
   * Set the `x`, `y` and `z` values of this Matrix.
   *
   * @method Phaser.Math.Matrix4#xyz
   * @since 3.0.0
   *
   * @param {number} x - The x value.
   * @param {number} y - The y value.
   * @param {number} z - The z value.
   *
   * @return {this} This Matrix4.
   */
  xyz: function(i, e, n) {
    this.identity();
    var s = this.val;
    return s[12] = i, s[13] = e, s[14] = n, this;
  },
  /**
   * Set the scaling values of this Matrix.
   *
   * @method Phaser.Math.Matrix4#scaling
   * @since 3.0.0
   *
   * @param {number} x - The x scaling value.
   * @param {number} y - The y scaling value.
   * @param {number} z - The z scaling value.
   *
   * @return {this} This Matrix4.
   */
  scaling: function(i, e, n) {
    this.zero();
    var s = this.val;
    return s[0] = i, s[5] = e, s[10] = n, s[15] = 1, this;
  },
  /**
   * Reset this Matrix to an identity (default) matrix.
   *
   * @method Phaser.Math.Matrix4#identity
   * @since 3.0.0
   *
   * @return {this} This Matrix4.
   */
  identity: function() {
    return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  },
  /**
   * Transpose this Matrix.
   *
   * @method Phaser.Math.Matrix4#transpose
   * @since 3.0.0
   *
   * @return {this} This Matrix4.
   */
  transpose: function() {
    var i = this.val, e = i[1], n = i[2], s = i[3], r = i[6], a = i[7], o = i[11];
    return i[1] = i[4], i[2] = i[8], i[3] = i[12], i[4] = e, i[6] = i[9], i[7] = i[13], i[8] = n, i[9] = r, i[11] = i[14], i[12] = s, i[13] = a, i[14] = o, this;
  },
  /**
   * Copies the given Matrix4 into this Matrix and then inverses it.
   *
   * @method Phaser.Math.Matrix4#getInverse
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} m - The Matrix4 to invert into this Matrix4.
   *
   * @return {this} This Matrix4.
   */
  getInverse: function(i) {
    return this.copy(i), this.invert();
  },
  /**
   * Invert this Matrix.
   *
   * @method Phaser.Math.Matrix4#invert
   * @since 3.0.0
   *
   * @return {this} This Matrix4.
   */
  invert: function() {
    var i = this.val, e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], h = i[6], c = i[7], l = i[8], u = i[9], f = i[10], d = i[11], p = i[12], y = i[13], x = i[14], g = i[15], m = e * o - n * a, v = e * h - s * a, w = e * c - r * a, b = n * h - s * o, S = n * c - r * o, E = s * c - r * h, A = l * y - u * p, M = l * x - f * p, _ = l * g - d * p, T = u * x - f * y, C = u * g - d * y, P = f * g - d * x, R = m * P - v * C + w * T + b * _ - S * M + E * A;
    return R ? (R = 1 / R, this.setValues(
      (o * P - h * C + c * T) * R,
      (s * C - n * P - r * T) * R,
      (y * E - x * S + g * b) * R,
      (f * S - u * E - d * b) * R,
      (h * _ - a * P - c * M) * R,
      (e * P - s * _ + r * M) * R,
      (x * w - p * E - g * v) * R,
      (l * E - f * w + d * v) * R,
      (a * C - o * _ + c * A) * R,
      (n * _ - e * C - r * A) * R,
      (p * S - y * w + g * m) * R,
      (u * w - l * S - d * m) * R,
      (o * M - a * T - h * A) * R,
      (e * T - n * M + s * A) * R,
      (y * v - p * b - x * m) * R,
      (l * b - u * v + f * m) * R
    )) : this;
  },
  /**
   * Calculate the adjoint, or adjugate, of this Matrix.
   *
   * @method Phaser.Math.Matrix4#adjoint
   * @since 3.0.0
   *
   * @return {this} This Matrix4.
   */
  adjoint: function() {
    var i = this.val, e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], h = i[6], c = i[7], l = i[8], u = i[9], f = i[10], d = i[11], p = i[12], y = i[13], x = i[14], g = i[15];
    return this.setValues(
      o * (f * g - d * x) - u * (h * g - c * x) + y * (h * d - c * f),
      -(n * (f * g - d * x) - u * (s * g - r * x) + y * (s * d - r * f)),
      n * (h * g - c * x) - o * (s * g - r * x) + y * (s * c - r * h),
      -(n * (h * d - c * f) - o * (s * d - r * f) + u * (s * c - r * h)),
      -(a * (f * g - d * x) - l * (h * g - c * x) + p * (h * d - c * f)),
      e * (f * g - d * x) - l * (s * g - r * x) + p * (s * d - r * f),
      -(e * (h * g - c * x) - a * (s * g - r * x) + p * (s * c - r * h)),
      e * (h * d - c * f) - a * (s * d - r * f) + l * (s * c - r * h),
      a * (u * g - d * y) - l * (o * g - c * y) + p * (o * d - c * u),
      -(e * (u * g - d * y) - l * (n * g - r * y) + p * (n * d - r * u)),
      e * (o * g - c * y) - a * (n * g - r * y) + p * (n * c - r * o),
      -(e * (o * d - c * u) - a * (n * d - r * u) + l * (n * c - r * o)),
      -(a * (u * x - f * y) - l * (o * x - h * y) + p * (o * f - h * u)),
      e * (u * x - f * y) - l * (n * x - s * y) + p * (n * f - s * u),
      -(e * (o * x - h * y) - a * (n * x - s * y) + p * (n * h - s * o)),
      e * (o * f - h * u) - a * (n * f - s * u) + l * (n * h - s * o)
    );
  },
  /**
   * Calculate the determinant of this Matrix.
   *
   * @method Phaser.Math.Matrix4#determinant
   * @since 3.0.0
   *
   * @return {number} The determinant of this Matrix.
   */
  determinant: function() {
    var i = this.val, e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], h = i[6], c = i[7], l = i[8], u = i[9], f = i[10], d = i[11], p = i[12], y = i[13], x = i[14], g = i[15], m = e * o - n * a, v = e * h - s * a, w = e * c - r * a, b = n * h - s * o, S = n * c - r * o, E = s * c - r * h, A = l * y - u * p, M = l * x - f * p, _ = l * g - d * p, T = u * x - f * y, C = u * g - d * y, P = f * g - d * x;
    return m * P - v * C + w * T + b * _ - S * M + E * A;
  },
  /**
   * Multiply this Matrix by the given Matrix.
   *
   * @method Phaser.Math.Matrix4#multiply
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} src - The Matrix to multiply this Matrix by.
   *
   * @return {this} This Matrix4.
   */
  multiply: function(i) {
    var e = this.val, n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = e[9], d = e[10], p = e[11], y = e[12], x = e[13], g = e[14], m = e[15], v = i.val, w = v[0], b = v[1], S = v[2], E = v[3];
    return e[0] = w * n + b * o + S * u + E * y, e[1] = w * s + b * h + S * f + E * x, e[2] = w * r + b * c + S * d + E * g, e[3] = w * a + b * l + S * p + E * m, w = v[4], b = v[5], S = v[6], E = v[7], e[4] = w * n + b * o + S * u + E * y, e[5] = w * s + b * h + S * f + E * x, e[6] = w * r + b * c + S * d + E * g, e[7] = w * a + b * l + S * p + E * m, w = v[8], b = v[9], S = v[10], E = v[11], e[8] = w * n + b * o + S * u + E * y, e[9] = w * s + b * h + S * f + E * x, e[10] = w * r + b * c + S * d + E * g, e[11] = w * a + b * l + S * p + E * m, w = v[12], b = v[13], S = v[14], E = v[15], e[12] = w * n + b * o + S * u + E * y, e[13] = w * s + b * h + S * f + E * x, e[14] = w * r + b * c + S * d + E * g, e[15] = w * a + b * l + S * p + E * m, this;
  },
  /**
   * Multiply the values of this Matrix4 by those given in the `src` argument.
   *
   * @method Phaser.Math.Matrix4#multiplyLocal
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} src - The source Matrix4 that this Matrix4 is multiplied by.
   *
   * @return {this} This Matrix4.
   */
  multiplyLocal: function(i) {
    var e = this.val, n = i.val;
    return this.setValues(
      e[0] * n[0] + e[1] * n[4] + e[2] * n[8] + e[3] * n[12],
      e[0] * n[1] + e[1] * n[5] + e[2] * n[9] + e[3] * n[13],
      e[0] * n[2] + e[1] * n[6] + e[2] * n[10] + e[3] * n[14],
      e[0] * n[3] + e[1] * n[7] + e[2] * n[11] + e[3] * n[15],
      e[4] * n[0] + e[5] * n[4] + e[6] * n[8] + e[7] * n[12],
      e[4] * n[1] + e[5] * n[5] + e[6] * n[9] + e[7] * n[13],
      e[4] * n[2] + e[5] * n[6] + e[6] * n[10] + e[7] * n[14],
      e[4] * n[3] + e[5] * n[7] + e[6] * n[11] + e[7] * n[15],
      e[8] * n[0] + e[9] * n[4] + e[10] * n[8] + e[11] * n[12],
      e[8] * n[1] + e[9] * n[5] + e[10] * n[9] + e[11] * n[13],
      e[8] * n[2] + e[9] * n[6] + e[10] * n[10] + e[11] * n[14],
      e[8] * n[3] + e[9] * n[7] + e[10] * n[11] + e[11] * n[15],
      e[12] * n[0] + e[13] * n[4] + e[14] * n[8] + e[15] * n[12],
      e[12] * n[1] + e[13] * n[5] + e[14] * n[9] + e[15] * n[13],
      e[12] * n[2] + e[13] * n[6] + e[14] * n[10] + e[15] * n[14],
      e[12] * n[3] + e[13] * n[7] + e[14] * n[11] + e[15] * n[15]
    );
  },
  /**
   * Multiplies the given Matrix4 object with this Matrix.
   *
   * This is the same as calling `multiplyMatrices(m, this)`.
   *
   * @method Phaser.Math.Matrix4#premultiply
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} m - The Matrix4 to multiply with this one.
   *
   * @return {this} This Matrix4.
   */
  premultiply: function(i) {
    return this.multiplyMatrices(i, this);
  },
  /**
   * Multiplies the two given Matrix4 objects and stores the results in this Matrix.
   *
   * @method Phaser.Math.Matrix4#multiplyMatrices
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} a - The first Matrix4 to multiply.
   * @param {Phaser.Math.Matrix4} b - The second Matrix4 to multiply.
   *
   * @return {this} This Matrix4.
   */
  multiplyMatrices: function(i, e) {
    var n = i.val, s = e.val, r = n[0], a = n[4], o = n[8], h = n[12], c = n[1], l = n[5], u = n[9], f = n[13], d = n[2], p = n[6], y = n[10], x = n[14], g = n[3], m = n[7], v = n[11], w = n[15], b = s[0], S = s[4], E = s[8], A = s[12], M = s[1], _ = s[5], T = s[9], C = s[13], P = s[2], R = s[6], k = s[10], I = s[14], L = s[3], F = s[7], B = s[11], V = s[15];
    return this.setValues(
      r * b + a * M + o * P + h * L,
      c * b + l * M + u * P + f * L,
      d * b + p * M + y * P + x * L,
      g * b + m * M + v * P + w * L,
      r * S + a * _ + o * R + h * F,
      c * S + l * _ + u * R + f * F,
      d * S + p * _ + y * R + x * F,
      g * S + m * _ + v * R + w * F,
      r * E + a * T + o * k + h * B,
      c * E + l * T + u * k + f * B,
      d * E + p * T + y * k + x * B,
      g * E + m * T + v * k + w * B,
      r * A + a * C + o * I + h * V,
      c * A + l * C + u * I + f * V,
      d * A + p * C + y * I + x * V,
      g * A + m * C + v * I + w * V
    );
  },
  /**
   * Translate this Matrix using the given Vector.
   *
   * @method Phaser.Math.Matrix4#translate
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.
   *
   * @return {this} This Matrix4.
   */
  translate: function(i) {
    return this.translateXYZ(i.x, i.y, i.z);
  },
  /**
   * Translate this Matrix using the given values.
   *
   * @method Phaser.Math.Matrix4#translateXYZ
   * @since 3.16.0
   *
   * @param {number} x - The x component.
   * @param {number} y - The y component.
   * @param {number} z - The z component.
   *
   * @return {this} This Matrix4.
   */
  translateXYZ: function(i, e, n) {
    var s = this.val;
    return s[12] = s[0] * i + s[4] * e + s[8] * n + s[12], s[13] = s[1] * i + s[5] * e + s[9] * n + s[13], s[14] = s[2] * i + s[6] * e + s[10] * n + s[14], s[15] = s[3] * i + s[7] * e + s[11] * n + s[15], this;
  },
  /**
   * Apply a scale transformation to this Matrix.
   *
   * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.
   *
   * @method Phaser.Math.Matrix4#scale
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.
   *
   * @return {this} This Matrix4.
   */
  scale: function(i) {
    return this.scaleXYZ(i.x, i.y, i.z);
  },
  /**
   * Apply a scale transformation to this Matrix.
   *
   * @method Phaser.Math.Matrix4#scaleXYZ
   * @since 3.16.0
   *
   * @param {number} x - The x component.
   * @param {number} y - The y component.
   * @param {number} z - The z component.
   *
   * @return {this} This Matrix4.
   */
  scaleXYZ: function(i, e, n) {
    var s = this.val;
    return s[0] = s[0] * i, s[1] = s[1] * i, s[2] = s[2] * i, s[3] = s[3] * i, s[4] = s[4] * e, s[5] = s[5] * e, s[6] = s[6] * e, s[7] = s[7] * e, s[8] = s[8] * n, s[9] = s[9] * n, s[10] = s[10] * n, s[11] = s[11] * n, this;
  },
  /**
   * Derive a rotation matrix around the given axis.
   *
   * @method Phaser.Math.Matrix4#makeRotationAxis
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - The rotation axis.
   * @param {number} angle - The rotation angle in radians.
   *
   * @return {this} This Matrix4.
   */
  makeRotationAxis: function(i, e) {
    var n = Math.cos(e), s = Math.sin(e), r = 1 - n, a = i.x, o = i.y, h = i.z, c = r * a, l = r * o;
    return this.setValues(
      c * a + n,
      c * o - s * h,
      c * h + s * o,
      0,
      c * o + s * h,
      l * o + n,
      l * h - s * a,
      0,
      c * h - s * o,
      l * h + s * a,
      r * h * h + n,
      0,
      0,
      0,
      0,
      1
    );
  },
  /**
   * Apply a rotation transformation to this Matrix.
   *
   * @method Phaser.Math.Matrix4#rotate
   * @since 3.0.0
   *
   * @param {number} rad - The angle in radians to rotate by.
   * @param {Phaser.Math.Vector3} axis - The axis to rotate upon.
   *
   * @return {this} This Matrix4.
   */
  rotate: function(i, e) {
    var n = this.val, s = e.x, r = e.y, a = e.z, o = Math.sqrt(s * s + r * r + a * a);
    if (Math.abs(o) < vc)
      return this;
    o = 1 / o, s *= o, r *= o, a *= o;
    var h = Math.sin(i), c = Math.cos(i), l = 1 - c, u = n[0], f = n[1], d = n[2], p = n[3], y = n[4], x = n[5], g = n[6], m = n[7], v = n[8], w = n[9], b = n[10], S = n[11], E = n[12], A = n[13], M = n[14], _ = n[15], T = s * s * l + c, C = r * s * l + a * h, P = a * s * l - r * h, R = s * r * l - a * h, k = r * r * l + c, I = a * r * l + s * h, L = s * a * l + r * h, F = r * a * l - s * h, B = a * a * l + c;
    return this.setValues(
      u * T + y * C + v * P,
      f * T + x * C + w * P,
      d * T + g * C + b * P,
      p * T + m * C + S * P,
      u * R + y * k + v * I,
      f * R + x * k + w * I,
      d * R + g * k + b * I,
      p * R + m * k + S * I,
      u * L + y * F + v * B,
      f * L + x * F + w * B,
      d * L + g * F + b * B,
      p * L + m * F + S * B,
      E,
      A,
      M,
      _
    );
  },
  /**
   * Rotate this matrix on its X axis.
   *
   * @method Phaser.Math.Matrix4#rotateX
   * @since 3.0.0
   *
   * @param {number} rad - The angle in radians to rotate by.
   *
   * @return {this} This Matrix4.
   */
  rotateX: function(i) {
    var e = this.val, n = Math.sin(i), s = Math.cos(i), r = e[4], a = e[5], o = e[6], h = e[7], c = e[8], l = e[9], u = e[10], f = e[11];
    return e[4] = r * s + c * n, e[5] = a * s + l * n, e[6] = o * s + u * n, e[7] = h * s + f * n, e[8] = c * s - r * n, e[9] = l * s - a * n, e[10] = u * s - o * n, e[11] = f * s - h * n, this;
  },
  /**
   * Rotate this matrix on its Y axis.
   *
   * @method Phaser.Math.Matrix4#rotateY
   * @since 3.0.0
   *
   * @param {number} rad - The angle to rotate by, in radians.
   *
   * @return {this} This Matrix4.
   */
  rotateY: function(i) {
    var e = this.val, n = Math.sin(i), s = Math.cos(i), r = e[0], a = e[1], o = e[2], h = e[3], c = e[8], l = e[9], u = e[10], f = e[11];
    return e[0] = r * s - c * n, e[1] = a * s - l * n, e[2] = o * s - u * n, e[3] = h * s - f * n, e[8] = r * n + c * s, e[9] = a * n + l * s, e[10] = o * n + u * s, e[11] = h * n + f * s, this;
  },
  /**
   * Rotate this matrix on its Z axis.
   *
   * @method Phaser.Math.Matrix4#rotateZ
   * @since 3.0.0
   *
   * @param {number} rad - The angle to rotate by, in radians.
   *
   * @return {this} This Matrix4.
   */
  rotateZ: function(i) {
    var e = this.val, n = Math.sin(i), s = Math.cos(i), r = e[0], a = e[1], o = e[2], h = e[3], c = e[4], l = e[5], u = e[6], f = e[7];
    return e[0] = r * s + c * n, e[1] = a * s + l * n, e[2] = o * s + u * n, e[3] = h * s + f * n, e[4] = c * s - r * n, e[5] = l * s - a * n, e[6] = u * s - o * n, e[7] = f * s - h * n, this;
  },
  /**
   * Set the values of this Matrix from the given rotation Quaternion and translation Vector.
   *
   * @method Phaser.Math.Matrix4#fromRotationTranslation
   * @since 3.0.0
   *
   * @param {Phaser.Math.Quaternion} q - The Quaternion to set rotation from.
   * @param {Phaser.Math.Vector3} v - The Vector to set translation from.
   *
   * @return {this} This Matrix4.
   */
  fromRotationTranslation: function(i, e) {
    var n = i.x, s = i.y, r = i.z, a = i.w, o = n + n, h = s + s, c = r + r, l = n * o, u = n * h, f = n * c, d = s * h, p = s * c, y = r * c, x = a * o, g = a * h, m = a * c;
    return this.setValues(
      1 - (d + y),
      u + m,
      f - g,
      0,
      u - m,
      1 - (l + y),
      p + x,
      0,
      f + g,
      p - x,
      1 - (l + d),
      0,
      e.x,
      e.y,
      e.z,
      1
    );
  },
  /**
   * Set the values of this Matrix from the given Quaternion.
   *
   * @method Phaser.Math.Matrix4#fromQuat
   * @since 3.0.0
   *
   * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.
   *
   * @return {this} This Matrix4.
   */
  fromQuat: function(i) {
    var e = i.x, n = i.y, s = i.z, r = i.w, a = e + e, o = n + n, h = s + s, c = e * a, l = e * o, u = e * h, f = n * o, d = n * h, p = s * h, y = r * a, x = r * o, g = r * h;
    return this.setValues(
      1 - (f + p),
      l + g,
      u - x,
      0,
      l - g,
      1 - (c + p),
      d + y,
      0,
      u + x,
      d - y,
      1 - (c + f),
      0,
      0,
      0,
      0,
      1
    );
  },
  /**
   * Generate a frustum matrix with the given bounds.
   *
   * @method Phaser.Math.Matrix4#frustum
   * @since 3.0.0
   *
   * @param {number} left - The left bound of the frustum.
   * @param {number} right - The right bound of the frustum.
   * @param {number} bottom - The bottom bound of the frustum.
   * @param {number} top - The top bound of the frustum.
   * @param {number} near - The near bound of the frustum.
   * @param {number} far - The far bound of the frustum.
   *
   * @return {this} This Matrix4.
   */
  frustum: function(i, e, n, s, r, a) {
    var o = 1 / (e - i), h = 1 / (s - n), c = 1 / (r - a);
    return this.setValues(
      r * 2 * o,
      0,
      0,
      0,
      0,
      r * 2 * h,
      0,
      0,
      (e + i) * o,
      (s + n) * h,
      (a + r) * c,
      -1,
      0,
      0,
      a * r * 2 * c,
      0
    );
  },
  /**
   * Generate a perspective projection matrix with the given bounds.
   *
   * @method Phaser.Math.Matrix4#perspective
   * @since 3.0.0
   *
   * @param {number} fovy - Vertical field of view in radians
   * @param {number} aspect - Aspect ratio. Typically viewport width  /height.
   * @param {number} near - Near bound of the frustum.
   * @param {number} far - Far bound of the frustum.
   *
   * @return {this} This Matrix4.
   */
  perspective: function(i, e, n, s) {
    var r = 1 / Math.tan(i / 2), a = 1 / (n - s);
    return this.setValues(
      r / e,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      (s + n) * a,
      -1,
      0,
      0,
      2 * s * n * a,
      0
    );
  },
  /**
   * Generate a perspective projection matrix with the given bounds.
   *
   * @method Phaser.Math.Matrix4#perspectiveLH
   * @since 3.0.0
   *
   * @param {number} width - The width of the frustum.
   * @param {number} height - The height of the frustum.
   * @param {number} near - Near bound of the frustum.
   * @param {number} far - Far bound of the frustum.
   *
   * @return {this} This Matrix4.
   */
  perspectiveLH: function(i, e, n, s) {
    return this.setValues(
      2 * n / i,
      0,
      0,
      0,
      0,
      2 * n / e,
      0,
      0,
      0,
      0,
      -s / (n - s),
      1,
      0,
      0,
      n * s / (n - s),
      0
    );
  },
  /**
   * Generate an orthogonal projection matrix with the given bounds.
   *
   * @method Phaser.Math.Matrix4#ortho
   * @since 3.0.0
   *
   * @param {number} left - The left bound of the frustum.
   * @param {number} right - The right bound of the frustum.
   * @param {number} bottom - The bottom bound of the frustum.
   * @param {number} top - The top bound of the frustum.
   * @param {number} near - The near bound of the frustum.
   * @param {number} far - The far bound of the frustum.
   *
   * @return {this} This Matrix4.
   */
  ortho: function(i, e, n, s, r, a) {
    var o = i - e, h = n - s, c = r - a;
    return o = o === 0 ? o : 1 / o, h = h === 0 ? h : 1 / h, c = c === 0 ? c : 1 / c, this.setValues(
      -2 * o,
      0,
      0,
      0,
      0,
      -2 * h,
      0,
      0,
      0,
      0,
      2 * c,
      0,
      (i + e) * o,
      (s + n) * h,
      (a + r) * c,
      1
    );
  },
  /**
   * Generate a right-handed look-at matrix with the given eye position, target and up axis.
   *
   * @method Phaser.Math.Matrix4#lookAtRH
   * @since 3.50.0
   *
   * @param {Phaser.Math.Vector3} eye - Position of the viewer.
   * @param {Phaser.Math.Vector3} target - Point the viewer is looking at.
   * @param {Phaser.Math.Vector3} up - vec3 pointing up.
   *
   * @return {this} This Matrix4.
   */
  lookAtRH: function(i, e, n) {
    var s = this.val;
    return xn.subVectors(i, e), xn.lengthSq() === 0 && (xn.z = 1), xn.normalize(), Ki.crossVectors(n, xn), Ki.lengthSq() === 0 && (Math.abs(n.z) === 1 ? xn.x += 1e-4 : xn.z += 1e-4, xn.normalize(), Ki.crossVectors(n, xn)), Ki.normalize(), wc.crossVectors(xn, Ki), s[0] = Ki.x, s[1] = Ki.y, s[2] = Ki.z, s[4] = wc.x, s[5] = wc.y, s[6] = wc.z, s[8] = xn.x, s[9] = xn.y, s[10] = xn.z, this;
  },
  /**
   * Generate a look-at matrix with the given eye position, focal point, and up axis.
   *
   * @method Phaser.Math.Matrix4#lookAt
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} eye - Position of the viewer
   * @param {Phaser.Math.Vector3} center - Point the viewer is looking at
   * @param {Phaser.Math.Vector3} up - vec3 pointing up.
   *
   * @return {this} This Matrix4.
   */
  lookAt: function(i, e, n) {
    var s = i.x, r = i.y, a = i.z, o = n.x, h = n.y, c = n.z, l = e.x, u = e.y, f = e.z;
    if (Math.abs(s - l) < vc && Math.abs(r - u) < vc && Math.abs(a - f) < vc)
      return this.identity();
    var d = s - l, p = r - u, y = a - f, x = 1 / Math.sqrt(d * d + p * p + y * y);
    d *= x, p *= x, y *= x;
    var g = h * y - c * p, m = c * d - o * y, v = o * p - h * d;
    x = Math.sqrt(g * g + m * m + v * v), x ? (x = 1 / x, g *= x, m *= x, v *= x) : (g = 0, m = 0, v = 0);
    var w = p * v - y * m, b = y * g - d * v, S = d * m - p * g;
    return x = Math.sqrt(w * w + b * b + S * S), x ? (x = 1 / x, w *= x, b *= x, S *= x) : (w = 0, b = 0, S = 0), this.setValues(
      g,
      w,
      d,
      0,
      m,
      b,
      p,
      0,
      v,
      S,
      y,
      0,
      -(g * s + m * r + v * a),
      -(w * s + b * r + S * a),
      -(d * s + p * r + y * a),
      1
    );
  },
  /**
   * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.
   *
   * @method Phaser.Math.Matrix4#yawPitchRoll
   * @since 3.0.0
   *
   * @param {number} yaw - The yaw value.
   * @param {number} pitch - The pitch value.
   * @param {number} roll - The roll value.
   *
   * @return {this} This Matrix4.
   */
  yawPitchRoll: function(i, e, n) {
    this.zero(), $r.zero(), no.zero();
    var s = this.val, r = $r.val, a = no.val, o = Math.sin(n), h = Math.cos(n);
    return s[10] = 1, s[15] = 1, s[0] = h, s[1] = o, s[4] = -o, s[5] = h, o = Math.sin(e), h = Math.cos(e), r[0] = 1, r[15] = 1, r[5] = h, r[10] = h, r[9] = -o, r[6] = o, o = Math.sin(i), h = Math.cos(i), a[5] = 1, a[15] = 1, a[0] = h, a[2] = -o, a[8] = o, a[10] = h, this.multiplyLocal($r), this.multiplyLocal(no), this;
  },
  /**
   * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.
   *
   * @method Phaser.Math.Matrix4#setWorldMatrix
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} rotation - The rotation of the world matrix.
   * @param {Phaser.Math.Vector3} position - The position of the world matrix.
   * @param {Phaser.Math.Vector3} scale - The scale of the world matrix.
   * @param {Phaser.Math.Matrix4} [viewMatrix] - The view matrix.
   * @param {Phaser.Math.Matrix4} [projectionMatrix] - The projection matrix.
   *
   * @return {this} This Matrix4.
   */
  setWorldMatrix: function(i, e, n, s, r) {
    return this.yawPitchRoll(i.y, i.x, i.z), $r.scaling(n.x, n.y, n.z), no.xyz(e.x, e.y, e.z), this.multiplyLocal($r), this.multiplyLocal(no), s && this.multiplyLocal(s), r && this.multiplyLocal(r), this;
  },
  /**
   * Multiplies this Matrix4 by the given `src` Matrix4 and stores the results in the `out` Matrix4.
   *
   * @method Phaser.Math.Matrix4#multiplyToMat4
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} src - The Matrix4 to multiply with this one.
   * @param {Phaser.Math.Matrix4} out - The receiving Matrix.
   *
   * @return {Phaser.Math.Matrix4} This `out` Matrix4.
   */
  multiplyToMat4: function(i, e) {
    var n = this.val, s = i.val, r = n[0], a = n[1], o = n[2], h = n[3], c = n[4], l = n[5], u = n[6], f = n[7], d = n[8], p = n[9], y = n[10], x = n[11], g = n[12], m = n[13], v = n[14], w = n[15], b = s[0], S = s[1], E = s[2], A = s[3], M = s[4], _ = s[5], T = s[6], C = s[7], P = s[8], R = s[9], k = s[10], I = s[11], L = s[12], F = s[13], B = s[14], V = s[15];
    return e.setValues(
      b * r + S * c + E * d + A * g,
      S * a + S * l + E * p + A * m,
      E * o + S * u + E * y + A * v,
      A * h + S * f + E * x + A * w,
      M * r + _ * c + T * d + C * g,
      M * a + _ * l + T * p + C * m,
      M * o + _ * u + T * y + C * v,
      M * h + _ * f + T * x + C * w,
      P * r + R * c + k * d + I * g,
      P * a + R * l + k * p + I * m,
      P * o + R * u + k * y + I * v,
      P * h + R * f + k * x + I * w,
      L * r + F * c + B * d + V * g,
      L * a + F * l + B * p + V * m,
      L * o + F * u + B * y + V * v,
      L * h + F * f + B * x + V * w
    );
  },
  /**
   * Takes the rotation and position vectors and builds this Matrix4 from them.
   *
   * @method Phaser.Math.Matrix4#fromRotationXYTranslation
   * @since 3.50.0
   *
   * @param {Phaser.Math.Vector3} rotation - The rotation vector.
   * @param {Phaser.Math.Vector3} position - The position vector.
   * @param {boolean} translateFirst - Should the operation translate then rotate (`true`), or rotate then translate? (`false`)
   *
   * @return {this} This Matrix4.
   */
  fromRotationXYTranslation: function(i, e, n) {
    var s = e.x, r = e.y, a = e.z, o = Math.sin(i.x), h = Math.cos(i.x), c = Math.sin(i.y), l = Math.cos(i.y), u = s, f = r, d = a, p = -o, y = 0 - p * c, x = 0 - h * c, g = p * l, m = h * l;
    return n || (u = l * s + c * a, f = y * s + h * r + g * a, d = x * s + o * r + m * a), this.setValues(
      l,
      y,
      x,
      0,
      0,
      h,
      o,
      0,
      c,
      g,
      m,
      0,
      u,
      f,
      d,
      1
    );
  },
  /**
   * Returns the maximum axis scale from this Matrix4.
   *
   * @method Phaser.Math.Matrix4#getMaxScaleOnAxis
   * @since 3.50.0
   *
   * @return {number} The maximum axis scale.
   */
  getMaxScaleOnAxis: function() {
    var i = this.val, e = i[0] * i[0] + i[1] * i[1] + i[2] * i[2], n = i[4] * i[4] + i[5] * i[5] + i[6] * i[6], s = i[8] * i[8] + i[9] * i[9] + i[10] * i[10];
    return Math.sqrt(Math.max(e, n, s));
  }
}), $r = new Ts(), no = new Ts(), Ki = new Nt(), wc = new Nt(), xn = new Nt();
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function rR(i, e) {
  var n = (e * 255 | 0) & 255;
  return (n << 24 | i) >>> 0;
}
var Ln = new Gt({
  Extends: Nt,
  initialize: function(e, n, s, r, a, o, h, c, l, u) {
    o === void 0 && (o = 16777215), h === void 0 && (h = 1), c === void 0 && (c = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), Nt.call(this, e, n, s), this.vx = 0, this.vy = 0, this.vz = 0, this.nx = c, this.ny = l, this.nz = u, this.u = r, this.v = a, this.color = o, this.alpha = h, this.tx = 0, this.ty = 0, this.ta = 0, this.tu = r, this.tv = a;
  },
  /**
   * Sets the U and V properties.
   *
   * Also resets the translated uv properties, undoing any scale
   * or shift they may have had.
   *
   * @method Phaser.Geom.Mesh.Vertex#setUVs
   * @since 3.50.0
   *
   * @param {number} u - The UV u coordinate of the vertex.
   * @param {number} v - The UV v coordinate of the vertex.
   *
   * @return {this} This Vertex.
   */
  setUVs: function(i, e) {
    return this.u = i, this.v = e, this.tu = i, this.tv = e, this;
  },
  /**
   * Translates the original UV positions by the given amounts.
   *
   * The original properties `Vertex.u` and `Vertex.v`
   * remain unchanged, only the translated properties
   * `Vertex.tu` and `Vertex.tv`, as used in rendering,
   * are updated.
   *
   * @method Phaser.Geom.Mesh.Vertex#scrollUV
   * @since 3.60.0
   *
   * @param {number} x - The amount to scroll the UV u coordinate by.
   * @param {number} y - The amount to scroll the UV v coordinate by.
   *
   * @return {this} This Vertex.
   */
  scrollUV: function(i, e) {
    return this.tu += i, this.tv += e, this;
  },
  /**
   * Scales the original UV values by the given amounts.
   *
   * The original properties `Vertex.u` and `Vertex.v`
   * remain unchanged, only the translated properties
   * `Vertex.tu` and `Vertex.tv`, as used in rendering,
   * are updated.
   *
   * @method Phaser.Geom.Mesh.Vertex#scaleUV
   * @since 3.60.0
   *
   * @param {number} x - The amount to scale the UV u coordinate by.
   * @param {number} y - The amount to scale the UV v coordinate by.
   *
   * @return {this} This Vertex.
   */
  scaleUV: function(i, e) {
    return this.tu = this.u * i, this.tv = this.v * e, this;
  },
  /**
   * Transforms this vertex by the given matrix, storing the results in `vx`, `vy` and `vz`.
   *
   * @method Phaser.Geom.Mesh.Vertex#transformCoordinatesLocal
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} transformMatrix - The transform matrix to apply to this vertex.
   * @param {number} width - The width of the parent Mesh.
   * @param {number} height - The height of the parent Mesh.
   * @param {number} cameraZ - The z position of the MeshCamera.
   */
  transformCoordinatesLocal: function(i, e, n, s) {
    var r = this.x, a = this.y, o = this.z, h = i.val, c = r * h[0] + a * h[4] + o * h[8] + h[12], l = r * h[1] + a * h[5] + o * h[9] + h[13], u = r * h[2] + a * h[6] + o * h[10] + h[14], f = r * h[3] + a * h[7] + o * h[11] + h[15];
    this.vx = c / f * e, this.vy = -(l / f) * n, s <= 0 ? this.vz = u / f : this.vz = -(u / f);
  },
  /**
   * Resizes this Vertex by setting the x and y coordinates, then transforms this vertex
   * by an identity matrix and dimensions, storing the results in `vx`, `vy` and `vz`.
   *
   * @method Phaser.Geom.Mesh.Vertex#resize
   * @since 3.60.0
   *
   * @param {number} x - The x position of the vertex.
   * @param {number} y - The y position of the vertex.
   * @param {number} width - The width of the parent Mesh.
   * @param {number} height - The height of the parent Mesh.
   * @param {number} originX - The originX of the parent Mesh.
   * @param {number} originY - The originY of the parent Mesh.
   *
   * @return {this} This Vertex.
   */
  resize: function(i, e, n, s, r, a) {
    return this.x = i, this.y = e, this.vx = this.x * n, this.vy = -this.y * s, this.vz = 0, r < 0.5 ? this.vx += n * (0.5 - r) : r > 0.5 && (this.vx -= n * (r - 0.5)), a < 0.5 ? this.vy += s * (0.5 - a) : a > 0.5 && (this.vy -= s * (a - 0.5)), this;
  },
  /**
   * Updates this Vertex based on the given transform.
   *
   * @method Phaser.Geom.Mesh.Vertex#update
   * @since 3.50.0
   *
   * @param {number} a - The parent transform matrix data a component.
   * @param {number} b - The parent transform matrix data b component.
   * @param {number} c - The parent transform matrix data c component.
   * @param {number} d - The parent transform matrix data d component.
   * @param {number} e - The parent transform matrix data e component.
   * @param {number} f - The parent transform matrix data f component.
   * @param {boolean} roundPixels - Round the vertex position or not?
   * @param {number} alpha - The alpha of the parent object.
   *
   * @return {this} This Vertex.
   */
  update: function(i, e, n, s, r, a, o, h) {
    var c = this.vx * i + this.vy * n + r, l = this.vx * e + this.vy * s + a;
    return o && (c = Math.round(c), l = Math.round(l)), this.tx = c, this.ty = l, this.ta = this.alpha * h, this;
  },
  /**
   * Loads the data from this Vertex into the given Typed Arrays.
   *
   * @method Phaser.Geom.Mesh.Vertex#load
   * @since 3.50.0
   *
   * @param {Float32Array} F32 - A Float32 Array to insert the position, UV and unit data in to.
   * @param {Uint32Array} U32 - A Uint32 Array to insert the color and alpha data in to.
   * @param {number} offset - The index of the array to insert this Vertex to.
   * @param {number} textureUnit - The texture unit currently in use.
   * @param {number} tintEffect - The tint effect to use.
   *
   * @return {number} The new array offset.
   */
  load: function(i, e, n, s, r) {
    return i[++n] = this.tx, i[++n] = this.ty, i[++n] = this.tu, i[++n] = this.tv, i[++n] = s, i[++n] = r, e[++n] = rR(this.color, this.ta), n;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Hx = new Nt(), Xx = new Nt(), qs = new Ts(), aR = function(i) {
  var e = xt(i, "mesh"), n = xt(i, "texture", null), s = xt(i, "frame"), r = xt(i, "width", 1), a = xt(i, "height", r), o = xt(i, "widthSegments", 1), h = xt(i, "heightSegments", o), c = xt(i, "x", 0), l = xt(i, "y", 0), u = xt(i, "z", 0), f = xt(i, "rotateX", 0), d = xt(i, "rotateY", 0), p = xt(i, "rotateZ", 0), y = xt(i, "zIsUp", !0), x = xt(i, "isOrtho", e ? e.dirtyCache[11] : !1), g = xt(i, "colors", [16777215]), m = xt(i, "alphas", [1]), v = xt(i, "tile", !1), w = xt(i, "flipY", !1), b = xt(i, "width", null), S = {
    faces: [],
    verts: []
  };
  Hx.set(c, l, u), Xx.set(f, d, p), qs.fromRotationXYTranslation(Xx, Hx, y);
  var E;
  if (!n && e)
    n = e.texture, s || (E = e.frame);
  else if (e && typeof n == "string")
    n = e.scene.sys.textures.get(n);
  else if (!n)
    return S;
  E || (E = n.get(s)), !b && x && n && e && (r = E.width / e.height, a = E.height / e.height);
  var A = r / 2, M = a / 2, _ = Math.floor(o), T = Math.floor(h), C = _ + 1, P = T + 1, R = r / _, k = a / T, I = [], L = [], F, B, V = 0, J = 1, j = 0, ht = 1;
  E && (V = E.u0, J = E.u1, w ? (j = E.v1, ht = E.v0) : (j = E.v0, ht = E.v1));
  var rt = J - V, ft = ht - j;
  for (B = 0; B < P; B++) {
    var lt = B * k - M;
    for (F = 0; F < C; F++) {
      var wt = F * R - A;
      L.push(wt, -lt);
      var Ut = V + rt * (F / _), fe = j + ft * (B / T);
      I.push(Ut, fe);
    }
  }
  Array.isArray(g) || (g = [g]), Array.isArray(m) || (m = [m]);
  var ie = 0, be = 0;
  for (B = 0; B < T; B++)
    for (F = 0; F < _; F++) {
      var de = (F + C * B) * 2, Qt = (F + C * (B + 1)) * 2, Xt = (F + 1 + C * (B + 1)) * 2, H = (F + 1 + C * B) * 2, Z = g[be], et = m[ie], ut = new Ln(L[de], L[de + 1], 0, I[de], I[de + 1], Z, et).transformMat4(qs), at = new Ln(L[Qt], L[Qt + 1], 0, I[Qt], I[Qt + 1], Z, et).transformMat4(qs), Ot = new Ln(L[H], L[H + 1], 0, I[H], I[H + 1], Z, et).transformMat4(qs), bt = new Ln(L[Qt], L[Qt + 1], 0, I[Qt], I[Qt + 1], Z, et).transformMat4(qs), Wt = new Ln(L[Xt], L[Xt + 1], 0, I[Xt], I[Xt + 1], Z, et).transformMat4(qs), nt = new Ln(L[H], L[H + 1], 0, I[H], I[H + 1], Z, et).transformMat4(qs);
      v && (ut.setUVs(V, ht), at.setUVs(V, j), Ot.setUVs(J, ht), bt.setUVs(V, j), Wt.setUVs(J, j), nt.setUVs(J, ht)), be++, be === g.length && (be = 0), ie++, ie === m.length && (ie = 0), S.verts.push(ut, at, Ot, bt, Wt, nt), S.faces.push(
        new rh(ut, at, Ot),
        new rh(bt, Wt, nt)
      );
    }
  return e && (e.faces = e.faces.concat(S.faces), e.vertices = e.vertices.concat(S.verts)), S;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Zx = new Nt(), Jx = new Nt(), Mc = new Ts(), oR = function(i, e, n, s, r, a, o, h, c, l) {
  n === void 0 && (n = 1), s === void 0 && (s = 0), r === void 0 && (r = 0), a === void 0 && (a = 0), o === void 0 && (o = 0), h === void 0 && (h = 0), c === void 0 && (c = 0), l === void 0 && (l = !0);
  var u = {
    faces: [],
    verts: []
  }, f = i.materials;
  Zx.set(s, r, a), Jx.set(o, h, c), Mc.fromRotationXYTranslation(Jx, Zx, l);
  for (var d = 0; d < i.models.length; d++)
    for (var p = i.models[d], y = p.vertices, x = p.textureCoords, g = p.faces, m = 0; m < g.length; m++) {
      var v = g[m], w = v.vertices[0], b = v.vertices[1], S = v.vertices[2], E = y[w.vertexIndex], A = y[b.vertexIndex], M = y[S.vertexIndex], _ = w.textureCoordsIndex, T = b.textureCoordsIndex, C = S.textureCoordsIndex, P = _ === -1 ? { u: 0, v: 1 } : x[_], R = T === -1 ? { u: 0, v: 0 } : x[T], k = C === -1 ? { u: 1, v: 1 } : x[C], I = 16777215;
      v.material !== "" && f[v.material] && (I = f[v.material]);
      var L = new Ln(E.x * n, E.y * n, E.z * n, P.u, P.v, I).transformMat4(Mc), F = new Ln(A.x * n, A.y * n, A.z * n, R.u, R.v, I).transformMat4(Mc), B = new Ln(M.x * n, M.y * n, M.z * n, k.u, k.v, I).transformMat4(Mc);
      u.verts.push(L, F, B), u.faces.push(new rh(L, F, B));
    }
  return e && (e.faces = e.faces.concat(u.faces), e.vertices = e.vertices.concat(u.verts)), u;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var hR = function(i, e, n, s, r, a, o, h) {
  if (s === void 0 && (s = !1), a === void 0 && (a = 16777215), o === void 0 && (o = 1), h === void 0 && (h = !1), i.length !== e.length && !s) {
    console.warn("GenerateVerts: vertices and uvs count not equal");
    return;
  }
  var c = {
    faces: [],
    vertices: []
  }, l, u, f, d, p, y, x, g, m, v, w, b = s ? 3 : 2, S = Array.isArray(a), E = Array.isArray(o);
  if (Array.isArray(n) && n.length > 0)
    for (l = 0; l < n.length; l++) {
      var A = n[l], M = n[l] * 2, _ = n[l] * b;
      u = i[_], f = i[_ + 1], d = s ? i[_ + 2] : 0, p = e[M], y = e[M + 1], h && (y = 1 - y), x = S ? a[A] : a, g = E ? o[A] : o, m = 0, v = 0, w = 0, r && (m = r[_], v = r[_ + 1], w = s ? r[_ + 2] : 0), c.vertices.push(new Ln(u, f, d, p, y, x, g, m, v, w));
    }
  else {
    var T = 0, C = 0;
    for (l = 0; l < i.length; l += b)
      u = i[l], f = i[l + 1], d = s ? i[l + 2] : 0, p = e[T], y = e[T + 1], x = S ? a[C] : a, g = E ? o[C] : o, m = 0, v = 0, w = 0, r && (m = r[l], v = r[l + 1], w = s ? r[l + 2] : 0), c.vertices.push(new Ln(u, f, d, p, y, x, g, m, v, w)), T += 2, C++;
  }
  for (l = 0; l < c.vertices.length; l += 3) {
    var P = c.vertices[l], R = c.vertices[l + 1], k = c.vertices[l + 2];
    c.faces.push(new rh(P, R, k));
  }
  return c;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Hw = !0, Xw = "untitled", Oh = "", t1 = "";
function cR(i) {
  var e = i.indexOf("#");
  return e > -1 ? i.substring(0, e) : i;
}
function ah(i) {
  return i.models.length === 0 && i.models.push({
    faces: [],
    name: Xw,
    textureCoords: [],
    vertexNormals: [],
    vertices: []
  }), Oh = "", i.models[i.models.length - 1];
}
function lR(i, e) {
  var n = i.length >= 2 ? i[1] : Xw;
  e.models.push({
    faces: [],
    name: n,
    textureCoords: [],
    vertexNormals: [],
    vertices: []
  }), Oh = "";
}
function uR(i) {
  i.length === 2 && (Oh = i[1]);
}
function fR(i, e) {
  var n = i.length, s = n >= 2 ? parseFloat(i[1]) : 0, r = n >= 3 ? parseFloat(i[2]) : 0, a = n >= 4 ? parseFloat(i[3]) : 0;
  ah(e).vertices.push({ x: s, y: r, z: a });
}
function dR(i, e) {
  var n = i.length, s = n >= 2 ? parseFloat(i[1]) : 0, r = n >= 3 ? parseFloat(i[2]) : 0, a = n >= 4 ? parseFloat(i[3]) : 0;
  isNaN(s) && (s = 0), isNaN(r) && (r = 0), isNaN(a) && (a = 0), Hw && (r = 1 - r), ah(e).textureCoords.push({ u: s, v: r, w: a });
}
function pR(i, e) {
  var n = i.length, s = n >= 2 ? parseFloat(i[1]) : 0, r = n >= 3 ? parseFloat(i[2]) : 0, a = n >= 4 ? parseFloat(i[3]) : 0;
  ah(e).vertexNormals.push({ x: s, y: r, z: a });
}
function yR(i, e) {
  var n = i.length - 1;
  if (!(n < 3)) {
    for (var s = {
      group: Oh,
      material: t1,
      vertices: []
    }, r = 0; r < n; r++) {
      var a = i[r + 1], o = a.split("/"), h = o.length;
      if (!(h < 1 || h > 3)) {
        var c = 0, l = 0, u = 0;
        c = parseInt(o[0], 10), h > 1 && o[1] !== "" && (l = parseInt(o[1], 10)), h > 2 && (u = parseInt(o[2], 10)), c !== 0 && (c < 0 && (c = ah(e).vertices.length + 1 + c), l -= 1, c -= 1, u -= 1, s.vertices.push({
          textureCoordsIndex: l,
          vertexIndex: c,
          vertexNormalIndex: u
        }));
      }
    }
    ah(e).faces.push(s);
  }
}
function xR(i, e) {
  i.length >= 2 && e.materialLibraries.push(i[1]);
}
function gR(i) {
  i.length >= 2 && (t1 = i[1]);
}
var mR = function(i, e) {
  e === void 0 && (e = !0), Hw = e;
  var n = {
    materials: {},
    materialLibraries: [],
    models: []
  };
  Oh = "", t1 = "";
  for (var s = i.split(`
`), r = 0; r < s.length; r++) {
    var a = cR(s[r]), o = a.replace(/\s\s+/g, " ").trim().split(" ");
    switch (o[0].toLowerCase()) {
      case "o":
        lR(o, n);
        break;
      case "g":
        uR(o);
        break;
      case "v":
        fR(o, n);
        break;
      case "vt":
        dR(o, n);
        break;
      case "vn":
        pR(o, n);
        break;
      case "f":
        yR(o, n);
        break;
      case "mtllib":
        xR(o, n);
        break;
      case "usemtl":
        gR(o);
        break;
    }
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var gi = function(i, e, n) {
  return i << 16 | e << 8 | n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vR = function(i) {
  for (var e = {}, n = i.split(`
`), s = "", r = 0; r < n.length; r++) {
    var a = n[r].trim();
    if (!(a.indexOf("#") === 0 || a === "")) {
      var o = a.replace(/\s\s+/g, " ").trim().split(" ");
      switch (o[0].toLowerCase()) {
        case "newmtl": {
          s = o[1];
          break;
        }
        //  The diffuse reflectivity of the current material
        //  Support r, [g], [b] format, where g and b are optional
        case "kd": {
          var h = Math.floor(o[1] * 255), c = o.length >= 2 ? Math.floor(o[2] * 255) : h, l = o.length >= 3 ? Math.floor(o[3] * 255) : h;
          e[s] = gi(h, c, l);
          break;
        }
      }
    }
  }
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var wR = function(i, e, n, s) {
  var r, a;
  if (n === void 0 && s === void 0) {
    var o = i.getInCenter();
    r = o.x, a = o.y;
  }
  var h = Math.cos(e), c = Math.sin(e), l = i.vertex1, u = i.vertex2, f = i.vertex3, d = l.x - r, p = l.y - a;
  l.set(d * h - p * c + r, d * c + p * h + a), d = u.x - r, p = u.y - a, u.set(d * h - p * c + r, d * c + p * h + a), d = f.x - r, p = f.y - a, f.set(d * h - p * c + r, d * c + p * h + a);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var MR = {
  Face: rh,
  GenerateGridVerts: aR,
  GenerateObjVerts: oR,
  GenerateVerts: hR,
  ParseObj: mR,
  ParseObjMaterial: vR,
  RotateFace: wR,
  Vertex: Ln
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var bR = function(i) {
  return i.setTo(Math.ceil(i.x), Math.ceil(i.y));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var _R = function(i) {
  return new ot(i.x, i.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var SR = function(i, e) {
  return e.setTo(i.x, i.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var TR = function(i, e) {
  return i.x === e.x && i.y === e.y;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ER = function(i) {
  return i.setTo(Math.floor(i.x), Math.floor(i.y));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var zR = function(i, e) {
  if (e === void 0 && (e = new ot()), !Array.isArray(i))
    throw new Error("GetCentroid points argument must be an array");
  var n = i.length;
  if (n < 1)
    throw new Error("GetCentroid points array must not be empty");
  if (n === 1)
    e.x = i[0].x, e.y = i[0].y;
  else {
    for (var s = 0; s < n; s++)
      e.x += i[s].x, e.y += i[s].y;
    e.x /= n, e.y /= n;
  }
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Zw = function(i) {
  return Math.sqrt(i.x * i.x + i.y * i.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Jw = function(i) {
  return i.x * i.x + i.y * i.y;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var CR = function(i, e) {
  e === void 0 && (e = new mt());
  for (var n = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, o = 0; o < i.length; o++) {
    var h = i[o];
    h.x > n && (n = h.x), h.x < s && (s = h.x), h.y > r && (r = h.y), h.y < a && (a = h.y);
  }
  return e.x = s, e.y = a, e.width = n - s, e.height = r - a, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var AR = function(i, e, n, s) {
  return n === void 0 && (n = 0), s === void 0 && (s = new ot()), s.x = i.x + (e.x - i.x) * n, s.y = i.y + (e.y - i.y) * n, s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var PR = function(i) {
  return i.setTo(i.y, i.x);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var IR = function(i, e) {
  return e === void 0 && (e = new ot()), e.setTo(-i.x, -i.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var RR = function(i, e, n) {
  n === void 0 && (n = new ot());
  var s = i.x * e.x + i.y * e.y, r = s / Jw(e);
  return r !== 0 && (n.x = r * e.x, n.y = r * e.y), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var OR = function(i, e, n) {
  n === void 0 && (n = new ot());
  var s = i.x * e.x + i.y * e.y;
  return s !== 0 && (n.x = s * e.x, n.y = s * e.y), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var kR = function(i, e) {
  if (i.x !== 0 || i.y !== 0) {
    var n = Zw(i);
    i.x /= n, i.y /= n;
  }
  return i.x *= e, i.y *= e, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
ot.Ceil = bR;
ot.Clone = _R;
ot.CopyFrom = SR;
ot.Equals = TR;
ot.Floor = ER;
ot.GetCentroid = zR;
ot.GetMagnitude = Zw;
ot.GetMagnitudeSq = Jw;
ot.GetRectangleFromPoints = CR;
ot.Interpolate = AR;
ot.Invert = PR;
ot.Negative = IR;
ot.Project = RR;
ot.ProjectUnit = OR;
ot.SetMagnitude = kR;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var e1 = function(i, e, n) {
  for (var s = !1, r = -1, a = i.points.length - 1; ++r < i.points.length; a = r) {
    var o = i.points[r].x, h = i.points[r].y, c = i.points[a].x, l = i.points[a].y;
    (h <= n && n < l || l <= n && n < h) && e < (c - o) * (n - h) / (l - h) + o && (s = !s);
  }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Qw = function(i) {
  for (var e = i.points, n = 0, s = 0; s < e.length; s++) {
    var r = e[s], a = e[(s + 1) % e.length], o = new Pt(
      r.x,
      r.y,
      a.x,
      a.y
    );
    n += un(o);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Kw = function(i, e, n, s) {
  s === void 0 && (s = []);
  var r = i.points, a = Qw(i);
  !e && n > 0 && (e = a / n);
  for (var o = 0; o < e; o++)
    for (var h = a * (o / e), c = 0, l = 0; l < r.length; l++) {
      var u = r[l], f = r[(l + 1) % r.length], d = new Pt(
        u.x,
        u.y,
        f.x,
        f.y
      ), p = un(d);
      if (h < c || h > c + p) {
        c += p;
        continue;
      }
      var y = d.getPoint((h - c) / p);
      s.push(y);
      break;
    }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var pn = new Gt({
  initialize: function(e) {
    this.type = Ss.POLYGON, this.area = 0, this.points = [], e && this.setTo(e);
  },
  /**
   * Check to see if the Polygon contains the given x / y coordinates.
   *
   * @method Phaser.Geom.Polygon#contains
   * @since 3.0.0
   *
   * @param {number} x - The x coordinate to check within the polygon.
   * @param {number} y - The y coordinate to check within the polygon.
   *
   * @return {boolean} `true` if the coordinates are within the polygon, otherwise `false`.
   */
  contains: function(i, e) {
    return e1(this, i, e);
  },
  /**
   * Sets this Polygon to the given points.
   *
   * The points can be set from a variety of formats:
   *
   * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`
   * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
   * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
   * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
   * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
   *
   * `setTo` may also be called without any arguments to remove all points.
   *
   * @method Phaser.Geom.Polygon#setTo
   * @since 3.0.0
   *
   * @param {(string|number[]|Phaser.Types.Math.Vector2Like[])} [points] - Points defining the perimeter of this polygon. Please check function description above for the different supported formats.
   *
   * @return {this} This Polygon object.
   */
  setTo: function(i) {
    if (this.area = 0, this.points = [], typeof i == "string" && (i = i.split(" ")), !Array.isArray(i))
      return this;
    for (var e, n = 0; n < i.length; n++)
      e = { x: 0, y: 0 }, typeof i[n] == "number" || typeof i[n] == "string" ? (e.x = parseFloat(i[n]), e.y = parseFloat(i[n + 1]), n++) : Array.isArray(i[n]) ? (e.x = i[n][0], e.y = i[n][1]) : (e.x = i[n].x, e.y = i[n].y), this.points.push(e);
    return this.calculateArea(), this;
  },
  /**
   * Calculates the area of the Polygon. This is available in the property Polygon.area
   *
   * @method Phaser.Geom.Polygon#calculateArea
   * @since 3.0.0
   *
   * @return {number} The area of the polygon.
   */
  calculateArea: function() {
    if (this.points.length < 3)
      return this.area = 0, this.area;
    for (var i = 0, e, n, s = 0; s < this.points.length - 1; s++)
      e = this.points[s], n = this.points[s + 1], i += (n.x - e.x) * (e.y + n.y);
    return e = this.points[0], n = this.points[this.points.length - 1], i += (e.x - n.x) * (n.y + e.y), this.area = -i * 0.5, this.area;
  },
  /**
   * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,
   * based on the given quantity or stepRate values.
   *
   * @method Phaser.Geom.Polygon#getPoints
   * @since 3.12.0
   *
   * @generic {Phaser.Geom.Point[]} O - [output,$return]
   *
   * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
   * @param {number} [stepRate] - Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.
   * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.
   *
   * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the perimeter of the Polygon.
   */
  getPoints: function(i, e, n) {
    return Kw(this, i, e, n);
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var LR = function(i) {
  return new pn(i.points);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var FR = function(i, e) {
  return e1(i, e.x, e.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function uu(i, e, n) {
  n = n || 2;
  var s = e && e.length, r = s ? e[0] * n : i.length, a = tM(i, 0, r, n, !0), o = [];
  if (!a || a.next === a.prev) return o;
  var h, c, l, u, f, d, p;
  if (s && (a = $R(i, e, a, n)), i.length > 80 * n) {
    h = l = i[0], c = u = i[1];
    for (var y = n; y < r; y += n)
      f = i[y], d = i[y + 1], f < h && (h = f), d < c && (c = d), f > l && (l = f), d > u && (u = d);
    p = Math.max(l - h, u - c), p = p !== 0 ? 32767 / p : 0;
  }
  return oh(a, o, n, h, c, p, 0), o;
}
function tM(i, e, n, s, r) {
  var a, o;
  if (r === N0(i, e, n, s) > 0)
    for (a = e; a < n; a += s) o = Qx(a, i[a], i[a + 1], o);
  else
    for (a = n - s; a >= e; a -= s) o = Qx(a, i[a], i[a + 1], o);
  return o && fu(o, o.next) && (ch(o), o = o.next), o;
}
function _r(i, e) {
  if (!i) return i;
  e || (e = i);
  var n = i, s;
  do
    if (s = !1, !n.steiner && (fu(n, n.next) || le(n.prev, n, n.next) === 0)) {
      if (ch(n), n = e = n.prev, n === n.next) break;
      s = !0;
    } else
      n = n.next;
  while (s || n !== e);
  return e;
}
function oh(i, e, n, s, r, a, o) {
  if (i) {
    !o && a && YR(i, s, r, a);
    for (var h = i, c, l; i.prev !== i.next; ) {
      if (c = i.prev, l = i.next, a ? BR(i, s, r, a) : NR(i)) {
        e.push(c.i / n | 0), e.push(i.i / n | 0), e.push(l.i / n | 0), ch(i), i = l.next, h = l.next;
        continue;
      }
      if (i = l, i === h) {
        o ? o === 1 ? (i = DR(_r(i), e, n), oh(i, e, n, s, r, a, 2)) : o === 2 && qR(i, e, n, s, r, a) : oh(_r(i), e, n, s, r, a, 1);
        break;
      }
    }
  }
}
function NR(i) {
  var e = i.prev, n = i, s = i.next;
  if (le(e, n, s) >= 0) return !1;
  for (var r = e.x, a = n.x, o = s.x, h = e.y, c = n.y, l = s.y, u = r < a ? r < o ? r : o : a < o ? a : o, f = h < c ? h < l ? h : l : c < l ? c : l, d = r > a ? r > o ? r : o : a > o ? a : o, p = h > c ? h > l ? h : l : c > l ? c : l, y = s.next; y !== e; ) {
    if (y.x >= u && y.x <= d && y.y >= f && y.y <= p && xa(r, h, a, c, o, l, y.x, y.y) && le(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function BR(i, e, n, s) {
  var r = i.prev, a = i, o = i.next;
  if (le(r, a, o) >= 0) return !1;
  for (var h = r.x, c = a.x, l = o.x, u = r.y, f = a.y, d = o.y, p = h < c ? h < l ? h : l : c < l ? c : l, y = u < f ? u < d ? u : d : f < d ? f : d, x = h > c ? h > l ? h : l : c > l ? c : l, g = u > f ? u > d ? u : d : f > d ? f : d, m = L0(p, y, e, n, s), v = L0(x, g, e, n, s), w = i.prevZ, b = i.nextZ; w && w.z >= m && b && b.z <= v; ) {
    if (w.x >= p && w.x <= x && w.y >= y && w.y <= g && w !== r && w !== o && xa(h, u, c, f, l, d, w.x, w.y) && le(w.prev, w, w.next) >= 0 || (w = w.prevZ, b.x >= p && b.x <= x && b.y >= y && b.y <= g && b !== r && b !== o && xa(h, u, c, f, l, d, b.x, b.y) && le(b.prev, b, b.next) >= 0)) return !1;
    b = b.nextZ;
  }
  for (; w && w.z >= m; ) {
    if (w.x >= p && w.x <= x && w.y >= y && w.y <= g && w !== r && w !== o && xa(h, u, c, f, l, d, w.x, w.y) && le(w.prev, w, w.next) >= 0) return !1;
    w = w.prevZ;
  }
  for (; b && b.z <= v; ) {
    if (b.x >= p && b.x <= x && b.y >= y && b.y <= g && b !== r && b !== o && xa(h, u, c, f, l, d, b.x, b.y) && le(b.prev, b, b.next) >= 0) return !1;
    b = b.nextZ;
  }
  return !0;
}
function DR(i, e, n) {
  var s = i;
  do {
    var r = s.prev, a = s.next.next;
    !fu(r, a) && eM(r, s, s.next, a) && hh(r, a) && hh(a, r) && (e.push(r.i / n | 0), e.push(s.i / n | 0), e.push(a.i / n | 0), ch(s), ch(s.next), s = i = a), s = s.next;
  } while (s !== i);
  return _r(s);
}
function qR(i, e, n, s, r, a) {
  var o = i;
  do {
    for (var h = o.next.next; h !== o.prev; ) {
      if (o.i !== h.i && XR(o, h)) {
        var c = nM(o, h);
        o = _r(o, o.next), c = _r(c, c.next), oh(o, e, n, s, r, a, 0), oh(c, e, n, s, r, a, 0);
        return;
      }
      h = h.next;
    }
    o = o.next;
  } while (o !== i);
}
function $R(i, e, n, s) {
  var r = [], a, o, h, c, l;
  for (a = 0, o = e.length; a < o; a++)
    h = e[a] * s, c = a < o - 1 ? e[a + 1] * s : i.length, l = tM(i, h, c, s, !1), l === l.next && (l.steiner = !0), r.push(HR(l));
  for (r.sort(VR), a = 0; a < r.length; a++)
    n = GR(r[a], n);
  return n;
}
function VR(i, e) {
  return i.x - e.x;
}
function GR(i, e) {
  var n = UR(i, e);
  if (!n)
    return e;
  var s = nM(n, i);
  return _r(s, s.next), _r(n, n.next);
}
function UR(i, e) {
  var n = e, s = i.x, r = i.y, a = -1 / 0, o;
  do {
    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
      var h = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (h <= s && h > a && (a = h, o = n.x < n.next.x ? n : n.next, h === s))
        return o;
    }
    n = n.next;
  } while (n !== e);
  if (!o) return null;
  var c = o, l = o.x, u = o.y, f = 1 / 0, d;
  n = o;
  do
    s >= n.x && n.x >= l && s !== n.x && xa(r < u ? s : a, r, l, u, r < u ? a : s, r, n.x, n.y) && (d = Math.abs(r - n.y) / (s - n.x), hh(n, i) && (d < f || d === f && (n.x > o.x || n.x === o.x && WR(o, n))) && (o = n, f = d)), n = n.next;
  while (n !== c);
  return o;
}
function WR(i, e) {
  return le(i.prev, i, e.prev) < 0 && le(e.next, i, i.next) < 0;
}
function YR(i, e, n, s) {
  var r = i;
  do
    r.z === 0 && (r.z = L0(r.x, r.y, e, n, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, jR(r);
}
function jR(i) {
  var e, n, s, r, a, o, h, c, l = 1;
  do {
    for (n = i, i = null, a = null, o = 0; n; ) {
      for (o++, s = n, h = 0, e = 0; e < l && (h++, s = s.nextZ, !!s); e++)
        ;
      for (c = l; h > 0 || c > 0 && s; )
        h !== 0 && (c === 0 || !s || n.z <= s.z) ? (r = n, n = n.nextZ, h--) : (r = s, s = s.nextZ, c--), a ? a.nextZ = r : i = r, r.prevZ = a, a = r;
      n = s;
    }
    a.nextZ = null, l *= 2;
  } while (o > 1);
  return i;
}
function L0(i, e, n, s, r) {
  return i = (i - n) * r | 0, e = (e - s) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function HR(i) {
  var e = i, n = i;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== i);
  return n;
}
function xa(i, e, n, s, r, a, o, h) {
  return (r - o) * (e - h) >= (i - o) * (a - h) && (i - o) * (s - h) >= (n - o) * (e - h) && (n - o) * (a - h) >= (r - o) * (s - h);
}
function XR(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !ZR(i, e) && // dones't intersect other edges
  (hh(i, e) && hh(e, i) && JR(i, e) && // locally visible
  (le(i.prev, i, e.prev) || le(i, e.prev, e)) || // does not create opposite-facing sectors
  fu(i, e) && le(i.prev, i, i.next) > 0 && le(e.prev, e, e.next) > 0);
}
function le(i, e, n) {
  return (e.y - i.y) * (n.x - e.x) - (e.x - i.x) * (n.y - e.y);
}
function fu(i, e) {
  return i.x === e.x && i.y === e.y;
}
function eM(i, e, n, s) {
  var r = _c(le(i, e, n)), a = _c(le(i, e, s)), o = _c(le(n, s, i)), h = _c(le(n, s, e));
  return !!(r !== a && o !== h || r === 0 && bc(i, n, e) || a === 0 && bc(i, s, e) || o === 0 && bc(n, i, s) || h === 0 && bc(n, e, s));
}
function bc(i, e, n) {
  return e.x <= Math.max(i.x, n.x) && e.x >= Math.min(i.x, n.x) && e.y <= Math.max(i.y, n.y) && e.y >= Math.min(i.y, n.y);
}
function _c(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function ZR(i, e) {
  var n = i;
  do {
    if (n.i !== i.i && n.next.i !== i.i && n.i !== e.i && n.next.i !== e.i && eM(n, n.next, i, e)) return !0;
    n = n.next;
  } while (n !== i);
  return !1;
}
function hh(i, e) {
  return le(i.prev, i, i.next) < 0 ? le(i, e, i.next) >= 0 && le(i, i.prev, e) >= 0 : le(i, e, i.prev) < 0 || le(i, i.next, e) < 0;
}
function JR(i, e) {
  var n = i, s = !1, r = (i.x + e.x) / 2, a = (i.y + e.y) / 2;
  do
    n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;
  while (n !== i);
  return s;
}
function nM(i, e) {
  var n = new F0(i.i, i.x, i.y), s = new F0(e.i, e.x, e.y), r = i.next, a = e.prev;
  return i.next = e, e.prev = i, n.next = r, r.prev = n, s.next = n, n.prev = s, a.next = s, s.prev = a, s;
}
function Qx(i, e, n, s) {
  var r = new F0(i, e, n);
  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;
}
function ch(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function F0(i, e, n) {
  this.i = i, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
uu.deviation = function(i, e, n, s) {
  var r = e && e.length, a = r ? e[0] * n : i.length, o = Math.abs(N0(i, 0, a, n));
  if (r)
    for (var h = 0, c = e.length; h < c; h++) {
      var l = e[h] * n, u = h < c - 1 ? e[h + 1] * n : i.length;
      o -= Math.abs(N0(i, l, u, n));
    }
  var f = 0;
  for (h = 0; h < s.length; h += 3) {
    var d = s[h] * n, p = s[h + 1] * n, y = s[h + 2] * n;
    f += Math.abs(
      (i[d] - i[y]) * (i[p + 1] - i[d + 1]) - (i[d] - i[p]) * (i[y + 1] - i[d + 1])
    );
  }
  return o === 0 && f === 0 ? 0 : Math.abs((f - o) / o);
};
function N0(i, e, n, s) {
  for (var r = 0, a = e, o = n - s; a < n; a += s)
    r += (i[o] - i[a]) * (i[a + 1] + i[o + 1]), o = a;
  return r;
}
uu.flatten = function(i) {
  for (var e = i[0][0].length, n = { vertices: [], holes: [], dimensions: e }, s = 0, r = 0; r < i.length; r++) {
    for (var a = 0; a < i[r].length; a++)
      for (var o = 0; o < e; o++) n.vertices.push(i[r][a][o]);
    r > 0 && (s += i[r - 1].length, n.holes.push(s));
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var QR = function(i, e) {
  e === void 0 && (e = new mt());
  for (var n = 1 / 0, s = 1 / 0, r = -n, a = -s, o, h = 0; h < i.points.length; h++)
    o = i.points[h], n = Math.min(n, o.x), s = Math.min(s, o.y), r = Math.max(r, o.x), a = Math.max(a, o.y);
  return e.x = n, e.y = s, e.width = r - n, e.height = a - s, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var KR = function(i, e) {
  e === void 0 && (e = []);
  for (var n = 0; n < i.points.length; n++)
    e.push(i.points[n].x), e.push(i.points[n].y);
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var tO = function(i) {
  return i.points.reverse(), i;
};
function eO(i, e) {
  var n = i.x - e.x, s = i.y - e.y;
  return n * n + s * s;
}
function nO(i, e, n) {
  var s = e.x, r = e.y, a = n.x - s, o = n.y - r;
  if (a !== 0 || o !== 0) {
    var h = ((i.x - s) * a + (i.y - r) * o) / (a * a + o * o);
    h > 1 ? (s = n.x, r = n.y) : h > 0 && (s += a * h, r += o * h);
  }
  return a = i.x - s, o = i.y - r, a * a + o * o;
}
function iO(i, e) {
  for (var n = i[0], s = [n], r, a = 1, o = i.length; a < o; a++)
    r = i[a], eO(r, n) > e && (s.push(r), n = r);
  return n !== r && s.push(r), s;
}
function B0(i, e, n, s, r) {
  for (var a = s, o, h = e + 1; h < n; h++) {
    var c = nO(i[h], i[e], i[n]);
    c > a && (o = h, a = c);
  }
  a > s && (o - e > 1 && B0(i, e, o, s, r), r.push(i[o]), n - o > 1 && B0(i, o, n, s, r));
}
function sO(i, e) {
  var n = i.length - 1, s = [i[0]];
  return B0(i, 0, n, e, s), s.push(i[n]), s;
}
var rO = function(i, e, n) {
  e === void 0 && (e = 1), n === void 0 && (n = !1);
  var s = i.points;
  if (s.length > 2) {
    var r = e * e;
    n || (s = iO(s, r)), i.setTo(sO(s, r));
  }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Kx = function(i, e) {
  return i[0] = e[0], i[1] = e[1], i;
}, aO = function(i) {
  var e, n = [], s = i.points;
  for (e = 0; e < s.length; e++)
    n.push([s[e].x, s[e].y]);
  var r = [];
  for (n.length > 0 && r.push(Kx([0, 0], n[0])), e = 0; e < n.length - 1; e++) {
    var a = n[e], o = n[e + 1], h = a[0], c = a[1], l = o[0], u = o[1];
    r.push([0.85 * h + 0.15 * l, 0.85 * c + 0.15 * u]), r.push([0.15 * h + 0.85 * l, 0.15 * c + 0.85 * u]);
  }
  return n.length > 1 && r.push(Kx([0, 0], n[n.length - 1])), i.setTo(r);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var oO = function(i, e, n) {
  for (var s = i.points, r = 0; r < s.length; r++)
    s[r].x += e, s[r].y += n;
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
pn.Clone = LR;
pn.Contains = e1;
pn.ContainsPoint = FR;
pn.Earcut = uu;
pn.GetAABB = QR;
pn.GetNumberArray = KR;
pn.GetPoints = Kw;
pn.Perimeter = Qw;
pn.Reverse = tO;
pn.Simplify = rO;
pn.Smooth = aO;
pn.Translate = oO;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var hO = function(i) {
  return i.width * i.height;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var cO = function(i) {
  return i.x = Math.ceil(i.x), i.y = Math.ceil(i.y), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var lO = function(i) {
  return i.x = Math.ceil(i.x), i.y = Math.ceil(i.y), i.width = Math.ceil(i.width), i.height = Math.ceil(i.height), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var iM = function(i, e, n) {
  return i.x = e - i.width / 2, i.y = n - i.height / 2, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var uO = function(i) {
  return new mt(i.x, i.y, i.width, i.height);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var fO = function(i, e) {
  return Bi(i, e.x, e.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sM = function(i, e) {
  return e.width * e.height > i.width * i.height ? !1 : e.x > i.x && e.x < i.right && e.right > i.x && e.right < i.right && e.y > i.y && e.y < i.bottom && e.bottom > i.y && e.bottom < i.bottom;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var dO = function(i, e) {
  return e.setTo(i.x, i.y, i.width, i.height);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var pO = function(i, e) {
  return i.x === e.x && i.y === e.y && i.width === e.width && i.height === e.height;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var lh = function(i) {
  return i.height === 0 ? NaN : i.width / i.height;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var yO = function(i, e) {
  var n = lh(i);
  return n < lh(e) ? i.setSize(e.height * n, e.height) : i.setSize(e.width, e.width / n), i.setPosition(
    e.centerX - i.width / 2,
    e.centerY - i.height / 2
  );
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xO = function(i, e) {
  var n = lh(i);
  return n > lh(e) ? i.setSize(e.height * n, e.height) : i.setSize(e.width, e.width / n), i.setPosition(
    e.centerX - i.width / 2,
    e.centerY - i.height / 2
  );
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var gO = function(i) {
  return i.x = Math.floor(i.x), i.y = Math.floor(i.y), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var mO = function(i) {
  return i.x = Math.floor(i.x), i.y = Math.floor(i.y), i.width = Math.floor(i.width), i.height = Math.floor(i.height), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vO = function(i, e) {
  if (e === void 0 && (e = new mt()), i.length === 0)
    return e;
  for (var n = Number.MAX_VALUE, s = Number.MAX_VALUE, r = ce.MIN_SAFE_INTEGER, a = ce.MIN_SAFE_INTEGER, o, h, c, l = 0; l < i.length; l++)
    o = i[l], Array.isArray(o) ? (h = o[0], c = o[1]) : (h = o.x, c = o.y), n = Math.min(n, h), s = Math.min(s, c), r = Math.max(r, h), a = Math.max(a, c);
  return e.x = n, e.y = s, e.width = r - n, e.height = a - s, e;
};
/**
 * @author       samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var wO = function(i, e, n, s, r) {
  return r === void 0 && (r = new mt()), r.setTo(
    Math.min(i, n),
    Math.min(e, s),
    Math.abs(i - n),
    Math.abs(e - s)
  );
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var MO = function(i, e) {
  return e === void 0 && (e = new ot()), e.x = i.centerX, e.y = i.centerY, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var bO = function(i, e) {
  return e === void 0 && (e = new ot()), e.x = i.width, e.y = i.height, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var _O = function(i, e, n) {
  var s = i.centerX, r = i.centerY;
  return i.setSize(i.width + e * 2, i.height + n * 2), iM(i, s, r);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var SO = function(i, e, n) {
  return n === void 0 && (n = new mt()), hu(i, e) ? (n.x = Math.max(i.x, e.x), n.y = Math.max(i.y, e.y), n.width = Math.min(i.right, e.right) - n.x, n.height = Math.min(i.bottom, e.bottom) - n.y) : n.setEmpty(), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var TO = function(i, e, n, s) {
  if (s === void 0 && (s = []), !e && !n)
    return s;
  e ? n = Math.round(sh(i) / e) : e = sh(i) / n;
  for (var r = i.x, a = i.y, o = 0, h = 0; h < n; h++)
    switch (s.push(new ot(r, a)), o) {
      //  Top face
      case 0:
        r += e, r >= i.right && (o = 1, a += r - i.right, r = i.right);
        break;
      //  Right face
      case 1:
        a += e, a >= i.bottom && (o = 2, r -= a - i.bottom, a = i.bottom);
        break;
      //  Bottom face
      case 2:
        r -= e, r <= i.left && (o = 3, a -= i.left - r, r = i.left);
        break;
      //  Left face
      case 3:
        a -= e, a <= i.top && (o = 0, a = i.top);
        break;
    }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var EO = function(i, e) {
  for (var n = i.x, s = i.right, r = i.y, a = i.bottom, o = 0; o < e.length; o++)
    n = Math.min(n, e[o].x), s = Math.max(s, e[o].x), r = Math.min(r, e[o].y), a = Math.max(a, e[o].y);
  return i.x = n, i.y = r, i.width = s - n, i.height = a - r, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var zO = function(i, e) {
  var n = Math.min(i.x, e.x), s = Math.max(i.right, e.right);
  i.x = n, i.width = s - n;
  var r = Math.min(i.y, e.y), a = Math.max(i.bottom, e.bottom);
  return i.y = r, i.height = a - r, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var CO = function(i, e, n) {
  var s = Math.min(i.x, e), r = Math.max(i.right, e);
  i.x = s, i.width = r - s;
  var a = Math.min(i.y, n), o = Math.max(i.bottom, n);
  return i.y = a, i.height = o - a, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var AO = function(i, e, n) {
  return i.x += e, i.y += n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var PO = function(i, e) {
  return i.x += e.x, i.y += e.y, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var IO = function(i, e) {
  return i.x < e.right && i.right > e.x && i.y < e.bottom && i.bottom > e.y;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var rM = function(i) {
  return i * ce.DEG_TO_RAD;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var RO = function(i, e, n) {
  n === void 0 && (n = new ot()), e = rM(e);
  var s = Math.sin(e), r = Math.cos(e), a = r > 0 ? i.width / 2 : i.width / -2, o = s > 0 ? i.height / 2 : i.height / -2;
  return Math.abs(a * s) < Math.abs(o * r) ? o = a * s / r : a = o * r / s, n.x = a + i.centerX, n.y = o + i.centerY, n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Sa = function(i, e) {
  return Math.floor(Math.random() * (e - i + 1) + i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var OO = function(i, e, n) {
  if (n === void 0 && (n = new ot()), sM(i, e))
    switch (Sa(0, 3)) {
      case 0:
        n.x = i.x + Math.random() * (e.right - i.x), n.y = i.y + Math.random() * (e.top - i.y);
        break;
      case 1:
        n.x = e.x + Math.random() * (i.right - e.x), n.y = e.bottom + Math.random() * (i.bottom - e.bottom);
        break;
      case 2:
        n.x = i.x + Math.random() * (e.x - i.x), n.y = e.y + Math.random() * (i.bottom - e.y);
        break;
      case 3:
        n.x = e.right + Math.random() * (i.right - e.right), n.y = i.y + Math.random() * (e.bottom - i.y);
        break;
    }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var kO = function(i, e) {
  return i.width === e.width && i.height === e.height;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var LO = function(i, e, n) {
  return n === void 0 && (n = e), i.width *= e, i.height *= n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var FO = function(i, e, n) {
  n === void 0 && (n = new mt());
  var s = Math.min(i.x, e.x), r = Math.min(i.y, e.y), a = Math.max(i.right, e.right) - s, o = Math.max(i.bottom, e.bottom) - r;
  return n.setTo(s, r, a, o);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
mt.Area = hO;
mt.Ceil = cO;
mt.CeilAll = lO;
mt.CenterOn = iM;
mt.Clone = uO;
mt.Contains = Bi;
mt.ContainsPoint = fO;
mt.ContainsRect = sM;
mt.CopyFrom = dO;
mt.Decompose = Dw;
mt.Equals = pO;
mt.FitInside = yO;
mt.FitOutside = xO;
mt.Floor = gO;
mt.FloorAll = mO;
mt.FromPoints = vO;
mt.FromXY = wO;
mt.GetAspectRatio = lh;
mt.GetCenter = MO;
mt.GetPoint = Jd;
mt.GetPoints = _w;
mt.GetSize = bO;
mt.Inflate = _O;
mt.Intersection = SO;
mt.MarchingAnts = TO;
mt.MergePoints = EO;
mt.MergeRect = zO;
mt.MergeXY = CO;
mt.Offset = AO;
mt.OffsetPoint = PO;
mt.Overlaps = IO;
mt.Perimeter = sh;
mt.PerimeterPoint = RO;
mt.Random = zw;
mt.RandomOutside = OO;
mt.SameDimensions = kO;
mt.Scale = LO;
mt.Union = FO;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var aM = function(i, e, n) {
  n === void 0 && (n = new ot());
  var s = i.getLineA(), r = i.getLineB(), a = i.getLineC();
  if (e <= 0 || e >= 1)
    return n.x = s.x1, n.y = s.y1, n;
  var o = un(s), h = un(r), c = un(a), l = o + h + c, u = l * e, f = 0;
  return u < o ? (f = u / o, n.x = s.x1 + (s.x2 - s.x1) * f, n.y = s.y1 + (s.y2 - s.y1) * f) : u > o + h ? (u -= o + h, f = u / c, n.x = a.x1 + (a.x2 - a.x1) * f, n.y = a.y1 + (a.y2 - a.y1) * f) : (u -= o, f = u / h, n.x = r.x1 + (r.x2 - r.x1) * f, n.y = r.y1 + (r.y2 - r.y1) * f), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var oM = function(i, e, n, s) {
  s === void 0 && (s = []);
  var r = i.getLineA(), a = i.getLineB(), o = i.getLineC(), h = un(r), c = un(a), l = un(o), u = h + c + l;
  !e && n > 0 && (e = u / n);
  for (var f = 0; f < e; f++) {
    var d = u * (f / e), p = 0, y = new ot();
    d < h ? (p = d / h, y.x = r.x1 + (r.x2 - r.x1) * p, y.y = r.y1 + (r.y2 - r.y1) * p) : d > h + c ? (d -= h + c, p = d / l, y.x = o.x1 + (o.x2 - o.x1) * p, y.y = o.y1 + (o.y2 - o.y1) * p) : (d -= h, p = d / c, y.x = a.x1 + (a.x2 - a.x1) * p, y.y = a.y1 + (a.y2 - a.y1) * p), s.push(y);
  }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var hM = function(i, e) {
  e === void 0 && (e = new ot());
  var n = i.x2 - i.x1, s = i.y2 - i.y1, r = i.x3 - i.x1, a = i.y3 - i.y1, o = Math.random(), h = Math.random();
  return o + h >= 1 && (o = 1 - o, h = 1 - h), e.x = i.x1 + (n * o + r * h), e.y = i.y1 + (s * o + a * h), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Zt = new Gt({
  initialize: function(e, n, s, r, a, o) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), r === void 0 && (r = 0), a === void 0 && (a = 0), o === void 0 && (o = 0), this.type = Ss.TRIANGLE, this.x1 = e, this.y1 = n, this.x2 = s, this.y2 = r, this.x3 = a, this.y3 = o;
  },
  /**
   * Checks whether a given points lies within the triangle.
   *
   * @method Phaser.Geom.Triangle#contains
   * @since 3.0.0
   *
   * @param {number} x - The x coordinate of the point to check.
   * @param {number} y - The y coordinate of the point to check.
   *
   * @return {boolean} `true` if the coordinate pair is within the triangle, otherwise `false`.
   */
  contains: function(i, e) {
    return cu(this, i, e);
  },
  /**
   * Returns a specific point  on the triangle.
   *
   * @method Phaser.Geom.Triangle#getPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [output,$return]
   *
   * @param {number} position - Position as float within `0` and `1`. `0` equals the first point.
   * @param {(Phaser.Geom.Point|object)} [output] - Optional Point, or point-like object, that the calculated point will be written to.
   *
   * @return {(Phaser.Geom.Point|object)} Calculated `Point` that represents the requested position. It is the same as `output` when this parameter has been given.
   */
  getPoint: function(i, e) {
    return aM(this, i, e);
  },
  /**
   * Calculates a list of evenly distributed points on the triangle. It is either possible to pass an amount of points to be generated (`quantity`) or the distance between two points (`stepRate`).
   *
   * @method Phaser.Geom.Triangle#getPoints
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point[]} O - [output,$return]
   *
   * @param {number} quantity - Number of points to be generated. Can be falsey when `stepRate` should be used. All points have the same distance along the triangle.
   * @param {number} [stepRate] - Distance between two points. Will only be used when `quantity` is falsey.
   * @param {(array|Phaser.Geom.Point[])} [output] - Optional Array for writing the calculated points into. Otherwise a new array will be created.
   *
   * @return {(array|Phaser.Geom.Point[])} Returns a list of calculated `Point` instances or the filled array passed as parameter `output`.
   */
  getPoints: function(i, e, n) {
    return oM(this, i, e, n);
  },
  /**
   * Returns a random point along the triangle.
   *
   * @method Phaser.Geom.Triangle#getRandomPoint
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Point} O - [point,$return]
   *
   * @param {Phaser.Geom.Point} [point] - Optional `Point` that should be modified. Otherwise a new one will be created.
   *
   * @return {Phaser.Geom.Point} Random `Point`. When parameter `point` has been provided it will be returned.
   */
  getRandomPoint: function(i) {
    return hM(this, i);
  },
  /**
   * Sets all three points of the triangle. Leaving out any coordinate sets it to be `0`.
   *
   * @method Phaser.Geom.Triangle#setTo
   * @since 3.0.0
   *
   * @param {number} [x1=0] - `x` coordinate of the first point.
   * @param {number} [y1=0] - `y` coordinate of the first point.
   * @param {number} [x2=0] - `x` coordinate of the second point.
   * @param {number} [y2=0] - `y` coordinate of the second point.
   * @param {number} [x3=0] - `x` coordinate of the third point.
   * @param {number} [y3=0] - `y` coordinate of the third point.
   *
   * @return {this} This Triangle object.
   */
  setTo: function(i, e, n, s, r, a) {
    return i === void 0 && (i = 0), e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), r === void 0 && (r = 0), a === void 0 && (a = 0), this.x1 = i, this.y1 = e, this.x2 = n, this.y2 = s, this.x3 = r, this.y3 = a, this;
  },
  /**
   * Returns a Line object that corresponds to Line A of this Triangle.
   *
   * @method Phaser.Geom.Triangle#getLineA
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Line} O - [line,$return]
   *
   * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
   *
   * @return {Phaser.Geom.Line} A Line object that corresponds to line A of this Triangle.
   */
  getLineA: function(i) {
    return i === void 0 && (i = new Pt()), i.setTo(this.x1, this.y1, this.x2, this.y2), i;
  },
  /**
   * Returns a Line object that corresponds to Line B of this Triangle.
   *
   * @method Phaser.Geom.Triangle#getLineB
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Line} O - [line,$return]
   *
   * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
   *
   * @return {Phaser.Geom.Line} A Line object that corresponds to line B of this Triangle.
   */
  getLineB: function(i) {
    return i === void 0 && (i = new Pt()), i.setTo(this.x2, this.y2, this.x3, this.y3), i;
  },
  /**
   * Returns a Line object that corresponds to Line C of this Triangle.
   *
   * @method Phaser.Geom.Triangle#getLineC
   * @since 3.0.0
   *
   * @generic {Phaser.Geom.Line} O - [line,$return]
   *
   * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.
   *
   * @return {Phaser.Geom.Line} A Line object that corresponds to line C of this Triangle.
   */
  getLineC: function(i) {
    return i === void 0 && (i = new Pt()), i.setTo(this.x3, this.y3, this.x1, this.y1), i;
  },
  /**
   * Left most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.
   *
   * @name Phaser.Geom.Triangle#left
   * @type {number}
   * @since 3.0.0
   */
  left: {
    get: function() {
      return Math.min(this.x1, this.x2, this.x3);
    },
    set: function(i) {
      var e = 0;
      this.x1 <= this.x2 && this.x1 <= this.x3 ? e = this.x1 - i : this.x2 <= this.x1 && this.x2 <= this.x3 ? e = this.x2 - i : e = this.x3 - i, this.x1 -= e, this.x2 -= e, this.x3 -= e;
    }
  },
  /**
   * Right most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.
   *
   * @name Phaser.Geom.Triangle#right
   * @type {number}
   * @since 3.0.0
   */
  right: {
    get: function() {
      return Math.max(this.x1, this.x2, this.x3);
    },
    set: function(i) {
      var e = 0;
      this.x1 >= this.x2 && this.x1 >= this.x3 ? e = this.x1 - i : this.x2 >= this.x1 && this.x2 >= this.x3 ? e = this.x2 - i : e = this.x3 - i, this.x1 -= e, this.x2 -= e, this.x3 -= e;
    }
  },
  /**
   * Top most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.
   *
   * @name Phaser.Geom.Triangle#top
   * @type {number}
   * @since 3.0.0
   */
  top: {
    get: function() {
      return Math.min(this.y1, this.y2, this.y3);
    },
    set: function(i) {
      var e = 0;
      this.y1 <= this.y2 && this.y1 <= this.y3 ? e = this.y1 - i : this.y2 <= this.y1 && this.y2 <= this.y3 ? e = this.y2 - i : e = this.y3 - i, this.y1 -= e, this.y2 -= e, this.y3 -= e;
    }
  },
  /**
   * Bottom most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.
   *
   * @name Phaser.Geom.Triangle#bottom
   * @type {number}
   * @since 3.0.0
   */
  bottom: {
    get: function() {
      return Math.max(this.y1, this.y2, this.y3);
    },
    set: function(i) {
      var e = 0;
      this.y1 >= this.y2 && this.y1 >= this.y3 ? e = this.y1 - i : this.y2 >= this.y1 && this.y2 >= this.y3 ? e = this.y2 - i : e = this.y3 - i, this.y1 -= e, this.y2 -= e, this.y3 -= e;
    }
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var NO = function(i) {
  var e = i.x1, n = i.y1, s = i.x2, r = i.y2, a = i.x3, o = i.y3;
  return Math.abs(((a - e) * (r - n) - (s - e) * (o - n)) / 2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var BO = function(i, e, n) {
  var s = n * (Math.sqrt(3) / 2), r = i, a = e, o = i + n / 2, h = e + s, c = i - n / 2, l = e + s;
  return new Zt(r, a, o, h, c, l);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var DO = function(i, e, n, s, r) {
  e === void 0 && (e = null), n === void 0 && (n = 1), s === void 0 && (s = 1), r === void 0 && (r = []);
  for (var a = uu(i, e), o, h, c, l, u, f, d, p, y, x = 0; x < a.length; x += 3)
    o = a[x], h = a[x + 1], c = a[x + 2], l = i[o * 2] * n, u = i[o * 2 + 1] * s, f = i[h * 2] * n, d = i[h * 2 + 1] * s, p = i[c * 2] * n, y = i[c * 2 + 1] * s, r.push(new Zt(l, u, f, d, p, y));
  return r;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var qO = function(i, e, n, s) {
  s === void 0 && (s = n);
  var r = i, a = e, o = i, h = e - s, c = i + n, l = e;
  return new Zt(r, a, o, h, c, l);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var cM = function(i, e) {
  return e === void 0 && (e = new ot()), e.x = (i.x1 + i.x2 + i.x3) / 3, e.y = (i.y1 + i.y2 + i.y3) / 3, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var lM = function(i, e, n) {
  return i.x1 += e, i.y1 += n, i.x2 += e, i.y2 += n, i.x3 += e, i.y3 += n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $O = function(i, e, n, s) {
  s === void 0 && (s = cM);
  var r = s(i), a = e - r.x, o = n - r.y;
  return lM(i, a, o);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function lf(i, e, n, s) {
  return i * s - e * n;
}
var VO = function(i, e) {
  e === void 0 && (e = new we());
  var n = i.x3, s = i.y3, r = i.x1 - n, a = i.y1 - s, o = i.x2 - n, h = i.y2 - s, c = 2 * lf(r, a, o, h), l = lf(a, r * r + a * a, h, o * o + h * h), u = lf(r, r * r + a * a, o, o * o + h * h);
  return e.x = n - l / c, e.y = s + u / c, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var GO = function(i, e) {
  e === void 0 && (e = new Oe());
  var n = i.x1, s = i.y1, r = i.x2, a = i.y2, o = i.x3, h = i.y3, c = r - n, l = a - s, u = o - n, f = h - s, d = c * (n + r) + l * (s + a), p = u * (n + o) + f * (s + h), y = 2 * (c * (h - a) - l * (o - r)), x, g;
  if (Math.abs(y) < 1e-6) {
    var m = Math.min(n, r, o), v = Math.min(s, a, h);
    x = (Math.max(n, r, o) - m) * 0.5, g = (Math.max(s, a, h) - v) * 0.5, e.x = m + x, e.y = v + g, e.radius = Math.sqrt(x * x + g * g);
  } else
    e.x = (f * d - l * p) / y, e.y = (c * p - u * d) / y, x = e.x - n, g = e.y - s, e.radius = Math.sqrt(x * x + g * g);
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var UO = function(i) {
  return new Zt(i.x1, i.y1, i.x2, i.y2, i.x3, i.y3);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var WO = function(i, e) {
  return cu(i, e.x, e.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var YO = function(i, e) {
  return e.setTo(i.x1, i.y1, i.x2, i.y2, i.x3, i.y3);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var jO = function(i, e) {
  return i.x1 === e.x1 && i.y1 === e.y1 && i.x2 === e.x2 && i.y2 === e.y2 && i.x3 === e.x3 && i.y3 === e.y3;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function uf(i, e, n, s) {
  var r = i - n, a = e - s, o = r * r + a * a;
  return Math.sqrt(o);
}
var uM = function(i, e) {
  e === void 0 && (e = new ot());
  var n = i.x1, s = i.y1, r = i.x2, a = i.y2, o = i.x3, h = i.y3, c = uf(o, h, r, a), l = uf(n, s, o, h), u = uf(r, a, n, s), f = c + l + u;
  return e.x = (n * c + r * l + o * u) / f, e.y = (s * c + a * l + h * u) / f, e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var HO = function(i) {
  var e = i.getLineA(), n = i.getLineB(), s = i.getLineC();
  return un(e) + un(n) + un(s);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var n1 = function(i, e, n, s) {
  var r = Math.cos(s), a = Math.sin(s), o = i.x1 - e, h = i.y1 - n;
  return i.x1 = o * r - h * a + e, i.y1 = o * a + h * r + n, o = i.x2 - e, h = i.y2 - n, i.x2 = o * r - h * a + e, i.y2 = o * a + h * r + n, o = i.x3 - e, h = i.y3 - n, i.x3 = o * r - h * a + e, i.y3 = o * a + h * r + n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var XO = function(i, e) {
  var n = uM(i);
  return n1(i, n.x, n.y, e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ZO = function(i, e, n) {
  return n1(i, e.x, e.y, n);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
Zt.Area = NO;
Zt.BuildEquilateral = BO;
Zt.BuildFromPolygon = DO;
Zt.BuildRight = qO;
Zt.CenterOn = $O;
Zt.Centroid = cM;
Zt.CircumCenter = VO;
Zt.CircumCircle = GO;
Zt.Clone = UO;
Zt.Contains = cu;
Zt.ContainsArray = $l;
Zt.ContainsPoint = WO;
Zt.CopyFrom = YO;
Zt.Decompose = R0;
Zt.Equals = jO;
Zt.GetPoint = aM;
Zt.GetPoints = oM;
Zt.InCenter = uM;
Zt.Perimeter = HO;
Zt.Offset = lM;
Zt.Random = hM;
Zt.Rotate = XO;
Zt.RotateAroundPoint = ZO;
Zt.RotateAroundXY = n1;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var JO = {
  Circle: Oe,
  Ellipse: Ne,
  Intersects: aI,
  Line: Pt,
  Mesh: MR,
  Point: ot,
  Polygon: pn,
  Rectangle: mt,
  Triangle: Zt,
  ...Ss
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var i1 = function(i) {
  if (!Array.isArray(i) || !Array.isArray(i[0]))
    return !1;
  for (var e = i[0].length, n = 1; n < i.length; n++)
    if (i[n].length !== e)
      return !1;
  return !0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var fM = function(i, e, n, s) {
  e === void 0 && (e = 0), n === void 0 && (n = " "), s === void 0 && (s = 3), i = i.toString();
  var r = 0;
  if (e + 1 >= i.length)
    switch (s) {
      case 1:
        i = new Array(e + 1 - i.length).join(n) + i;
        break;
      case 3:
        var a = Math.ceil((r = e - i.length) / 2), o = r - a;
        i = new Array(o + 1).join(n) + i + new Array(a + 1).join(n);
        break;
      default:
        i = i + new Array(e + 1 - i.length).join(n);
        break;
    }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var QO = function(i) {
  var e = "";
  if (!i1(i))
    return e;
  for (var n = 0; n < i.length; n++) {
    for (var s = 0; s < i[n].length; s++) {
      var r = i[n][s].toString();
      r !== "undefined" ? e += fM(r, 2) : e += "?", s < i[n].length - 1 && (e += " |");
    }
    if (n < i.length - 1) {
      e += `
`;
      for (var a = 0; a < i[n].length; a++)
        e += "---", a < i[n].length - 1 && (e += "+");
      e += `
`;
    }
  }
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var KO = function(i) {
  return i.reverse();
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var tk = function(i) {
  for (var e = 0; e < i.length; e++)
    i[e].reverse();
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var D0 = function(i) {
  for (var e = i.length, n = i[0].length, s = new Array(n), r = 0; r < n; r++) {
    s[r] = new Array(e);
    for (var a = e - 1; a > -1; a--)
      s[r][a] = i[a][r];
  }
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var du = function(i, e) {
  if (e === void 0 && (e = 90), !i1(i))
    return null;
  if (typeof e != "string" && (e = (e % 360 + 360) % 360), e === 90 || e === -270 || e === "rotateLeft")
    i = D0(i), i.reverse();
  else if (e === -90 || e === 270 || e === "rotateRight")
    i.reverse(), i = D0(i);
  else if (Math.abs(e) === 180 || e === "rotate180") {
    for (var n = 0; n < i.length; n++)
      i[n].reverse();
    i.reverse();
  }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ek = function(i) {
  return du(i, 180);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var nk = function(i, e) {
  e === void 0 && (e = 1);
  for (var n = 0; n < e; n++)
    i = du(i, 90);
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ik = function(i, e) {
  e === void 0 && (e = 1);
  for (var n = 0; n < e; n++)
    i = du(i, -90);
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var q0 = function(i, e) {
  e === void 0 && (e = 1);
  for (var n = null, s = 0; s < e; s++)
    n = i.shift(), i.push(n);
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $0 = function(i, e) {
  e === void 0 && (e = 1);
  for (var n = null, s = 0; s < e; s++)
    n = i.pop(), i.unshift(n);
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sk = function(i, e, n) {
  if (e === void 0 && (e = 0), n === void 0 && (n = 0), n !== 0 && (n < 0 ? q0(i, Math.abs(n)) : $0(i, n)), e !== 0)
    for (var s = 0; s < i.length; s++) {
      var r = i[s];
      e < 0 ? q0(r, Math.abs(e)) : $0(r, e);
    }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const rk = {
  CheckMatrix: i1,
  MatrixToString: QO,
  ReverseColumns: KO,
  ReverseRows: tk,
  Rotate180: ek,
  RotateLeft: nk,
  RotateMatrix: du,
  RotateRight: ik,
  Translate: sk,
  TransposeMatrix: D0
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ak = function(i, e, n, s, r) {
  if (r === void 0 && (r = i), n > 0) {
    var a = n - i.length;
    if (a <= 0)
      return null;
  }
  if (!Array.isArray(e))
    return i.indexOf(e) === -1 ? (i.push(e), s && s.call(r, e), e) : null;
  for (var o = e.length - 1; o >= 0; )
    i.indexOf(e[o]) !== -1 && e.splice(o, 1), o--;
  if (o = e.length, o === 0)
    return null;
  n > 0 && o > a && (e.splice(a), o = a);
  for (var h = 0; h < o; h++) {
    var c = e[h];
    i.push(c), s && s.call(r, c);
  }
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ok = function(i, e, n, s, r, a) {
  if (n === void 0 && (n = 0), a === void 0 && (a = i), s > 0) {
    var o = s - i.length;
    if (o <= 0)
      return null;
  }
  if (!Array.isArray(e))
    return i.indexOf(e) === -1 ? (i.splice(n, 0, e), r && r.call(a, e), e) : null;
  for (var h = e.length - 1; h >= 0; )
    i.indexOf(e[h]) !== -1 && e.pop(), h--;
  if (h = e.length, h === 0)
    return null;
  s > 0 && h > o && (e.splice(o), h = o);
  for (var c = h - 1; c >= 0; c--) {
    var l = e[c];
    i.splice(n, 0, l), r && r.call(a, l);
  }
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var hk = function(i, e) {
  var n = i.indexOf(e);
  return n !== -1 && n < i.length && (i.splice(n, 1), i.push(e)), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var bs = function(i, e, n, s) {
  var r = i.length;
  if (e < 0 || e >= r || e >= n || n > r) {
    if (s)
      throw new Error("Range Error: Values outside acceptable range");
    return !1;
  } else
    return !0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ck = function(i, e, n, s, r) {
  s === void 0 && (s = 0), r === void 0 && (r = i.length);
  var a = 0;
  if (bs(i, s, r))
    for (var o = s; o < r; o++) {
      var h = i[o];
      h[e] === n && a++;
    }
  return a;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var lk = function(i, e, n) {
  var s, r = [null];
  for (s = 3; s < arguments.length; s++)
    r.push(arguments[s]);
  for (s = 0; s < i.length; s++)
    r[0] = i[s], e.apply(n, r);
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var uk = function(i, e, n, s, r) {
  if (s === void 0 && (s = 0), r === void 0 && (r = i.length), bs(i, s, r)) {
    var a, o = [null];
    for (a = 5; a < arguments.length; a++)
      o.push(arguments[a]);
    for (a = s; a < r; a++)
      o[0] = i[a], e.apply(n, o);
  }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var fk = function(i, e, n) {
  if (e.length) {
    if (e.length === 1)
      return e[0];
  } else return NaN;
  var s = 1, r, a;
  if (n) {
    if (i < e[0][n])
      return e[0];
    for (; e[s][n] < i; )
      s++;
  } else
    for (; e[s] < i; )
      s++;
  return s > e.length && (s = e.length), n ? (r = e[s - 1][n], a = e[s][n], a - i <= i - r ? e[s] : e[s - 1]) : (r = e[s - 1], a = e[s], a - i <= i - r ? a : r);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var s1 = function(i, e) {
  e === void 0 && (e = []);
  for (var n = 0; n < i.length; n++)
    Array.isArray(i[n]) ? s1(i[n], e) : e.push(i[n]);
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var dk = function(i, e, n, s, r) {
  s === void 0 && (s = 0), r === void 0 && (r = i.length);
  var a = [];
  if (bs(i, s, r))
    for (var o = s; o < r; o++) {
      var h = i[o];
      (!e || e && n === void 0 && h.hasOwnProperty(e) || e && n !== void 0 && h[e] === n) && a.push(h);
    }
  return a;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var pk = function(i, e, n, s, r) {
  if (s === void 0 && (s = 0), r === void 0 && (r = i.length), s !== -1) {
    if (bs(i, s, r))
      for (var a = s; a < r; a++) {
        var o = i[a];
        if (!e || e && n === void 0 && o.hasOwnProperty(e) || e && n !== void 0 && o[e] === n)
          return o;
      }
  } else if (bs(i, 0, r))
    for (var a = r; a >= 0; a--) {
      var o = i[a];
      if (!e || e && n === void 0 && o.hasOwnProperty(e) || e && n !== void 0 && o[e] === n)
        return o;
    }
  return null;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var yk = function(i, e, n) {
  e === void 0 && (e = 0), n === void 0 && (n = i.length);
  var s = e + Math.floor(Math.random() * n);
  return i[s] === void 0 ? null : i[s];
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xk = function(i, e) {
  var n = i.indexOf(e);
  if (n > 0) {
    var s = i[n - 1], r = i.indexOf(s);
    i[n] = s, i[r] = e;
  }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var gk = function(i, e, n) {
  var s = i.indexOf(e);
  if (s === -1 || n < 0 || n >= i.length)
    throw new Error("Supplied index out of bounds");
  return s !== n && (i.splice(s, 1), i.splice(n, 0, e)), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var mk = function(i, e) {
  var n = i.indexOf(e);
  if (n !== -1 && n < i.length - 1) {
    var s = i[n + 1], r = i.indexOf(s);
    i[n] = s, i[r] = e;
  }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vk = function(i, e, n) {
  if (e === n)
    return i;
  var s = i.indexOf(e), r = i.indexOf(n);
  if (s < 0 || r < 0)
    throw new Error("Supplied items must be elements of the same array");
  return s > r || (i.splice(s, 1), r = i.indexOf(n), i.splice(r + 1, 0, e)), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var wk = function(i, e, n) {
  if (e === n)
    return i;
  var s = i.indexOf(e), r = i.indexOf(n);
  if (s < 0 || r < 0)
    throw new Error("Supplied items must be elements of the same array");
  return s < r || (i.splice(s, 1), r === 0 ? i.unshift(e) : i.splice(r, 0, e)), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Mk = function(i, e, n, s) {
  var r = [], a, o = !1;
  if ((n || s) && (o = !0, n || (n = ""), s || (s = "")), e < i)
    for (a = i; a >= e; a--)
      o ? r.push(n + a.toString() + s) : r.push(a);
  else
    for (a = i; a <= e; a++)
      o ? r.push(n + a.toString() + s) : r.push(a);
  return r;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var dM = function(i) {
  return i > 0 ? Math.ceil(i) : Math.floor(i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var bk = function(i, e, n) {
  i === void 0 && (i = 0), e === void 0 && (e = null), n === void 0 && (n = 1), e === null && (e = i, i = 0);
  for (var s = [], r = Math.max(dM((e - i) / (n || 1)), 0), a = 0; a < r; a++)
    s.push(i), i += n;
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function io(i, e, n) {
  var s = i[e];
  i[e] = i[n], i[n] = s;
}
function _k(i, e) {
  return i < e ? -1 : i > e ? 1 : 0;
}
var pM = function(i, e, n, s, r) {
  for (n === void 0 && (n = 0), s === void 0 && (s = i.length - 1), r === void 0 && (r = _k); s > n; ) {
    if (s - n > 600) {
      var a = s - n + 1, o = e - n + 1, h = Math.log(a), c = 0.5 * Math.exp(2 * h / 3), l = 0.5 * Math.sqrt(h * c * (a - c) / a) * (o - a / 2 < 0 ? -1 : 1), u = Math.max(n, Math.floor(e - o * c / a + l)), f = Math.min(s, Math.floor(e + (a - o) * c / a + l));
      pM(i, e, u, f, r);
    }
    var d = i[e], p = n, y = s;
    for (io(i, n, e), r(i[s], d) > 0 && io(i, n, s); p < y; ) {
      for (io(i, p, y), p++, y--; r(i[p], d) < 0; )
        p++;
      for (; r(i[y], d) > 0; )
        y--;
    }
    r(i[n], d) === 0 ? io(i, n, y) : (y++, io(i, y, s)), y <= e && (n = y + 1), e <= y && (s = y - 1);
  }
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ne = function(i, e, n, s) {
  if (!i && !s || typeof i == "number")
    return n;
  if (i && i.hasOwnProperty(e))
    return i[e];
  if (s && s.hasOwnProperty(e))
    return s[e];
  if (e.indexOf(".") !== -1) {
    for (var r = e.split("."), a = i, o = s, h = n, c = n, l = !0, u = !0, f = 0; f < r.length; f++)
      a && a.hasOwnProperty(r[f]) ? (h = a[r[f]], a = a[r[f]]) : l = !1, o && o.hasOwnProperty(r[f]) ? (c = o[r[f]], o = o[r[f]]) : u = !1;
    return l ? h : u ? c : n;
  } else
    return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var V0 = function(i) {
  for (var e = i.length - 1; e > 0; e--) {
    var n = Math.floor(Math.random() * (e + 1)), s = i[e];
    i[e] = i[n], i[n] = s;
  }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Sk = function(i, e, n) {
  for (var s = [], r = 0; r < i.length; r++)
    for (var a = 0; a < e.length; a++)
      for (var o = 0; o < n; o++)
        s.push({ a: i[r], b: e[a] });
  return s;
}, Tk = function(i, e, n) {
  var s = ne(n, "max", 0), r = ne(n, "qty", 1), a = ne(n, "random", !1), o = ne(n, "randomB", !1), h = ne(n, "repeat", 0), c = ne(n, "yoyo", !1), l = [];
  if (o && V0(e), h === -1)
    if (s === 0)
      h = 0;
    else {
      var u = i.length * e.length * r;
      c && (u *= 2), h = Math.ceil(s / u);
    }
  for (var f = 0; f <= h; f++) {
    var d = Sk(i, e, r);
    a && V0(d), l = l.concat(d), c && (d.reverse(), l = l.concat(d));
  }
  return s && l.splice(s), l;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var uh = function(i, e) {
  if (!(e >= i.length)) {
    for (var n = i.length - 1, s = i[e], r = e; r < n; r++)
      i[r] = i[r + 1];
    return i.length = n, s;
  }
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var r1 = function(i, e, n, s) {
  s === void 0 && (s = i);
  var r;
  if (!Array.isArray(e))
    return r = i.indexOf(e), r !== -1 ? (uh(i, r), n && n.call(s, e), e) : null;
  for (var a = e.length - 1, o = []; a >= 0; ) {
    var h = e[a];
    r = i.indexOf(h), r !== -1 && (uh(i, r), o.push(h), n && n.call(s, h)), a--;
  }
  return o;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ek = function(i, e, n, s) {
  if (s === void 0 && (s = i), e < 0 || e > i.length - 1)
    throw new Error("Index out of bounds");
  var r = uh(i, e);
  return n && n.call(s, r), r;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var zk = function(i, e, n, s, r) {
  if (e === void 0 && (e = 0), n === void 0 && (n = i.length), r === void 0 && (r = i), bs(i, e, n)) {
    var a = n - e, o = i.splice(e, a);
    if (s)
      for (var h = 0; h < o.length; h++) {
        var c = o[h];
        s.call(r, c);
      }
    return o;
  } else
    return [];
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ck = function(i, e, n) {
  e === void 0 && (e = 0), n === void 0 && (n = i.length);
  var s = e + Math.floor(Math.random() * n);
  return uh(i, s);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ak = function(i, e, n) {
  var s = i.indexOf(e), r = i.indexOf(n);
  return s !== -1 && r === -1 ? (i[s] = n, !0) : !1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Pk = function(i, e) {
  var n = i.indexOf(e);
  return n !== -1 && n > 0 && (i.splice(n, 1), i.unshift(e)), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ik = function(i, e, n, s, r) {
  if (s === void 0 && (s = 0), r === void 0 && (r = i.length), bs(i, s, r))
    for (var a = s; a < r; a++) {
      var o = i[a];
      o.hasOwnProperty(e) && (o[e] = n);
    }
  return i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Rk = function(i) {
  var e = /\D/g;
  return i.sort(function(n, s) {
    return parseInt(n.replace(e, ""), 10) - parseInt(s.replace(e, ""), 10);
  }), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @author       Angry Bytes (and contributors)
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function Ok(i, e) {
  return String(i).localeCompare(e);
}
function kk(i, e) {
  var n = i.length;
  if (n <= 1)
    return i;
  for (var s = new Array(n), r = 1; r < n; r *= 2) {
    yM(i, e, r, s);
    var a = i;
    i = s, s = a;
  }
  return i;
}
function yM(i, e, n, s) {
  var r = i.length, a = 0, o = n * 2, h, c, l, u, f;
  for (h = 0; h < r; h += o)
    for (c = h + n, l = c + n, c > r && (c = r), l > r && (l = r), u = h, f = c; ; )
      if (u < c && f < l)
        e(i[u], i[f]) <= 0 ? s[a++] = i[u++] : s[a++] = i[f++];
      else if (u < c)
        s[a++] = i[u++];
      else if (f < l)
        s[a++] = i[f++];
      else
        break;
}
var Lk = function(i, e, n = !0) {
  if (e === void 0 && (e = Ok), !i || i.length < 2)
    return i;
  if (n)
    return i.sort(e);
  var s = kk(i, e);
  return s !== i && yM(s, null, i.length, i), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Fk = function(i, e, n) {
  if (e === n)
    return i;
  var s = i.indexOf(e), r = i.indexOf(n);
  if (s < 0 || r < 0)
    throw new Error("Supplied items must be elements of the same array");
  return i[s] = n, i[r] = e, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const Nk = {
  Matrix: rk,
  Add: ak,
  AddAt: ok,
  BringToTop: hk,
  CountAllMatching: ck,
  Each: lk,
  EachInRange: uk,
  FindClosestInSorted: fk,
  Flatten: s1,
  GetAll: dk,
  GetFirst: pk,
  GetRandom: yk,
  MoveDown: xk,
  MoveTo: gk,
  MoveUp: mk,
  MoveAbove: vk,
  MoveBelow: wk,
  NumberArray: Mk,
  NumberArrayStep: bk,
  QuickSelect: pM,
  Range: Tk,
  Remove: r1,
  RemoveAt: Ek,
  RemoveBetween: zk,
  RemoveRandomElement: Ck,
  Replace: Ak,
  RotateLeft: q0,
  RotateRight: $0,
  SafeRange: bs,
  SendToBack: Pk,
  SetAll: Ik,
  Shuffle: V0,
  SortByDigits: Rk,
  SpliceOne: uh,
  StableSort: Lk,
  Swap: Fk
};
/**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Sc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Bk = function(i, e) {
  for (var n = new Uint8Array(i), s = n.length, r = e ? "data:" + e + ";base64," : "", a = 0; a < s; a += 3)
    r += Sc[n[a] >> 2], r += Sc[(n[a] & 3) << 4 | n[a + 1] >> 4], r += Sc[(n[a + 1] & 15) << 2 | n[a + 2] >> 6], r += Sc[n[a + 2] & 63];
  return s % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : s % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
};
/**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var tg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", To = new Uint8Array(256);
for (var Tc = 0; Tc < tg.length; Tc++)
  To[tg.charCodeAt(Tc)] = Tc;
var Dk = function(i) {
  i = i.substr(i.indexOf(",") + 1);
  var e = i.length, n = e * 0.75, s = 0, r, a, o, h;
  i[e - 1] === "=" && (n--, i[e - 2] === "=" && n--);
  for (var c = new ArrayBuffer(n), l = new Uint8Array(c), u = 0; u < e; u += 4)
    r = To[i.charCodeAt(u)], a = To[i.charCodeAt(u + 1)], o = To[i.charCodeAt(u + 2)], h = To[i.charCodeAt(u + 3)], l[s++] = r << 2 | a >> 4, l[s++] = (a & 15) << 4 | o >> 2, l[s++] = (o & 3) << 6 | h & 63;
  return c;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const qk = {
  ArrayBufferToBase64: Bk,
  Base64ToArrayBuffer: Dk
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var a1 = function(i) {
  var e = {};
  for (var n in i)
    Array.isArray(i[n]) ? e[n] = i[n].slice(0) : e[n] = i[n];
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xM = function(i) {
  var e, n, s;
  if (typeof i != "object" || i === null)
    return i;
  e = Array.isArray(i) ? [] : {};
  for (s in i)
    n = i[s], e[s] = xM(n);
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var G0 = function(i) {
  if (!i || typeof i != "object" || i.nodeType || i === i.window)
    return !1;
  try {
    if (i.constructor && !{}.hasOwnProperty.call(i.constructor.prototype, "isPrototypeOf"))
      return !1;
  } catch {
    return !1;
  }
  return !0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var o1 = function() {
  var i, e, n, s, r, a, o = arguments[0] || {}, h = 1, c = arguments.length, l = !1;
  for (typeof o == "boolean" && (l = o, o = arguments[1] || {}, h = 2), c === h && (o = this, --h); h < c; h++)
    if ((i = arguments[h]) != null)
      for (e in i)
        n = o[e], s = i[e], o !== s && (l && s && (G0(s) || (r = Array.isArray(s))) ? (r ? (r = !1, a = n && Array.isArray(n) ? n : []) : a = n && G0(n) ? n : {}, o[e] = o1(l, a, s)) : s !== void 0 && (o[e] = s));
  return o;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $k = function(i, e, n, s) {
  return Math.atan2(s - e, n - i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Vk = function(i, e) {
  return Math.atan2(e.y - i.y, e.x - i.x);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Gk = function(i, e) {
  return Math.atan2(e.x - i.x, e.y - i.y);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Uk = function(i, e, n, s) {
  return Math.atan2(n - i, s - e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Wk = function(i) {
  return i > Math.PI && (i -= ce.PI2), Math.abs(((i + ce.TAU) % ce.PI2 - ce.PI2) % ce.PI2);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var pu = function(i) {
  return i = i % (2 * Math.PI), i >= 0 ? i : i + 2 * Math.PI;
};
/**
 * @author       samme
 * @copyright    2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Yk = function(i, e) {
  return pu(e - i);
};
/**
 * @author       samme
 * @copyright    2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var jk = 2 * Math.PI, Hk = function(i, e) {
  var n = pu(e - i);
  return n > 0 && (n -= jk), n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var gM = function(i) {
  return lu(i, -Math.PI, Math.PI);
};
/**
 * @author       samme
 * @copyright    2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Xk = function(i, e) {
  return gM(e - i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var yu = function(i, e) {
  return Math.random() * (e - i) + i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @author       @samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Zk = function() {
  return yu(-Math.PI, Math.PI);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @author       @samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Jk = function() {
  return yu(-180, 180);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Qk = function(i) {
  return pu(i + Math.PI);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Kk = function(i, e, n) {
  return n === void 0 && (n = 0.05), i === e || (Math.abs(e - i) <= n || Math.abs(e - i) >= ce.PI2 - n ? i = e : (Math.abs(e - i) > Math.PI && (e < i ? e += ce.PI2 : e -= ce.PI2), e > i ? i += n : e < i && (i -= n))), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var tL = function(i, e) {
  var n = e - i;
  if (n === 0)
    return 0;
  var s = Math.floor((n - -180) / 360);
  return n - s * 360;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var eL = function(i) {
  return lu(i, -180, 180);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const nL = {
  Between: $k,
  BetweenPoints: Vk,
  BetweenPointsY: Gk,
  BetweenY: Uk,
  CounterClockwise: Wk,
  GetClockwiseDistance: Yk,
  GetCounterClockwiseDistance: Hk,
  GetShortestDistance: Xk,
  Normalize: pu,
  Random: Zk,
  RandomDegrees: Jk,
  Reverse: Qk,
  RotateTo: Kk,
  ShortestBetween: tL,
  Wrap: gM,
  WrapDegrees: eL
};
/**
 * @author       samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var iL = function(i, e) {
  var n = i.x - e.x, s = i.y - e.y;
  return n * n + s * s;
};
/**
 * @author       samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sL = function(i, e, n, s) {
  return Math.max(Math.abs(i - n), Math.abs(e - s));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var rL = function(i, e, n, s, r) {
  return r === void 0 && (r = 2), Math.sqrt(Math.pow(n - i, r) + Math.pow(s - e, r));
};
/**
 * @author       samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var aL = function(i, e, n, s) {
  return Math.abs(i - n) + Math.abs(e - s);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var oL = function(i, e, n, s) {
  var r = i - n, a = e - s;
  return r * r + a * a;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const hL = {
  Between: Rw,
  BetweenPoints: O0,
  BetweenPointsSquared: iL,
  Chebyshev: sL,
  Power: rL,
  Snake: aL,
  Squared: oL
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const cL = {
  Back: vo,
  Bounce: wo,
  Circular: Mo,
  Cubic: aa,
  Elastic: bo,
  Expo: _o,
  Linear: k0,
  Quadratic: oa,
  Quartic: ha,
  Quintic: ca,
  Sine: So,
  Stepped: Ww
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var lL = function(i, e) {
  return e === void 0 && (e = 1e-4), Math.ceil(i - e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var uL = function(i, e) {
  return e === void 0 && (e = 1e-4), Math.floor(i + e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var fL = function(i, e, n) {
  return n === void 0 && (n = 1e-4), i > e - n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var dL = function(i, e, n) {
  return n === void 0 && (n = 1e-4), i < e + n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const pL = {
  Ceil: lL,
  Equal: I0,
  Floor: uL,
  GreaterThan: fL,
  LessThan: dL
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sl = function(i) {
  if (i === 0)
    return 1;
  for (var e = i; --i; )
    e *= i;
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var mM = function(i, e) {
  return sl(i) / sl(e) / sl(i - e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vM = function(i, e) {
  for (var n = 0, s = i.length - 1, r = 0; r <= s; r++)
    n += Math.pow(1 - e, s - r) * Math.pow(e, r) * i[r] * mM(s, r);
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Eo = function(i, e, n, s, r) {
  var a = (s - e) * 0.5, o = (r - n) * 0.5, h = i * i, c = i * h;
  return (2 * n - 2 * s + a + o) * c + (-3 * n + 3 * s - 2 * a - o) * h + a * i + n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var U0 = function(i, e) {
  var n = i.length - 1, s = n * e, r = Math.floor(s);
  return i[0] === i[n] ? (e < 0 && (r = Math.floor(s = n * (1 + e))), Eo(s - r, i[(r - 1 + n) % n], i[r], i[(r + 1) % n], i[(r + 2) % n])) : e < 0 ? i[0] - (Eo(-s, i[0], i[0], i[1], i[1]) - i[0]) : e > 1 ? i[n] - (Eo(s - n, i[n], i[n], i[n - 1], i[n - 1]) - i[n]) : Eo(s - r, i[r ? r - 1 : 0], i[r], i[n < r + 1 ? n : r + 1], i[n < r + 2 ? n : r + 2]);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function yL(i, e) {
  var n = 1 - i;
  return n * n * n * e;
}
function xL(i, e) {
  var n = 1 - i;
  return 3 * n * n * i * e;
}
function gL(i, e) {
  return 3 * (1 - i) * i * i * e;
}
function mL(i, e) {
  return i * i * i * e;
}
var vL = function(i, e, n, s, r) {
  return yL(i, e) + xL(i, n) + gL(i, s) + mL(i, r);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vr = function(i, e, n) {
  return (e - i) * n + i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var wM = function(i, e) {
  var n = i.length - 1, s = n * e, r = Math.floor(s);
  return e < 0 ? vr(i[0], i[1], s) : e > 1 ? vr(i[n], i[n - 1], n - s) : vr(i[r], i[r + 1 > n ? n : r + 1], s - r);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function wL(i, e) {
  var n = 1 - i;
  return n * n * e;
}
function ML(i, e) {
  return 2 * (1 - i) * i * e;
}
function bL(i, e) {
  return i * i * e;
}
var _L = function(i, e, n, s) {
  return wL(i, e) + ML(i, n) + bL(i, s);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var MM = function(i, e, n) {
  return i <= e ? 0 : i >= n ? 1 : (i = (i - e) / (n - e), i * i * (3 - 2 * i));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var SL = function(i, e, n) {
  return e + (n - e) * MM(i, 0, 1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var bM = function(i, e, n) {
  return i = Math.max(0, Math.min(1, (i - e) / (n - e))), i * i * i * (i * (i * 6 - 15) + 10);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var TL = function(i, e, n) {
  return e + (n - e) * bM(i, 0, 1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const EL = {
  Bezier: vM,
  CatmullRom: U0,
  CubicBezier: vL,
  Linear: wM,
  QuadraticBezier: _L,
  SmoothStep: SL,
  SmootherStep: TL
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var zL = function(i) {
  var e = Math.log(i) / 0.6931471805599453;
  return 1 << Math.ceil(e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var CL = function(i, e) {
  return i > 0 && (i & i - 1) === 0 && e > 0 && (e & e - 1) === 0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var AL = function(i) {
  return i > 0 && (i & i - 1) === 0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const PL = {
  GetNext: zL,
  IsSize: CL,
  IsValue: AL
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var IL = function(i, e, n, s) {
  return n === void 0 && (n = 0), e === 0 ? i : (i -= n, i = e * Math.ceil(i / e), s ? (n + i) / e : n + i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var RL = function(i, e, n, s) {
  return n === void 0 && (n = 0), e === 0 ? i : (i -= n, i = e * Math.floor(i / e), s ? (n + i) / e : n + i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var OL = function(i, e, n, s) {
  return n === void 0 && (n = 0), e === 0 ? i : (i -= n, i = e * Math.round(i / e), s ? (n + i) / e : n + i);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const kL = {
  Ceil: IL,
  Floor: RL,
  To: OL
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var LL = new Gt({
  initialize: function(e) {
    e === void 0 && (e = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], e && this.init(e);
  },
  /**
   * Private random helper.
   *
   * @method Phaser.Math.RandomDataGenerator#rnd
   * @since 3.0.0
   * @private
   *
   * @return {number} A random number.
   */
  rnd: function() {
    var i = 2091639 * this.s0 + this.c * 23283064365386963e-26;
    return this.c = i | 0, this.s0 = this.s1, this.s1 = this.s2, this.s2 = i - this.c, this.s2;
  },
  /**
   * Internal method that creates a seed hash.
   *
   * @method Phaser.Math.RandomDataGenerator#hash
   * @since 3.0.0
   * @private
   *
   * @param {string} data - The value to hash.
   *
   * @return {number} The hashed value.
   */
  hash: function(i) {
    var e, n = this.n;
    i = i.toString();
    for (var s = 0; s < i.length; s++)
      n += i.charCodeAt(s), e = 0.02519603282416938 * n, n = e >>> 0, e -= n, e *= n, n = e >>> 0, e -= n, n += e * 4294967296;
    return this.n = n, (n >>> 0) * 23283064365386963e-26;
  },
  /**
   * Initialize the state of the random data generator.
   *
   * @method Phaser.Math.RandomDataGenerator#init
   * @since 3.0.0
   *
   * @param {(string|string[])} seeds - The seeds to initialize the random data generator with.
   */
  init: function(i) {
    typeof i == "string" ? this.state(i) : this.sow(i);
  },
  /**
   * Reset the seed of the random data generator.
   *
   * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
   *
   * @method Phaser.Math.RandomDataGenerator#sow
   * @since 3.0.0
   *
   * @param {string[]} seeds - The array of seeds: the `toString()` of each value is used.
   */
  sow: function(i) {
    if (this.n = 4022871197, this.s0 = this.hash(" "), this.s1 = this.hash(" "), this.s2 = this.hash(" "), this.c = 1, !!i)
      for (var e = 0; e < i.length && i[e] != null; e++) {
        var n = i[e];
        this.s0 -= this.hash(n), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(n), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(n), this.s2 += ~~(this.s2 < 0);
      }
  },
  /**
   * Returns a random integer between 0 and 2^32.
   *
   * @method Phaser.Math.RandomDataGenerator#integer
   * @since 3.0.0
   *
   * @return {number} A random integer between 0 and 2^32.
   */
  integer: function() {
    return this.rnd() * 4294967296;
  },
  /**
   * Returns a random real number between 0 and 1.
   *
   * @method Phaser.Math.RandomDataGenerator#frac
   * @since 3.0.0
   *
   * @return {number} A random real number between 0 and 1.
   */
  frac: function() {
    return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
  },
  /**
   * Returns a random real number between 0 and 2^32.
   *
   * @method Phaser.Math.RandomDataGenerator#real
   * @since 3.0.0
   *
   * @return {number} A random real number between 0 and 2^32.
   */
  real: function() {
    return this.integer() + this.frac();
  },
  /**
   * Returns a random integer between and including min and max.
   *
   * @method Phaser.Math.RandomDataGenerator#integerInRange
   * @since 3.0.0
   *
   * @param {number} min - The minimum value in the range.
   * @param {number} max - The maximum value in the range.
   *
   * @return {number} A random number between min and max.
   */
  integerInRange: function(i, e) {
    return Math.floor(this.realInRange(0, e - i + 1) + i);
  },
  /**
   * Returns a random integer between and including min and max.
   * This method is an alias for RandomDataGenerator.integerInRange.
   *
   * @method Phaser.Math.RandomDataGenerator#between
   * @since 3.0.0
   *
   * @param {number} min - The minimum value in the range.
   * @param {number} max - The maximum value in the range.
   *
   * @return {number} A random number between min and max.
   */
  between: function(i, e) {
    return Math.floor(this.realInRange(0, e - i + 1) + i);
  },
  /**
   * Returns a random real number between min and max.
   *
   * @method Phaser.Math.RandomDataGenerator#realInRange
   * @since 3.0.0
   *
   * @param {number} min - The minimum value in the range.
   * @param {number} max - The maximum value in the range.
   *
   * @return {number} A random number between min and max.
   */
  realInRange: function(i, e) {
    return this.frac() * (e - i) + i;
  },
  /**
   * Returns a random real number between -1 and 1.
   *
   * @method Phaser.Math.RandomDataGenerator#normal
   * @since 3.0.0
   *
   * @return {number} A random real number between -1 and 1.
   */
  normal: function() {
    return 1 - 2 * this.frac();
  },
  /**
   * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
   *
   * @method Phaser.Math.RandomDataGenerator#uuid
   * @since 3.0.0
   *
   * @return {string} A valid RFC4122 version4 ID hex string
   */
  uuid: function() {
    var i = "", e = "";
    for (e = i = ""; i++ < 36; e += ~i % 5 | i * 3 & 4 ? (i ^ 15 ? 8 ^ this.frac() * (i ^ 20 ? 16 : 4) : 4).toString(16) : "-")
      ;
    return e;
  },
  /**
   * Returns a random element from within the given array.
   *
   * @method Phaser.Math.RandomDataGenerator#pick
   * @since 3.0.0
   *
   * @generic T
   * @genericUse {T[]} - [array]
   * @genericUse {T} - [$return]
   *
   * @param {T[]} array - The array to pick a random element from.
   *
   * @return {T} A random member of the array.
   */
  pick: function(i) {
    return i[this.integerInRange(0, i.length - 1)];
  },
  /**
   * Returns a sign to be used with multiplication operator.
   *
   * @method Phaser.Math.RandomDataGenerator#sign
   * @since 3.0.0
   *
   * @return {number} -1 or +1.
   */
  sign: function() {
    return this.pick(this.signs);
  },
  /**
   * Returns a random element from within the given array, favoring the earlier entries.
   *
   * @method Phaser.Math.RandomDataGenerator#weightedPick
   * @since 3.0.0
   *
   * @generic T
   * @genericUse {T[]} - [array]
   * @genericUse {T} - [$return]
   *
   * @param {T[]} array - The array to pick a random element from.
   *
   * @return {T} A random member of the array.
   */
  weightedPick: function(i) {
    return i[~~(Math.pow(this.frac(), 2) * (i.length - 0.5) + 0.5)];
  },
  /**
   * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
   *
   * @method Phaser.Math.RandomDataGenerator#timestamp
   * @since 3.0.0
   *
   * @param {number} min - The minimum value in the range.
   * @param {number} max - The maximum value in the range.
   *
   * @return {number} A random timestamp between min and max.
   */
  timestamp: function(i, e) {
    return this.realInRange(i || 9466848e5, e || 1577862e6);
  },
  /**
   * Returns a random angle between -180 and 180.
   *
   * @method Phaser.Math.RandomDataGenerator#angle
   * @since 3.0.0
   *
   * @return {number} A random number between -180 and 180.
   */
  angle: function() {
    return this.integerInRange(-180, 180);
  },
  /**
   * Returns a random rotation in radians, between -3.141 and 3.141
   *
   * @method Phaser.Math.RandomDataGenerator#rotation
   * @since 3.0.0
   *
   * @return {number} A random number between -3.141 and 3.141
   */
  rotation: function() {
    return this.realInRange(-3.1415926, 3.1415926);
  },
  /**
   * Gets or Sets the state of the generator. This allows you to retain the values
   * that the generator is using between games, i.e. in a game save file.
   *
   * To seed this generator with a previously saved state you can pass it as the
   * `seed` value in your game config, or call this method directly after Phaser has booted.
   *
   * Call this method with no parameters to return the current state.
   *
   * If providing a state it should match the same format that this method
   * returns, which is a string with a header `!rnd` followed by the `c`,
   * `s0`, `s1` and `s2` values respectively, each comma-delimited.
   *
   * @method Phaser.Math.RandomDataGenerator#state
   * @since 3.0.0
   *
   * @param {string} [state] - Generator state to be set.
   *
   * @return {string} The current state of the generator.
   */
  state: function(i) {
    return typeof i == "string" && i.match(/^!rnd/) && (i = i.split(","), this.c = parseFloat(i[1]), this.s0 = parseFloat(i[2]), this.s1 = parseFloat(i[3]), this.s2 = parseFloat(i[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
  },
  /**
   * Shuffles the given array, using the current seed.
   *
   * @method Phaser.Math.RandomDataGenerator#shuffle
   * @since 3.7.0
   *
   * @generic T
   * @genericUse {T[]} - [array,$return]
   *
   * @param {T[]} [array] - The array to be shuffled.
   *
   * @return {T[]} The shuffled array.
   */
  shuffle: function(i) {
    for (var e = i.length - 1, n = e; n > 0; n--) {
      var s = Math.floor(this.frac() * (n + 1)), r = i[s];
      i[s] = i[n], i[n] = r;
    }
    return i;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var FL = function(i) {
  for (var e = 0, n = 0; n < i.length; n++)
    e += +i[n];
  return e / i.length;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var NL = function(i, e, n) {
  e === void 0 && (e = 0), n === void 0 && (n = 10);
  var s = Math.pow(n, -e);
  return Math.ceil(i * s) / s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var BL = function(i, e) {
  return Math.abs(i - e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xu = function() {
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var eg = new Ts(), h1 = new Gt({
  initialize: function i(e, n, s, r) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), r === void 0 && (r = i.DefaultOrder), this._x = e, this._y = n, this._z = s, this._order = r, this.onChangeCallback = xu;
  },
  x: {
    get: function() {
      return this._x;
    },
    set: function(i) {
      this._x = i, this.onChangeCallback(this);
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(i) {
      this._y = i, this.onChangeCallback(this);
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(i) {
      this._z = i, this.onChangeCallback(this);
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(i) {
      this._order = i, this.onChangeCallback(this);
    }
  },
  set: function(i, e, n, s) {
    return s === void 0 && (s = this._order), this._x = i, this._y = e, this._z = n, this._order = s, this.onChangeCallback(this), this;
  },
  copy: function(i) {
    return this.set(i.x, i.y, i.z, i.order);
  },
  setFromQuaternion: function(i, e, n) {
    return e === void 0 && (e = this._order), n === void 0 && (n = !1), eg.fromQuat(i), this.setFromRotationMatrix(eg, e, n);
  },
  setFromRotationMatrix: function(i, e, n) {
    e === void 0 && (e = this._order), n === void 0 && (n = !1);
    var s = i.val, r = s[0], a = s[4], o = s[8], h = s[1], c = s[5], l = s[9], u = s[2], f = s[6], d = s[10], p = 0, y = 0, x = 0, g = 0.99999;
    switch (e) {
      case "XYZ": {
        y = Math.asin(Zn(o, -1, 1)), Math.abs(o) < g ? (p = Math.atan2(-l, d), x = Math.atan2(-a, r)) : p = Math.atan2(f, c);
        break;
      }
      case "YXZ": {
        p = Math.asin(-Zn(l, -1, 1)), Math.abs(l) < g ? (y = Math.atan2(o, d), x = Math.atan2(h, c)) : y = Math.atan2(-u, r);
        break;
      }
      case "ZXY": {
        p = Math.asin(Zn(f, -1, 1)), Math.abs(f) < g ? (y = Math.atan2(-u, d), x = Math.atan2(-a, c)) : x = Math.atan2(h, r);
        break;
      }
      case "ZYX": {
        y = Math.asin(-Zn(u, -1, 1)), Math.abs(u) < g ? (p = Math.atan2(f, d), x = Math.atan2(h, r)) : x = Math.atan2(-a, c);
        break;
      }
      case "YZX": {
        x = Math.asin(Zn(h, -1, 1)), Math.abs(h) < g ? (p = Math.atan2(-l, c), y = Math.atan2(-u, r)) : y = Math.atan2(o, d);
        break;
      }
      case "XZY": {
        x = Math.asin(-Zn(a, -1, 1)), Math.abs(a) < g ? (p = Math.atan2(f, c), y = Math.atan2(o, r)) : p = Math.atan2(-l, d);
        break;
      }
    }
    return this._x = p, this._y = y, this._z = x, this._order = e, n && this.onChangeCallback(this), this;
  }
});
h1.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
h1.DefaultOrder = "XYZ";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var DL = function(i, e, n) {
  e === void 0 && (e = 0), n === void 0 && (n = 10);
  var s = Math.pow(n, -e);
  return Math.floor(i * s) / s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var qL = function(i, e) {
  return i / e / 1e3;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $L = function(i) {
  return i == parseFloat(i) ? !(i % 2) : void 0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var VL = function(i) {
  return i === parseFloat(i) ? !(i % 2) : void 0;
};
/**
 * @author       Greg McLean <GregDevProjects>
 * @copyright    2021 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var GL = function(i, e, n) {
  return n === void 0 && (n = 0), i.clone().lerp(e, n);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var UL = function(i, e, n) {
  return Math.min(i + e, n);
};
/**
 * @author       Vladislav Forsh <vlad@robowhale.com>
 * @copyright    2021 RoboWhale
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var WL = function(i) {
  var e = i.length;
  if (e === 0)
    return 0;
  i.sort(function(s, r) {
    return s - r;
  });
  var n = Math.floor(e / 2);
  return e % 2 === 0 ? (i[n] + i[n - 1]) / 2 : i[n];
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var YL = function(i, e, n) {
  return Math.max(i - e, n);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var jL = function(i, e, n, s) {
  n === void 0 && (n = e + 1);
  var r = (i - e) / (n - e);
  return r > 1 ? s !== void 0 ? (r = (s - i) / (s - n), r < 0 && (r = 0)) : r = 1 : r < 0 && (r = 0), r;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var HL = function(i) {
  return i * ce.RAD_TO_DEG;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var XL = function(i, e) {
  e === void 0 && (e = 1);
  var n = Math.random() * 2 * Math.PI;
  return i.x = Math.cos(n) * e, i.y = Math.sin(n) * e, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ZL = function(i, e) {
  e === void 0 && (e = 1);
  var n = Math.random() * 2 * Math.PI, s = Math.random() * 2 - 1, r = Math.sqrt(1 - s * s) * e;
  return i.x = Math.cos(n) * r, i.y = Math.sin(n) * r, i.z = s * e, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var JL = function(i, e) {
  return e === void 0 && (e = 1), i.x = (Math.random() * 2 - 1) * e, i.y = (Math.random() * 2 - 1) * e, i.z = (Math.random() * 2 - 1) * e, i.w = (Math.random() * 2 - 1) * e, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var QL = function(i, e) {
  var n = i.x, s = i.y;
  return i.x = n * Math.cos(e) - s * Math.sin(e), i.y = n * Math.sin(e) + s * Math.cos(e), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var KL = function(i, e, n, s) {
  var r = Math.cos(s), a = Math.sin(s), o = i.x - e, h = i.y - n;
  return i.x = o * r - h * a + e, i.y = o * a + h * r + n, i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var tF = function(i, e, n, s, r) {
  var a = s + Math.atan2(i.y - n, i.x - e);
  return i.x = e + r * Math.cos(a), i.y = n + r * Math.sin(a), i;
};
/**
 * @author       samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var eF = function(i, e, n, s, r) {
  return i.x = e + r * Math.cos(s), i.y = n + r * Math.sin(s), i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var nF = function(i, e, n) {
  e === void 0 && (e = 0), n === void 0 && (n = 10);
  var s = Math.pow(n, -e);
  return Math.round(i * s) / s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var iF = function(i, e, n, s) {
  e === void 0 && (e = 1), n === void 0 && (n = 1), s === void 0 && (s = 1), s *= Math.PI / i;
  for (var r = [], a = [], o = 0; o < i; o++)
    n -= e * s, e += n * s, r[o] = n, a[o] = e;
  return {
    sin: a,
    cos: r,
    length: i
  };
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var sF = function(i, e, n, s) {
  s === void 0 && (s = new we());
  var r = 0, a = 0, o = e * n;
  return i > 0 && i <= o && (i > e - 1 ? (a = Math.floor(i / e), r = i - a * e) : r = i), s.set(r, a);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var rF = function(i, e, n, s, r, a, o, h) {
  h === void 0 && (h = new we());
  var c = Math.sin(r), l = Math.cos(r), u = l * a, f = c * a, d = -c * o, p = l * o, y = 1 / (u * p + d * -f);
  return h.x = p * y * i + -d * y * e + (s * d - n * p) * y, h.y = u * y * e + -f * y * i + (-s * u + n * f) * y, h;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var aF = function(i, e, n) {
  return Math.abs(i - e) <= n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var c1 = new Gt({
  initialize: function(e) {
    this.val = new Float32Array(9), e ? this.copy(e) : this.identity();
  },
  /**
   * Make a clone of this Matrix3.
   *
   * @method Phaser.Math.Matrix3#clone
   * @since 3.0.0
   *
   * @return {Phaser.Math.Matrix3} A clone of this Matrix3.
   */
  clone: function() {
    return new c1(this);
  },
  /**
   * This method is an alias for `Matrix3.copy`.
   *
   * @method Phaser.Math.Matrix3#set
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix3} src - The Matrix to set the values of this Matrix's from.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  set: function(i) {
    return this.copy(i);
  },
  /**
   * Copy the values of a given Matrix into this Matrix.
   *
   * @method Phaser.Math.Matrix3#copy
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix3} src - The Matrix to copy the values from.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  copy: function(i) {
    var e = this.val, n = i.val;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
  },
  /**
   * Copy the values of a given Matrix4 into this Matrix3.
   *
   * @method Phaser.Math.Matrix3#fromMat4
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} m - The Matrix4 to copy the values from.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  fromMat4: function(i) {
    var e = i.val, n = this.val;
    return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[4], n[4] = e[5], n[5] = e[6], n[6] = e[8], n[7] = e[9], n[8] = e[10], this;
  },
  /**
   * Set the values of this Matrix from the given array.
   *
   * @method Phaser.Math.Matrix3#fromArray
   * @since 3.0.0
   *
   * @param {array} a - The array to copy the values from.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  fromArray: function(i) {
    var e = this.val;
    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
  },
  /**
   * Reset this Matrix to an identity (default) matrix.
   *
   * @method Phaser.Math.Matrix3#identity
   * @since 3.0.0
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  identity: function() {
    var i = this.val;
    return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 1, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, this;
  },
  /**
   * Transpose this Matrix.
   *
   * @method Phaser.Math.Matrix3#transpose
   * @since 3.0.0
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  transpose: function() {
    var i = this.val, e = i[1], n = i[2], s = i[5];
    return i[1] = i[3], i[2] = i[6], i[3] = e, i[5] = i[7], i[6] = n, i[7] = s, this;
  },
  /**
   * Invert this Matrix.
   *
   * @method Phaser.Math.Matrix3#invert
   * @since 3.0.0
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  invert: function() {
    var i = this.val, e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], h = i[6], c = i[7], l = i[8], u = l * a - o * c, f = -l * r + o * h, d = c * r - a * h, p = e * u + n * f + s * d;
    return p ? (p = 1 / p, i[0] = u * p, i[1] = (-l * n + s * c) * p, i[2] = (o * n - s * a) * p, i[3] = f * p, i[4] = (l * e - s * h) * p, i[5] = (-o * e + s * r) * p, i[6] = d * p, i[7] = (-c * e + n * h) * p, i[8] = (a * e - n * r) * p, this) : null;
  },
  /**
   * Calculate the adjoint, or adjugate, of this Matrix.
   *
   * @method Phaser.Math.Matrix3#adjoint
   * @since 3.0.0
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  adjoint: function() {
    var i = this.val, e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], h = i[6], c = i[7], l = i[8];
    return i[0] = a * l - o * c, i[1] = s * c - n * l, i[2] = n * o - s * a, i[3] = o * h - r * l, i[4] = e * l - s * h, i[5] = s * r - e * o, i[6] = r * c - a * h, i[7] = n * h - e * c, i[8] = e * a - n * r, this;
  },
  /**
   * Calculate the determinant of this Matrix.
   *
   * @method Phaser.Math.Matrix3#determinant
   * @since 3.0.0
   *
   * @return {number} The determinant of this Matrix.
   */
  determinant: function() {
    var i = this.val, e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], h = i[6], c = i[7], l = i[8];
    return e * (l * a - o * c) + n * (-l * r + o * h) + s * (c * r - a * h);
  },
  /**
   * Multiply this Matrix by the given Matrix.
   *
   * @method Phaser.Math.Matrix3#multiply
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix3} src - The Matrix to multiply this Matrix by.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  multiply: function(i) {
    var e = this.val, n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = i.val, d = f[0], p = f[1], y = f[2], x = f[3], g = f[4], m = f[5], v = f[6], w = f[7], b = f[8];
    return e[0] = d * n + p * a + y * c, e[1] = d * s + p * o + y * l, e[2] = d * r + p * h + y * u, e[3] = x * n + g * a + m * c, e[4] = x * s + g * o + m * l, e[5] = x * r + g * h + m * u, e[6] = v * n + w * a + b * c, e[7] = v * s + w * o + b * l, e[8] = v * r + w * h + b * u, this;
  },
  /**
   * Translate this Matrix using the given Vector.
   *
   * @method Phaser.Math.Matrix3#translate
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  translate: function(i) {
    var e = this.val, n = i.x, s = i.y;
    return e[6] = n * e[0] + s * e[3] + e[6], e[7] = n * e[1] + s * e[4] + e[7], e[8] = n * e[2] + s * e[5] + e[8], this;
  },
  /**
   * Apply a rotation transformation to this Matrix.
   *
   * @method Phaser.Math.Matrix3#rotate
   * @since 3.0.0
   *
   * @param {number} rad - The angle in radians to rotate by.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  rotate: function(i) {
    var e = this.val, n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = Math.sin(i), l = Math.cos(i);
    return e[0] = l * n + c * a, e[1] = l * s + c * o, e[2] = l * r + c * h, e[3] = l * a - c * n, e[4] = l * o - c * s, e[5] = l * h - c * r, this;
  },
  /**
   * Apply a scale transformation to this Matrix.
   *
   * Uses the `x` and `y` components of the given Vector to scale the Matrix.
   *
   * @method Phaser.Math.Matrix3#scale
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  scale: function(i) {
    var e = this.val, n = i.x, s = i.y;
    return e[0] = n * e[0], e[1] = n * e[1], e[2] = n * e[2], e[3] = s * e[3], e[4] = s * e[4], e[5] = s * e[5], this;
  },
  /**
   * Set the values of this Matrix from the given Quaternion.
   *
   * @method Phaser.Math.Matrix3#fromQuat
   * @since 3.0.0
   *
   * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  fromQuat: function(i) {
    var e = i.x, n = i.y, s = i.z, r = i.w, a = e + e, o = n + n, h = s + s, c = e * a, l = e * o, u = e * h, f = n * o, d = n * h, p = s * h, y = r * a, x = r * o, g = r * h, m = this.val;
    return m[0] = 1 - (f + p), m[3] = l + g, m[6] = u - x, m[1] = l - g, m[4] = 1 - (c + p), m[7] = d + y, m[2] = u + x, m[5] = d - y, m[8] = 1 - (c + f), this;
  },
  /**
   * Set the values of this Matrix3 to be normalized from the given Matrix4.
   *
   * @method Phaser.Math.Matrix3#normalFromMat4
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix4} m - The Matrix4 to normalize the values from.
   *
   * @return {Phaser.Math.Matrix3} This Matrix3.
   */
  normalFromMat4: function(i) {
    var e = i.val, n = this.val, s = e[0], r = e[1], a = e[2], o = e[3], h = e[4], c = e[5], l = e[6], u = e[7], f = e[8], d = e[9], p = e[10], y = e[11], x = e[12], g = e[13], m = e[14], v = e[15], w = s * c - r * h, b = s * l - a * h, S = s * u - o * h, E = r * l - a * c, A = r * u - o * c, M = a * u - o * l, _ = f * g - d * x, T = f * m - p * x, C = f * v - y * x, P = d * m - p * g, R = d * v - y * g, k = p * v - y * m, I = w * k - b * R + S * P + E * C - A * T + M * _;
    return I ? (I = 1 / I, n[0] = (c * k - l * R + u * P) * I, n[1] = (l * C - h * k - u * T) * I, n[2] = (h * R - c * C + u * _) * I, n[3] = (a * R - r * k - o * P) * I, n[4] = (s * k - a * C + o * T) * I, n[5] = (r * C - s * R - o * _) * I, n[6] = (g * M - m * A + v * E) * I, n[7] = (m * S - x * M - v * b) * I, n[8] = (x * A - g * S + v * w) * I, this) : null;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ng = 1e-6, ig = new Int8Array([1, 2, 0]), Vr = new Float32Array([0, 0, 0]), oF = new Nt(1, 0, 0), hF = new Nt(0, 1, 0), ts = new Nt(), sg = new c1(), _M = new Gt({
  initialize: function(e, n, s, r) {
    this.onChangeCallback = xu, this.set(e, n, s, r);
  },
  /**
   * The x component of this Quaternion.
   *
   * @name Phaser.Math.Quaternion#x
   * @type {number}
   * @default 0
   * @since 3.0.0
   */
  x: {
    get: function() {
      return this._x;
    },
    set: function(i) {
      this._x = i, this.onChangeCallback(this);
    }
  },
  /**
   * The y component of this Quaternion.
   *
   * @name Phaser.Math.Quaternion#y
   * @type {number}
   * @default 0
   * @since 3.0.0
   */
  y: {
    get: function() {
      return this._y;
    },
    set: function(i) {
      this._y = i, this.onChangeCallback(this);
    }
  },
  /**
   * The z component of this Quaternion.
   *
   * @name Phaser.Math.Quaternion#z
   * @type {number}
   * @default 0
   * @since 3.0.0
   */
  z: {
    get: function() {
      return this._z;
    },
    set: function(i) {
      this._z = i, this.onChangeCallback(this);
    }
  },
  /**
   * The w component of this Quaternion.
   *
   * @name Phaser.Math.Quaternion#w
   * @type {number}
   * @default 0
   * @since 3.0.0
   */
  w: {
    get: function() {
      return this._w;
    },
    set: function(i) {
      this._w = i, this.onChangeCallback(this);
    }
  },
  /**
   * Copy the components of a given Quaternion or Vector into this Quaternion.
   *
   * @method Phaser.Math.Quaternion#copy
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} src - The Quaternion or Vector to copy the components from.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  copy: function(i) {
    return this.set(i);
  },
  /**
   * Set the components of this Quaternion and optionally call the `onChangeCallback`.
   *
   * @method Phaser.Math.Quaternion#set
   * @since 3.0.0
   *
   * @param {(number|object)} [x=0] - The x component, or an object containing x, y, z, and w components.
   * @param {number} [y=0] - The y component.
   * @param {number} [z=0] - The z component.
   * @param {number} [w=0] - The w component.
   * @param {boolean} [update=true] - Call the `onChangeCallback`?
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  set: function(i, e, n, s, r) {
    return r === void 0 && (r = !0), typeof i == "object" ? (this._x = i.x || 0, this._y = i.y || 0, this._z = i.z || 0, this._w = i.w || 0) : (this._x = i || 0, this._y = e || 0, this._z = n || 0, this._w = s || 0), r && this.onChangeCallback(this), this;
  },
  /**
   * Add a given Quaternion or Vector to this Quaternion. Addition is component-wise.
   *
   * @method Phaser.Math.Quaternion#add
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to add to this Quaternion.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  add: function(i) {
    return this._x += i.x, this._y += i.y, this._z += i.z, this._w += i.w, this.onChangeCallback(this), this;
  },
  /**
   * Subtract a given Quaternion or Vector from this Quaternion. Subtraction is component-wise.
   *
   * @method Phaser.Math.Quaternion#subtract
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to subtract from this Quaternion.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  subtract: function(i) {
    return this._x -= i.x, this._y -= i.y, this._z -= i.z, this._w -= i.w, this.onChangeCallback(this), this;
  },
  /**
   * Scale this Quaternion by the given value.
   *
   * @method Phaser.Math.Quaternion#scale
   * @since 3.0.0
   *
   * @param {number} scale - The value to scale this Quaternion by.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  scale: function(i) {
    return this._x *= i, this._y *= i, this._z *= i, this._w *= i, this.onChangeCallback(this), this;
  },
  /**
   * Calculate the length of this Quaternion.
   *
   * @method Phaser.Math.Quaternion#length
   * @since 3.0.0
   *
   * @return {number} The length of this Quaternion.
   */
  length: function() {
    var i = this.x, e = this.y, n = this.z, s = this.w;
    return Math.sqrt(i * i + e * e + n * n + s * s);
  },
  /**
   * Calculate the length of this Quaternion squared.
   *
   * @method Phaser.Math.Quaternion#lengthSq
   * @since 3.0.0
   *
   * @return {number} The length of this Quaternion, squared.
   */
  lengthSq: function() {
    var i = this.x, e = this.y, n = this.z, s = this.w;
    return i * i + e * e + n * n + s * s;
  },
  /**
   * Normalize this Quaternion.
   *
   * @method Phaser.Math.Quaternion#normalize
   * @since 3.0.0
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  normalize: function() {
    var i = this.x, e = this.y, n = this.z, s = this.w, r = i * i + e * e + n * n + s * s;
    return r > 0 && (r = 1 / Math.sqrt(r), this._x = i * r, this._y = e * r, this._z = n * r, this._w = s * r), this.onChangeCallback(this), this;
  },
  /**
   * Calculate the dot product of this Quaternion and the given Quaternion or Vector.
   *
   * @method Phaser.Math.Quaternion#dot
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to dot product with this Quaternion.
   *
   * @return {number} The dot product of this Quaternion and the given Quaternion or Vector.
   */
  dot: function(i) {
    return this.x * i.x + this.y * i.y + this.z * i.z + this.w * i.w;
  },
  /**
   * Linearly interpolate this Quaternion towards the given Quaternion or Vector.
   *
   * @method Phaser.Math.Quaternion#lerp
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to interpolate towards.
   * @param {number} [t=0] - The percentage of interpolation.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  lerp: function(i, e) {
    e === void 0 && (e = 0);
    var n = this.x, s = this.y, r = this.z, a = this.w;
    return this.set(
      n + e * (i.x - n),
      s + e * (i.y - s),
      r + e * (i.z - r),
      a + e * (i.w - a)
    );
  },
  /**
   * Rotates this Quaternion based on the two given vectors.
   *
   * @method Phaser.Math.Quaternion#rotationTo
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} a - The transform rotation vector.
   * @param {Phaser.Math.Vector3} b - The target rotation vector.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  rotationTo: function(i, e) {
    var n = i.x * e.x + i.y * e.y + i.z * e.z;
    return n < -0.999999 ? (ts.copy(oF).cross(i).length() < ng && ts.copy(hF).cross(i), ts.normalize(), this.setAxisAngle(ts, Math.PI)) : n > 0.999999 ? this.set(0, 0, 0, 1) : (ts.copy(i).cross(e), this._x = ts.x, this._y = ts.y, this._z = ts.z, this._w = 1 + n, this.normalize());
  },
  /**
   * Set the axes of this Quaternion.
   *
   * @method Phaser.Math.Quaternion#setAxes
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} view - The view axis.
   * @param {Phaser.Math.Vector3} right - The right axis.
   * @param {Phaser.Math.Vector3} up - The upwards axis.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  setAxes: function(i, e, n) {
    var s = sg.val;
    return s[0] = e.x, s[3] = e.y, s[6] = e.z, s[1] = n.x, s[4] = n.y, s[7] = n.z, s[2] = -i.x, s[5] = -i.y, s[8] = -i.z, this.fromMat3(sg).normalize();
  },
  /**
   * Reset this Matrix to an identity (default) Quaternion.
   *
   * @method Phaser.Math.Quaternion#identity
   * @since 3.0.0
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  identity: function() {
    return this.set(0, 0, 0, 1);
  },
  /**
   * Set the axis angle of this Quaternion.
   *
   * @method Phaser.Math.Quaternion#setAxisAngle
   * @since 3.0.0
   *
   * @param {Phaser.Math.Vector3} axis - The axis.
   * @param {number} rad - The angle in radians.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  setAxisAngle: function(i, e) {
    e = e * 0.5;
    var n = Math.sin(e);
    return this.set(
      n * i.x,
      n * i.y,
      n * i.z,
      Math.cos(e)
    );
  },
  /**
   * Multiply this Quaternion by the given Quaternion or Vector.
   *
   * @method Phaser.Math.Quaternion#multiply
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to multiply this Quaternion by.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  multiply: function(i) {
    var e = this.x, n = this.y, s = this.z, r = this.w, a = i.x, o = i.y, h = i.z, c = i.w;
    return this.set(
      e * c + r * a + n * h - s * o,
      n * c + r * o + s * a - e * h,
      s * c + r * h + e * o - n * a,
      r * c - e * a - n * o - s * h
    );
  },
  /**
   * Smoothly linearly interpolate this Quaternion towards the given Quaternion or Vector.
   *
   * @method Phaser.Math.Quaternion#slerp
   * @since 3.0.0
   *
   * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to interpolate towards.
   * @param {number} t - The percentage of interpolation.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  slerp: function(i, e) {
    var n = this.x, s = this.y, r = this.z, a = this.w, o = i.x, h = i.y, c = i.z, l = i.w, u = n * o + s * h + r * c + a * l;
    u < 0 && (u = -u, o = -o, h = -h, c = -c, l = -l);
    var f = 1 - e, d = e;
    if (1 - u > ng) {
      var p = Math.acos(u), y = Math.sin(p);
      f = Math.sin((1 - e) * p) / y, d = Math.sin(e * p) / y;
    }
    return this.set(
      f * n + d * o,
      f * s + d * h,
      f * r + d * c,
      f * a + d * l
    );
  },
  /**
   * Invert this Quaternion.
   *
   * @method Phaser.Math.Quaternion#invert
   * @since 3.0.0
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  invert: function() {
    var i = this.x, e = this.y, n = this.z, s = this.w, r = i * i + e * e + n * n + s * s, a = r ? 1 / r : 0;
    return this.set(
      -i * a,
      -e * a,
      -n * a,
      s * a
    );
  },
  /**
   * Convert this Quaternion into its conjugate.
   *
   * Sets the x, y and z components.
   *
   * @method Phaser.Math.Quaternion#conjugate
   * @since 3.0.0
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  conjugate: function() {
    return this._x = -this.x, this._y = -this.y, this._z = -this.z, this.onChangeCallback(this), this;
  },
  /**
   * Rotate this Quaternion on the X axis.
   *
   * @method Phaser.Math.Quaternion#rotateX
   * @since 3.0.0
   *
   * @param {number} rad - The rotation angle in radians.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  rotateX: function(i) {
    i *= 0.5;
    var e = this.x, n = this.y, s = this.z, r = this.w, a = Math.sin(i), o = Math.cos(i);
    return this.set(
      e * o + r * a,
      n * o + s * a,
      s * o - n * a,
      r * o - e * a
    );
  },
  /**
   * Rotate this Quaternion on the Y axis.
   *
   * @method Phaser.Math.Quaternion#rotateY
   * @since 3.0.0
   *
   * @param {number} rad - The rotation angle in radians.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  rotateY: function(i) {
    i *= 0.5;
    var e = this.x, n = this.y, s = this.z, r = this.w, a = Math.sin(i), o = Math.cos(i);
    return this.set(
      e * o - s * a,
      n * o + r * a,
      s * o + e * a,
      r * o - n * a
    );
  },
  /**
   * Rotate this Quaternion on the Z axis.
   *
   * @method Phaser.Math.Quaternion#rotateZ
   * @since 3.0.0
   *
   * @param {number} rad - The rotation angle in radians.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  rotateZ: function(i) {
    i *= 0.5;
    var e = this.x, n = this.y, s = this.z, r = this.w, a = Math.sin(i), o = Math.cos(i);
    return this.set(
      e * o + n * a,
      n * o - e * a,
      s * o + r * a,
      r * o - s * a
    );
  },
  /**
   * Create a unit (or rotation) Quaternion from its x, y, and z components.
   *
   * Sets the w component.
   *
   * @method Phaser.Math.Quaternion#calculateW
   * @since 3.0.0
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  calculateW: function() {
    var i = this.x, e = this.y, n = this.z;
    return this.w = -Math.sqrt(1 - i * i - e * e - n * n), this;
  },
  /**
   * Set this Quaternion from the given Euler, based on Euler order.
   *
   * @method Phaser.Math.Quaternion#setFromEuler
   * @since 3.50.0
   *
   * @param {Phaser.Math.Euler} euler - The Euler to convert from.
   * @param {boolean} [update=true] - Run the `onChangeCallback`?
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  setFromEuler: function(i, e) {
    var n = i.x / 2, s = i.y / 2, r = i.z / 2, a = Math.cos(n), o = Math.cos(s), h = Math.cos(r), c = Math.sin(n), l = Math.sin(s), u = Math.sin(r);
    switch (i.order) {
      case "XYZ": {
        this.set(
          c * o * h + a * l * u,
          a * l * h - c * o * u,
          a * o * u + c * l * h,
          a * o * h - c * l * u,
          e
        );
        break;
      }
      case "YXZ": {
        this.set(
          c * o * h + a * l * u,
          a * l * h - c * o * u,
          a * o * u - c * l * h,
          a * o * h + c * l * u,
          e
        );
        break;
      }
      case "ZXY": {
        this.set(
          c * o * h - a * l * u,
          a * l * h + c * o * u,
          a * o * u + c * l * h,
          a * o * h - c * l * u,
          e
        );
        break;
      }
      case "ZYX": {
        this.set(
          c * o * h - a * l * u,
          a * l * h + c * o * u,
          a * o * u - c * l * h,
          a * o * h + c * l * u,
          e
        );
        break;
      }
      case "YZX": {
        this.set(
          c * o * h + a * l * u,
          a * l * h + c * o * u,
          a * o * u - c * l * h,
          a * o * h - c * l * u,
          e
        );
        break;
      }
      case "XZY": {
        this.set(
          c * o * h - a * l * u,
          a * l * h - c * o * u,
          a * o * u + c * l * h,
          a * o * h + c * l * u,
          e
        );
        break;
      }
    }
    return this;
  },
  /**
   * Sets the rotation of this Quaternion from the given Matrix4.
   *
   * @method Phaser.Math.Quaternion#setFromRotationMatrix
   * @since 3.50.0
   *
   * @param {Phaser.Math.Matrix4} mat4 - The Matrix4 to set the rotation from.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  setFromRotationMatrix: function(i) {
    var e = i.val, n = e[0], s = e[4], r = e[8], a = e[1], o = e[5], h = e[9], c = e[2], l = e[6], u = e[10], f = n + o + u, d;
    return f > 0 ? (d = 0.5 / Math.sqrt(f + 1), this.set(
      (l - h) * d,
      (r - c) * d,
      (a - s) * d,
      0.25 / d
    )) : n > o && n > u ? (d = 2 * Math.sqrt(1 + n - o - u), this.set(
      0.25 * d,
      (s + a) / d,
      (r + c) / d,
      (l - h) / d
    )) : o > u ? (d = 2 * Math.sqrt(1 + o - n - u), this.set(
      (s + a) / d,
      0.25 * d,
      (h + l) / d,
      (r - c) / d
    )) : (d = 2 * Math.sqrt(1 + u - n - o), this.set(
      (r + c) / d,
      (h + l) / d,
      0.25 * d,
      (a - s) / d
    )), this;
  },
  /**
   * Convert the given Matrix into this Quaternion.
   *
   * @method Phaser.Math.Quaternion#fromMat3
   * @since 3.0.0
   *
   * @param {Phaser.Math.Matrix3} mat - The Matrix to convert from.
   *
   * @return {Phaser.Math.Quaternion} This Quaternion.
   */
  fromMat3: function(i) {
    var e = i.val, n = e[0] + e[4] + e[8], s;
    if (n > 0)
      s = Math.sqrt(n + 1), this.w = 0.5 * s, s = 0.5 / s, this._x = (e[7] - e[5]) * s, this._y = (e[2] - e[6]) * s, this._z = (e[3] - e[1]) * s;
    else {
      var r = 0;
      e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2);
      var a = ig[r], o = ig[a];
      s = Math.sqrt(e[r * 3 + r] - e[a * 3 + a] - e[o * 3 + o] + 1), Vr[r] = 0.5 * s, s = 0.5 / s, Vr[a] = (e[a * 3 + r] + e[r * 3 + a]) * s, Vr[o] = (e[o * 3 + r] + e[r * 3 + o]) * s, this._x = Vr[0], this._y = Vr[1], this._z = Vr[2], this._w = (e[o * 3 + a] - e[a * 3 + o]) * s;
    }
    return this.onChangeCallback(this), this;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var rg = new Ts(), ag = new _M(), cF = new Nt(), lF = function(i, e, n) {
  return ag.setAxisAngle(e, n), rg.fromRotationTranslation(ag, cF.set(0, 0, 0)), i.transformMat4(rg);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var W0 = {
  //  Collections of functions
  Angle: nL,
  Distance: hL,
  Easing: cL,
  Fuzzy: pL,
  Interpolation: EL,
  Pow2: PL,
  Snap: kL,
  //  Expose the RNG Class
  RandomDataGenerator: LL,
  //  Single functions
  Average: FL,
  Bernstein: mM,
  Between: Sa,
  CatmullRom: Eo,
  CeilTo: NL,
  Clamp: Zn,
  DegToRad: rM,
  Difference: BL,
  Euler: h1,
  Factorial: sl,
  FloatBetween: yu,
  FloorTo: DL,
  FromPercent: Ih,
  GetSpeed: qL,
  IsEven: $L,
  IsEvenStrict: VL,
  Linear: vr,
  LinearXY: GL,
  MaxAdd: UL,
  Median: WL,
  MinSub: YL,
  Percent: jL,
  RadToDeg: HL,
  RandomXY: XL,
  RandomXYZ: ZL,
  RandomXYZW: JL,
  Rotate: QL,
  RotateAround: KL,
  RotateAroundDistance: tF,
  RotateTo: eF,
  RoundAwayFromZero: dM,
  RoundTo: nF,
  SinCosTableGenerator: iF,
  SmootherStep: bM,
  SmoothStep: MM,
  ToXY: sF,
  TransformXY: rF,
  Within: aF,
  Wrap: lu,
  //  Vector classes
  Vector2: we,
  Vector3: Nt,
  Vector4: Re,
  Matrix3: c1,
  Matrix4: Ts,
  Quaternion: _M,
  RotateVec3: lF
};
W0 = o1(!1, W0, ce);
const rl = W0;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Mi = function(i, e, n) {
  var s = ne(i, e, null);
  if (s === null)
    return n;
  if (Array.isArray(s))
    return rl.RND.pick(s);
  if (typeof s == "object") {
    if (s.hasOwnProperty("randInt"))
      return rl.RND.integerInRange(s.randInt[0], s.randInt[1]);
    if (s.hasOwnProperty("randFloat"))
      return rl.RND.realInRange(s.randFloat[0], s.randFloat[1]);
  } else if (typeof s == "function")
    return s(e);
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var uF = function(i, e, n, s, r) {
  r === void 0 && (r = n);
  var a = ne(i, e, r);
  return Zn(a, n, s);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var fF = function(i, e) {
  for (var n = 0; n < e.length; n++)
    if (!i.hasOwnProperty(e[n]))
      return !1;
  return !0;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var dF = function(i, e) {
  for (var n = 0; n < e.length; n++)
    if (i.hasOwnProperty(e[n]))
      return !0;
  return !1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var SM = function(i, e) {
  return i.hasOwnProperty(e);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var pF = function(i, e) {
  var n = a1(i);
  for (var s in e)
    n.hasOwnProperty(s) || (n[s] = e[s]);
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var l1 = function(i, e) {
  var n = a1(i);
  for (var s in e)
    n.hasOwnProperty(s) && (n[s] = e[s]);
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var yF = function(i, e) {
  for (var n = {}, s = 0; s < e.length; s++) {
    var r = e[s];
    SM(i, r) && (n[r] = i[r]);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xF = function(i, e, n) {
  if (!i || typeof i == "number")
    return !1;
  if (i.hasOwnProperty(e))
    return i[e] = n, !0;
  if (e.indexOf(".") !== -1) {
    for (var s = e.split("."), r = i, a = i, o = 0; o < s.length; o++)
      if (r.hasOwnProperty(s[o]))
        a = r, r = r[s[o]];
      else
        return !1;
    return a[s[s.length - 1]] = n, !0;
  }
  return !1;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const gF = {
  Clone: a1,
  DeepCopy: xM,
  Extend: o1,
  GetAdvancedValue: Mi,
  GetFastValue: xt,
  GetMinMaxValue: uF,
  GetValue: ne,
  HasAll: fF,
  HasAny: dF,
  HasValue: SM,
  IsPlainObject: G0,
  Merge: pF,
  MergeRight: l1,
  Pick: yF,
  SetValue: xF
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var mF = function(i, e) {
  return i.replace(/%([0-9]+)/g, function(n, s) {
    return e[Number(s) - 1];
  });
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vF = function(i, e) {
  return e === 0 ? i.slice(1) : i.slice(0, e) + i.slice(e + 1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var wF = function(i) {
  return i.split("").reverse().join("");
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var MF = function() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(i) {
    var e = Math.random() * 16 | 0, n = i === "x" ? e : e & 3 | 8;
    return n.toString(16);
  });
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const bF = {
  Format: mF,
  Pad: fM,
  RemoveAt: vF,
  Reverse: wF,
  UppercaseFirst: Yw,
  UUID: MF
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var _F = function() {
  return null;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const SF = {
  Array: Nk,
  Base64: qk,
  Objects: gF,
  String: bF,
  NOOP: xu,
  NULL: _F
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var _t = {
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.CREATED
   * @type {number}
   * @const
   * @since 3.0.0
   */
  CREATED: 0,
  //  1 used to be INIT prior to 3.60
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.DELAY
   * @type {number}
   * @const
   * @since 3.0.0
   */
  DELAY: 2,
  //  3 used to be OFFSET_DELAY prior to 3.60
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.PENDING_RENDER
   * @type {number}
   * @const
   * @since 3.0.0
   */
  PENDING_RENDER: 4,
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.PLAYING_FORWARD
   * @type {number}
   * @const
   * @since 3.0.0
   */
  PLAYING_FORWARD: 5,
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.PLAYING_BACKWARD
   * @type {number}
   * @const
   * @since 3.0.0
   */
  PLAYING_BACKWARD: 6,
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.HOLD_DELAY
   * @type {number}
   * @const
   * @since 3.0.0
   */
  HOLD_DELAY: 7,
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.REPEAT_DELAY
   * @type {number}
   * @const
   * @since 3.0.0
   */
  REPEAT_DELAY: 8,
  /**
   * TweenData state.
   *
   * @name Phaser.Tweens.States.COMPLETE
   * @type {number}
   * @const
   * @since 3.0.0
   */
  COMPLETE: 9,
  //  Tween specific (starts from 20 to cleanly allow extra TweenData consts in the future)
  /**
   * Tween state. The Tween has been created but has not yet been added to the Tween Manager.
   *
   * @name Phaser.Tweens.States.PENDING
   * @type {number}
   * @const
   * @since 3.0.0
   */
  PENDING: 20,
  /**
   * Tween state. The Tween is active within the Tween Manager. This means it is either playing,
   * or was playing and is currently paused, but in both cases it's still being processed by
   * the Tween Manager, so is considered 'active'.
   *
   * @name Phaser.Tweens.States.ACTIVE
   * @type {number}
   * @const
   * @since 3.0.0
   */
  ACTIVE: 21,
  /**
   * Tween state. The Tween is waiting for a loop countdown to elapse.
   *
   * @name Phaser.Tweens.States.LOOP_DELAY
   * @type {number}
   * @const
   * @since 3.0.0
   */
  LOOP_DELAY: 22,
  /**
   * Tween state. The Tween is waiting for a complete delay to elapse.
   *
   * @name Phaser.Tweens.States.COMPLETE_DELAY
   * @type {number}
   * @const
   * @since 3.0.0
   */
  COMPLETE_DELAY: 23,
  /**
   * Tween state. The Tween is waiting for a starting delay to elapse.
   *
   * @name Phaser.Tweens.States.START_DELAY
   * @type {number}
   * @const
   * @since 3.0.0
   */
  START_DELAY: 24,
  /**
   * Tween state. The Tween has finished playback and is waiting to be removed from the Tween Manager.
   *
   * @name Phaser.Tweens.States.PENDING_REMOVE
   * @type {number}
   * @const
   * @since 3.0.0
   */
  PENDING_REMOVE: 25,
  /**
   * Tween state. The Tween has been removed from the Tween Manager.
   *
   * @name Phaser.Tweens.States.REMOVED
   * @type {number}
   * @const
   * @since 3.0.0
   */
  REMOVED: 26,
  /**
   * Tween state. The Tween has finished playback but was flagged as 'persistent' during creation,
   * so will not be automatically removed by the Tween Manager.
   *
   * @name Phaser.Tweens.States.FINISHED
   * @type {number}
   * @const
   * @since 3.60.0
   */
  FINISHED: 27,
  /**
   * Tween state. The Tween has been destroyed and can no longer be played by a Tween Manager.
   *
   * @name Phaser.Tweens.States.DESTROYED
   * @type {number}
   * @const
   * @since 3.60.0
   */
  DESTROYED: 28,
  /**
   * A large integer value used for 'infinite' style countdowns.
   *
   * Similar use-case to Number.MAX_SAFE_INTEGER but we cannot use that because it's not
   * supported on IE.
   *
   * @name Phaser.Tweens.States.MAX
   * @type {number}
   * @const
   * @since 3.60.0
   */
  MAX: 999999999999
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $e = function(i, e, n) {
  return i && i.hasOwnProperty(e) ? i[e] : n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ff = {
  bezier: vM,
  catmull: U0,
  catmullrom: U0,
  linear: wM
}, TM = function(i) {
  if (i === null)
    return null;
  var e = ff.linear;
  return typeof i == "string" ? ff.hasOwnProperty(i) && (e = ff[i]) : typeof i == "function" && (e = i), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Vl = function(i, e, n) {
  var s;
  if (i.hasOwnProperty(e)) {
    var r = typeof i[e];
    r === "function" ? s = function(a, o, h, c, l, u) {
      return i[e](a, o, h, c, l, u);
    } : s = function() {
      return i[e];
    };
  } else typeof n == "function" ? s = n : s = function() {
    return n;
  };
  return s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const TF = [
  "callbackScope",
  "completeDelay",
  "delay",
  "duration",
  "ease",
  "easeParams",
  "flipX",
  "flipY",
  "hold",
  "interpolation",
  "loop",
  "loopDelay",
  "onActive",
  "onActiveParams",
  "onComplete",
  "onCompleteParams",
  "onLoop",
  "onLoopParams",
  "onPause",
  "onPauseParams",
  "onRepeat",
  "onRepeatParams",
  "onResume",
  "onResumeParams",
  "onStart",
  "onStartParams",
  "onStop",
  "onStopParams",
  "onUpdate",
  "onUpdateParams",
  "onYoyo",
  "onYoyoParams",
  "paused",
  "persist",
  "props",
  "repeat",
  "repeatDelay",
  "targets",
  "yoyo"
];
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var EM = function(i) {
  var e, n = [];
  if (i.hasOwnProperty("props"))
    for (e in i.props)
      e.substring(0, 1) !== "_" && n.push({ key: e, value: i.props[e] });
  else
    for (e in i)
      TF.indexOf(e) === -1 && e.substring(0, 1) !== "_" && n.push({ key: e, value: i[e] });
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var u1 = function(i) {
  var e = ne(i, "targets", null);
  return e === null || (typeof e == "function" && (e = e.call()), Array.isArray(e) || (e = [e])), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function zM(i) {
  return !!i.getActive && typeof i.getActive == "function";
}
function CM(i) {
  return !!i.getStart && typeof i.getStart == "function";
}
function AM(i) {
  return !!i.getEnd && typeof i.getEnd == "function";
}
function EF(i) {
  return CM(i) || AM(i) || zM(i);
}
var dr = function(i, e) {
  var n, s = function(S, E, A) {
    return A;
  }, r = function(S, E, A) {
    return A;
  }, a = null, o = typeof e;
  if (o === "number")
    s = function() {
      return e;
    };
  else if (Array.isArray(e))
    r = function() {
      return e[0];
    }, s = function() {
      return e[e.length - 1];
    };
  else if (o === "string") {
    var h = e.toLowerCase(), c = h.substring(0, 6) === "random", l = h.substring(0, 3) === "int";
    if (c || l) {
      var u = h.indexOf("("), f = h.indexOf(")"), d = h.indexOf(",");
      if (u && f && d) {
        var p = parseFloat(h.substring(u + 1, d)), y = parseFloat(h.substring(d + 1, f));
        c ? s = function() {
          return yu(p, y);
        } : s = function() {
          return Sa(p, y);
        };
      } else
        throw new Error("invalid random() format");
    } else {
      h = h[0];
      var x = parseFloat(e.substr(2));
      switch (h) {
        case "+":
          s = function(S, E, A) {
            return A + x;
          };
          break;
        case "-":
          s = function(S, E, A) {
            return A - x;
          };
          break;
        case "*":
          s = function(S, E, A) {
            return A * x;
          };
          break;
        case "/":
          s = function(S, E, A) {
            return A / x;
          };
          break;
        default:
          s = function() {
            return parseFloat(e);
          };
      }
    }
  } else if (o === "function")
    s = e;
  else if (o === "object")
    if (EF(e))
      zM(e) && (a = e.getActive), AM(e) && (s = e.getEnd), CM(e) && (r = e.getStart);
    else if (e.hasOwnProperty("value"))
      n = dr(i, e.value);
    else {
      var g = e.hasOwnProperty("to"), m = e.hasOwnProperty("from"), v = e.hasOwnProperty("start");
      if (g && (m || v)) {
        if (n = dr(i, e.to), v) {
          var w = dr(i, e.start);
          n.getActive = w.getEnd;
        }
        if (m) {
          var b = dr(i, e.from);
          n.getStart = b.getEnd;
        }
      }
    }
  return n || (n = {
    getActive: a,
    getEnd: s,
    getStart: r
  }), n;
}, zF = Object.prototype.hasOwnProperty, nn = "~";
function fh() {
}
Object.create && (fh.prototype = /* @__PURE__ */ Object.create(null), new fh().__proto__ || (nn = !1));
function CF(i, e, n) {
  this.fn = i, this.context = e, this.once = n || !1;
}
function PM(i, e, n, s, r) {
  if (typeof n != "function")
    throw new TypeError("The listener must be a function");
  var a = new CF(n, s || i, r), o = nn ? nn + e : e;
  return i._events[o] ? i._events[o].fn ? i._events[o] = [i._events[o], a] : i._events[o].push(a) : (i._events[o] = a, i._eventsCount++), i;
}
function al(i, e) {
  --i._eventsCount === 0 ? i._events = new fh() : delete i._events[e];
}
function Fe() {
  this._events = new fh(), this._eventsCount = 0;
}
Fe.prototype.eventNames = function() {
  var e = [], n, s;
  if (this._eventsCount === 0) return e;
  for (s in n = this._events)
    zF.call(n, s) && e.push(nn ? s.slice(1) : s);
  return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(n)) : e;
};
Fe.prototype.listeners = function(e) {
  var n = nn ? nn + e : e, s = this._events[n];
  if (!s) return [];
  if (s.fn) return [s.fn];
  for (var r = 0, a = s.length, o = new Array(a); r < a; r++)
    o[r] = s[r].fn;
  return o;
};
Fe.prototype.listenerCount = function(e) {
  var n = nn ? nn + e : e, s = this._events[n];
  return s ? s.fn ? 1 : s.length : 0;
};
Fe.prototype.emit = function(e, n, s, r, a, o) {
  var h = nn ? nn + e : e;
  if (!this._events[h]) return !1;
  var c = this._events[h], l = arguments.length, u, f;
  if (c.fn) {
    switch (c.once && this.removeListener(e, c.fn, void 0, !0), l) {
      case 1:
        return c.fn.call(c.context), !0;
      case 2:
        return c.fn.call(c.context, n), !0;
      case 3:
        return c.fn.call(c.context, n, s), !0;
      case 4:
        return c.fn.call(c.context, n, s, r), !0;
      case 5:
        return c.fn.call(c.context, n, s, r, a), !0;
      case 6:
        return c.fn.call(c.context, n, s, r, a, o), !0;
    }
    for (f = 1, u = new Array(l - 1); f < l; f++)
      u[f - 1] = arguments[f];
    c.fn.apply(c.context, u);
  } else {
    var d = c.length, p;
    for (f = 0; f < d; f++)
      switch (c[f].once && this.removeListener(e, c[f].fn, void 0, !0), l) {
        case 1:
          c[f].fn.call(c[f].context);
          break;
        case 2:
          c[f].fn.call(c[f].context, n);
          break;
        case 3:
          c[f].fn.call(c[f].context, n, s);
          break;
        case 4:
          c[f].fn.call(c[f].context, n, s, r);
          break;
        default:
          if (!u) for (p = 1, u = new Array(l - 1); p < l; p++)
            u[p - 1] = arguments[p];
          c[f].fn.apply(c[f].context, u);
      }
  }
  return !0;
};
Fe.prototype.on = function(e, n, s) {
  return PM(this, e, n, s, !1);
};
Fe.prototype.once = function(e, n, s) {
  return PM(this, e, n, s, !0);
};
Fe.prototype.removeListener = function(e, n, s, r) {
  var a = nn ? nn + e : e;
  if (!this._events[a]) return this;
  if (!n)
    return al(this, a), this;
  var o = this._events[a];
  if (o.fn)
    o.fn === n && (!r || o.once) && (!s || o.context === s) && al(this, a);
  else {
    for (var h = 0, c = [], l = o.length; h < l; h++)
      (o[h].fn !== n || r && !o[h].once || s && o[h].context !== s) && c.push(o[h]);
    c.length ? this._events[a] = c.length === 1 ? c[0] : c : al(this, a);
  }
  return this;
};
Fe.prototype.removeAllListeners = function(e) {
  var n;
  return e ? (n = nn ? nn + e : e, this._events[n] && al(this, n)) : (this._events = new fh(), this._eventsCount = 0), this;
};
Fe.prototype.off = Fe.prototype.removeListener;
Fe.prototype.addListener = Fe.prototype.on;
Fe.prefixed = nn;
Fe.EventEmitter = Fe;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const AF = "active";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const PF = "complete";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const IF = "loop";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const RF = "pause";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const OF = "resume";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const kF = "repeat";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const LF = "start";
/**
 * @author       samme
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const FF = "stop";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const NF = "update";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const BF = "yoyo";
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const me = {
  TWEEN_ACTIVE: AF,
  TWEEN_COMPLETE: PF,
  TWEEN_LOOP: IF,
  TWEEN_PAUSE: RF,
  TWEEN_RESUME: OF,
  TWEEN_REPEAT: kF,
  TWEEN_START: LF,
  TWEEN_STOP: FF,
  TWEEN_UPDATE: NF,
  TWEEN_YOYO: BF
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Nn = new Gt({
  Extends: Fe,
  initialize: function(e) {
    Fe.call(this), this.parent = e, this.data = [], this.totalData = 0, this.startDelay = 0, this.hasStarted = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = _t.PENDING, this.paused = !1, this.callbacks = {
      onActive: null,
      onComplete: null,
      onLoop: null,
      onPause: null,
      onRepeat: null,
      onResume: null,
      onStart: null,
      onStop: null,
      onUpdate: null,
      onYoyo: null
    }, this.callbackScope, this.persist = !1;
  },
  /**
   * Sets the value of the time scale applied to this Tween. A value of 1 runs in real-time.
   * A value of 0.5 runs 50% slower, and so on.
   *
   * The value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
   *
   * This value is multiplied by the `TweenManager.timeScale`.
   *
   * @method Phaser.Tweens.BaseTween#setTimeScale
   * @since 3.60.0
   *
   * @param {number} value - The time scale value to set.
   *
   * @return {this} This Tween instance.
   */
  setTimeScale: function(i) {
    return this.timeScale = i, this;
  },
  /**
   * Gets the value of the time scale applied to this Tween. A value of 1 runs in real-time.
   * A value of 0.5 runs 50% slower, and so on.
   *
   * @method Phaser.Tweens.BaseTween#getTimeScale
   * @since 3.60.0
   *
   * @return {number} The value of the time scale applied to this Tween.
   */
  getTimeScale: function() {
    return this.timeScale;
  },
  /**
   * Checks if this Tween is currently playing.
   *
   * If this Tween is paused, or not active, this method will return false.
   *
   * @method Phaser.Tweens.BaseTween#isPlaying
   * @since 3.60.0
   *
   * @return {boolean} `true` if the Tween is playing, otherwise `false`.
   */
  isPlaying: function() {
    return !this.paused && this.isActive();
  },
  /**
   * Checks if the Tween is currently paused.
   *
   * This is the same as inspecting the `BaseTween.paused` property directly.
   *
   * @method Phaser.Tweens.BaseTween#isPaused
   * @since 3.60.0
   *
   * @return {boolean} `true` if the Tween is paused, otherwise `false`.
   */
  isPaused: function() {
    return this.paused;
  },
  /**
   * Pauses the Tween immediately. Use `resume` to continue playback.
   *
   * You can also toggle the `Tween.paused` boolean property, but doing so will not trigger the PAUSE event.
   *
   * @method Phaser.Tweens.BaseTween#pause
   * @fires Phaser.Tweens.Events#TWEEN_PAUSE
   * @since 3.60.0
   *
   * @return {this} This Tween instance.
   */
  pause: function() {
    return this.paused || (this.paused = !0, this.dispatchEvent(me.TWEEN_PAUSE, "onPause")), this;
  },
  /**
   * Resumes the playback of a previously paused Tween.
   *
   * You can also toggle the `Tween.paused` boolean property, but doing so will not trigger the RESUME event.
   *
   * @method Phaser.Tweens.BaseTween#resume
   * @fires Phaser.Tweens.Events#TWEEN_RESUME
   * @since 3.60.0
   *
   * @return {this} This Tween instance.
   */
  resume: function() {
    return this.paused && (this.paused = !1, this.dispatchEvent(me.TWEEN_RESUME, "onResume")), this;
  },
  /**
   * Internal method that makes this Tween active within the TweenManager
   * and emits the onActive event and callback.
   *
   * @method Phaser.Tweens.BaseTween#makeActive
   * @fires Phaser.Tweens.Events#TWEEN_ACTIVE
   * @since 3.60.0
   */
  makeActive: function() {
    this.parent.makeActive(this), this.dispatchEvent(me.TWEEN_ACTIVE, "onActive");
  },
  /**
   * Internal method that handles this tween completing and emitting the onComplete event
   * and callback.
   *
   * @method Phaser.Tweens.BaseTween#onCompleteHandler
   * @since 3.60.0
   */
  onCompleteHandler: function() {
    this.setPendingRemoveState(), this.dispatchEvent(me.TWEEN_COMPLETE, "onComplete");
  },
  /**
   * Flags the Tween as being complete, whatever stage of progress it is at.
   *
   * If an `onComplete` callback has been defined it will automatically invoke it, unless a `delay`
   * argument is provided, in which case the Tween will delay for that period of time before calling the callback.
   *
   * If you don't need a delay or don't have an `onComplete` callback then call `Tween.stop` instead.
   *
   * @method Phaser.Tweens.BaseTween#complete
   * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
   * @since 3.2.0
   *
   * @param {number} [delay=0] - The time to wait before invoking the complete callback. If zero it will fire immediately.
   *
   * @return {this} This Tween instance.
   */
  complete: function(i) {
    return i === void 0 && (i = 0), i ? (this.setCompleteDelayState(), this.countdown = i) : this.onCompleteHandler(), this;
  },
  /**
   * Flags the Tween as being complete only once the current loop has finished.
   *
   * This is a useful way to stop an infinitely looping tween once a complete cycle is over,
   * rather than abruptly.
   *
   * If you don't have a loop then call `Tween.stop` instead.
   *
   * @method Phaser.Tweens.BaseTween#completeAfterLoop
   * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
   * @since 3.60.0
   *
   * @param {number} [loops=0] - The number of loops that should finish before this tween completes. Zero means complete just the current loop.
   *
   * @return {this} This Tween instance.
   */
  completeAfterLoop: function(i) {
    return i === void 0 && (i = 0), this.loopCounter > i && (this.loopCounter = i), this;
  },
  /**
   * Immediately removes this Tween from the TweenManager and all of its internal arrays,
   * no matter what stage it is at. Then sets the tween state to `REMOVED`.
   *
   * You should dispose of your reference to this tween after calling this method, to
   * free it from memory. If you no longer require it, call `Tween.destroy()` on it.
   *
   * @method Phaser.Tweens.BaseTween#remove
   * @since 3.60.0
   *
   * @return {this} This Tween instance.
   */
  remove: function() {
    return this.parent && this.parent.remove(this), this;
  },
  /**
   * Stops the Tween immediately, whatever stage of progress it is at.
   *
   * If not a part of a Tween Chain it is also flagged for removal by the Tween Manager.
   *
   * If an `onStop` callback has been defined it will automatically invoke it.
   *
   * The Tween will be removed during the next game frame, but should be considered 'destroyed' from this point on.
   *
   * Typically, you cannot play a Tween that has been stopped. If you just wish to pause the tween, not destroy it,
   * then call the `pause` method instead and use `resume` to continue playback. If you wish to restart the Tween,
   * use the `restart` or `seek` methods.
   *
   * @method Phaser.Tweens.BaseTween#stop
   * @fires Phaser.Tweens.Events#TWEEN_STOP
   * @since 3.60.0
   *
   * @return {this} This Tween instance.
   */
  stop: function() {
    return this.parent && !this.isRemoved() && !this.isPendingRemove() && !this.isDestroyed() && (this.dispatchEvent(me.TWEEN_STOP, "onStop"), this.setPendingRemoveState()), this;
  },
  /**
   * Internal method that handles the processing of the loop delay countdown timer and
   * the dispatch of related events. Called automatically by `Tween.update`.
   *
   * @method Phaser.Tweens.BaseTween#updateLoopCountdown
   * @since 3.60.0
   *
   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
   */
  updateLoopCountdown: function(i) {
    this.countdown -= i, this.countdown <= 0 && (this.setActiveState(), this.dispatchEvent(me.TWEEN_LOOP, "onLoop"));
  },
  /**
   * Internal method that handles the processing of the start delay countdown timer and
   * the dispatch of related events. Called automatically by `Tween.update`.
   *
   * @method Phaser.Tweens.BaseTween#updateStartCountdown
   * @since 3.60.0
   *
   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
   */
  updateStartCountdown: function(i) {
    return this.countdown -= i, this.countdown <= 0 && (this.hasStarted = !0, this.setActiveState(), this.dispatchEvent(me.TWEEN_START, "onStart"), i = 0), i;
  },
  /**
   * Internal method that handles the processing of the complete delay countdown timer and
   * the dispatch of related events. Called automatically by `Tween.update`.
   *
   * @method Phaser.Tweens.BaseTween#updateCompleteDelay
   * @since 3.60.0
   *
   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
   */
  updateCompleteDelay: function(i) {
    this.countdown -= i, this.countdown <= 0 && this.onCompleteHandler();
  },
  /**
   * Sets an event based callback to be invoked during playback.
   *
   * Calling this method will replace a previously set callback for the given type, if any exists.
   *
   * The types available are:
   *
   * `onActive` - When the Tween is first created it moves to an 'active' state when added to the Tween Manager. 'Active' does not mean 'playing'.
   * `onStart` - When the Tween starts playing after a delayed or paused state. This will happen at the same time as `onActive` if the tween has no delay and isn't paused.
   * `onLoop` - When a Tween loops, if it has been set to do so. This happens _after_ the `loopDelay` expires, if set.
   * `onComplete` - When the Tween finishes playback fully. Never invoked if the Tween is set to repeat infinitely.
   * `onStop` - Invoked only if the `Tween.stop` method is called.
   * `onPause` - Invoked only if the `Tween.pause` method is called. Not invoked if the Tween Manager is paused.
   * `onResume` - Invoked only if the `Tween.resume` method is called. Not invoked if the Tween Manager is resumed.
   *
       * The following types are also available and are invoked on a `TweenData` level - that is per-object, per-property, being tweened.
   *
   * `onYoyo` - When a TweenData starts a yoyo. This happens _after_ the `hold` delay expires, if set.
   * `onRepeat` - When a TweenData repeats playback. This happens _after_ the `repeatDelay` expires, if set.
   * `onUpdate` - When a TweenData updates a property on a source target during playback.
   *
   * @method Phaser.Tweens.BaseTween#setCallback
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.TweenCallbackTypes} type - The type of callback to set. One of: `onActive`, `onComplete`, `onLoop`, `onPause`, `onRepeat`, `onResume`, `onStart`, `onStop`, `onUpdate` or `onYoyo`.
   * @param {function} callback - Your callback that will be invoked.
   * @param {array} [params] - The parameters to pass to the callback. Pass an empty array if you don't want to define any, but do wish to set the scope.
   *
   * @return {this} This Tween instance.
   */
  setCallback: function(i, e, n) {
    return n === void 0 && (n = []), this.callbacks.hasOwnProperty(i) && (this.callbacks[i] = { func: e, params: n }), this;
  },
  /**
   * Sets this Tween state to PENDING.
   *
   * @method Phaser.Tweens.BaseTween#setPendingState
   * @since 3.60.0
   */
  setPendingState: function() {
    this.state = _t.PENDING;
  },
  /**
   * Sets this Tween state to ACTIVE.
   *
   * @method Phaser.Tweens.BaseTween#setActiveState
   * @since 3.60.0
   */
  setActiveState: function() {
    this.state = _t.ACTIVE, this.hasStarted = !1;
  },
  /**
   * Sets this Tween state to LOOP_DELAY.
   *
   * @method Phaser.Tweens.BaseTween#setLoopDelayState
   * @since 3.60.0
   */
  setLoopDelayState: function() {
    this.state = _t.LOOP_DELAY;
  },
  /**
   * Sets this Tween state to COMPLETE_DELAY.
   *
   * @method Phaser.Tweens.BaseTween#setCompleteDelayState
   * @since 3.60.0
   */
  setCompleteDelayState: function() {
    this.state = _t.COMPLETE_DELAY;
  },
  /**
   * Sets this Tween state to START_DELAY.
   *
   * @method Phaser.Tweens.BaseTween#setStartDelayState
   * @since 3.60.0
   */
  setStartDelayState: function() {
    this.state = _t.START_DELAY, this.countdown = this.startDelay, this.hasStarted = !1;
  },
  /**
   * Sets this Tween state to PENDING_REMOVE.
   *
   * @method Phaser.Tweens.BaseTween#setPendingRemoveState
   * @since 3.60.0
   */
  setPendingRemoveState: function() {
    this.state = _t.PENDING_REMOVE;
  },
  /**
   * Sets this Tween state to REMOVED.
   *
   * @method Phaser.Tweens.BaseTween#setRemovedState
   * @since 3.60.0
   */
  setRemovedState: function() {
    this.state = _t.REMOVED;
  },
  /**
   * Sets this Tween state to FINISHED.
   *
   * @method Phaser.Tweens.BaseTween#setFinishedState
   * @since 3.60.0
   */
  setFinishedState: function() {
    this.state = _t.FINISHED;
  },
  /**
   * Sets this Tween state to DESTROYED.
   *
   * @method Phaser.Tweens.BaseTween#setDestroyedState
   * @since 3.60.0
   */
  setDestroyedState: function() {
    this.state = _t.DESTROYED;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of PENDING, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isPending
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of PENDING, otherwise `false`.
   */
  isPending: function() {
    return this.state === _t.PENDING;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of ACTIVE, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isActive
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of ACTIVE, otherwise `false`.
   */
  isActive: function() {
    return this.state === _t.ACTIVE;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of LOOP_DELAY, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isLoopDelayed
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of LOOP_DELAY, otherwise `false`.
   */
  isLoopDelayed: function() {
    return this.state === _t.LOOP_DELAY;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of COMPLETE_DELAY, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isCompleteDelayed
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of COMPLETE_DELAY, otherwise `false`.
   */
  isCompleteDelayed: function() {
    return this.state === _t.COMPLETE_DELAY;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of START_DELAY, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isStartDelayed
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of START_DELAY, otherwise `false`.
   */
  isStartDelayed: function() {
    return this.state === _t.START_DELAY;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of PENDING_REMOVE, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isPendingRemove
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of PENDING_REMOVE, otherwise `false`.
   */
  isPendingRemove: function() {
    return this.state === _t.PENDING_REMOVE;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of REMOVED, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isRemoved
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of REMOVED, otherwise `false`.
   */
  isRemoved: function() {
    return this.state === _t.REMOVED;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of FINISHED, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isFinished
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of FINISHED, otherwise `false`.
   */
  isFinished: function() {
    return this.state === _t.FINISHED;
  },
  /**
   * Returns `true` if this Tween has a _current_ state of DESTROYED, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTween#isDestroyed
   * @since 3.60.0
   *
   * @return {boolean} `true` if this Tween has a _current_ state of DESTROYED, otherwise `false`.
   */
  isDestroyed: function() {
    return this.state === _t.DESTROYED;
  },
  /**
   * Handles the destroy process of this Tween, clearing out the
   * Tween Data and resetting the targets. A Tween that has been
   * destroyed cannot ever be played or used again.
   *
   * @method Phaser.Tweens.BaseTween#destroy
   * @since 3.60.0
   */
  destroy: function() {
    this.data && this.data.forEach(function(i) {
      i.destroy();
    }), this.removeAllListeners(), this.callbacks = null, this.data = null, this.parent = null, this.setDestroyedState();
  }
});
Nn.TYPES = [
  "onActive",
  "onComplete",
  "onLoop",
  "onPause",
  "onRepeat",
  "onResume",
  "onStart",
  "onStop",
  "onUpdate",
  "onYoyo"
];
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Gl = {
  targets: null,
  delay: 0,
  duration: 1e3,
  ease: "Power0",
  easeParams: null,
  hold: 0,
  repeat: 0,
  repeatDelay: 0,
  yoyo: !1,
  flipX: !1,
  flipY: !1,
  persist: !1,
  interpolation: null
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var xs = new Gt({
  initialize: function(e, n, s, r, a, o, h, c, l, u) {
    this.tween = e, this.targetIndex = n, this.duration = r <= 0 ? 0.01 : r, this.totalDuration = 0, this.delay = 0, this.getDelay = s, this.yoyo = a, this.hold = o, this.repeat = h, this.repeatDelay = c, this.repeatCounter = 0, this.flipX = l, this.flipY = u, this.progress = 0, this.elapsed = 0, this.state = 0, this.isCountdown = !1;
  },
  /**
   * Returns a reference to the target object belonging to this TweenData.
   *
   * @method Phaser.Tweens.BaseTweenData#getTarget
   * @since 3.60.0
   *
   * @return {object} The target object. Can be any JavaScript object, but is typically a Game Object.
   */
  getTarget: function() {
    return this.tween.targets[this.targetIndex];
  },
  /**
   * Sets this TweenData's target object property to be the given value.
   *
   * @method Phaser.Tweens.BaseTweenData#setTargetValue
   * @since 3.60.0
   *
   * @param {number} [value] - The value to set on the target. If not given, sets it to the last `current` value.
   */
  setTargetValue: function(i) {
    i === void 0 && (i = this.current), this.tween.targets[this.targetIndex][this.key] = i;
  },
  /**
   * Sets this TweenData state to CREATED.
   *
   * @method Phaser.Tweens.BaseTweenData#setCreatedState
   * @since 3.60.0
   */
  setCreatedState: function() {
    this.state = _t.CREATED, this.isCountdown = !1;
  },
  /**
   * Sets this TweenData state to DELAY.
   *
   * @method Phaser.Tweens.BaseTweenData#setDelayState
   * @since 3.60.0
   */
  setDelayState: function() {
    this.state = _t.DELAY, this.isCountdown = !0;
  },
  /**
   * Sets this TweenData state to PENDING_RENDER.
   *
   * @method Phaser.Tweens.BaseTweenData#setPendingRenderState
   * @since 3.60.0
   */
  setPendingRenderState: function() {
    this.state = _t.PENDING_RENDER, this.isCountdown = !1;
  },
  /**
   * Sets this TweenData state to PLAYING_FORWARD.
   *
   * @method Phaser.Tweens.BaseTweenData#setPlayingForwardState
   * @since 3.60.0
   */
  setPlayingForwardState: function() {
    this.state = _t.PLAYING_FORWARD, this.isCountdown = !1;
  },
  /**
   * Sets this TweenData state to PLAYING_BACKWARD.
   *
   * @method Phaser.Tweens.BaseTweenData#setPlayingBackwardState
   * @since 3.60.0
   */
  setPlayingBackwardState: function() {
    this.state = _t.PLAYING_BACKWARD, this.isCountdown = !1;
  },
  /**
   * Sets this TweenData state to HOLD_DELAY.
   *
   * @method Phaser.Tweens.BaseTweenData#setHoldState
   * @since 3.60.0
   */
  setHoldState: function() {
    this.state = _t.HOLD_DELAY, this.isCountdown = !0;
  },
  /**
   * Sets this TweenData state to REPEAT_DELAY.
   *
   * @method Phaser.Tweens.BaseTweenData#setRepeatState
   * @since 3.60.0
   */
  setRepeatState: function() {
    this.state = _t.REPEAT_DELAY, this.isCountdown = !0;
  },
  /**
   * Sets this TweenData state to COMPLETE.
   *
   * @method Phaser.Tweens.BaseTweenData#setCompleteState
   * @since 3.60.0
   */
  setCompleteState: function() {
    this.state = _t.COMPLETE, this.isCountdown = !1;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of CREATED, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isCreated
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of CREATED, otherwise `false`.
   */
  isCreated: function() {
    return this.state === _t.CREATED;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of DELAY, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isDelayed
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of DELAY, otherwise `false`.
   */
  isDelayed: function() {
    return this.state === _t.DELAY;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of PENDING_RENDER, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isPendingRender
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of PENDING_RENDER, otherwise `false`.
   */
  isPendingRender: function() {
    return this.state === _t.PENDING_RENDER;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of PLAYING_FORWARD, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isPlayingForward
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of PLAYING_FORWARD, otherwise `false`.
   */
  isPlayingForward: function() {
    return this.state === _t.PLAYING_FORWARD;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of PLAYING_BACKWARD, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isPlayingBackward
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of PLAYING_BACKWARD, otherwise `false`.
   */
  isPlayingBackward: function() {
    return this.state === _t.PLAYING_BACKWARD;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of HOLD_DELAY, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isHolding
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of HOLD_DELAY, otherwise `false`.
   */
  isHolding: function() {
    return this.state === _t.HOLD_DELAY;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of REPEAT_DELAY, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isRepeating
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of REPEAT_DELAY, otherwise `false`.
   */
  isRepeating: function() {
    return this.state === _t.REPEAT_DELAY;
  },
  /**
   * Returns `true` if this TweenData has a _current_ state of COMPLETE, otherwise `false`.
   *
   * @method Phaser.Tweens.BaseTweenData#isComplete
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenData has a _current_ state of COMPLETE, otherwise `false`.
   */
  isComplete: function() {
    return this.state === _t.COMPLETE;
  },
  /**
   * Internal method used as part of the playback process that checks if this
   * TweenData should yoyo, repeat, or has completed.
   *
   * @method Phaser.Tweens.BaseTweenData#setStateFromEnd
   * @fires Phaser.Tweens.Events#TWEEN_REPEAT
   * @fires Phaser.Tweens.Events#TWEEN_YOYO
   * @since 3.60.0
   *
   * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.
   */
  setStateFromEnd: function(i) {
    this.yoyo ? this.onRepeat(i, !0, !0) : this.repeatCounter > 0 ? this.onRepeat(i, !0, !1) : this.setCompleteState();
  },
  /**
   * Internal method used as part of the playback process that checks if this
   * TweenData should repeat or has completed.
   *
   * @method Phaser.Tweens.BaseTweenData#setStateFromStart
   * @fires Phaser.Tweens.Events#TWEEN_REPEAT
   * @since 3.60.0
   *
   * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.
   */
  setStateFromStart: function(i) {
    this.repeatCounter > 0 ? this.onRepeat(i, !1) : this.setCompleteState();
  },
  /**
   * Internal method that resets this Tween Data entirely, including the progress and elapsed values.
   *
   * Called automatically by the parent Tween. Should not be called directly.
   *
   * @method Phaser.Tweens.BaseTweenData#reset
   * @since 3.60.0
   */
  reset: function() {
    var i = this.tween, e = i.totalTargets, n = this.targetIndex, s = i.targets[n], r = this.key;
    this.progress = 0, this.elapsed = 0, this.delay = this.getDelay(s, r, 0, n, e, i), this.repeatCounter = this.repeat === -1 ? _t.MAX : this.repeat, this.setPendingRenderState();
    var a = this.duration + this.hold;
    this.yoyo && (a += this.duration);
    var o = a + this.repeatDelay;
    this.totalDuration = this.delay + a, this.repeat === -1 ? (this.totalDuration += o * _t.MAX, i.isInfinite = !0) : this.repeat > 0 && (this.totalDuration += o * this.repeat), this.totalDuration > i.duration && (i.duration = this.totalDuration), this.delay < i.startDelay && (i.startDelay = this.delay), this.delay > 0 && (this.elapsed = this.delay, this.setDelayState());
  },
  /**
   * Internal method that handles repeating or yoyo'ing this TweenData.
   *
   * Called automatically by `setStateFromStart` and `setStateFromEnd`.
   *
   * @method Phaser.Tweens.BaseTweenData#onRepeat
   * @fires Phaser.Tweens.Events#TWEEN_REPEAT
   * @fires Phaser.Tweens.Events#TWEEN_YOYO
   * @since 3.60.0
   *
   * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.
   * @param {boolean} setStart - Set the TweenData start values?
   * @param {boolean} isYoyo - Is this call a Yoyo check?
   */
  onRepeat: function(i, e, n) {
    var s = this.tween, r = s.totalTargets, a = this.targetIndex, o = s.targets[a], h = this.key, c = h !== "texture";
    if (this.elapsed = i, this.progress = i / this.duration, this.flipX && o.toggleFlipX(), this.flipY && o.toggleFlipY(), c && (e || n) && (this.start = this.getStartValue(o, h, this.start, a, r, s)), n) {
      this.setPlayingBackwardState(), this.dispatchEvent(me.TWEEN_YOYO, "onYoyo");
      return;
    }
    this.repeatCounter--, c && (this.end = this.getEndValue(o, h, this.start, a, r, s)), this.repeatDelay > 0 ? (this.elapsed = this.repeatDelay - i, c && (this.current = this.start, o[h] = this.current), this.setRepeatState()) : (this.setPlayingForwardState(), this.dispatchEvent(me.TWEEN_REPEAT, "onRepeat"));
  },
  /**
   * Immediately destroys this TweenData, nulling of all its references.
   *
   * @method Phaser.Tweens.BaseTweenData#destroy
   * @since 3.60.0
   */
  destroy: function() {
    this.tween = null, this.getDelay = null, this.setCompleteState();
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var IM = new Gt({
  Extends: xs,
  initialize: function(e, n, s, r, a, o, h, c, l, u, f, d, p, y, x, g, m) {
    xs.call(this, e, n, c, l, u, f, d, p, y, x), this.key = s, this.getActiveValue = o, this.getEndValue = r, this.getStartValue = a, this.ease = h, this.start = 0, this.previous = 0, this.current = 0, this.end = 0, this.interpolation = g, this.interpolationData = m;
  },
  /**
   * Internal method that resets this Tween Data entirely, including the progress and elapsed values.
   *
   * Called automatically by the parent Tween. Should not be called directly.
   *
   * @method Phaser.Tweens.TweenData#reset
   * @since 3.60.0
   *
   * @param {boolean} [isSeeking=false] - Is the Tween Data being reset as part of a Tween seek?
   */
  reset: function(i) {
    xs.prototype.reset.call(this);
    var e = this.tween.targets[this.targetIndex], n = this.key;
    i && (e[n] = this.start), this.start = 0, this.previous = 0, this.current = 0, this.end = 0, this.getActiveValue && (e[n] = this.getActiveValue(e, n, 0));
  },
  /**
   * Internal method that advances this TweenData based on the delta value given.
   *
   * @method Phaser.Tweens.TweenData#update
   * @fires Phaser.Tweens.Events#TWEEN_UPDATE
   * @fires Phaser.Tweens.Events#TWEEN_REPEAT
   * @since 3.60.0
   *
   * @param {number} delta - The elapsed delta time in ms.
   *
   * @return {boolean} `true` if this TweenData is still playing, or `false` if it has finished entirely.
   */
  update: function(i) {
    var e = this.tween, n = e.totalTargets, s = this.targetIndex, r = e.targets[s], a = this.key;
    if (!r)
      return this.setCompleteState(), !1;
    if (this.isCountdown && (this.elapsed -= i, this.elapsed <= 0 && (this.elapsed = 0, i = 0, this.isDelayed() ? this.setPendingRenderState() : this.isRepeating() ? (this.setPlayingForwardState(), this.dispatchEvent(me.TWEEN_REPEAT, "onRepeat")) : this.isHolding() && this.setStateFromEnd(0))), this.isPendingRender())
      return this.start = this.getStartValue(r, a, r[a], s, n, e), this.end = this.getEndValue(r, a, this.start, s, n, e), this.current = this.start, r[a] = this.start, this.setPlayingForwardState(), !0;
    var o = this.isPlayingForward(), h = this.isPlayingBackward();
    if (o || h) {
      var c = this.elapsed, l = this.duration, u = 0, f = !1;
      c += i, c >= l ? (u = c - l, c = l, f = !0) : c < 0 && (c = 0);
      var d = Zn(c / l, 0, 1);
      this.elapsed = c, this.progress = d, this.previous = this.current, o || (d = 1 - d);
      var p = this.ease(d);
      this.interpolation ? this.current = this.interpolation(this.interpolationData, p) : this.current = this.start + (this.end - this.start) * p, r[a] = this.current, f && (o ? (e.isNumberTween && (this.current = this.end, r[a] = this.current), this.hold > 0 ? (this.elapsed = this.hold, this.setHoldState()) : this.setStateFromEnd(u)) : (e.isNumberTween && (this.current = this.start, r[a] = this.current), this.setStateFromStart(u))), this.dispatchEvent(me.TWEEN_UPDATE, "onUpdate");
    }
    return !this.isComplete();
  },
  /**
   * Internal method that will emit a TweenData based Event on the
   * parent Tween and also invoke the given callback, if provided.
   *
   * @method Phaser.Tweens.TweenData#dispatchEvent
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.Event} event - The Event to be dispatched.
   * @param {Phaser.Types.Tweens.TweenCallbackTypes} [callback] - The name of the callback to be invoked. Can be `null` or `undefined` to skip invocation.
   */
  dispatchEvent: function(i, e) {
    var n = this.tween;
    if (!n.isSeeking) {
      var s = n.targets[this.targetIndex], r = this.key, a = this.current, o = this.previous;
      n.emit(i, n, r, s, a, o);
      var h = n.callbacks[e];
      h && h.func.apply(n.callbackScope, [n, s, r, a, o].concat(h.params));
    }
  },
  /**
   * Immediately destroys this TweenData, nulling of all its references.
   *
   * @method Phaser.Tweens.TweenData#destroy
   * @since 3.60.0
   */
  destroy: function() {
    xs.prototype.destroy.call(this), this.getActiveValue = null, this.getEndValue = null, this.getStartValue = null, this.ease = null;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var RM = new Gt({
  Extends: xs,
  initialize: function(e, n, s, r, a, o, h, c, l, u, f) {
    xs.call(this, e, n, a, o, !1, h, c, l, u, f), this.key = "texture", this.startTexture = null, this.endTexture = s, this.startFrame = null, this.endFrame = r, this.yoyo = c !== 0;
  },
  /**
   * Internal method that resets this Tween Data entirely, including the progress and elapsed values.
   *
   * Called automatically by the parent Tween. Should not be called directly.
   *
   * @method Phaser.Tweens.TweenFrameData#reset
   * @since 3.60.0
   *
   * @param {boolean} [isSeeking=false] - Is the Tween Data being reset as part of a Tween seek?
   */
  reset: function(i) {
    xs.prototype.reset.call(this);
    var e = this.tween.targets[this.targetIndex];
    this.startTexture || (this.startTexture = e.texture.key, this.startFrame = e.frame.name), i && e.setTexture(this.startTexture, this.startFrame);
  },
  /**
   * Internal method that advances this TweenData based on the delta value given.
   *
   * @method Phaser.Tweens.TweenFrameData#update
   * @fires Phaser.Tweens.Events#TWEEN_UPDATE
   * @fires Phaser.Tweens.Events#TWEEN_REPEAT
   * @since 3.60.0
   *
   * @param {number} delta - The elapsed delta time in ms.
   *
   * @return {boolean} `true` if this TweenData is still playing, or `false` if it has finished entirely.
   */
  update: function(i) {
    var e = this.tween, n = this.targetIndex, s = e.targets[n];
    if (!s)
      return this.setCompleteState(), !1;
    if (this.isCountdown && (this.elapsed -= i, this.elapsed <= 0 && (this.elapsed = 0, i = 0, this.isDelayed() ? this.setPendingRenderState() : this.isRepeating() ? (this.setPlayingForwardState(), this.dispatchEvent(me.TWEEN_REPEAT, "onRepeat")) : this.isHolding() && this.setStateFromEnd(0))), this.isPendingRender())
      return this.startTexture && s.setTexture(this.startTexture, this.startFrame), this.setPlayingForwardState(), !0;
    var r = this.isPlayingForward(), a = this.isPlayingBackward();
    if (r || a) {
      var o = this.elapsed, h = this.duration, c = 0, l = !1;
      o += i, o >= h ? (c = o - h, o = h, l = !0) : o < 0 && (o = 0);
      var u = Zn(o / h, 0, 1);
      this.elapsed = o, this.progress = u, l && (r ? (s.setTexture(this.endTexture, this.endFrame), this.hold > 0 ? (this.elapsed = this.hold, this.setHoldState()) : this.setStateFromEnd(c)) : (s.setTexture(this.startTexture, this.startFrame), this.setStateFromStart(c))), this.dispatchEvent(me.TWEEN_UPDATE, "onUpdate");
    }
    return !this.isComplete();
  },
  /**
   * Internal method that will emit a TweenData based Event on the
   * parent Tween and also invoke the given callback, if provided.
   *
   * @method Phaser.Tweens.TweenFrameData#dispatchEvent
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.Event} event - The Event to be dispatched.
   * @param {Phaser.Types.Tweens.TweenCallbackTypes} [callback] - The name of the callback to be invoked. Can be `null` or `undefined` to skip invocation.
   */
  dispatchEvent: function(i, e) {
    var n = this.tween;
    if (!n.isSeeking) {
      var s = n.targets[this.targetIndex], r = this.key;
      n.emit(i, n, r, s);
      var a = n.callbacks[e];
      a && a.func.apply(n.callbackScope, [n, s, r].concat(a.params));
    }
  },
  /**
   * Immediately destroys this TweenData, nulling of all its references.
   *
   * @method Phaser.Tweens.TweenFrameData#destroy
   * @since 3.60.0
   */
  destroy: function() {
    xs.prototype.destroy.call(this), this.startTexture = null, this.endTexture = null, this.startFrame = null, this.endFrame = null;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var vs = new Gt({
  Extends: Nn,
  initialize: function(e, n) {
    Nn.call(this, e), this.targets = n, this.totalTargets = n.length, this.isSeeking = !1, this.isInfinite = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.isNumberTween = !1;
  },
  /**
   * Adds a new TweenData to this Tween. Typically, this method is called
   * automatically by the TweenBuilder, however you can also invoke it
   * yourself.
   *
   * @method Phaser.Tweens.Tween#add
   * @since 3.60.0
   *
   * @param {number} targetIndex - The target index within the Tween targets array.
   * @param {string} key - The property of the target to tween.
   * @param {Phaser.Types.Tweens.GetEndCallback} getEnd - What the property will be at the END of the Tween.
   * @param {Phaser.Types.Tweens.GetStartCallback} getStart - What the property will be at the START of the Tween.
   * @param {?Phaser.Types.Tweens.GetActiveCallback} getActive - If not null, is invoked _immediately_ as soon as the TweenData is running, and is set on the target property.
   * @param {function} ease - The ease function this tween uses.
   * @param {function} delay - Function that returns the time in milliseconds before tween will start.
   * @param {number} duration - The duration of the tween in milliseconds.
   * @param {boolean} yoyo - Determines whether the tween should return back to its start value after hold has expired.
   * @param {number} hold - Function that returns the time in milliseconds the tween will pause before repeating or returning to its starting value if yoyo is set to true.
   * @param {number} repeat - Function that returns the number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
   * @param {number} repeatDelay - Function that returns the time in milliseconds before the repeat will start.
   * @param {boolean} flipX - Should toggleFlipX be called when yoyo or repeat happens?
   * @param {boolean} flipY - Should toggleFlipY be called when yoyo or repeat happens?
   * @param {?function} interpolation - The interpolation function to be used for arrays of data. Defaults to 'null'.
   * @param {?number[]} interpolationData - The array of interpolation data to be set. Defaults to 'null'.
   *
   * @return {Phaser.Tweens.TweenData} The TweenData instance that was added.
   */
  add: function(i, e, n, s, r, a, o, h, c, l, u, f, d, p, y, x) {
    var g = new IM(this, i, e, n, s, r, a, o, h, c, l, u, f, d, p, y, x);
    return this.totalData = this.data.push(g), g;
  },
  /**
   * Adds a new TweenFrameData to this Tween. Typically, this method is called
   * automatically by the TweenBuilder, however you can also invoke it
   * yourself.
   *
   * @method Phaser.Tweens.Tween#addFrame
   * @since 3.60.0
   *
   * @param {number} targetIndex - The target index within the Tween targets array.
   * @param {string} texture - The texture to set on the target at the end of the tween.
   * @param {string|number} frame - The texture frame to set on the target at the end of the tween.
   * @param {function} delay - Function that returns the time in milliseconds before tween will start.
   * @param {number} duration - The duration of the tween in milliseconds.
   * @param {number} hold - Function that returns the time in milliseconds the tween will pause before repeating or returning to its starting value if yoyo is set to true.
   * @param {number} repeat - Function that returns the number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
   * @param {number} repeatDelay - Function that returns the time in milliseconds before the repeat will start.
   * @param {boolean} flipX - Should toggleFlipX be called when yoyo or repeat happens?
   * @param {boolean} flipY - Should toggleFlipY be called when yoyo or repeat happens?
   *
   * @return {Phaser.Tweens.TweenFrameData} The TweenFrameData instance that was added.
   */
  addFrame: function(i, e, n, s, r, a, o, h, c, l) {
    var u = new RM(this, i, e, n, s, r, a, o, h, c, l);
    return this.totalData = this.data.push(u), u;
  },
  /**
   * Returns the current value of the specified Tween Data.
   *
   * If this Tween has been destroyed, it will return `null`.
   *
   * @method Phaser.Tweens.Tween#getValue
   * @since 3.0.0
   *
   * @param {number} [index=0] - The Tween Data to return the value from.
   *
   * @return {number|null} The value of the requested Tween Data, or `null` if this Tween has been destroyed.
   */
  getValue: function(i) {
    i === void 0 && (i = 0);
    var e = null;
    return this.data && (e = this.data[i].current), e;
  },
  /**
   * See if this Tween is currently acting upon the given target.
   *
   * @method Phaser.Tweens.Tween#hasTarget
   * @since 3.0.0
   *
   * @param {object} target - The target to check against this Tween.
   *
   * @return {boolean} `true` if the given target is a target of this Tween, otherwise `false`.
   */
  hasTarget: function(i) {
    return this.targets && this.targets.indexOf(i) !== -1;
  },
  /**
   * Updates the 'end' value of the given property across all matching targets, as long
   * as this Tween is currently playing (either forwards or backwards).
   *
   * Calling this does not adjust the duration of the Tween, or the current progress.
   *
   * You can optionally tell it to set the 'start' value to be the current value.
   *
   * If this Tween is in any other state other than playing then calling this method has no effect.
   *
   * Additionally, if the Tween repeats, is reset, or is seeked, it will revert to the original
   * starting and ending values.
   *
   * @method Phaser.Tweens.Tween#updateTo
   * @since 3.0.0
   *
   * @param {string} key - The property to set the new value for. You cannot update the 'texture' property via this method.
   * @param {number} value - The new value of the property.
   * @param {boolean} [startToCurrent=false] - Should this change set the start value to be the current value?
   *
   * @return {this} This Tween instance.
   */
  updateTo: function(i, e, n) {
    if (n === void 0 && (n = !1), i !== "texture")
      for (var s = 0; s < this.totalData; s++) {
        var r = this.data[s];
        r.key === i && (r.isPlayingForward() || r.isPlayingBackward()) && (r.end = e, n && (r.start = r.current));
      }
    return this;
  },
  /**
   * Restarts the Tween from the beginning.
   *
   * If the Tween has already finished and been destroyed, restarting it will throw an error.
   *
   * If you wish to restart the Tween from a specific point, use the `Tween.seek` method instead.
   *
   * @method Phaser.Tweens.Tween#restart
   * @since 3.0.0
   *
   * @return {this} This Tween instance.
   */
  restart: function() {
    switch (this.state) {
      case _t.REMOVED:
      case _t.FINISHED:
        this.seek(), this.parent.makeActive(this);
        break;
      case _t.PENDING:
      case _t.PENDING_REMOVE:
        this.parent.reset(this);
        break;
      case _t.DESTROYED:
        console.warn("Cannot restart destroyed Tween", this);
        break;
      default:
        this.seek();
        break;
    }
    return this.paused = !1, this.hasStarted = !1, this;
  },
  /**
   * Internal method that advances to the next state of the Tween during playback.
   *
   * @method Phaser.Tweens.Tween#nextState
   * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
   * @fires Phaser.Tweens.Events#TWEEN_LOOP
   * @since 3.0.0
   *
   * @return {boolean} `true` if this Tween has completed, otherwise `false`.
   */
  nextState: function() {
    if (this.loopCounter > 0)
      this.elapsed = 0, this.progress = 0, this.loopCounter--, this.initTweenData(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.setLoopDelayState()) : (this.setActiveState(), this.dispatchEvent(me.TWEEN_LOOP, "onLoop"));
    else if (this.completeDelay > 0)
      this.countdown = this.completeDelay, this.setCompleteDelayState();
    else
      return this.onCompleteHandler(), !0;
    return !1;
  },
  /**
   * Internal method that handles this tween completing and starting
   * the next tween in the chain, if any.
   *
   * @method Phaser.Tweens.Tween#onCompleteHandler
   * @since 3.60.0
   */
  onCompleteHandler: function() {
    this.progress = 1, this.totalProgress = 1, Nn.prototype.onCompleteHandler.call(this);
  },
  /**
   * Starts a Tween playing.
   *
   * You only need to call this method if you have configured the tween to be paused on creation.
   *
   * If the Tween is already playing, calling this method again will have no effect. If you wish to
   * restart the Tween, use `Tween.restart` instead.
   *
   * Calling this method after the Tween has completed will start the Tween playing again from the beginning.
   * This is the same as calling `Tween.seek(0)` and then `Tween.play()`.
   *
   * @method Phaser.Tweens.Tween#play
   * @since 3.0.0
   *
   * @return {this} This Tween instance.
   */
  play: function() {
    return this.isDestroyed() ? (console.warn("Cannot play destroyed Tween", this), this) : ((this.isPendingRemove() || this.isFinished()) && this.seek(), this.paused = !1, this.setActiveState(), this);
  },
  /**
   * Seeks to a specific point in the Tween.
   *
   * The given amount is a value in milliseconds that represents how far into the Tween
   * you wish to seek, based on the start of the Tween.
   *
   * Note that the seek amount takes the entire duration of the Tween into account, including delays, loops and repeats.
   * For example, a Tween that lasts for 2 seconds, but that loops 3 times, would have a total duration of 6 seconds,
   * so seeking to 3000 ms would seek to the Tweens half-way point based on its _entire_ duration.
   *
   * Prior to Phaser 3.60 this value was given as a number between 0 and 1 and didn't
   * work for Tweens had an infinite repeat. This new method works for all Tweens.
   *
   * Seeking works by resetting the Tween to its initial values and then iterating through the Tween at `delta`
   * jumps per step. The longer the Tween, the longer this can take. If you need more precision you can
   * reduce the delta value. If you need a faster seek, you can increase it. When the Tween is
   * reset it will refresh the starting and ending values. If these are coming from a dynamic function,
   * or a random array, it will be called for each seek.
   *
   * While seeking the Tween will _not_ emit any of its events or callbacks unless
   * the 3rd parameter is set to `true`.
   *
   * If this Tween is paused, seeking will not change this fact. It will advance the Tween
   * to the desired point and then pause it again.
   *
   * @method Phaser.Tweens.Tween#seek
   * @since 3.0.0
   *
   * @param {number} [amount=0] - The number of milliseconds to seek into the Tween from the beginning.
   * @param {number} [delta=16.6] - The size of each step when seeking through the Tween. A higher value completes faster but at the cost of less precision.
   * @param {boolean} [emit=false] - While seeking, should the Tween emit any of its events or callbacks? The default is 'false', i.e. to seek silently.
   *
   * @return {this} This Tween instance.
   */
  seek: function(i, e, n) {
    if (i === void 0 && (i = 0), e === void 0 && (e = 16.6), n === void 0 && (n = !1), this.isDestroyed())
      return console.warn("Cannot seek destroyed Tween", this), this;
    n || (this.isSeeking = !0), this.reset(!0), this.initTweenData(!0), this.setActiveState(), this.dispatchEvent(me.TWEEN_ACTIVE, "onActive");
    var s = this.paused;
    if (this.paused = !1, i > 0) {
      for (var r = Math.floor(i / e), a = i - r * e, o = 0; o < r; o++)
        this.update(e);
      a > 0 && this.update(a);
    }
    return this.paused = s, this.isSeeking = !1, this;
  },
  /**
   * Initialises all of the Tween Data and Tween values.
   *
   * This is called automatically and should not typically be invoked directly.
   *
   * @method Phaser.Tweens.Tween#initTweenData
   * @since 3.60.0
   *
   * @param {boolean} [isSeeking=false] - Is the Tween Data being reset as part of a seek?
   */
  initTweenData: function(i) {
    i === void 0 && (i = !1), this.duration = 0, this.startDelay = ce.MAX_SAFE_INTEGER;
    for (var e = this.data, n = 0; n < this.totalData; n++)
      e[n].reset(i);
    this.duration = Math.max(this.duration, 0.01);
    var s = this.duration, r = this.completeDelay, a = this.loopCounter, o = this.loopDelay;
    a > 0 ? this.totalDuration = s + r + (s + o) * a : this.totalDuration = s + r;
  },
  /**
   * Resets this Tween ready for another play-through.
   *
   * This is called automatically from the Tween Manager, or from the parent TweenChain,
   * and should not typically be invoked directly.
   *
   * If you wish to restart this Tween, use the `Tween.restart` or `Tween.seek` methods instead.
   *
   * @method Phaser.Tweens.Tween#reset
   * @fires Phaser.Tweens.Events#TWEEN_ACTIVE
   * @since 3.60.0
   *
   * @param {boolean} [skipInit=false] - Skip resetting the TweenData and Active State?
   *
   * @return {this} This Tween instance.
   */
  reset: function(i) {
    return i === void 0 && (i = !1), this.elapsed = 0, this.totalElapsed = 0, this.progress = 0, this.totalProgress = 0, this.loopCounter = this.loop, this.loop === -1 && (this.isInfinite = !0, this.loopCounter = _t.MAX), i || (this.initTweenData(), this.setActiveState(), this.dispatchEvent(me.TWEEN_ACTIVE, "onActive")), this;
  },
  /**
   * Internal method that advances the Tween based on the time values.
   *
   * @method Phaser.Tweens.Tween#update
   * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
   * @fires Phaser.Tweens.Events#TWEEN_LOOP
   * @fires Phaser.Tweens.Events#TWEEN_START
   * @since 3.0.0
   *
   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
   *
   * @return {boolean} Returns `true` if this Tween has finished and should be removed from the Tween Manager, otherwise returns `false`.
   */
  update: function(i) {
    if (this.isPendingRemove() || this.isDestroyed())
      return this.persist ? (this.setFinishedState(), !1) : !0;
    if (this.paused || this.isFinished())
      return !1;
    if (i *= this.timeScale * this.parent.timeScale, this.isLoopDelayed())
      return this.updateLoopCountdown(i), !1;
    if (this.isCompleteDelayed())
      return this.updateCompleteDelay(i), !1;
    this.hasStarted || (this.startDelay -= i, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchEvent(me.TWEEN_START, "onStart"), i = 0));
    var e = !1;
    if (this.isActive())
      for (var n = this.data, s = 0; s < this.totalData; s++)
        n[s].update(i) && (e = !0);
    this.elapsed += i, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += i, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), e || this.nextState();
    var r = this.isPendingRemove();
    return r && this.persist && (this.setFinishedState(), r = !1), r;
  },
  /**
   * Moves this Tween forward by the given amount of milliseconds.
   *
   * It will only advance through the current loop of the Tween. For example, if the
   * Tween is set to repeat or yoyo, it can only fast forward through a single
   * section of the sequence. Use `Tween.seek` for more complex playhead control.
   *
   * If the Tween is paused or has already finished, calling this will have no effect.
   *
   * @method Phaser.Tweens.Tween#forward
   * @since 3.60.0
   *
   * @param {number} ms - The number of milliseconds to advance this Tween by.
   *
   * @return {this} This Tween instance.
   */
  forward: function(i) {
    return this.update(i), this;
  },
  /**
   * Moves this Tween backward by the given amount of milliseconds.
   *
   * It will only rewind through the current loop of the Tween. For example, if the
   * Tween is set to repeat or yoyo, it can only fast forward through a single
   * section of the sequence. Use `Tween.seek` for more complex playhead control.
   *
   * If the Tween is paused or has already finished, calling this will have no effect.
   *
   * @method Phaser.Tweens.Tween#rewind
   * @since 3.60.0
   *
   * @param {number} ms - The number of milliseconds to rewind this Tween by.
   *
   * @return {this} This Tween instance.
   */
  rewind: function(i) {
    return this.update(-i), this;
  },
  /**
   * Internal method that will emit a Tween based Event and invoke the given callback.
   *
   * @method Phaser.Tweens.Tween#dispatchEvent
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.Event} event - The Event to be dispatched.
   * @param {Phaser.Types.Tweens.TweenCallbackTypes} [callback] - The name of the callback to be invoked. Can be `null` or `undefined` to skip invocation.
   */
  dispatchEvent: function(i, e) {
    if (!this.isSeeking) {
      if (this.emit(i, this, this.targets), !this.callbacks)
        return;
      var n = this.callbacks[e];
      n && n.func.apply(this.callbackScope, [this, this.targets].concat(n.params));
    }
  },
  /**
   * Handles the destroy process of this Tween, clearing out the
   * Tween Data and resetting the targets. A Tween that has been
   * destroyed cannot ever be played or used again.
   *
   * @method Phaser.Tweens.Tween#destroy
   * @since 3.60.0
   */
  destroy: function() {
    Nn.prototype.destroy.call(this), this.targets = null;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var OM = function(i, e, n) {
  if (e instanceof vs)
    return e.parent = i, e;
  n === void 0 ? n = Gl : n = l1(Gl, n);
  var s = xt(e, "from", 0), r = xt(e, "to", 1), a = [{ value: s }], o = xt(e, "delay", n.delay), h = xt(e, "easeParams", n.easeParams), c = xt(e, "ease", n.ease), l = dr("value", r), u = new vs(i, a), f = u.add(
    0,
    "value",
    l.getEnd,
    l.getStart,
    l.getActive,
    Rh(xt(e, "ease", c), xt(e, "easeParams", h)),
    Vl(e, "delay", o),
    xt(e, "duration", n.duration),
    $e(e, "yoyo", n.yoyo),
    xt(e, "hold", n.hold),
    xt(e, "repeat", n.repeat),
    xt(e, "repeatDelay", n.repeatDelay),
    !1,
    !1
  );
  f.start = s, f.current = s, u.completeDelay = Mi(e, "completeDelay", 0), u.loop = Math.round(Mi(e, "loop", 0)), u.loopDelay = Math.round(Mi(e, "loopDelay", 0)), u.paused = $e(e, "paused", !1), u.persist = $e(e, "persist", !1), u.isNumberTween = !0, u.callbackScope = ne(e, "callbackScope", u);
  for (var d = Nn.TYPES, p = 0; p < d.length; p++) {
    var y = d[p], x = ne(e, y, !1);
    if (x) {
      var g = ne(e, y + "Params", []);
      u.setCallback(y, x, g);
    }
  }
  return u;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var kM = function(i, e) {
  e === void 0 && (e = {});
  var n, s = ne(e, "start", 0), r = ne(e, "ease", null), a = ne(e, "grid", null), o = ne(e, "from", 0), h = o === "first", c = o === "center", l = o === "last", u = typeof o == "number", f = Array.isArray(i), d = parseFloat(f ? i[0] : i), p = f ? parseFloat(i[1]) : 0, y = Math.max(d, p);
  if (f && (s += d), a) {
    var x = a[0], g = a[1], m = 0, v = 0, w = 0, b = 0, S = [];
    l ? (m = x - 1, v = g - 1) : u ? (m = o % x, v = Math.floor(o / x)) : c && (m = (x - 1) / 2, v = (g - 1) / 2);
    for (var E = ce.MIN_SAFE_INTEGER, A = 0; A < g; A++) {
      S[A] = [];
      for (var M = 0; M < x; M++) {
        w = m - M, b = v - A;
        var _ = Math.sqrt(w * w + b * b);
        _ > E && (E = _), S[A][M] = _;
      }
    }
  }
  var T = r ? Rh(r) : null;
  return a ? n = function(C, P, R, k) {
    var I = 0, L = k % x, F = Math.floor(k / x);
    L >= 0 && L < x && F >= 0 && F < g && (I = S[F][L]);
    var B;
    if (f) {
      var V = p - d;
      T ? B = I / E * V * T(I / E) : B = I / E * V;
    } else T ? B = I * d * T(I / E) : B = I * d;
    return B + s;
  } : n = function(C, P, R, k, I) {
    I--;
    var L;
    h ? L = k : c ? L = Math.abs(I / 2 - k) : l ? L = I - k : u && (L = Math.abs(o - k));
    var F;
    if (f) {
      var B;
      c ? B = (p - d) / I * (L * 2) : B = (p - d) / I * L, T ? F = B * T(L / I) : F = B;
    } else T ? F = I * y * T(L / I) : F = L * d;
    return F + s;
  }, n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Do = function(i, e, n) {
  if (e instanceof vs)
    return e.parent = i, e;
  n === void 0 ? n = Gl : n = l1(Gl, n);
  var s = u1(e);
  !s && n.targets && (s = n.targets);
  for (var r = EM(e), a = xt(e, "delay", n.delay), o = xt(e, "duration", n.duration), h = xt(e, "easeParams", n.easeParams), c = xt(e, "ease", n.ease), l = xt(e, "hold", n.hold), u = xt(e, "repeat", n.repeat), f = xt(e, "repeatDelay", n.repeatDelay), d = $e(e, "yoyo", n.yoyo), p = $e(e, "flipX", n.flipX), y = $e(e, "flipY", n.flipY), x = xt(e, "interpolation", n.interpolation), g = function(C, P, R, k) {
    if (R === "texture") {
      var I = k, L = void 0;
      Array.isArray(k) ? (I = k[0], L = k[1]) : k.hasOwnProperty("value") ? (I = k.value, Array.isArray(k.value) ? (I = k.value[0], L = k.value[1]) : typeof k.value == "string" && (I = k.value)) : typeof k == "string" && (I = k), C.addFrame(
        P,
        I,
        L,
        Vl(k, "delay", a),
        xt(k, "duration", o),
        xt(k, "hold", l),
        xt(k, "repeat", u),
        xt(k, "repeatDelay", f),
        $e(k, "flipX", p),
        $e(k, "flipY", y)
      );
    } else {
      var F = dr(R, k), B = TM(xt(k, "interpolation", x));
      C.add(
        P,
        R,
        F.getEnd,
        F.getStart,
        F.getActive,
        Rh(xt(k, "ease", c), xt(k, "easeParams", h)),
        Vl(k, "delay", a),
        xt(k, "duration", o),
        $e(k, "yoyo", d),
        xt(k, "hold", l),
        xt(k, "repeat", u),
        xt(k, "repeatDelay", f),
        $e(k, "flipX", p),
        $e(k, "flipY", y),
        B,
        B ? k : null
      );
    }
  }, m = new vs(i, s), v = 0; v < r.length; v++)
    for (var w = r[v].key, b = r[v].value, S = 0; S < s.length; S++)
      w === "scale" && !s[S].hasOwnProperty("scale") ? (g(m, S, "scaleX", b), g(m, S, "scaleY", b)) : g(m, S, w, b);
  m.completeDelay = Mi(e, "completeDelay", 0), m.loop = Math.round(Mi(e, "loop", 0)), m.loopDelay = Math.round(Mi(e, "loopDelay", 0)), m.paused = $e(e, "paused", !1), m.persist = $e(e, "persist", !1), m.callbackScope = xt(e, "callbackScope", m);
  for (var E = Nn.TYPES, A = 0; A < E.length; A++) {
    var M = E[A], _ = ne(e, M, !1);
    if (_) {
      var T = ne(e, M + "Params", []);
      m.setCallback(M, _, T);
    }
  }
  return m;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const DF = {
  GetBoolean: $e,
  GetEaseFunction: Rh,
  GetInterpolationFunction: TM,
  GetNewValue: Vl,
  GetProps: EM,
  GetTargets: u1,
  GetValueOp: dr,
  NumberTweenBuilder: OM,
  StaggerBuilder: kM,
  TweenBuilder: Do
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ta = new Gt({
  Extends: Nn,
  initialize: function(e) {
    Nn.call(this, e), this.currentTween = null, this.currentIndex = 0;
  },
  /**
   * Prepares this TweenChain for playback.
   *
   * Called automatically by the TweenManager. Should not be called directly.
   *
   * @method Phaser.Tweens.TweenChain#init
   * @fires Phaser.Tweens.Events#TWEEN_ACTIVE
   * @since 3.60.0
   *
   * @return {this} This TweenChain instance.
   */
  init: function() {
    return this.loopCounter = this.loop === -1 ? _t.MAX : this.loop, this.setCurrentTween(0), this.startDelay > 0 && !this.isStartDelayed() ? this.setStartDelayState() : this.setActiveState(), this;
  },
  /**
   * Create a sequence of Tweens, chained to one-another, and add them to this Tween Manager.
   *
   * The tweens are played in order, from start to finish. You can optionally set the chain
   * to repeat as many times as you like. Once the chain has finished playing, or repeating if set,
   * all tweens in the chain will be destroyed automatically. To override this, set the 'persist'
   * argument to 'true'.
   *
   * Playback will start immediately unless the _first_ Tween has been configured to be paused.
   *
   * Please note that Tweens will not manipulate any target property that begins with an underscore.
   *
   * @method Phaser.Tweens.TweenChain#add
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.TweenBuilderConfig[]|object[]} tweens - An array of Tween configuration objects for the Tweens in this chain.
   *
   * @return {this} This TweenChain instance.
   */
  add: function(i) {
    var e = this.parent.create(i);
    Array.isArray(e) || (e = [e]);
    for (var n = this.data, s = 0; s < e.length; s++) {
      var r = e[s];
      r.parent = this, n.push(r.reset());
    }
    return this.totalData = n.length, this;
  },
  /**
   * Removes the given Tween from this Tween Chain.
   *
   * The removed tween is _not_ destroyed. It is just removed from this Tween Chain.
   *
   * If the given Tween is currently playing then the chain will automatically move
   * to the next tween in the chain. If there are no more tweens, this chain will complete.
   *
   * @method Phaser.Tweens.TweenChain#remove
   * @since 3.60.0
   * @override
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to be removed.
   *
   * @return {this} This Tween Chain instance.
   */
  remove: function(i) {
    return r1(this.data, i), i.setRemovedState(), i === this.currentTween && this.nextTween(), this.totalData = this.data.length, this;
  },
  /**
   * See if any of the tweens in this Tween Chain is currently acting upon the given target.
   *
   * @method Phaser.Tweens.TweenChain#hasTarget
   * @since 3.60.0
   *
   * @param {object} target - The target to check against this TweenChain.
   *
   * @return {boolean} `true` if the given target is a target of this TweenChain, otherwise `false`.
   */
  hasTarget: function(i) {
    for (var e = this.data, n = 0; n < this.totalData; n++)
      if (e[n].hasTarget(i))
        return !0;
    return !1;
  },
  /**
   * Restarts the TweenChain from the beginning.
   *
   * If this TweenChain was configured to have a loop, or start delay, those
   * are reset to their initial values as well. It will also dispatch the
   * `onActive` callback and event again.
   *
   * @method Phaser.Tweens.TweenChain#restart
   * @since 3.60.0
   *
   * @return {this} This TweenChain instance.
   */
  restart: function() {
    return this.isDestroyed() ? (console.warn("Cannot restart destroyed TweenChain", this), this) : (this.isRemoved() && this.parent.makeActive(this), this.resetTweens(), this.paused = !1, this.init());
  },
  /**
   * Resets the given Tween.
   *
   * It will seek to position 0 and playback will start on the next frame.
   *
   * @method Phaser.Tweens.TweenChain#reset
   * @since 3.60.0
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to be reset.
   *
   * @return {this} This TweenChain instance.
   */
  reset: function(i) {
    return i.seek(), i.setActiveState(), this;
  },
  /**
   * Re-initialises the given Tween and sets it to the Active state.
   *
   * @method Phaser.Tweens.TweenChain#makeActive
   * @since 3.60.0
   * @override
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to check.
   *
   * @return {this} This TweenChain instance.
   */
  makeActive: function(i) {
    return i.reset(), i.setActiveState(), this;
  },
  /**
   * Internal method that advances to the next state of the TweenChain playback.
   *
   * @method Phaser.Tweens.TweenChain#nextState
   * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
   * @fires Phaser.Tweens.Events#TWEEN_LOOP
   * @since 3.60.0
   *
   * @return {boolean} `true` if this TweenChain has completed, otherwise `false`.
   */
  nextState: function() {
    if (this.loopCounter > 0)
      this.loopCounter--, this.resetTweens(), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.setLoopDelayState()) : (this.setActiveState(), this.dispatchEvent(me.TWEEN_LOOP, "onLoop"));
    else if (this.completeDelay > 0)
      this.countdown = this.completeDelay, this.setCompleteDelayState();
    else
      return this.onCompleteHandler(), !0;
    return !1;
  },
  /**
   * Starts this TweenChain playing.
   *
   * You only need to call this method if you have configured this TweenChain to be paused on creation.
   *
   * If the TweenChain is already playing, calling this method again will have no effect. If you wish to
   * restart the chain, use `TweenChain.restart` instead.
   *
   * Calling this method after the TweenChain has completed will start the chain playing again from the beginning.
   *
   * @method Phaser.Tweens.TweenChain#play
   * @since 3.60.0
   *
   * @return {this} This TweenChain instance.
   */
  play: function() {
    return this.isDestroyed() ? (console.warn("Cannot play destroyed TweenChain", this), this) : ((this.isPendingRemove() || this.isPending()) && this.resetTweens(), this.paused = !1, this.startDelay > 0 && !this.isStartDelayed() ? this.setStartDelayState() : this.setActiveState(), this);
  },
  /**
   * Internal method that resets all of the Tweens and the current index pointer.
   *
   * @method Phaser.Tweens.TweenChain#resetTweens
   * @since 3.60.0
   */
  resetTweens: function() {
    for (var i = this.data, e = this.totalData, n = 0; n < e; n++)
      i[n].reset(!1);
    this.setCurrentTween(0);
  },
  /**
   * Internal method that advances the TweenChain based on the time values.
   *
   * @method Phaser.Tweens.TweenChain#update
   * @fires Phaser.Tweens.Events#TWEEN_COMPLETE
   * @fires Phaser.Tweens.Events#TWEEN_LOOP
   * @fires Phaser.Tweens.Events#TWEEN_START
   * @since 3.60.0
   *
   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.
   *
   * @return {boolean} Returns `true` if this TweenChain has finished and should be removed from the Tween Manager, otherwise returns `false`.
   */
  update: function(i) {
    if (this.isPendingRemove() || this.isDestroyed())
      return this.persist ? (this.setFinishedState(), !1) : !0;
    if (this.isFinished() || this.paused)
      return !1;
    if (i *= this.parent.timeScale, this.isLoopDelayed())
      return this.updateLoopCountdown(i), !1;
    if (this.isCompleteDelayed())
      return this.updateCompleteDelay(i), !1;
    this.hasStarted || (this.startDelay -= i, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchEvent(me.TWEEN_START, "onStart"), i = 0));
    var e = !1;
    return this.isActive() && this.currentTween && (this.currentTween.update(i) && this.nextTween() && this.nextState(), e = this.isPendingRemove(), e && this.persist && (this.setFinishedState(), e = !1)), e;
  },
  /**
   * Immediately advances to the next Tween in the chain.
   *
   * This is typically called internally, but can be used if you need to
   * advance playback for some reason.
   *
   * @method Phaser.Tweens.TweenChain#nextTween
   * @since 3.60.0
   *
   * @return {boolean} `true` if there are no more Tweens in the chain, otherwise `false`.
   */
  nextTween: function() {
    return this.currentIndex++, this.currentIndex === this.totalData ? !0 : (this.setCurrentTween(this.currentIndex), !1);
  },
  /**
   * Sets the current active Tween to the given index, based on its
   * entry in the TweenChain data array.
   *
   * @method Phaser.Tweens.TweenChain#setCurrentTween
   * @since 3.60.0
   *
   * @param {number} index - The index of the Tween to be made current.
   */
  setCurrentTween: function(i) {
    this.currentIndex = i, this.currentTween = this.data[i], this.currentTween.setActiveState();
  },
  /**
   * Internal method that will emit a TweenChain based Event and invoke the given callback.
   *
   * @method Phaser.Tweens.TweenChain#dispatchEvent
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.Event} event - The Event to be dispatched.
   * @param {Phaser.Types.Tweens.TweenCallbackTypes} [callback] - The name of the callback to be invoked. Can be `null` or `undefined` to skip invocation.
   */
  dispatchEvent: function(i, e) {
    this.emit(i, this);
    var n = this.callbacks[e];
    n && n.func.apply(this.callbackScope, [this].concat(n.params));
  },
  /**
   * Immediately destroys this TweenChain, nulling of all its references.
   *
   * @method Phaser.Tweens.TweenChain#destroy
   * @since 3.60.0
   */
  destroy: function() {
    Nn.prototype.destroy.call(this), this.currentTween = null;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Ec = function(i, e) {
  if (e instanceof Ta)
    return e.parent = i, e;
  var n = new Ta(i);
  n.startDelay = ne(e, "delay", 0), n.completeDelay = Mi(e, "completeDelay", 0), n.loop = Math.round(Mi(e, "loop", ne(e, "repeat", 0))), n.loopDelay = Math.round(Mi(e, "loopDelay", ne(e, "repeatDelay", 0))), n.paused = $e(e, "paused", !1), n.persist = $e(e, "persist", !1), n.callbackScope = ne(e, "callbackScope", n);
  var s, r = Nn.TYPES;
  for (s = 0; s < r.length; s++) {
    var a = r[s], o = ne(e, a, !1);
    if (o) {
      var h = ne(e, a + "Params", []);
      n.setCallback(a, o, h);
    }
  }
  var c = ne(e, "tweens", null);
  if (Array.isArray(c)) {
    var l = [], u = u1(e), f = void 0;
    for (u && (f = { targets: u }), s = 0; s < c.length; s++)
      l.push(Do(n, c[s], f));
    n.add(l);
  }
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const Li = {
  BOOT: "boot",
  START: "start",
  DESTROY: "destroy",
  PAUSE: "pause",
  RESUME: "resume",
  UPDATE: "update",
  SHUTDOWN: "shutdown"
};
var LM = new Gt({
  initialize: function(e) {
    this.scene = e, this.events = e.sys.events, this.timeScale = 1, this.paused = !1, this.processing = !1, this.tweens = [], this.time = 0, this.startTime = 0, this.nextTime = 0, this.prevTime = 0, this.maxLag = 500, this.lagSkip = 33, this.gap = 1e3 / 240, this.events.once(Li.BOOT, this.boot, this), this.events.on(Li.START, this.start, this);
  },
  /**
   * This method is called automatically, only once, when the Scene is first created.
   * Do not invoke it directly.
   *
   * @method Phaser.Tweens.TweenManager#boot
   * @private
   * @since 3.5.1
   */
  boot: function() {
    this.events.once(Li.DESTROY, this.destroy, this);
  },
  /**
   * This method is called automatically by the Scene when it is starting up.
   * It is responsible for creating local systems, properties and listening for Scene events.
   * Do not invoke it directly.
   *
   * @method Phaser.Tweens.TweenManager#start
   * @private
   * @since 3.5.0
   */
  start: function() {
    this.timeScale = 1, this.paused = !1, this.startTime = Date.now(), this.prevTime = this.startTime, this.nextTime = this.gap, this.events.on(Li.UPDATE, this.update, this), this.events.once(Li.SHUTDOWN, this.shutdown, this);
  },
  /**
   * Create a Tween and return it, but does not add it to this Tween Manager.
   *
   * Please note that a Tween will not manipulate any target property that begins with an underscore.
   *
   * In order to play this tween, you'll need to add it to a Tween Manager via
   * the `TweenManager.existing` method.
   *
   * You can optionally pass an **array** of Tween Configuration objects to this method and it will create
   * one Tween per entry in the array. If an array is given, an array of tweens is returned.
   *
   * @method Phaser.Tweens.TweenManager#create
   * @since 3.0.0
   *
   * @param {Phaser.Types.Tweens.TweenBuilderConfig|Phaser.Types.Tweens.TweenBuilderConfig[]|object|object[]} config - A Tween Configuration object. Or an array of Tween Configuration objects.
   *
   * @return {Phaser.Tweens.Tween|Phaser.Tweens.Tween[]} The created Tween, or an array of Tweens if an array of tween configs was provided.
   */
  create: function(i) {
    Array.isArray(i) || (i = [i]);
    for (var e = [], n = 0; n < i.length; n++) {
      var s = i[n];
      s instanceof vs || s instanceof Ta ? e.push(s) : Array.isArray(s.tweens) ? e.push(Ec(this, s)) : e.push(Do(this, s));
    }
    return e.length === 1 ? e[0] : e;
  },
  /**
   * Create a Tween and add it to this Tween Manager by passing a Tween Configuration object.
   *
   * Example, run from within a Scene:
   *
   * ```js
   * const logo = this.add.image(100, 100, 'logo');
   *
   * this.tweens.add({
   *   targets: logo,
   *   x: 600,
   *   ease: 'Power1',
   *   duration: 2000
   * });
   * ```
   *
   * See the `TweenBuilderConfig` for all of the options you have available.
   *
   * Playback will start immediately unless the tween has been configured to be paused.
   *
   * Please note that a Tween will not manipulate any target property that begins with an underscore.
   *
   * Tweens are designed to be 'fire-and-forget'. They automatically destroy themselves once playback
   * is complete, to free-up memory and resources. If you wish to keep a tween after playback, i.e. to
   * play it again at a later time, then you should set the `persist` property to `true` in the config.
   * However, doing so means it's entirely up to _you_ to destroy the tween when you're finished with it,
   * otherwise it will linger in memory forever.
   *
   * If you wish to chain Tweens together for sequential playback, see the `TweenManager.chain` method.
   *
   * @method Phaser.Tweens.TweenManager#add
   * @since 3.0.0
   *
   * @param {Phaser.Types.Tweens.TweenBuilderConfig|Phaser.Types.Tweens.TweenChainBuilderConfig|Phaser.Tweens.Tween|Phaser.Tweens.TweenChain} config - A Tween Configuration object, or a Tween or TweenChain instance.
   *
   * @return {Phaser.Tweens.Tween} The created Tween.
   */
  add: function(i) {
    var e = i, n = this.tweens;
    return e instanceof vs || e instanceof Ta || (Array.isArray(e.tweens) ? e = Ec(this, e) : e = Do(this, e)), n.push(e.reset()), e;
  },
  /**
   * Create multiple Tweens and add them all to this Tween Manager, by passing an array of Tween Configuration objects.
   *
   * See the `TweenBuilderConfig` for all of the options you have available.
   *
   * Playback will start immediately unless the tweens have been configured to be paused.
   *
   * Please note that a Tween will not manipulate any target property that begins with an underscore.
   *
   * Tweens are designed to be 'fire-and-forget'. They automatically destroy themselves once playback
   * is complete, to free-up memory and resources. If you wish to keep a tween after playback, i.e. to
   * play it again at a later time, then you should set the `persist` property to `true` in the config.
   * However, doing so means it's entirely up to _you_ to destroy the tween when you're finished with it,
   * otherwise it will linger in memory forever.
   *
   * If you wish to chain Tweens together for sequential playback, see the `TweenManager.chain` method.
   *
   * @method Phaser.Tweens.TweenManager#addMultiple
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.TweenBuilderConfig[]|object[]} configs - An array of Tween Configuration objects.
   *
   * @return {Phaser.Tweens.Tween[]} An array of created Tweens.
   */
  addMultiple: function(i) {
    for (var e, n = [], s = this.tweens, r = 0; r < i.length; r++)
      e = i[r], e instanceof vs || e instanceof Ta || (Array.isArray(e.tweens) ? e = Ec(this, e) : e = Do(this, e)), s.push(e.reset()), n.push(e);
    return n;
  },
  /**
   * Create a sequence of Tweens, chained to one-another, and add them to this Tween Manager.
   *
   * The tweens are played in order, from start to finish. You can optionally set the chain
   * to repeat as many times as you like. Once the chain has finished playing, or repeating if set,
   * all tweens in the chain will be destroyed automatically. To override this, set the `persist`
   * argument to 'true'.
   *
   * Playback will start immediately unless the _first_ Tween has been configured to be paused.
   *
   * Please note that Tweens will not manipulate any target property that begins with an underscore.
   *
   * @method Phaser.Tweens.TweenManager#chain
   * @since 3.60.0
   *
   * @param {Phaser.Types.Tweens.TweenChainBuilderConfig|object} tweens - A Tween Chain configuration object.
   *
   * @return {Phaser.Tweens.TweenChain} The Tween Chain instance.
   */
  chain: function(i) {
    var e = Ec(this, i);
    return this.tweens.push(e.init()), e;
  },
  /**
   * Returns an array containing this Tween and all Tweens chained to it,
   * in the order in which they will be played.
   *
   * If there are no chained Tweens an empty array is returned.
   *
   * @method Phaser.Tweens.TweenManager#getChainedTweens
   * @since 3.60.0
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to return the chain from.
   *
   * @return {Phaser.Tweens.Tween[]} An array of the chained tweens, or an empty array if there aren't any.
   */
  getChainedTweens: function(i) {
    return i.getChainedTweens();
  },
  /**
   * Check to see if the given Tween instance exists within this Tween Manager.
   *
   * Will return `true` as long as the Tween is being processed by this Tween Manager.
   *
   * Will return `false` if not present, or has a state of `REMOVED` or `DESTROYED`.
   *
   * @method Phaser.Tweens.TweenManager#has
   * @since 3.60.0
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween instance to check.
   *
   * @return {boolean} `true` if the Tween exists within this Tween Manager, otherwise `false`.
   */
  has: function(i) {
    return this.tweens.indexOf(i) > -1;
  },
  /**
   * Add an existing Tween to this Tween Manager.
   *
   * Playback will start immediately unless the tween has been configured to be paused.
   *
   * @method Phaser.Tweens.TweenManager#existing
   * @since 3.0.0
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to add.
   *
   * @return {this} This Tween Manager instance.
   */
  existing: function(i) {
    return this.has(i) || this.tweens.push(i.reset()), this;
  },
  /**
   * Create a Number Tween and add it to the active Tween list.
   *
   * A Number Tween is a special kind of tween that doesn't have a target. Instead,
   * it allows you to tween between 2 numeric values. The default values are
   * `0` and `1`, but you can change them via the `from` and `to` properties.
   *
   * You can get the current tweened value via the `Tween.getValue()` method.
   *
   * Playback will start immediately unless the tween has been configured to be paused.
   *
   * Please note that a Tween will not manipulate any target property that begins with an underscore.
   *
   * @method Phaser.Tweens.TweenManager#addCounter
   * @since 3.0.0
   *
   * @param {Phaser.Types.Tweens.NumberTweenBuilderConfig} config - The configuration object for the Number Tween.
   *
   * @return {Phaser.Tweens.Tween} The created Number Tween.
   */
  addCounter: function(i) {
    var e = OM(this, i);
    return this.tweens.push(e.reset()), e;
  },
  /**
   * Creates a Stagger function to be used by a Tween property.
   *
   * The stagger function will allow you to stagger changes to the value of the property across all targets of the tween.
   *
   * This is only worth using if the tween has multiple targets.
   *
   * The following will stagger the delay by 100ms across all targets of the tween, causing them to scale down to 0.2
   * over the duration specified:
   *
   * ```javascript
   * this.tweens.add({
   *     targets: [ ... ],
   *     scale: 0.2,
   *     ease: 'linear',
   *     duration: 1000,
   *     delay: this.tweens.stagger(100)
   * });
   * ```
   *
   * The following will stagger the delay by 500ms across all targets of the tween using a 10 x 6 grid, staggering
   * from the center out, using a cubic ease.
   *
   * ```javascript
   * this.tweens.add({
   *     targets: [ ... ],
   *     scale: 0.2,
   *     ease: 'linear',
   *     duration: 1000,
   *     delay: this.tweens.stagger(500, { grid: [ 10, 6 ], from: 'center', ease: 'cubic.out' })
   * });
   * ```
   *
   * @method Phaser.Tweens.TweenManager#stagger
   * @since 3.19.0
   *
   * @param {(number|number[])} value - The amount to stagger by, or an array containing two elements representing the min and max values to stagger between.
   * @param {Phaser.Types.Tweens.StaggerConfig} config - The configuration object for the Stagger function.
   *
   * @return {function} The stagger function.
   */
  stagger: function(i, e) {
    return kM(i, e);
  },
  /**
   * Set the limits that are used when a browser encounters lag, or delays that cause the elapsed
   * time between two frames to exceed the expected amount. If this occurs, the Tween Manager will
   * act as if the 'skip' amount of times has passed, in order to maintain strict tween sequencing.
   *
   * This is enabled by default with the values 500ms for the lag limit and 33ms for the skip.
   *
   * You should not set these to low values, as it won't give time for the browser to ever
   * catch-up with itself and reclaim sync.
   *
   * Call this method with no arguments to disable smoothing.
   *
   * Call it with the arguments `500` and `33` to reset to the defaults.
   *
   * @method Phaser.Tweens.TweenManager#setLagSmooth
   * @since 3.60.0
   *
   * @param {number} [limit=0] - If the browser exceeds this amount, in milliseconds, it will act as if the 'skip' amount has elapsed instead.
   * @param {number} [skip=0] - The amount, in milliseconds, to use as the step delta should the browser lag beyond the 'limit'.
   *
   * @return {this} This Tween Manager instance.
   */
  setLagSmooth: function(i, e) {
    return i === void 0 && (i = 1 / 1e-8), e === void 0 && (e = 0), this.maxLag = i, this.lagSkip = Math.min(e, this.maxLag), this;
  },
  /**
   * Limits the Tween system to run at a particular frame rate.
   *
   * You should not set this _above_ the frequency of the browser,
   * but instead can use it to throttle the frame rate lower, should
   * you need to in certain situations.
   *
   * @method Phaser.Tweens.TweenManager#setFps
   * @since 3.60.0
   *
   * @param {number} [fps=240] - The frame rate to tick at.
   *
   * @return {this} This Tween Manager instance.
   */
  setFps: function(i) {
    return i === void 0 && (i = 240), this.gap = 1e3 / i, this.nextTime = this.time * 1e3 + this.gap, this;
  },
  /**
   * Internal method that calculates the delta value, along with the other timing values,
   * and returns the new delta.
   *
   * You should not typically call this method directly.
   *
   * @method Phaser.Tweens.TweenManager#getDelta
   * @since 3.60.0
   *
   * @param {boolean} [tick=false] - Is this a manual tick, or an automated tick?
   *
   * @return {number} The new delta value.
   */
  getDelta: function(i) {
    var e = Date.now() - this.prevTime;
    e > this.maxLag && (this.startTime += e - this.lagSkip), this.prevTime += e;
    var n = this.prevTime - this.startTime, s = n - this.nextTime, r = n - this.time * 1e3;
    return s > 0 || i ? (n /= 1e3, this.time = n, this.nextTime += s + (s >= this.gap ? 4 : this.gap - s)) : r = 0, r;
  },
  /**
   * Manually advance the Tween system by one step.
   *
   * This will update all Tweens even if the Tween Manager is currently
   * paused.
   *
   * @method Phaser.Tweens.TweenManager#tick
   * @since 3.60.0
   *
   * @return {this} This Tween Manager instance.
   */
  tick: function() {
    return this.step(!0), this;
  },
  /**
   * Internal update handler.
   *
   * Calls `TweenManager.step` as long as the Tween Manager has not
   * been paused.
   *
   * @method Phaser.Tweens.TweenManager#update
   * @since 3.0.0
   */
  update: function() {
    this.paused || this.step(!1);
  },
  /**
   * Updates all Tweens belonging to this Tween Manager.
   *
   * Called automatically by `update` and `tick`.
   *
   * @method Phaser.Tweens.TweenManager#step
   * @since 3.60.0
   *
   * @param {boolean} [tick=false] - Is this a manual tick, or an automated tick?
   */
  step: function(i) {
    i === void 0 && (i = !1);
    var e = this.getDelta(i);
    if (!(e <= 0)) {
      this.processing = !0;
      var n, s, r = [], a = this.tweens;
      for (n = 0; n < a.length; n++)
        s = a[n], s.update(e) && r.push(s);
      var o = r.length;
      if (o && a.length > 0) {
        for (n = 0; n < o; n++) {
          s = r[n];
          var h = a.indexOf(s);
          h > -1 && (s.isPendingRemove() || s.isDestroyed()) && (a.splice(h, 1), s.destroy());
        }
        r.length = 0;
      }
      this.processing = !1;
    }
  },
  /**
   * Removes the given Tween from this Tween Manager, even if it hasn't started
   * playback yet. If this method is called while the Tween Manager is processing
   * an update loop, then the tween will be flagged for removal at the start of
   * the next frame. Otherwise, it is removed immediately.
   *
   * The removed tween is _not_ destroyed. It is just removed from this Tween Manager.
   *
   * @method Phaser.Tweens.TweenManager#remove
   * @since 3.17.0
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to be removed.
   *
   * @return {this} This Tween Manager instance.
   */
  remove: function(i) {
    return this.processing ? i.setPendingRemoveState() : (r1(this.tweens, i), i.setRemovedState()), this;
  },
  /**
   * Resets the given Tween.
   *
   * If the Tween does not belong to this Tween Manager, it will first be added.
   *
   * Then it will seek to position 0 and playback will start on the next frame.
   *
   * @method Phaser.Tweens.TweenManager#reset
   * @since 3.60.0
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to be reset.
   *
   * @return {this} This Tween Manager instance.
   */
  reset: function(i) {
    return this.existing(i), i.seek(), i.setActiveState(), this;
  },
  /**
   * Checks if a Tween is active and adds it to the Tween Manager at the start of the frame if it isn't.
   *
   * @method Phaser.Tweens.TweenManager#makeActive
   * @since 3.0.0
   *
   * @param {Phaser.Tweens.Tween} tween - The Tween to check.
   *
   * @return {this} This Tween Manager instance.
   */
  makeActive: function(i) {
    return this.existing(i), i.setActiveState(), this;
  },
  /**
   * Passes all Tweens to the given callback.
   *
   * @method Phaser.Tweens.TweenManager#each
   * @since 3.0.0
   *
   * @param {function} callback - The function to call.
   * @param {object} [scope] - The scope (`this` object) to call the function with.
   * @param {...*} [args] - The arguments to pass into the function. Its first argument will always be the Tween currently being iterated.
   *
   * @return {this} This Tween Manager instance.
   */
  each: function(i, e) {
    var n, s = [null];
    for (n = 1; n < arguments.length; n++)
      s.push(arguments[n]);
    return this.tweens.forEach(function(r) {
      s[0] = r, i.apply(e, s);
    }), this;
  },
  /**
   * Returns an array containing references to all Tweens in this Tween Manager.
   *
   * It is safe to mutate the returned array. However, acting upon any of the Tweens
   * within it, will adjust those stored in this Tween Manager, as they are passed
   * by reference and not cloned.
   *
   * If you wish to get tweens for a specific target, see `getTweensOf`.
   *
   * @method Phaser.Tweens.TweenManager#getTweens
   * @since 3.0.0
   *
   * @return {Phaser.Tweens.Tween[]} A new array containing references to all Tweens.
   */
  getTweens: function() {
    return this.tweens.slice();
  },
  /**
   * Returns an array of all Tweens in the Tween Manager which affect the given target, or array of targets.
   *
   * It's possible for this method to return tweens that are about to be removed from
   * the Tween Manager. You should check the state of the returned tween before acting
   * upon it.
   *
   * @method Phaser.Tweens.TweenManager#getTweensOf
   * @since 3.0.0
   *
   * @param {(object|object[])} target - The target to look for. Provide an array to look for multiple targets.
   *
   * @return {Phaser.Tweens.Tween[]} A new array containing all Tweens which affect the given target(s).
   */
  getTweensOf: function(i) {
    var e = [], n = this.tweens;
    Array.isArray(i) ? i = s1(i) : i = [i];
    for (var s = i.length, r = 0; r < n.length; r++)
      for (var a = n[r], o = 0; o < s; o++)
        !a.isDestroyed() && a.hasTarget(i[o]) && e.push(a);
    return e;
  },
  /**
   * Returns the scale of the time delta for all Tweens owned by this Tween Manager.
   *
   * @method Phaser.Tweens.TweenManager#getGlobalTimeScale
   * @since 3.0.0
   *
   * @return {number} The scale of the time delta, usually 1.
   */
  getGlobalTimeScale: function() {
    return this.timeScale;
  },
  /**
   * Sets a new scale of the time delta for this Tween Manager.
   *
   * The time delta is the time elapsed between two consecutive frames and influences the speed of time for this Tween Manager and all Tweens it owns. Values higher than 1 increase the speed of time, while values smaller than 1 decrease it. A value of 0 freezes time and is effectively equivalent to pausing all Tweens.
   *
   * @method Phaser.Tweens.TweenManager#setGlobalTimeScale
   * @since 3.0.0
   *
   * @param {number} value - The new scale of the time delta, where 1 is the normal speed.
   *
   * @return {this} This Tween Manager instance.
   */
  setGlobalTimeScale: function(i) {
    return this.timeScale = i, this;
  },
  /**
   * Checks if the given object is being affected by a _playing_ Tween.
   *
   * If the Tween is paused, this method will return false.
   *
   * @method Phaser.Tweens.TweenManager#isTweening
   * @since 3.0.0
   *
   * @param {object} target - The object to check if a tween is active for it, or not.
   *
   * @return {boolean} Returns `true` if a tween is active on the given target, otherwise `false`.
   */
  isTweening: function(i) {
    for (var e = this.tweens, n, s = 0; s < e.length; s++)
      if (n = e[s], n.isPlaying() && n.hasTarget(i))
        return !0;
    return !1;
  },
  /**
   * Destroys all Tweens in this Tween Manager.
   *
   * The tweens will erase all references to any targets they hold
   * and be stopped immediately.
   *
   * If this method is called while the Tween Manager is running its
   * update process, then the tweens will be removed at the start of
   * the next frame. Outside of this, they are removed immediately.
   *
   * @method Phaser.Tweens.TweenManager#killAll
   * @since 3.0.0
   *
   * @return {this} This Tween Manager instance.
   */
  killAll: function() {
    for (var i = this.processing ? this.getTweens() : this.tweens, e = 0; e < i.length; e++)
      i[e].destroy();
    return this.processing || (i.length = 0), this;
  },
  /**
   * Stops all Tweens which affect the given target or array of targets.
   *
   * The tweens will erase all references to any targets they hold
   * and be stopped immediately.
   *
   * If this method is called while the Tween Manager is running its
   * update process, then the tweens will be removed at the start of
   * the next frame. Outside of this, they are removed immediately.
   *
   * @see {@link #getTweensOf}
   *
   * @method Phaser.Tweens.TweenManager#killTweensOf
   * @since 3.0.0
   *
   * @param {(object|array)} target - The target to kill the tweens of. Provide an array to use multiple targets.
   *
   * @return {this} This Tween Manager instance.
   */
  killTweensOf: function(i) {
    for (var e = this.getTweensOf(i), n = 0; n < e.length; n++)
      e[n].destroy();
    return this;
  },
  /**
   * Pauses this Tween Manager. No Tweens will update while paused.
   *
   * This includes tweens created after this method was called.
   *
   * See `TweenManager#resumeAll` to resume the playback.
   *
   * As of Phaser 3.60 you can also toggle the boolean property `TweenManager.paused`.
   *
   * @method Phaser.Tweens.TweenManager#pauseAll
   * @since 3.0.0
   *
   * @return {this} This Tween Manager instance.
   */
  pauseAll: function() {
    return this.paused = !0, this;
  },
  /**
   * Resumes playback of this Tween Manager.
   *
   * All active Tweens will continue updating.
   *
   * See `TweenManager#pauseAll` to pause the playback.
   *
   * As of Phaser 3.60 you can also toggle the boolean property `TweenManager.paused`.
   *
   * @method Phaser.Tweens.TweenManager#resumeAll
   * @since 3.0.0
   *
   * @return {this} This Tween Manager instance.
   */
  resumeAll: function() {
    return this.paused = !1, this;
  },
  /**
   * The Scene that owns this plugin is shutting down.
   *
   * We need to kill and reset all internal properties as well as stop listening to Scene events.
   *
   * @method Phaser.Tweens.TweenManager#shutdown
   * @since 3.0.0
   */
  shutdown: function() {
    this.killAll(), this.tweens = [], this.events.off(Li.UPDATE, this.update, this), this.events.off(Li.SHUTDOWN, this.shutdown, this);
  },
  /**
   * The Scene that owns this plugin is being destroyed.
   * We need to shutdown and then kill off all external references.
   *
   * @method Phaser.Tweens.TweenManager#destroy
   * @since 3.0.0
   */
  destroy: function() {
    this.shutdown(), this.events.off(Li.START, this.start, this), this.scene = null, this.events = null;
  }
});
LM.SceneEvents = Li;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var qF = {
  States: _t,
  Builders: DF,
  Events: me,
  TweenManager: LM,
  Tween: vs,
  TweenData: IM,
  TweenFrameData: RM,
  BaseTween: Nn,
  TweenChain: Ta
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var FM = function(i, e, n, s) {
  return s << 24 | i << 16 | e << 8 | n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
function df(i, e, n, s) {
  var r = (i + e * 6) % 6, a = Math.min(r, 4 - r, 1);
  return Math.round(255 * (s - s * n * Math.max(0, a)));
}
var ga = function(i, e, n, s) {
  e === void 0 && (e = 1), n === void 0 && (n = 1);
  var r = df(5, i, e, n), a = df(3, i, e, n), o = df(1, i, e, n);
  return s ? s.setTo ? s.setTo(r, a, o, s.alpha, !0) : (s.r = r, s.g = a, s.b = o, s.color = gi(r, a, o), s) : { r, g: a, b: o, color: gi(r, a, o) };
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var Y0 = function(i, e, n, s) {
  s === void 0 && (s = { h: 0, s: 0, v: 0 }), i /= 255, e /= 255, n /= 255;
  var r = Math.min(i, e, n), a = Math.max(i, e, n), o = a - r, h = 0, c = a === 0 ? 0 : o / a, l = a;
  return a !== r && (a === i ? h = (e - n) / o + (e < n ? 6 : 0) : a === e ? h = (n - i) / o + 2 : a === n && (h = (i - e) / o + 4), h /= 6), s.hasOwnProperty("_h") ? (s._h = h, s._s = c, s._v = l) : (s.h = h, s.s = c, s.v = l), s;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ee = new Gt({
  initialize: function(e, n, s, r) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), r === void 0 && (r = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = "", this.setTo(e, n, s, r);
  },
  /**
   * Sets this color to be transparent. Sets all values to zero.
   *
   * @method Phaser.Display.Color#transparent
   * @since 3.0.0
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  transparent: function() {
    return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0);
  },
  /**
   * Sets the color of this Color component.
   *
   * @method Phaser.Display.Color#setTo
   * @since 3.0.0
   *
   * @param {number} red - The red color value. A number between 0 and 255.
   * @param {number} green - The green color value. A number between 0 and 255.
   * @param {number} blue - The blue color value. A number between 0 and 255.
   * @param {number} [alpha=255] - The alpha value. A number between 0 and 255.
   * @param {boolean} [updateHSV=true] - Update the HSV values after setting the RGB values?
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  setTo: function(i, e, n, s, r) {
    return s === void 0 && (s = 255), r === void 0 && (r = !0), this._locked = !0, this.red = i, this.green = e, this.blue = n, this.alpha = s, this._locked = !1, this.update(r);
  },
  /**
   * Sets the red, green, blue and alpha GL values of this Color component.
   *
   * @method Phaser.Display.Color#setGLTo
   * @since 3.0.0
   *
   * @param {number} red - The red color value. A number between 0 and 1.
   * @param {number} green - The green color value. A number between 0 and 1.
   * @param {number} blue - The blue color value. A number between 0 and 1.
   * @param {number} [alpha=1] - The alpha value. A number between 0 and 1.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  setGLTo: function(i, e, n, s) {
    return s === void 0 && (s = 1), this._locked = !0, this.redGL = i, this.greenGL = e, this.blueGL = n, this.alphaGL = s, this._locked = !1, this.update(!0);
  },
  /**
   * Sets the color based on the color object given.
   *
   * @method Phaser.Display.Color#setFromRGB
   * @since 3.0.0
   *
   * @param {Phaser.Types.Display.InputColorObject} color - An object containing `r`, `g`, `b` and optionally `a` values in the range 0 to 255.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  setFromRGB: function(i) {
    return this._locked = !0, this.red = i.r, this.green = i.g, this.blue = i.b, i.hasOwnProperty("a") && (this.alpha = i.a), this._locked = !1, this.update(!0);
  },
  /**
   * Sets the color based on the hue, saturation and lightness values given.
   *
   * @method Phaser.Display.Color#setFromHSV
   * @since 3.13.0
   *
   * @param {number} h - The hue, in the range 0 - 1. This is the base color.
   * @param {number} s - The saturation, in the range 0 - 1. This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
   * @param {number} v - The value, in the range 0 - 1. This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  setFromHSV: function(i, e, n) {
    return ga(i, e, n, this);
  },
  /**
   * Updates the internal cache values.
   *
   * @method Phaser.Display.Color#update
   * @private
   * @since 3.0.0
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  update: function(i) {
    if (i === void 0 && (i = !1), this._locked)
      return this;
    var e = this.r, n = this.g, s = this.b, r = this.a;
    return this._color = gi(e, n, s), this._color32 = FM(e, n, s, r), this._rgba = "rgba(" + e + "," + n + "," + s + "," + r / 255 + ")", i && Y0(e, n, s, this), this;
  },
  /**
   * Updates the internal hsv cache values.
   *
   * @method Phaser.Display.Color#updateHSV
   * @private
   * @since 3.13.0
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  updateHSV: function() {
    var i = this.r, e = this.g, n = this.b;
    return Y0(i, e, n, this), this;
  },
  /**
   * Returns a new Color component using the values from this one.
   *
   * @method Phaser.Display.Color#clone
   * @since 3.0.0
   *
   * @return {Phaser.Display.Color} A new Color object.
   */
  clone: function() {
    return new ee(this.r, this.g, this.b, this.a);
  },
  /**
   * Sets this Color object to be grayscaled based on the shade value given.
   *
   * @method Phaser.Display.Color#gray
   * @since 3.13.0
   * 
   * @param {number} shade - A value between 0 and 255.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  gray: function(i) {
    return this.setTo(i, i, i);
  },
  /**
   * Sets this Color object to be a random color between the `min` and `max` values given.
   *
   * @method Phaser.Display.Color#random
   * @since 3.13.0
   * 
   * @param {number} [min=0] - The minimum random color value. Between 0 and 255.
   * @param {number} [max=255] - The maximum random color value. Between 0 and 255.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  random: function(i, e) {
    i === void 0 && (i = 0), e === void 0 && (e = 255);
    var n = Math.floor(i + Math.random() * (e - i)), s = Math.floor(i + Math.random() * (e - i)), r = Math.floor(i + Math.random() * (e - i));
    return this.setTo(n, s, r);
  },
  /**
   * Sets this Color object to be a random grayscale color between the `min` and `max` values given.
   *
   * @method Phaser.Display.Color#randomGray
   * @since 3.13.0
   * 
   * @param {number} [min=0] - The minimum random color value. Between 0 and 255.
   * @param {number} [max=255] - The maximum random color value. Between 0 and 255.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  randomGray: function(i, e) {
    i === void 0 && (i = 0), e === void 0 && (e = 255);
    var n = Math.floor(i + Math.random() * (e - i));
    return this.setTo(n, n, n);
  },
  /**
   * Increase the saturation of this Color by the percentage amount given.
   * The saturation is the amount of the base color in the hue.
   *
   * @method Phaser.Display.Color#saturate
   * @since 3.13.0
   * 
   * @param {number} amount - The percentage amount to change this color by. A value between 0 and 100.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  saturate: function(i) {
    return this.s += i / 100, this;
  },
  /**
   * Decrease the saturation of this Color by the percentage amount given.
   * The saturation is the amount of the base color in the hue.
   *
   * @method Phaser.Display.Color#desaturate
   * @since 3.13.0
   * 
   * @param {number} amount - The percentage amount to change this color by. A value between 0 and 100.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  desaturate: function(i) {
    return this.s -= i / 100, this;
  },
  /**
   * Increase the lightness of this Color by the percentage amount given.
   *
   * @method Phaser.Display.Color#lighten
   * @since 3.13.0
   * 
   * @param {number} amount - The percentage amount to change this color by. A value between 0 and 100.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  lighten: function(i) {
    return this.v += i / 100, this;
  },
  /**
   * Decrease the lightness of this Color by the percentage amount given.
   *
   * @method Phaser.Display.Color#darken
   * @since 3.13.0
   * 
   * @param {number} amount - The percentage amount to change this color by. A value between 0 and 100.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  darken: function(i) {
    return this.v -= i / 100, this;
  },
  /**
   * Brighten this Color by the percentage amount given.
   *
   * @method Phaser.Display.Color#brighten
   * @since 3.13.0
   * 
   * @param {number} amount - The percentage amount to change this color by. A value between 0 and 100.
   *
   * @return {Phaser.Display.Color} This Color object.
   */
  brighten: function(i) {
    var e = this.r, n = this.g, s = this.b;
    return e = Math.max(0, Math.min(255, e - Math.round(255 * -(i / 100)))), n = Math.max(0, Math.min(255, n - Math.round(255 * -(i / 100)))), s = Math.max(0, Math.min(255, s - Math.round(255 * -(i / 100)))), this.setTo(e, n, s);
  },
  /**
   * The color of this Color component, not including the alpha channel.
   *
   * @name Phaser.Display.Color#color
   * @type {number}
   * @readonly
   * @since 3.0.0
   */
  color: {
    get: function() {
      return this._color;
    }
  },
  /**
   * The color of this Color component, including the alpha channel.
   *
   * @name Phaser.Display.Color#color32
   * @type {number}
   * @readonly
   * @since 3.0.0
   */
  color32: {
    get: function() {
      return this._color32;
    }
  },
  /**
   * The color of this Color component as a string which can be used in CSS color values.
   *
   * @name Phaser.Display.Color#rgba
   * @type {string}
   * @readonly
   * @since 3.0.0
   */
  rgba: {
    get: function() {
      return this._rgba;
    }
  },
  /**
   * The red color value, normalized to the range 0 to 1.
   *
   * @name Phaser.Display.Color#redGL
   * @type {number}
   * @since 3.0.0
   */
  redGL: {
    get: function() {
      return this.gl[0];
    },
    set: function(i) {
      this.gl[0] = Math.min(Math.abs(i), 1), this.r = Math.floor(this.gl[0] * 255), this.update(!0);
    }
  },
  /**
   * The green color value, normalized to the range 0 to 1.
   *
   * @name Phaser.Display.Color#greenGL
   * @type {number}
   * @since 3.0.0
   */
  greenGL: {
    get: function() {
      return this.gl[1];
    },
    set: function(i) {
      this.gl[1] = Math.min(Math.abs(i), 1), this.g = Math.floor(this.gl[1] * 255), this.update(!0);
    }
  },
  /**
   * The blue color value, normalized to the range 0 to 1.
   *
   * @name Phaser.Display.Color#blueGL
   * @type {number}
   * @since 3.0.0
   */
  blueGL: {
    get: function() {
      return this.gl[2];
    },
    set: function(i) {
      this.gl[2] = Math.min(Math.abs(i), 1), this.b = Math.floor(this.gl[2] * 255), this.update(!0);
    }
  },
  /**
   * The alpha color value, normalized to the range 0 to 1.
   *
   * @name Phaser.Display.Color#alphaGL
   * @type {number}
   * @since 3.0.0
   */
  alphaGL: {
    get: function() {
      return this.gl[3];
    },
    set: function(i) {
      this.gl[3] = Math.min(Math.abs(i), 1), this.a = Math.floor(this.gl[3] * 255), this.update();
    }
  },
  /**
   * The red color value, normalized to the range 0 to 255.
   *
   * @name Phaser.Display.Color#red
   * @type {number}
   * @since 3.0.0
   */
  red: {
    get: function() {
      return this.r;
    },
    set: function(i) {
      i = Math.floor(Math.abs(i)), this.r = Math.min(i, 255), this.gl[0] = i / 255, this.update(!0);
    }
  },
  /**
   * The green color value, normalized to the range 0 to 255.
   *
   * @name Phaser.Display.Color#green
   * @type {number}
   * @since 3.0.0
   */
  green: {
    get: function() {
      return this.g;
    },
    set: function(i) {
      i = Math.floor(Math.abs(i)), this.g = Math.min(i, 255), this.gl[1] = i / 255, this.update(!0);
    }
  },
  /**
   * The blue color value, normalized to the range 0 to 255.
   *
   * @name Phaser.Display.Color#blue
   * @type {number}
   * @since 3.0.0
   */
  blue: {
    get: function() {
      return this.b;
    },
    set: function(i) {
      i = Math.floor(Math.abs(i)), this.b = Math.min(i, 255), this.gl[2] = i / 255, this.update(!0);
    }
  },
  /**
   * The alpha color value, normalized to the range 0 to 255.
   *
   * @name Phaser.Display.Color#alpha
   * @type {number}
   * @since 3.0.0
   */
  alpha: {
    get: function() {
      return this.a;
    },
    set: function(i) {
      i = Math.floor(Math.abs(i)), this.a = Math.min(i, 255), this.gl[3] = i / 255, this.update();
    }
  },
  /**
   * The hue color value. A number between 0 and 1.
   * This is the base color.
   *
   * @name Phaser.Display.Color#h
   * @type {number}
   * @since 3.13.0
   */
  h: {
    get: function() {
      return this._h;
    },
    set: function(i) {
      this._h = i, ga(i, this._s, this._v, this);
    }
  },
  /**
   * The saturation color value. A number between 0 and 1.
   * This controls how much of the hue will be in the final color, where 1 is fully saturated and 0 will give you white.
   *
   * @name Phaser.Display.Color#s
   * @type {number}
   * @since 3.13.0
   */
  s: {
    get: function() {
      return this._s;
    },
    set: function(i) {
      this._s = i, ga(this._h, i, this._v, this);
    }
  },
  /**
   * The lightness color value. A number between 0 and 1.
   * This controls how dark the color is. Where 1 is as bright as possible and 0 is black.
   *
   * @name Phaser.Display.Color#v
   * @type {number}
   * @since 3.13.0
   */
  v: {
    get: function() {
      return this._v;
    },
    set: function(i) {
      this._v = i, ga(this._h, this._s, i, this);
    }
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $F = function(i) {
  i === void 0 && (i = 1024);
  var e = [], n = 255, s, r = 255, a = 0, o = 0;
  for (s = 0; s <= n; s++)
    e.push({ r, g: s, b: o, color: gi(r, s, o) });
  for (a = 255, s = n; s >= 0; s--)
    e.push({ r: s, g: a, b: o, color: gi(s, a, o) });
  for (r = 0, s = 0; s <= n; s++, a--)
    e.push({ r, g: a, b: s, color: gi(r, a, s) });
  for (a = 0, o = 255, s = 0; s <= n; s++, o--, r++)
    e.push({ r, g: a, b: o, color: gi(r, a, o) });
  if (i === 1024)
    return e;
  var h = [], c = 0, l = 1024 / i;
  for (s = 0; s < i; s++)
    h.push(e[Math.floor(c)]), c += l;
  return h;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var VF = function(i) {
  var e = {
    r: i >> 16 & 255,
    g: i >> 8 & 255,
    b: i & 255,
    a: 255
  };
  return i > 16777215 && (e.a = i >>> 24), e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var zo = function(i) {
  var e = i.toString(16);
  return e.length === 1 ? "0" + e : e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var NM = function(i) {
  var e = new ee();
  i = i.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(o, h, c, l) {
    return h + h + c + c + l + l;
  });
  var n = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i);
  if (n) {
    var s = parseInt(n[1], 16), r = parseInt(n[2], 16), a = parseInt(n[3], 16);
    e.setTo(s, r, a);
  }
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ol = function(i, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? i + (e - i) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? i + (e - i) * (2 / 3 - n) * 6 : i;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var GF = function(i, e, n) {
  var s = n, r = n, a = n;
  if (e !== 0) {
    var o = n < 0.5 ? n * (1 + e) : n + e - n * e, h = 2 * n - o;
    s = ol(h, o, i + 1 / 3), r = ol(h, o, i), a = ol(h, o, i - 1 / 3);
  }
  var c = new ee();
  return c.setGLTo(s, r, a, 1);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var UF = function(i, e) {
  i === void 0 && (i = 1), e === void 0 && (e = 1);
  for (var n = [], s = 0; s <= 359; s++)
    n.push(ga(s / 359, i, e));
  return n;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var BM = function(i) {
  return i > 16777215 ? {
    a: i >>> 24,
    r: i >> 16 & 255,
    g: i >> 8 & 255,
    b: i & 255
  } : {
    a: 255,
    r: i >> 16 & 255,
    g: i >> 8 & 255,
    b: i & 255
  };
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var DM = function(i) {
  var e = BM(i);
  return new ee(e.r, e.g, e.b, e.a);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var f1 = function(i, e, n, s, r, a, o, h) {
  o === void 0 && (o = 100), h === void 0 && (h = 0);
  var c = h / o, l = vr(i, s, c), u = vr(e, r, c), f = vr(n, a, c);
  return {
    r: l,
    g: u,
    b: f,
    a: 255,
    color: gi(l, u, f)
  };
}, WF = function(i, e, n, s) {
  return n === void 0 && (n = 100), s === void 0 && (s = 0), f1(i.r, i.g, i.b, e.r, e.g, e.b, n, s);
}, YF = function(i, e, n, s, r, a) {
  return r === void 0 && (r = 100), a === void 0 && (a = 0), f1(i.r, i.g, i.b, e, n, s, r, a);
};
const jF = {
  RGBWithRGB: f1,
  ColorWithRGB: YF,
  ColorWithColor: WF
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var qM = function(i) {
  return new ee(i.r, i.g, i.b, i.a);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var HF = function(i, e) {
  return i === void 0 && (i = 0), e === void 0 && (e = 255), new ee(Sa(i, e), Sa(i, e), Sa(i, e));
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var $M = function(i) {
  var e = new ee(), n = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(i.toLowerCase());
  if (n) {
    var s = parseInt(n[1], 10), r = parseInt(n[2], 10), a = parseInt(n[3], 10), o = n[4] !== void 0 ? parseFloat(n[4]) : 1;
    e.setTo(s, r, a, o * 255);
  }
  return e;
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var XF = function(i, e, n, s, r) {
  return s === void 0 && (s = 255), r === void 0 && (r = "#"), r === "#" ? "#" + ((1 << 24) + (i << 16) + (e << 8) + n).toString(16).slice(1, 7) : "0x" + zo(s) + zo(i) + zo(e) + zo(n);
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var ZF = function(i) {
  var e = typeof i;
  switch (e) {
    case "string":
      return i.substr(0, 3).toLowerCase() === "rgb" ? $M(i) : NM(i);
    case "number":
      return DM(i);
    case "object":
      return qM(i);
  }
};
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
ee.ColorSpectrum = $F;
ee.ColorToRGBA = VF;
ee.ComponentToHex = zo;
ee.GetColor = gi;
ee.GetColor32 = FM;
ee.HexStringToColor = NM;
ee.HSLToColor = GF;
ee.HSVColorWheel = UF;
ee.HSVToRGB = ga;
ee.HueToComponent = ol;
ee.IntegerToColor = DM;
ee.IntegerToRGB = BM;
ee.Interpolate = jF;
ee.ObjectToColor = qM;
ee.RandomRGB = HF;
ee.RGBStringToColor = $M;
ee.RGBToHSV = Y0;
ee.RGBToString = XF;
ee.ValueToColor = ZF;
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var JF = new Float32Array(20), oe = new Gt({
  initialize: function() {
    this._matrix = new Float32Array(20), this.alpha = 1, this._dirty = !0, this._data = new Float32Array(20), this.reset();
  },
  /**
   * Sets this ColorMatrix from the given array of color values.
   *
   * @method Phaser.Display.ColorMatrix#set
   * @since 3.50.0
   *
   * @param {(number[]|Float32Array)} value - The ColorMatrix values to set. Must have 20 elements.
   *
   * @return {this} This ColorMatrix instance.
   */
  set: function(i) {
    return this._matrix.set(i), this._dirty = !0, this;
  },
  /**
   * Resets the ColorMatrix to default values and also resets
   * the `alpha` property back to 1.
   *
   * @method Phaser.Display.ColorMatrix#reset
   * @since 3.50.0
   *
   * @return {this} This ColorMatrix instance.
   */
  reset: function() {
    var i = this._matrix;
    return i.fill(0), i[0] = 1, i[6] = 1, i[12] = 1, i[18] = 1, this.alpha = 1, this._dirty = !0, this;
  },
  /**
   * Gets the ColorMatrix as a Float32Array.
   *
   * Can be used directly as a 1fv shader uniform value.
   *
   * @method Phaser.Display.ColorMatrix#getData
   * @since 3.50.0
   *
   * @return {Float32Array} The ColorMatrix as a Float32Array.
   */
  getData: function() {
    var i = this._data;
    return this._dirty && (i.set(this._matrix), i[4] /= 255, i[9] /= 255, i[14] /= 255, i[19] /= 255, this._dirty = !1), i;
  },
  /**
   * Changes the brightness of this ColorMatrix by the given amount.
   *
   * @method Phaser.Display.ColorMatrix#brightness
   * @since 3.50.0
   *
   * @param {number} [value=0] - The amount of brightness to apply to this ColorMatrix. Between 0 (black) and 1.
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  brightness: function(i, e) {
    i === void 0 && (i = 0), e === void 0 && (e = !1);
    var n = i;
    return this.multiply([
      n,
      0,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ], e);
  },
  /**
   * Changes the saturation of this ColorMatrix by the given amount.
   *
   * @method Phaser.Display.ColorMatrix#saturate
   * @since 3.50.0
   *
   * @param {number} [value=0] - The amount of saturation to apply to this ColorMatrix.
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  saturate: function(i, e) {
    i === void 0 && (i = 0), e === void 0 && (e = !1);
    var n = i * 2 / 3 + 1, s = (n - 1) * -0.5;
    return this.multiply([
      n,
      s,
      s,
      0,
      0,
      s,
      n,
      s,
      0,
      0,
      s,
      s,
      n,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ], e);
  },
  /**
   * Desaturates this ColorMatrix (removes color from it).
   *
   * @method Phaser.Display.ColorMatrix#saturation
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  desaturate: function(i) {
    return i === void 0 && (i = !1), this.saturate(-1, i);
  },
  /**
   * Rotates the hues of this ColorMatrix by the value given.
   *
   * @method Phaser.Display.ColorMatrix#hue
   * @since 3.50.0
   *
   * @param {number} [rotation=0] - The amount of hue rotation to apply to this ColorMatrix, in degrees.
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  hue: function(i, e) {
    i === void 0 && (i = 0), e === void 0 && (e = !1), i = i / 180 * Math.PI;
    var n = Math.cos(i), s = Math.sin(i), r = 0.213, a = 0.715, o = 0.072;
    return this.multiply([
      r + n * (1 - r) + s * -r,
      a + n * -a + s * -a,
      o + n * -o + s * (1 - o),
      0,
      0,
      r + n * -r + s * 0.143,
      a + n * (1 - a) + s * 0.14,
      o + n * -o + s * -0.283,
      0,
      0,
      r + n * -r + s * -0.787,
      a + n * -a + s * a,
      o + n * (1 - o) + s * o,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ], e);
  },
  /**
   * Sets this ColorMatrix to be grayscale.
   *
   * @method Phaser.Display.ColorMatrix#grayscale
   * @since 3.50.0
   *
   * @param {number} [value=1] - The grayscale scale (0 is black).
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  grayscale: function(i, e) {
    return i === void 0 && (i = 1), e === void 0 && (e = !1), this.saturate(-i, e);
  },
  /**
   * Sets this ColorMatrix to be black and white.
   *
   * @method Phaser.Display.ColorMatrix#blackWhite
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  blackWhite: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.BLACK_WHITE, i);
  },
  /**
   * Change the contrast of this ColorMatrix by the amount given.
   *
   * @method Phaser.Display.ColorMatrix#contrast
   * @since 3.50.0
   *
   * @param {number} [value=0] - The amount of contrast to apply to this ColorMatrix.
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  contrast: function(i, e) {
    i === void 0 && (i = 0), e === void 0 && (e = !1);
    var n = i + 1, s = -0.5 * (n - 1);
    return this.multiply([
      n,
      0,
      0,
      0,
      s,
      0,
      n,
      0,
      0,
      s,
      0,
      0,
      n,
      0,
      s,
      0,
      0,
      0,
      1,
      0
    ], e);
  },
  /**
   * Converts this ColorMatrix to have negative values.
   *
   * @method Phaser.Display.ColorMatrix#negative
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  negative: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.NEGATIVE, i);
  },
  /**
   * Apply a desaturated luminance to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#desaturateLuminance
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  desaturateLuminance: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.DESATURATE_LUMINANCE, i);
  },
  /**
   * Applies a sepia tone to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#sepia
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  sepia: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.SEPIA, i);
  },
  /**
   * Applies a night vision tone to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#night
   * @since 3.50.0
   *
   * @param {number} [intensity=0.1] - The intensity of this effect.
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  night: function(i, e) {
    return i === void 0 && (i = 0.1), e === void 0 && (e = !1), this.multiply([
      i * -2,
      -i,
      0,
      0,
      0,
      -i,
      0,
      i,
      0,
      0,
      0,
      i,
      i * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ], e);
  },
  /**
   * Applies a trippy color tone to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#lsd
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  lsd: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.LSD, i);
  },
  /**
   * Applies a brown tone to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#brown
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  brown: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.BROWN, i);
  },
  /**
   * Applies a vintage pinhole color effect to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#vintagePinhole
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  vintagePinhole: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.VINTAGE, i);
  },
  /**
   * Applies a kodachrome color effect to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#kodachrome
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  kodachrome: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.KODACHROME, i);
  },
  /**
   * Applies a technicolor color effect to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#technicolor
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  technicolor: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.TECHNICOLOR, i);
  },
  /**
   * Applies a polaroid color effect to this ColorMatrix.
   *
   * @method Phaser.Display.ColorMatrix#polaroid
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  polaroid: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.POLAROID, i);
  },
  /**
   * Shifts the values of this ColorMatrix into BGR order.
   *
   * @method Phaser.Display.ColorMatrix#shiftToBGR
   * @since 3.50.0
   *
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  shiftToBGR: function(i) {
    return i === void 0 && (i = !1), this.multiply(oe.SHIFT_BGR, i);
  },
  /**
   * Multiplies the two given matrices.
   *
   * @method Phaser.Display.ColorMatrix#multiply
   * @since 3.50.0
   *
   * @param {number[]} a - The 5x4 array to multiply with ColorMatrix._matrix.
   * @param {boolean} [multiply=false] - Multiply the resulting ColorMatrix (`true`), or set it (`false`) ?
   *
   * @return {this} This ColorMatrix instance.
   */
  multiply: function(i, e) {
    e === void 0 && (e = !1), e || this.reset();
    var n = this._matrix, s = JF;
    return s.set(n), n.set([
      //  R
      s[0] * i[0] + s[1] * i[5] + s[2] * i[10] + s[3] * i[15],
      s[0] * i[1] + s[1] * i[6] + s[2] * i[11] + s[3] * i[16],
      s[0] * i[2] + s[1] * i[7] + s[2] * i[12] + s[3] * i[17],
      s[0] * i[3] + s[1] * i[8] + s[2] * i[13] + s[3] * i[18],
      s[0] * i[4] + s[1] * i[9] + s[2] * i[14] + s[3] * i[19] + s[4],
      //  G
      s[5] * i[0] + s[6] * i[5] + s[7] * i[10] + s[8] * i[15],
      s[5] * i[1] + s[6] * i[6] + s[7] * i[11] + s[8] * i[16],
      s[5] * i[2] + s[6] * i[7] + s[7] * i[12] + s[8] * i[17],
      s[5] * i[3] + s[6] * i[8] + s[7] * i[13] + s[8] * i[18],
      s[5] * i[4] + s[6] * i[9] + s[7] * i[14] + s[8] * i[19] + s[9],
      //  B
      s[10] * i[0] + s[11] * i[5] + s[12] * i[10] + s[13] * i[15],
      s[10] * i[1] + s[11] * i[6] + s[12] * i[11] + s[13] * i[16],
      s[10] * i[2] + s[11] * i[7] + s[12] * i[12] + s[13] * i[17],
      s[10] * i[3] + s[11] * i[8] + s[12] * i[13] + s[13] * i[18],
      s[10] * i[4] + s[11] * i[9] + s[12] * i[14] + s[13] * i[19] + s[14],
      //  A
      s[15] * i[0] + s[16] * i[5] + s[17] * i[10] + s[18] * i[15],
      s[15] * i[1] + s[16] * i[6] + s[17] * i[11] + s[18] * i[16],
      s[15] * i[2] + s[16] * i[7] + s[17] * i[12] + s[18] * i[17],
      s[15] * i[3] + s[16] * i[8] + s[17] * i[13] + s[18] * i[18],
      s[15] * i[4] + s[16] * i[9] + s[17] * i[14] + s[18] * i[19] + s[19]
    ]), this._dirty = !0, this;
  }
});
oe.BLACK_WHITE = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0];
oe.NEGATIVE = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
oe.DESATURATE_LUMINANCE = [0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0];
oe.SEPIA = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0];
oe.LSD = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];
oe.BROWN = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
oe.VINTAGE = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
oe.KODACHROME = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
oe.TECHNICOLOR = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
oe.POLAROID = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
oe.SHIFT_BGR = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
var QF = new Gt({
  initialize: function(e, n, s) {
    this._rgb = [0, 0, 0], this.onChangeCallback = xu, this.dirty = !1, this.set(e, n, s);
  },
  /**
   * Sets the red, green and blue values of this RGB object, flags it as being
   * dirty and then invokes the `onChangeCallback`, if set.
   *
   * @method Phaser.Display.RGB#set
   * @since 3.50.0
   *
   * @param {number} [red=0] - The red color value. A number between 0 and 1.
   * @param {number} [green=0] - The green color value. A number between 0 and 1.
   * @param {number} [blue=0] - The blue color value. A number between 0 and 1.
   *
   * @return {this} This RGB instance.
   */
  set: function(i, e, n) {
    return i === void 0 && (i = 0), e === void 0 && (e = 0), n === void 0 && (n = 0), this._rgb = [i, e, n], this.onChange(), this;
  },
  /**
   * Compares the given rgb parameters with those in this object and returns
   * a boolean `true` value if they are equal, otherwise it returns `false`.
   *
   * @method Phaser.Display.RGB#equals
   * @since 3.50.0
   *
   * @param {number} red - The red value to compare with this object.
   * @param {number} green - The green value to compare with this object.
   * @param {number} blue - The blue value to compare with this object.
   *
   * @return {boolean} `true` if the given values match those in this object, otherwise `false`.
   */
  equals: function(i, e, n) {
    var s = this._rgb;
    return s[0] === i && s[1] === e && s[2] === n;
  },
  /**
   * Internal on change handler. Sets this object as being dirty and
   * then invokes the `onChangeCallback`, if set, passing in the
   * new RGB values.
   *
   * @method Phaser.Display.RGB#onChange
   * @since 3.50.0
   */
  onChange: function() {
    this.dirty = !0;
    var i = this._rgb;
    this.onChangeCallback.call(this, i[0], i[1], i[2]);
  },
  /**
   * The red color value. Between 0 and 1.
   *
   * Changing this property will flag this RGB object as being dirty
   * and invoke the `onChangeCallback` , if set.
   *
   * @name Phaser.Display.RGB#r
   * @type {number}
   * @since 3.50.0
   */
  r: {
    get: function() {
      return this._rgb[0];
    },
    set: function(i) {
      this._rgb[0] = i, this.onChange();
    }
  },
  /**
   * The green color value. Between 0 and 1.
   *
   * Changing this property will flag this RGB object as being dirty
   * and invoke the `onChangeCallback` , if set.
   *
   * @name Phaser.Display.RGB#g
   * @type {number}
   * @since 3.50.0
   */
  g: {
    get: function() {
      return this._rgb[1];
    },
    set: function(i) {
      this._rgb[1] = i, this.onChange();
    }
  },
  /**
   * The blue color value. Between 0 and 1.
   *
   * Changing this property will flag this RGB object as being dirty
   * and invoke the `onChangeCallback` , if set.
   *
   * @name Phaser.Display.RGB#b
   * @type {number}
   * @since 3.50.0
   */
  b: {
    get: function() {
      return this._rgb[2];
    },
    set: function(i) {
      this._rgb[2] = i, this.onChange();
    }
  },
  /**
   * Nulls any external references this object contains.
   *
   * @method Phaser.Display.RGB#destroy
   * @since 3.50.0
   */
  destroy: function() {
    this.onChangeCallback = null;
  }
});
/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2013-2025 Phaser Studio Inc.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
const KF = {
  Color: ee,
  ColorMatrix: oe,
  RGB: QF
}, t6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  display: KF,
  geom: JO,
  math: rl,
  tweens: qF,
  utils: SF
}, Symbol.toStringTag, { value: "Module" })), E7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AxisAlignedBounds: Uo,
  Bezier: se,
  Big: OP,
  BigNumber: Kn,
  BoundingRect: gr,
  CubicBezier: Uf,
  Matrix: Hl,
  Matrix2D: Pe,
  Matrix3: a3,
  ObservablePoint: ea,
  OrientedBounds: M3,
  Point: Ue,
  QuadBezier: Ca,
  RBush: M4,
  Spline: qS,
  TinyQueue: ow,
  Transformable: o3,
  Vector2: N,
  animation: oT,
  bernstein: Na,
  bezierCurvatureAt: cS,
  bezierDerivative: pS,
  bezierFirstDerivative: om,
  bezierSecondDerivative: hm,
  bigInt: ze,
  center_to_endpoint: Jg,
  chopBezierAt: ho,
  chopBezierBetween: xS,
  chopCubicBezierAt: ld,
  chopQuadBezierAt: Zl,
  chopQuadBezierAtMaxCurature: gS,
  clipper: h5,
  computeCubicExtremas: Jf,
  computeQuadExtremas: Zf,
  conicBezierAt: aS,
  conicBezierPointAt: oS,
  contains: rz,
  core: hz,
  cubicBezierAt: Pn,
  cubicBezierPointAt: cd,
  cubicBezierWithMatrixAt: uS,
  cubicLength: zS,
  cubicProjectPoint: um,
  curve: DS,
  ellipseArcToCubicBezier: Xl,
  endpoint_to_center: Qg,
  evalCubicBezierTangentAt: MS,
  evalQuadBezierTangentAt: wS,
  findCubicExtrema: Xf,
  findCubicMaxCurvature: TS,
  findQuadExtrema: Hf,
  findQuadMaxCurvature: cm,
  findUnitQuadRoots: ud,
  flattenCubicBezier: jf,
  flattenQuadBezier: Yf,
  getBezierDerivativeControlPoints: yS,
  getBezierPointWithBernstein: rS,
  getBezierPointWithDeCasteljau: hd,
  getRationalBezierPointWithBernstein: hS,
  intersections: $T,
  mapbox: y4,
  mathigon: SP,
  pathBool: gC,
  pathUtil: kE,
  phaser: t6,
  pixi: v4,
  pointOnEllipse: Kg,
  pointOnLineDistance: pl,
  pointOnSegmentDistance: mS,
  points: w3,
  polyClip: Pz,
  polytri: GC,
  quadBezierToCubic: vS,
  quadBezierWithMatrixAt: lS,
  quadraticBezierAt: jn,
  quadraticBezierPointAt: am,
  quadraticLength: ES,
  quadraticProjectPoint: lm,
  quarterArcToCubicBezier: od,
  raiseBezier: fS,
  shapes: m3,
  shapes2: QC,
  tess: w5,
  tweenjs: gT,
  utils: X3
}, Symbol.toStringTag, { value: "Module" })), e6 = "179dev", n6 = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, i6 = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, s6 = 0, r6 = 1, a6 = 2, o6 = 3, h6 = 0, c6 = 1, l6 = 2, u6 = 3, f6 = 0, d6 = 1, p6 = 2, y6 = 0, x6 = 1, g6 = 2, m6 = 3, v6 = 4, w6 = 5, M6 = 100, b6 = 101, _6 = 102, S6 = 103, T6 = 104, E6 = 200, z6 = 201, C6 = 202, A6 = 203, P6 = 204, I6 = 205, R6 = 206, O6 = 207, k6 = 208, L6 = 209, F6 = 210, N6 = 211, B6 = 212, D6 = 213, q6 = 214, $6 = 0, V6 = 1, G6 = 2, U6 = 3, W6 = 4, Y6 = 5, j6 = 6, H6 = 7, X6 = 0, Z6 = 1, J6 = 2, Q6 = 0, K6 = 1, tN = 2, eN = 3, nN = 4, iN = 5, sN = 6, rN = 7, aN = "attached", oN = "detached", d1 = 300, p1 = 301, hN = 302, cN = 303, lN = 304, uN = 306, j0 = 1e3, gs = 1001, H0 = 1002, si = 1003, fN = 1004, dN = 1004, pN = 1005, yN = 1005, La = 1006, xN = 1007, gN = 1007, VM = 1008, mN = 1008, y1 = 1009, GM = 1010, UM = 1011, WM = 1012, YM = 1013, x1 = 1014, g1 = 1015, jM = 1016, HM = 1017, XM = 1018, vN = 1020, ZM = 35902, JM = 1021, QM = 1022, m1 = 1023, X0 = 1026, KM = 1027, tb = 1028, eb = 1029, nb = 1030, ib = 1031, wN = 1032, sb = 1033, rb = 33776, ab = 33777, ob = 33778, hb = 33779, cb = 35840, lb = 35841, ub = 35842, fb = 35843, db = 36196, pb = 37492, yb = 37496, xb = 37808, gb = 37809, mb = 37810, vb = 37811, wb = 37812, Mb = 37813, bb = 37814, _b = 37815, Sb = 37816, Tb = 37817, Eb = 37818, zb = 37819, Cb = 37820, Ab = 37821, Pb = 36492, Ib = 36494, Rb = 36495, Ob = 36283, kb = 36284, Lb = 36285, Fb = 36286, Nb = 2200, Bb = 2201, Db = 2202, dh = 2300, Ul = 2301, hl = 2302, pr = 2400, yr = 2401, ph = 2402, gu = 2500, v1 = 2501, MN = 0, bN = 1, _N = 2, SN = 3200, TN = 3201, EN = 3202, zN = 3203, CN = 0, AN = 1, w1 = "", On = "srgb", Z0 = "srgb-linear", J0 = "linear", cl = "srgb", PN = 0, IN = 7680, RN = 7681, ON = 7682, kN = 7683, LN = 34055, FN = 34056, NN = 5386, BN = 512, DN = 513, qN = 514, $N = 515, VN = 516, GN = 517, UN = 518, WN = 519, YN = 512, jN = 513, HN = 514, XN = 515, ZN = 516, JN = 517, QN = 518, KN = 519, yh = 35044, tB = 35048, eB = 35040, nB = 35045, iB = 35049, sB = 35041, rB = 35046, aB = 35050, oB = 35042, hB = "100", cB = "300 es", mi = 2e3, xh = 2001, lB = {
  COMPUTE: "compute",
  RENDER: "render"
}, uB = {
  PERSPECTIVE: "perspective",
  LINEAR: "linear",
  FLAT: "flat"
}, fB = {
  NORMAL: "normal",
  CENTROID: "centroid",
  SAMPLE: "sample",
  FIRST: "first",
  EITHER: "either"
};
class qb {
  /**
   * Constructs a new animation action.
   *
   * @param {AnimationMixer} mixer - The mixer that is controlled by this action.
   * @param {AnimationClip} clip - The animation clip that holds the actual keyframes.
   * @param {?Object3D} [localRoot=null] - The root object on which this action is performed.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   */
  constructor(e, n, s = null, r = n.blendMode) {
    this._mixer = e, this._clip = n, this._localRoot = s, this.blendMode = r;
    const a = n.tracks, o = a.length, h = new Array(o), c = {
      endingStart: pr,
      endingEnd: pr
    };
    for (let l = 0; l !== o; ++l) {
      const u = a[l].createInterpolant(null);
      h[l] = u, u.settings = c;
    }
    this._interpolantSettings = c, this._interpolants = h, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Bb, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  /**
   * Starts the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  play() {
    return this._mixer._activateAction(this), this;
  }
  /**
   * Stops the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  /**
   * Resets the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  /**
   * Returns `true` if the animation is running.
   *
   * @return {boolean} Whether the animation is running or not.
   */
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  /**
   * Returns `true` when {@link AnimationAction#play} has been called.
   *
   * @return {boolean} Whether the animation is scheduled or not.
   */
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  /**
   * Defines the time when the animation should start.
   *
   * @param {number} time - The start time in seconds.
   * @return {AnimationAction} A reference to this animation action.
   */
  startAt(e) {
    return this._startTime = e, this;
  }
  /**
   * Configures the loop settings for this action.
   *
   * @param {(LoopRepeat|LoopOnce|LoopPingPong)} mode - The loop mode.
   * @param {number} repetitions - The number of repetitions.
   * @return {AnimationAction} A reference to this animation action.
   */
  setLoop(e, n) {
    return this.loop = e, this.repetitions = n, this;
  }
  /**
   * Sets the effective weight of this action.
   *
   * An action has no effect and thus an effective weight of zero when the
   * action is disabled.
   *
   * @param {number} weight - The weight to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  /**
   * Returns the effective weight of this action.
   *
   * @return {number} The effective weight.
   */
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  /**
   * Fades the animation in by increasing its weight gradually from `0` to `1`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  /**
   * Fades the animation out by decreasing its weight gradually from `1` to `0`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  /**
   * Causes this action to fade in and the given action to fade out,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeOutAction - The animation action to fade out.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeFrom(e, n, s = !1) {
    if (e.fadeOut(n), this.fadeIn(n), s === !0) {
      const r = this._clip.duration, a = e._clip.duration, o = a / r, h = r / a;
      e.warp(1, o, n), this.warp(h, 1, n);
    }
    return this;
  }
  /**
   * Causes this action to fade out and the given action to fade in,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeInAction - The animation action to fade in.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeTo(e, n, s = !1) {
    return e.crossFadeFrom(this, n, s);
  }
  /**
   * Stops any fading which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Sets the effective time scale of this action.
   *
   * An action has no effect and thus an effective time scale of zero when the
   * action is paused.
   *
   * @param {number} timeScale - The time scale to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  /**
   * Returns the effective time scale of this action.
   *
   * @return {number} The effective time scale.
   */
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  /**
   * Sets the duration for a single loop of this action.
   *
   * @param {number} duration - The duration to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  /**
   * Synchronizes this action with the passed other action.
   *
   * @param {AnimationAction} action - The action to sync with.
   * @return {AnimationAction} A reference to this animation action.
   */
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  /**
   * Decelerates this animation's speed to `0` within the passed time interval.
   *
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  /**
   * Changes the playback speed, within the passed time interval, by modifying
   * {@link AnimationAction#timeScale} gradually from `startTimeScale` to
   * `endTimeScale`.
   *
   * @param {number} startTimeScale - The start time scale.
   * @param {number} endTimeScale - The end time scale.
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  warp(e, n, s) {
    const r = this._mixer, a = r.time, o = this.timeScale;
    let h = this._timeScaleInterpolant;
    h === null && (h = r._lendControlInterpolant(), this._timeScaleInterpolant = h);
    const c = h.parameterPositions, l = h.sampleValues;
    return c[0] = a, c[1] = a + s, l[0] = e / o, l[1] = n / o, this;
  }
  /**
   * Stops any scheduled warping which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Returns the animation mixer of this animation action.
   *
   * @return {AnimationMixer} The animation mixer.
   */
  getMixer() {
    return this._mixer;
  }
  /**
   * Returns the animation clip of this animation action.
   *
   * @return {AnimationClip} The animation clip.
   */
  getClip() {
    return this._clip;
  }
  /**
   * Returns the root object of this animation action.
   *
   * @return {Object3D} The root object.
   */
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, n, s, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const a = this._startTime;
    if (a !== null) {
      const c = (e - a) * s;
      c < 0 || s === 0 ? n = 0 : (this._startTime = null, n = s * c);
    }
    n *= this._updateTimeScale(e);
    const o = this._updateTime(n), h = this._updateWeight(e);
    if (h > 0) {
      const c = this._interpolants, l = this._propertyBindings;
      switch (this.blendMode) {
        case v1:
          for (let u = 0, f = c.length; u !== f; ++u)
            c[u].evaluate(o), l[u].accumulateAdditive(h);
          break;
        case gu:
        default:
          for (let u = 0, f = c.length; u !== f; ++u)
            c[u].evaluate(o), l[u].accumulate(r, h);
      }
    }
  }
  _updateWeight(e) {
    let n = 0;
    if (this.enabled) {
      n = this.weight;
      const s = this._weightInterpolant;
      if (s !== null) {
        const r = s.evaluate(e)[0];
        n *= r, e > s.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = n, n;
  }
  _updateTimeScale(e) {
    let n = 0;
    if (!this.paused) {
      n = this.timeScale;
      const s = this._timeScaleInterpolant;
      if (s !== null) {
        const r = s.evaluate(e)[0];
        n *= r, e > s.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n);
      }
    }
    return this._effectiveTimeScale = n, n;
  }
  _updateTime(e) {
    const n = this._clip.duration, s = this.loop;
    let r = this.time + e, a = this._loopCount;
    const o = s === Db;
    if (e === 0)
      return a === -1 ? r : o && (a & 1) === 1 ? n - r : r;
    if (s === Nb) {
      a === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      t: {
        if (r >= n)
          r = n;
        else if (r < 0)
          r = 0;
        else {
          this.time = r;
          break t;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (a === -1 && (e >= 0 ? (a = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= n || r < 0) {
        const h = Math.floor(r / n);
        r -= n * h, a += Math.abs(h);
        const c = this.repetitions - a;
        if (c <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? n : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (c === 1) {
            const l = e < 0;
            this._setEndings(l, !l, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = a, this.time = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: h
          });
        }
      } else
        this.time = r;
      if (o && (a & 1) === 1)
        return n - r;
    }
    return r;
  }
  _setEndings(e, n, s) {
    const r = this._interpolantSettings;
    s ? (r.endingStart = yr, r.endingEnd = yr) : (e ? r.endingStart = this.zeroSlopeAtStart ? yr : pr : r.endingStart = ph, n ? r.endingEnd = this.zeroSlopeAtEnd ? yr : pr : r.endingEnd = ph);
  }
  _scheduleFading(e, n, s) {
    const r = this._mixer, a = r.time;
    let o = this._weightInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
    const h = o.parameterPositions, c = o.sampleValues;
    return h[0] = a, c[0] = n, h[1] = a + e, c[1] = s, this;
  }
}
const De = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let og = 1234567;
const wr = Math.PI / 180, Wl = 180 / Math.PI;
function ni() {
  const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0;
  return (De[i & 255] + De[i >> 8 & 255] + De[i >> 16 & 255] + De[i >> 24 & 255] + "-" + De[e & 255] + De[e >> 8 & 255] + "-" + De[e >> 16 & 15 | 64] + De[e >> 24 & 255] + "-" + De[n & 63 | 128] + De[n >> 8 & 255] + "-" + De[n >> 16 & 255] + De[n >> 24 & 255] + De[s & 255] + De[s >> 8 & 255] + De[s >> 16 & 255] + De[s >> 24 & 255]).toLowerCase();
}
function zt(i, e, n) {
  return Math.max(e, Math.min(n, i));
}
function M1(i, e) {
  return (i % e + e) % e;
}
function dB(i, e, n, s, r) {
  return s + (i - e) * (r - s) / (n - e);
}
function pB(i, e, n) {
  return i !== e ? (n - i) / (e - i) : 0;
}
function qo(i, e, n) {
  return (1 - n) * i + n * e;
}
function yB(i, e, n, s) {
  return qo(i, e, 1 - Math.exp(-n * s));
}
function xB(i, e = 1) {
  return e - Math.abs(M1(i, e * 2) - e);
}
function gB(i, e, n) {
  return i <= e ? 0 : i >= n ? 1 : (i = (i - e) / (n - e), i * i * (3 - 2 * i));
}
function mB(i, e, n) {
  return i <= e ? 0 : i >= n ? 1 : (i = (i - e) / (n - e), i * i * i * (i * (i * 6 - 15) + 10));
}
function vB(i, e) {
  return i + Math.floor(Math.random() * (e - i + 1));
}
function wB(i, e) {
  return i + Math.random() * (e - i);
}
function MB(i) {
  return i * (0.5 - Math.random());
}
function bB(i) {
  i !== void 0 && (og = i);
  let e = og += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function _B(i) {
  return i * wr;
}
function SB(i) {
  return i * Wl;
}
function TB(i) {
  return (i & i - 1) === 0 && i !== 0;
}
function EB(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function zB(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function CB(i, e, n, s, r) {
  const a = Math.cos, o = Math.sin, h = a(n / 2), c = o(n / 2), l = a((e + s) / 2), u = o((e + s) / 2), f = a((e - s) / 2), d = o((e - s) / 2), p = a((s - e) / 2), y = o((s - e) / 2);
  switch (r) {
    case "XYX":
      i.set(h * u, c * f, c * d, h * l);
      break;
    case "YZY":
      i.set(c * d, h * u, c * f, h * l);
      break;
    case "ZXZ":
      i.set(c * f, c * d, h * u, h * l);
      break;
    case "XZX":
      i.set(h * u, c * y, c * p, h * l);
      break;
    case "YXY":
      i.set(c * p, h * u, c * y, h * l);
      break;
    case "ZYZ":
      i.set(c * y, c * p, h * u, h * l);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function Ke(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function At(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const AB = {
  DEG2RAD: wr,
  RAD2DEG: Wl,
  /**
   * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID: ni,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp: zt,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo: M1,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear: dB,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp: pB,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp: qo,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp: yB,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong: xB,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep: gB,
  /**
   * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep: mB,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt: vB,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat: wB,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread: MB,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom: bB,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad: _B,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg: SB,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo: TB,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo: EB,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo: zB,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler: CB,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize: At,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize: Ke
};
class fn {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(e = 0, n = 0, s = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = s, this._w = r;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed  in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(e, n, s, r, a, o, h) {
    let c = s[r + 0], l = s[r + 1], u = s[r + 2], f = s[r + 3];
    const d = a[o + 0], p = a[o + 1], y = a[o + 2], x = a[o + 3];
    if (h === 0) {
      e[n + 0] = c, e[n + 1] = l, e[n + 2] = u, e[n + 3] = f;
      return;
    }
    if (h === 1) {
      e[n + 0] = d, e[n + 1] = p, e[n + 2] = y, e[n + 3] = x;
      return;
    }
    if (f !== x || c !== d || l !== p || u !== y) {
      let g = 1 - h;
      const m = c * d + l * p + u * y + f * x, v = m >= 0 ? 1 : -1, w = 1 - m * m;
      if (w > Number.EPSILON) {
        const S = Math.sqrt(w), E = Math.atan2(S, m * v);
        g = Math.sin(g * E) / S, h = Math.sin(h * E) / S;
      }
      const b = h * v;
      if (c = c * g + d * b, l = l * g + p * b, u = u * g + y * b, f = f * g + x * b, g === 1 - h) {
        const S = 1 / Math.sqrt(c * c + l * l + u * u + f * f);
        c *= S, l *= S, u *= S, f *= S;
      }
    }
    e[n] = c, e[n + 1] = l, e[n + 2] = u, e[n + 3] = f;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(e, n, s, r, a, o) {
    const h = s[r], c = s[r + 1], l = s[r + 2], u = s[r + 3], f = a[o], d = a[o + 1], p = a[o + 2], y = a[o + 3];
    return e[n] = h * y + u * f + c * p - l * d, e[n + 1] = c * y + u * d + l * f - h * p, e[n + 2] = l * y + u * p + h * d - c * f, e[n + 3] = u * y - h * f - c * d - l * p, e;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(e, n, s, r) {
    return this._x = e, this._y = n, this._z = s, this._w = r, this._onChangeCallback(), this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(e, n = !0) {
    const s = e._x, r = e._y, a = e._z, o = e._order, h = Math.cos, c = Math.sin, l = h(s / 2), u = h(r / 2), f = h(a / 2), d = c(s / 2), p = c(r / 2), y = c(a / 2);
    switch (o) {
      case "XYZ":
        this._x = d * u * f + l * p * y, this._y = l * p * f - d * u * y, this._z = l * u * y + d * p * f, this._w = l * u * f - d * p * y;
        break;
      case "YXZ":
        this._x = d * u * f + l * p * y, this._y = l * p * f - d * u * y, this._z = l * u * y - d * p * f, this._w = l * u * f + d * p * y;
        break;
      case "ZXY":
        this._x = d * u * f - l * p * y, this._y = l * p * f + d * u * y, this._z = l * u * y + d * p * f, this._w = l * u * f - d * p * y;
        break;
      case "ZYX":
        this._x = d * u * f - l * p * y, this._y = l * p * f + d * u * y, this._z = l * u * y - d * p * f, this._w = l * u * f + d * p * y;
        break;
      case "YZX":
        this._x = d * u * f + l * p * y, this._y = l * p * f + d * u * y, this._z = l * u * y - d * p * f, this._w = l * u * f - d * p * y;
        break;
      case "XZY":
        this._x = d * u * f - l * p * y, this._y = l * p * f - d * u * y, this._z = l * u * y + d * p * f, this._w = l * u * f + d * p * y;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(e, n) {
    const s = n / 2, r = Math.sin(s);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(s), this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(e) {
    const n = e.elements, s = n[0], r = n[4], a = n[8], o = n[1], h = n[5], c = n[9], l = n[2], u = n[6], f = n[10], d = s + h + f;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (u - c) * p, this._y = (a - l) * p, this._z = (o - r) * p;
    } else if (s > h && s > f) {
      const p = 2 * Math.sqrt(1 + s - h - f);
      this._w = (u - c) / p, this._x = 0.25 * p, this._y = (r + o) / p, this._z = (a + l) / p;
    } else if (h > f) {
      const p = 2 * Math.sqrt(1 + h - s - f);
      this._w = (a - l) / p, this._x = (r + o) / p, this._y = 0.25 * p, this._z = (c + u) / p;
    } else {
      const p = 2 * Math.sqrt(1 + f - s - h);
      this._w = (o - r) / p, this._x = (a + l) / p, this._y = (c + u) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(e, n) {
    let s = e.dot(n) + 1;
    return s < 1e-8 ? (s = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = s) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = s)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = s), this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    return 2 * Math.acos(Math.abs(zt(this.dot(e), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(e, n) {
    const s = this.angleTo(e);
    if (s === 0) return this;
    const r = Math.min(1, n / s);
    return this.slerp(e, r), this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(e, n) {
    const s = e._x, r = e._y, a = e._z, o = e._w, h = n._x, c = n._y, l = n._z, u = n._w;
    return this._x = s * u + o * h + r * l - a * c, this._y = r * u + o * c + a * h - s * l, this._z = a * u + o * l + s * c - r * h, this._w = o * u - s * h - r * c - a * l, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const s = this._x, r = this._y, a = this._z, o = this._w;
    let h = o * e._w + s * e._x + r * e._y + a * e._z;
    if (h < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, h = -h) : this.copy(e), h >= 1)
      return this._w = o, this._x = s, this._y = r, this._z = a, this;
    const c = 1 - h * h;
    if (c <= Number.EPSILON) {
      const p = 1 - n;
      return this._w = p * o + n * this._w, this._x = p * s + n * this._x, this._y = p * r + n * this._y, this._z = p * a + n * this._z, this.normalize(), this;
    }
    const l = Math.sqrt(c), u = Math.atan2(l, h), f = Math.sin((1 - n) * u) / l, d = Math.sin(n * u) / l;
    return this._w = o * f + this._w * d, this._x = s * f + this._x * d, this._y = r * f + this._y * d, this._z = a * f + this._z * d, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(e, n, s) {
    return this.copy(e).slerp(n, s);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), s = Math.random(), r = Math.sqrt(1 - s), a = Math.sqrt(s);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      a * Math.sin(n),
      a * Math.cos(n)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
function xr(i, e) {
  return !i || i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
}
function $b(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function Vb(i) {
  function e(r, a) {
    return i[r] - i[a];
  }
  const n = i.length, s = new Array(n);
  for (let r = 0; r !== n; ++r) s[r] = r;
  return s.sort(e), s;
}
function Q0(i, e, n) {
  const s = i.length, r = new i.constructor(s);
  for (let a = 0, o = 0; o !== s; ++a) {
    const h = n[a] * e;
    for (let c = 0; c !== e; ++c)
      r[o++] = i[h + c];
  }
  return r;
}
function b1(i, e, n, s) {
  let r = 1, a = i[0];
  for (; a !== void 0 && a[s] === void 0; )
    a = i[r++];
  if (a === void 0) return;
  let o = a[s];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = a[s], o !== void 0 && (e.push(a.time), n.push(...o)), a = i[r++];
      while (a !== void 0);
    else if (o.toArray !== void 0)
      do
        o = a[s], o !== void 0 && (e.push(a.time), o.toArray(n, n.length)), a = i[r++];
      while (a !== void 0);
    else
      do
        o = a[s], o !== void 0 && (e.push(a.time), n.push(o)), a = i[r++];
      while (a !== void 0);
}
function PB(i, e, n, s, r = 30) {
  const a = i.clone();
  a.name = e;
  const o = [];
  for (let c = 0; c < a.tracks.length; ++c) {
    const l = a.tracks[c], u = l.getValueSize(), f = [], d = [];
    for (let p = 0; p < l.times.length; ++p) {
      const y = l.times[p] * r;
      if (!(y < n || y >= s)) {
        f.push(l.times[p]);
        for (let x = 0; x < u; ++x)
          d.push(l.values[p * u + x]);
      }
    }
    f.length !== 0 && (l.times = xr(f, l.times.constructor), l.values = xr(d, l.values.constructor), o.push(l));
  }
  a.tracks = o;
  let h = 1 / 0;
  for (let c = 0; c < a.tracks.length; ++c)
    h > a.tracks[c].times[0] && (h = a.tracks[c].times[0]);
  for (let c = 0; c < a.tracks.length; ++c)
    a.tracks[c].shift(-1 * h);
  return a.resetDuration(), a;
}
function IB(i, e = 0, n = i, s = 30) {
  s <= 0 && (s = 30);
  const r = n.tracks.length, a = e / s;
  for (let o = 0; o < r; ++o) {
    const h = n.tracks[o], c = h.ValueTypeName;
    if (c === "bool" || c === "string") continue;
    const l = i.tracks.find(function(m) {
      return m.name === h.name && m.ValueTypeName === c;
    });
    if (l === void 0) continue;
    let u = 0;
    const f = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = f / 3);
    let d = 0;
    const p = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = p / 3);
    const y = h.times.length - 1;
    let x;
    if (a <= h.times[0]) {
      const m = u, v = f - u;
      x = h.values.slice(m, v);
    } else if (a >= h.times[y]) {
      const m = y * f + u, v = m + f - u;
      x = h.values.slice(m, v);
    } else {
      const m = h.createInterpolant(), v = u, w = f - u;
      m.evaluate(a), x = m.resultBuffer.slice(v, w);
    }
    c === "quaternion" && new fn().fromArray(x).normalize().conjugate().toArray(x);
    const g = l.times.length;
    for (let m = 0; m < g; ++m) {
      const v = m * p + d;
      if (c === "quaternion")
        fn.multiplyQuaternionsFlat(
          l.values,
          v,
          x,
          0,
          l.values,
          v
        );
      else {
        const w = p - d * 2;
        for (let b = 0; b < w; ++b)
          l.values[v + b] -= x[b];
      }
    }
  }
  return i.blendMode = v1, i;
}
class RB {
  /**
   * Converts an array to a specific type
   *
   * @static
   * @param {TypedArray|Array} array - The array to convert.
   * @param {TypedArray.constructor} type - The constructor of a type array.
   * @return {TypedArray} The converted array
   */
  static convertArray(e, n) {
    return xr(e, n);
  }
  /**
   * Returns `true` if the given object is a typed array.
   *
   * @static
   * @param {any} object - The object to check.
   * @return {boolean} Whether the given object is a typed array.
   */
  static isTypedArray(e) {
    return $b(e);
  }
  /**
   * Returns an array by which times and values can be sorted.
   *
   * @static
   * @param {Array<number>} times - The keyframe time values.
   * @return {Array<number>} The array.
   */
  static getKeyframeOrder(e) {
    return Vb(e);
  }
  /**
   * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
   *
   * @static
   * @param {Array<number>} values - The values to sort.
   * @param {number} stride - The stride.
   * @param {Array<number>} order - The sort order.
   * @return {Array<number>} The sorted values.
   */
  static sortedArray(e, n, s) {
    return Q0(e, n, s);
  }
  /**
   * Used for parsing AOS keyframe formats.
   *
   * @static
   * @param {Array<number>} jsonKeys - A list of JSON keyframes.
   * @param {Array<number>} times - This array will be filled with keyframe times by this method.
   * @param {Array<number>} values - This array will be filled with keyframe values by this method.
   * @param {string} valuePropertyName - The name of the property to use.
   */
  static flattenJSON(e, n, s, r) {
    b1(e, n, s, r);
  }
  /**
   * Creates a new clip, containing only the segment of the original clip between the given frames.
   *
   * @static
   * @param {AnimationClip} sourceClip - The values to sort.
   * @param {string} name - The name of the clip.
   * @param {number} startFrame - The start frame.
   * @param {number} endFrame - The end frame.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The new sub clip.
   */
  static subclip(e, n, s, r, a = 30) {
    return PB(e, n, s, r, a);
  }
  /**
   * Converts the keyframes of the given animation clip to an additive format.
   *
   * @static
   * @param {AnimationClip} targetClip - The clip to make additive.
   * @param {number} [referenceFrame=0] - The reference frame.
   * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The updated clip which is now additive.
   */
  static makeClipAdditive(e, n = 0, s = e, r = 30) {
    return IB(e, n, s, r);
  }
}
class kh {
  /**
   * Constructs a new interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, s, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new n.constructor(s), this.sampleValues = n, this.valueSize = s, this.settings = null, this.DefaultSettings_ = {};
  }
  /**
   * Evaluate the interpolant at position `t`.
   *
   * @param {number} t - The interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  evaluate(e) {
    const n = this.parameterPositions;
    let s = this._cachedIndex, r = n[s], a = n[s - 1];
    t: {
      e: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let h = s + 2; ; ) {
              if (r === void 0) {
                if (e < a) break i;
                return s = n.length, this._cachedIndex = s, this.copySampleValue_(s - 1);
              }
              if (s === h) break;
              if (a = r, r = n[++s], e < r)
                break e;
            }
            o = n.length;
            break n;
          }
          if (!(e >= a)) {
            const h = n[1];
            e < h && (s = 2, a = h);
            for (let c = s - 2; ; ) {
              if (a === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (s === c) break;
              if (r = a, a = n[--s - 1], e >= a)
                break e;
            }
            o = s, s = 0;
            break n;
          }
          break t;
        }
        for (; s < o; ) {
          const h = s + o >>> 1;
          e < n[h] ? o = h : s = h + 1;
        }
        if (r = n[s], a = n[s - 1], a === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return s = n.length, this._cachedIndex = s, this.copySampleValue_(s - 1);
      }
      this._cachedIndex = s, this.intervalChanged_(s, a, r);
    }
    return this.interpolate_(s, a, e, r);
  }
  /**
   * Returns the interpolation settings.
   *
   * @return {Object} The interpolation settings.
   */
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @param {number} index - An index into the sample value buffer.
   * @return {TypedArray} The result buffer.
   */
  copySampleValue_(e) {
    const n = this.resultBuffer, s = this.sampleValues, r = this.valueSize, a = e * r;
    for (let o = 0; o !== r; ++o)
      n[o] = s[a + o];
    return n;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @abstract
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   * @param {number} t1 - The next interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  interpolate_() {
    throw new Error("call to abstract method");
  }
  /**
   * Optional method that is executed when the interval has changed.
   *
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   */
  intervalChanged_() {
  }
}
class Gb extends kh {
  /**
   * Constructs a new cubic interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: pr,
      endingEnd: pr
    };
  }
  intervalChanged_(e, n, s) {
    const r = this.parameterPositions;
    let a = e - 2, o = e + 1, h = r[a], c = r[o];
    if (h === void 0)
      switch (this.getSettings_().endingStart) {
        case yr:
          a = e, h = 2 * n - s;
          break;
        case ph:
          a = r.length - 2, h = n + r[a] - r[a + 1];
          break;
        default:
          a = e, h = s;
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case yr:
          o = e, c = 2 * s - n;
          break;
        case ph:
          o = 1, c = s + r[1] - r[0];
          break;
        default:
          o = e - 1, c = n;
      }
    const l = (s - n) * 0.5, u = this.valueSize;
    this._weightPrev = l / (n - h), this._weightNext = l / (c - s), this._offsetPrev = a * u, this._offsetNext = o * u;
  }
  interpolate_(e, n, s, r) {
    const a = this.resultBuffer, o = this.sampleValues, h = this.valueSize, c = e * h, l = c - h, u = this._offsetPrev, f = this._offsetNext, d = this._weightPrev, p = this._weightNext, y = (s - n) / (r - n), x = y * y, g = x * y, m = -d * g + 2 * d * x - d * y, v = (1 + d) * g + (-1.5 - 2 * d) * x + (-0.5 + d) * y + 1, w = (-1 - p) * g + (1.5 + p) * x + 0.5 * y, b = p * g - p * x;
    for (let S = 0; S !== h; ++S)
      a[S] = m * o[u + S] + v * o[l + S] + w * o[c + S] + b * o[f + S];
    return a;
  }
}
class _1 extends kh {
  /**
   * Constructs a new linear interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r);
  }
  interpolate_(e, n, s, r) {
    const a = this.resultBuffer, o = this.sampleValues, h = this.valueSize, c = e * h, l = c - h, u = (s - n) / (r - n), f = 1 - u;
    for (let d = 0; d !== h; ++d)
      a[d] = o[l + d] * f + o[c + d] * u;
    return a;
  }
}
class Ub extends kh {
  /**
   * Constructs a new discrete interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Dn {
  /**
   * Constructs a new keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, s, r) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (n === void 0 || n.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = xr(n, this.TimeBufferType), this.values = xr(s, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  /**
   * Converts the keyframe track to JSON.
   *
   * @static
   * @param {KeyframeTrack} track - The keyframe track to serialize.
   * @return {Object} The serialized keyframe track as JSON.
   */
  static toJSON(e) {
    const n = e.constructor;
    let s;
    if (n.toJSON !== this.toJSON)
      s = n.toJSON(e);
    else {
      s = {
        name: e.name,
        times: xr(e.times, Array),
        values: xr(e.values, Array)
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (s.interpolation = r);
    }
    return s.type = e.ValueTypeName, s;
  }
  /**
   * Factory method for creating a new discrete interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {DiscreteInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodDiscrete(e) {
    return new Ub(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new linear interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {LinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new _1(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new smooth interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {CubicInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodSmooth(e) {
    return new Gb(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Defines the interpolation factor method for this keyframe track.
   *
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  setInterpolation(e) {
    let n;
    switch (e) {
      case dh:
        n = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ul:
        n = this.InterpolantFactoryMethodLinear;
        break;
      case hl:
        n = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (n === void 0) {
      const s = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(s);
      return console.warn("THREE.KeyframeTrack:", s), this;
    }
    return this.createInterpolant = n, this;
  }
  /**
   * Returns the current interpolation type.
   *
   * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
   */
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return dh;
      case this.InterpolantFactoryMethodLinear:
        return Ul;
      case this.InterpolantFactoryMethodSmooth:
        return hl;
    }
  }
  /**
   * Returns the value size.
   *
   * @return {number} The value size.
   */
  getValueSize() {
    return this.values.length / this.times.length;
  }
  /**
   * Moves all keyframes either forward or backward in time.
   *
   * @param {number} timeOffset - The offset to move the time values.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  shift(e) {
    if (e !== 0) {
      const n = this.times;
      for (let s = 0, r = n.length; s !== r; ++s)
        n[s] += e;
    }
    return this;
  }
  /**
   * Scale all keyframe times by a factor (useful for frame - seconds conversions).
   *
   * @param {number} timeScale - The time scale.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  scale(e) {
    if (e !== 1) {
      const n = this.times;
      for (let s = 0, r = n.length; s !== r; ++s)
        n[s] *= e;
    }
    return this;
  }
  /**
   * Removes keyframes before and after animation without changing any values within the defined time range.
   *
   * Note: The method does not shift around keys to the start of the track time, because for interpolated
   * keys this will change their values
   *
   * @param {number} startTime - The start time.
   * @param {number} endTime - The end time.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  trim(e, n) {
    const s = this.times, r = s.length;
    let a = 0, o = r - 1;
    for (; a !== r && s[a] < e; )
      ++a;
    for (; o !== -1 && s[o] > n; )
      --o;
    if (++o, a !== 0 || o !== r) {
      a >= o && (o = Math.max(o, 1), a = o - 1);
      const h = this.getValueSize();
      this.times = s.slice(a, o), this.values = this.values.slice(a * h, o * h);
    }
    return this;
  }
  /**
   * Performs minimal validation on the keyframe track. Returns `true` if the values
   * are valid.
   *
   * @return {boolean} Whether the keyframes are valid or not.
   */
  validate() {
    let e = !0;
    const n = this.getValueSize();
    n - Math.floor(n) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const s = this.times, r = this.values, a = s.length;
    a === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let h = 0; h !== a; h++) {
      const c = s[h];
      if (typeof c == "number" && isNaN(c)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, h, c), e = !1;
        break;
      }
      if (o !== null && o > c) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, h, c, o), e = !1;
        break;
      }
      o = c;
    }
    if (r !== void 0 && $b(r))
      for (let h = 0, c = r.length; h !== c; ++h) {
        const l = r[h];
        if (isNaN(l)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, h, l), e = !1;
          break;
        }
      }
    return e;
  }
  /**
   * Optimizes this keyframe track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    const e = this.times.slice(), n = this.values.slice(), s = this.getValueSize(), r = this.getInterpolation() === hl, a = e.length - 1;
    let o = 1;
    for (let h = 1; h < a; ++h) {
      let c = !1;
      const l = e[h], u = e[h + 1];
      if (l !== u && (h !== 1 || l !== e[0]))
        if (r)
          c = !0;
        else {
          const f = h * s, d = f - s, p = f + s;
          for (let y = 0; y !== s; ++y) {
            const x = n[f + y];
            if (x !== n[d + y] || x !== n[p + y]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (h !== o) {
          e[o] = e[h];
          const f = h * s, d = o * s;
          for (let p = 0; p !== s; ++p)
            n[d + p] = n[f + p];
        }
        ++o;
      }
    }
    if (a > 0) {
      e[o] = e[a];
      for (let h = a * s, c = o * s, l = 0; l !== s; ++l)
        n[c + l] = n[h + l];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = n.slice(0, o * s)) : (this.times = e, this.values = n), this;
  }
  /**
   * Returns a new keyframe track with copied values from this instance.
   *
   * @return {KeyframeTrack} A clone of this instance.
   */
  clone() {
    const e = this.times.slice(), n = this.values.slice(), s = this.constructor, r = new s(this.name, e, n);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
Dn.prototype.ValueTypeName = "";
Dn.prototype.TimeBufferType = Float32Array;
Dn.prototype.ValueBufferType = Float32Array;
Dn.prototype.DefaultInterpolation = Ul;
class Rr extends Dn {
  /**
   * Constructs a new boolean keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   */
  constructor(e, n, s) {
    super(e, n, s);
  }
}
Rr.prototype.ValueTypeName = "bool";
Rr.prototype.ValueBufferType = Array;
Rr.prototype.DefaultInterpolation = dh;
Rr.prototype.InterpolantFactoryMethodLinear = void 0;
Rr.prototype.InterpolantFactoryMethodSmooth = void 0;
class S1 extends Dn {
  /**
   * Constructs a new color keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r);
  }
}
S1.prototype.ValueTypeName = "color";
class gh extends Dn {
  /**
   * Constructs a new number keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r);
  }
}
gh.prototype.ValueTypeName = "number";
class Wb extends kh {
  /**
   * Constructs a new SLERP interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r);
  }
  interpolate_(e, n, s, r) {
    const a = this.resultBuffer, o = this.sampleValues, h = this.valueSize, c = (s - n) / (r - n);
    let l = e * h;
    for (let u = l + h; l !== u; l += 4)
      fn.slerpFlat(a, 0, o, l - h, o, l, c);
    return a;
  }
}
class Lh extends Dn {
  /**
   * Constructs a new Quaternion keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r);
  }
  /**
   * Overwritten so the method returns Quaternion based interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {QuaternionLinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new Wb(this.times, this.values, this.getValueSize(), e);
  }
}
Lh.prototype.ValueTypeName = "quaternion";
Lh.prototype.InterpolantFactoryMethodSmooth = void 0;
class Or extends Dn {
  /**
   * Constructs a new string keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   */
  constructor(e, n, s) {
    super(e, n, s);
  }
}
Or.prototype.ValueTypeName = "string";
Or.prototype.ValueBufferType = Array;
Or.prototype.DefaultInterpolation = dh;
Or.prototype.InterpolantFactoryMethodLinear = void 0;
Or.prototype.InterpolantFactoryMethodSmooth = void 0;
class mh extends Dn {
  /**
   * Constructs a new vector keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, n, s, r) {
    super(e, n, s, r);
  }
}
mh.prototype.ValueTypeName = "vector";
class K0 {
  /**
   * Constructs a new animation clip.
   *
   * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
   * use the static interface of this class for creating clips. In most cases though, animation clips
   * will automatically be created by loaders when importing animated 3D assets.
   *
   * @param {string} [name=''] - The clip's name.
   * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
   * the duration will be calculated from the passed keyframes.
   * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
   * is blended/combined when two or more animations are simultaneously played.
   */
  constructor(e = "", n = -1, s = [], r = gu) {
    this.name = e, this.tracks = s, this.duration = n, this.blendMode = r, this.uuid = ni(), this.duration < 0 && this.resetDuration();
  }
  /**
   * Factory method for creating an animation clip from the given JSON.
   *
   * @static
   * @param {Object} json - The serialized animation clip.
   * @return {AnimationClip} The new animation clip.
   */
  static parse(e) {
    const n = [], s = e.tracks, r = 1 / (e.fps || 1);
    for (let o = 0, h = s.length; o !== h; ++o)
      n.push(kB(s[o]).scale(r));
    const a = new this(e.name, e.duration, n, e.blendMode);
    return a.uuid = e.uuid, a;
  }
  /**
   * Serializes the given animation clip into JSON.
   *
   * @static
   * @param {AnimationClip} clip - The animation clip to serialize.
   * @return {Object} The JSON object.
   */
  static toJSON(e) {
    const n = [], s = e.tracks, r = {
      name: e.name,
      duration: e.duration,
      tracks: n,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let a = 0, o = s.length; a !== o; ++a)
      n.push(Dn.toJSON(s[a]));
    return r;
  }
  /**
   * Returns a new animation clip from the passed morph targets array of a
   * geometry, taking a name and the number of frames per second.
   *
   * Note: The fps parameter is required, but the animation speed can be
   * overridden via {@link AnimationAction#setDuration}.
   *
   * @static
   * @param {string} name - The name of the animation clip.
   * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {AnimationClip} The new animation clip.
   */
  static CreateFromMorphTargetSequence(e, n, s, r) {
    const a = n.length, o = [];
    for (let h = 0; h < a; h++) {
      let c = [], l = [];
      c.push(
        (h + a - 1) % a,
        h,
        (h + 1) % a
      ), l.push(0, 1, 0);
      const u = Vb(c);
      c = Q0(c, 1, u), l = Q0(l, 1, u), !r && c[0] === 0 && (c.push(a), l.push(l[0])), o.push(
        new gh(
          ".morphTargetInfluences[" + n[h].name + "]",
          c,
          l
        ).scale(1 / s)
      );
    }
    return new this(e, -1, o);
  }
  /**
   * Searches for an animation clip by name, taking as its first parameter
   * either an array of clips, or a mesh or geometry that contains an
   * array named "animations" property.
   *
   * @static
   * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
   * @param {string} name - The name to search for.
   * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
   */
  static findByName(e, n) {
    let s = e;
    if (!Array.isArray(e)) {
      const r = e;
      s = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < s.length; r++)
      if (s[r].name === n)
        return s[r];
    return null;
  }
  /**
   * Returns an array of new AnimationClips created from the morph target
   * sequences of a geometry, trying to sort morph target names into
   * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
   *
   * See {@link MD2Loader#parse} as an example for how the method should be used.
   *
   * @static
   * @param {Array<Object>} morphTargets - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {Array<AnimationClip>} An array of new animation clips.
   */
  static CreateClipsFromMorphTargetSequences(e, n, s) {
    const r = {}, a = /^([\w-]*?)([\d]+)$/;
    for (let h = 0, c = e.length; h < c; h++) {
      const l = e[h], u = l.name.match(a);
      if (u && u.length > 1) {
        const f = u[1];
        let d = r[f];
        d || (r[f] = d = []), d.push(l);
      }
    }
    const o = [];
    for (const h in r)
      o.push(this.CreateFromMorphTargetSequence(h, r[h], n, s));
    return o;
  }
  /**
   * Parses the `animation.hierarchy` format and returns a new animation clip.
   *
   * @static
   * @deprecated since r175.
   * @param {Object} animation - A serialized animation clip as JSON.
   * @param {Array<Bones>} bones - An array of bones.
   * @return {?AnimationClip} The new animation clip.
   */
  static parseAnimation(e, n) {
    if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const s = function(f, d, p, y, x) {
      if (p.length !== 0) {
        const g = [], m = [];
        b1(p, g, m, y), g.length !== 0 && x.push(new f(d, g, m));
      }
    }, r = [], a = e.name || "default", o = e.fps || 30, h = e.blendMode;
    let c = e.length || -1;
    const l = e.hierarchy || [];
    for (let f = 0; f < l.length; f++) {
      const d = l[f].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const p = {};
          let y;
          for (y = 0; y < d.length; y++)
            if (d[y].morphTargets)
              for (let x = 0; x < d[y].morphTargets.length; x++)
                p[d[y].morphTargets[x]] = -1;
          for (const x in p) {
            const g = [], m = [];
            for (let v = 0; v !== d[y].morphTargets.length; ++v) {
              const w = d[y];
              g.push(w.time), m.push(w.morphTarget === x ? 1 : 0);
            }
            r.push(new gh(".morphTargetInfluence[" + x + "]", g, m));
          }
          c = p.length * o;
        } else {
          const p = ".bones[" + n[f].name + "]";
          s(
            mh,
            p + ".position",
            d,
            "pos",
            r
          ), s(
            Lh,
            p + ".quaternion",
            d,
            "rot",
            r
          ), s(
            mh,
            p + ".scale",
            d,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new this(a, c, r, h);
  }
  /**
   * Sets the duration of this clip to the duration of its longest keyframe track.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  resetDuration() {
    const e = this.tracks;
    let n = 0;
    for (let s = 0, r = e.length; s !== r; ++s) {
      const a = this.tracks[s];
      n = Math.max(n, a.times[a.times.length - 1]);
    }
    return this.duration = n, this;
  }
  /**
   * Trims all tracks to the clip's duration.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  /**
   * Performs minimal validation on each track in the clip. Returns `true` if all
   * tracks are valid.
   *
   * @return {boolean} Whether the clip's keyframes are valid or not.
   */
  validate() {
    let e = !0;
    for (let n = 0; n < this.tracks.length; n++)
      e = e && this.tracks[n].validate();
    return e;
  }
  /**
   * Optimizes each track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  /**
   * Returns a new animation clip with copied values from this instance.
   *
   * @return {AnimationClip} A clone of this instance.
   */
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++)
      e.push(this.tracks[n].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  /**
   * Serializes this animation clip into JSON.
   *
   * @return {Object} The JSON object.
   */
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function OB(i) {
  switch (i.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return gh;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return mh;
    case "color":
      return S1;
    case "quaternion":
      return Lh;
    case "bool":
    case "boolean":
      return Rr;
    case "string":
      return Or;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function kB(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = OB(i.type);
  if (i.times === void 0) {
    const n = [], s = [];
    b1(i.keys, n, s, "value"), i.times = n, i.values = s;
  }
  return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
class Es {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const s = this._listeners;
    s[e] === void 0 && (s[e] = []), s[e].indexOf(n) === -1 && s[e].push(n);
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(e, n) {
    const s = this._listeners;
    return s === void 0 ? !1 : s[e] !== void 0 && s[e].indexOf(n) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(e, n) {
    const s = this._listeners;
    if (s === void 0) return;
    const r = s[e];
    if (r !== void 0) {
      const a = r.indexOf(n);
      a !== -1 && r.splice(a, 1);
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(e) {
    const n = this._listeners;
    if (n === void 0) return;
    const s = n[e.type];
    if (s !== void 0) {
      e.target = this;
      const r = s.slice(0);
      for (let a = 0, o = r.length; a < o; a++)
        r[a].call(this, e);
      e.target = null;
    }
  }
}
const T1 = "\\[\\]\\.:\\/", LB = new RegExp("[" + T1 + "]", "g"), E1 = "[^" + T1 + "]", FB = "[^" + T1.replace("\\.", "") + "]", NB = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", E1), BB = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", FB), DB = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", E1), qB = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", E1), $B = new RegExp(
  "^" + NB + BB + DB + qB + "$"
), VB = ["material", "materials", "bones", "map"];
class GB {
  constructor(e, n, s) {
    const r = s || Dt.parseTrackName(n);
    this._targetGroup = e, this._bindings = e.subscribe_(n, r);
  }
  getValue(e, n) {
    this.bind();
    const s = this._targetGroup.nCachedObjects_, r = this._bindings[s];
    r !== void 0 && r.getValue(e, n);
  }
  setValue(e, n) {
    const s = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, a = s.length; r !== a; ++r)
      s[r].setValue(e, n);
  }
  bind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, s = e.length; n !== s; ++n)
      e[n].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, s = e.length; n !== s; ++n)
      e[n].unbind();
  }
}
class Dt {
  /**
   * Constructs a new property binding.
   *
   * @param {Object} rootNode - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   */
  constructor(e, n, s) {
    this.path = n, this.parsedPath = s || Dt.parseTrackName(n), this.node = Dt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  /**
   * Factory method for creating a property binding from the given parameters.
   *
   * @static
   * @param {Object} root - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   * @return {PropertyBinding|Composite} The created property binding or composite.
   */
  static create(e, n, s) {
    return e && e.isAnimationObjectGroup ? new Dt.Composite(e, n, s) : new Dt(e, n, s);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name - Node name to be sanitized.
   * @return {string} The sanitized node name.
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(LB, "");
  }
  /**
   * Parses the given track name (an object path to an animated property) and
   * returns an object with information about the path. Matches strings in the following forms:
   *
   * - nodeName.property
   * - nodeName.property[accessor]
   * - nodeName.material.property[accessor]
   * - uuid.property[accessor]
   * - uuid.objectName[objectIndex].propertyName[propertyIndex]
   * - parentName/nodeName.property
   * - parentName/parentName/nodeName.property[index]
   * - .bone[Armature.DEF_cog].position
   * - scene:helium_balloon_model:helium_balloon_model.position
   *
   * @static
   * @param {string} trackName - The track name to parse.
   * @return {Object} The parsed track name as an object.
   */
  static parseTrackName(e) {
    const n = $B.exec(e);
    if (n === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const s = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: n[2],
      objectName: n[3],
      objectIndex: n[4],
      propertyName: n[5],
      // required
      propertyIndex: n[6]
    }, r = s.nodeName && s.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const a = s.nodeName.substring(r + 1);
      VB.indexOf(a) !== -1 && (s.nodeName = s.nodeName.substring(0, r), s.objectName = a);
    }
    if (s.propertyName === null || s.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return s;
  }
  /**
   * Searches for a node in the hierarchy of the given root object by the given
   * node name.
   *
   * @static
   * @param {Object} root - The root object.
   * @param {string|number} nodeName - The name of the node.
   * @return {?Object} The found node. Returns `null` if no object was found.
   */
  static findNode(e, n) {
    if (n === void 0 || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid)
      return e;
    if (e.skeleton) {
      const s = e.skeleton.getBoneByName(n);
      if (s !== void 0)
        return s;
    }
    if (e.children) {
      const s = function(a) {
        for (let o = 0; o < a.length; o++) {
          const h = a[o];
          if (h.name === n || h.uuid === n)
            return h;
          const c = s(h.children);
          if (c) return c;
        }
        return null;
      }, r = s(e.children);
      if (r)
        return r;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, n) {
    e[n] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, n) {
    const s = this.resolvedProperty;
    for (let r = 0, a = s.length; r !== a; ++r)
      e[n++] = s[r];
  }
  _getValue_arrayElement(e, n) {
    e[n] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, n) {
    this.resolvedProperty.toArray(e, n);
  }
  // Direct
  _setValue_direct(e, n) {
    this.targetObject[this.propertyName] = e[n];
  }
  _setValue_direct_setNeedsUpdate(e, n) {
    this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
    this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, n) {
    const s = this.resolvedProperty;
    for (let r = 0, a = s.length; r !== a; ++r)
      s[r] = e[n++];
  }
  _setValue_array_setNeedsUpdate(e, n) {
    const s = this.resolvedProperty;
    for (let r = 0, a = s.length; r !== a; ++r)
      s[r] = e[n++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
    const s = this.resolvedProperty;
    for (let r = 0, a = s.length; r !== a; ++r)
      s[r] = e[n++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n];
  }
  _setValue_arrayElement_setNeedsUpdate(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, n) {
    this.resolvedProperty.fromArray(e, n);
  }
  _setValue_fromArray_setNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, n) {
    this.bind(), this.getValue(e, n);
  }
  _setValue_unbound(e, n) {
    this.bind(), this.setValue(e, n);
  }
  /**
   * Creates a getter / setter pair for the property tracked by this binding.
   */
  bind() {
    let e = this.node;
    const n = this.parsedPath, s = n.objectName, r = n.propertyName;
    let a = n.propertyIndex;
    if (e || (e = Dt.findNode(this.rootNode, n.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (s) {
      let l = n.objectIndex;
      switch (s) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === l) {
              l = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[s] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[s];
      }
      if (l !== void 0) {
        if (e[l] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[l];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const l = n.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", e);
      return;
    }
    let h = this.Versioning.None;
    this.targetObject = e, e.isMaterial === !0 ? h = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (h = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (a !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[a] !== void 0 && (a = e.morphTargetDictionary[a]);
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = a;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][h];
  }
  /**
   * Unbinds the property.
   */
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Dt.Composite = GB;
Dt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Dt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Dt.prototype.GetterByBindingType = [
  Dt.prototype._getValue_direct,
  Dt.prototype._getValue_array,
  Dt.prototype._getValue_arrayElement,
  Dt.prototype._getValue_toArray
];
Dt.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Dt.prototype._setValue_direct,
    Dt.prototype._setValue_direct_setNeedsUpdate,
    Dt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Dt.prototype._setValue_array,
    Dt.prototype._setValue_array_setNeedsUpdate,
    Dt.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Dt.prototype._setValue_arrayElement,
    Dt.prototype._setValue_arrayElement_setNeedsUpdate,
    Dt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Dt.prototype._setValue_fromArray,
    Dt.prototype._setValue_fromArray_setNeedsUpdate,
    Dt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class Yb {
  /**
   * Constructs a new property mixer.
   *
   * @param {PropertyBinding} binding - The property binding.
   * @param {string} typeName - The keyframe track type name.
   * @param {number} valueSize - The keyframe track value size.
   */
  constructor(e, n, s) {
    this.binding = e, this.valueSize = s;
    let r, a, o;
    switch (n) {
      case "quaternion":
        r = this._slerp, a = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(s * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, a = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(s * 5);
        break;
      default:
        r = this._lerp, a = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(s * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = a, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  /**
   * Accumulates data in the `incoming` region into `accu<i>`.
   *
   * @param {number} accuIndex - The accumulation index.
   * @param {number} weight - The weight.
   */
  accumulate(e, n) {
    const s = this.buffer, r = this.valueSize, a = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let h = 0; h !== r; ++h)
        s[a + h] = s[h];
      o = n;
    } else {
      o += n;
      const h = n / o;
      this._mixBufferRegion(s, a, 0, h, r);
    }
    this.cumulativeWeight = o;
  }
  /**
   * Accumulates data in the `incoming` region into `add`.
   *
   * @param {number} weight - The weight.
   */
  accumulateAdditive(e) {
    const n = this.buffer, s = this.valueSize, r = s * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(n, r, 0, e, s), this.cumulativeWeightAdditive += e;
  }
  /**
   * Applies the state of `accu<i>` to the binding when accus differ.
   *
   * @param {number} accuIndex - The accumulation index.
   */
  apply(e) {
    const n = this.valueSize, s = this.buffer, r = e * n + n, a = this.cumulativeWeight, o = this.cumulativeWeightAdditive, h = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, a < 1) {
      const c = n * this._origIndex;
      this._mixBufferRegion(
        s,
        r,
        c,
        1 - a,
        n
      );
    }
    o > 0 && this._mixBufferRegionAdditive(s, r, this._addIndex * n, 1, n);
    for (let c = n, l = n + n; c !== l; ++c)
      if (s[c] !== s[c + n]) {
        h.setValue(s, r);
        break;
      }
  }
  /**
   * Remembers the state of the bound property and copy it to both accus.
   */
  saveOriginalState() {
    const e = this.binding, n = this.buffer, s = this.valueSize, r = s * this._origIndex;
    e.getValue(n, r);
    for (let a = s, o = r; a !== o; ++a)
      n[a] = n[r + a % s];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  /**
   * Applies the state previously taken via {@link PropertyMixer#saveOriginalState} to the binding.
   */
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  // internals
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, n = e + this.valueSize;
    for (let s = e; s < n; s++)
      this.buffer[s] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, n = this._addIndex * this.valueSize;
    for (let s = 0; s < this.valueSize; s++)
      this.buffer[n + s] = this.buffer[e + s];
  }
  // mix functions
  _select(e, n, s, r, a) {
    if (r >= 0.5)
      for (let o = 0; o !== a; ++o)
        e[n + o] = e[s + o];
  }
  _slerp(e, n, s, r) {
    fn.slerpFlat(e, n, e, n, e, s, r);
  }
  _slerpAdditive(e, n, s, r, a) {
    const o = this._workIndex * a;
    fn.multiplyQuaternionsFlat(e, o, e, n, e, s), fn.slerpFlat(e, n, e, n, e, o, r);
  }
  _lerp(e, n, s, r, a) {
    const o = 1 - r;
    for (let h = 0; h !== a; ++h) {
      const c = n + h;
      e[c] = e[c] * o + e[s + h] * r;
    }
  }
  _lerpAdditive(e, n, s, r, a) {
    for (let o = 0; o !== a; ++o) {
      const h = n + o;
      e[h] = e[h] + e[s + o] * r;
    }
  }
}
const UB = new Float32Array(1);
class WB extends Es {
  /**
   * Constructs a new animation mixer.
   *
   * @param {Object3D} root - The object whose animations shall be played by this mixer.
   */
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, n) {
    const s = e._localRoot || this._root, r = e._clip.tracks, a = r.length, o = e._propertyBindings, h = e._interpolants, c = s.uuid, l = this._bindingsByRootAndName;
    let u = l[c];
    u === void 0 && (u = {}, l[c] = u);
    for (let f = 0; f !== a; ++f) {
      const d = r[f], p = d.name;
      let y = u[p];
      if (y !== void 0)
        ++y.referenceCount, o[f] = y;
      else {
        if (y = o[f], y !== void 0) {
          y._cacheIndex === null && (++y.referenceCount, this._addInactiveBinding(y, c, p));
          continue;
        }
        const x = n && n._propertyBindings[f].binding.parsedPath;
        y = new Yb(
          Dt.create(s, p, x),
          d.ValueTypeName,
          d.getValueSize()
        ), ++y.referenceCount, this._addInactiveBinding(y, c, p), o[f] = y;
      }
      h[f].resultBuffer = y.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const s = (e._localRoot || this._root).uuid, r = e._clip.uuid, a = this._actionsByClip[r];
        this._bindAction(
          e,
          a && a.knownActions[0]
        ), this._addInactiveAction(e, r, s);
      }
      const n = e._propertyBindings;
      for (let s = 0, r = n.length; s !== r; ++s) {
        const a = n[s];
        a.useCount++ === 0 && (this._lendBinding(a), a.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const n = e._propertyBindings;
      for (let s = 0, r = n.length; s !== r; ++s) {
        const a = n[s];
        --a.useCount === 0 && (a.restoreOriginalState(), this._takeBackBinding(a));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const n = e._cacheIndex;
    return n !== null && n < this._nActiveActions;
  }
  _addInactiveAction(e, n, s) {
    const r = this._actions, a = this._actionsByClip;
    let o = a[n];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, a[n] = o;
    else {
      const h = o.knownActions;
      e._byClipCacheIndex = h.length, h.push(e);
    }
    e._cacheIndex = r.length, r.push(e), o.actionByRoot[s] = e;
  }
  _removeInactiveAction(e) {
    const n = this._actions, s = n[n.length - 1], r = e._cacheIndex;
    s._cacheIndex = r, n[r] = s, n.pop(), e._cacheIndex = null;
    const a = e._clip.uuid, o = this._actionsByClip, h = o[a], c = h.knownActions, l = c[c.length - 1], u = e._byClipCacheIndex;
    l._byClipCacheIndex = u, c[u] = l, c.pop(), e._byClipCacheIndex = null;
    const f = h.actionByRoot, d = (e._localRoot || this._root).uuid;
    delete f[d], c.length === 0 && delete o[a], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const n = e._propertyBindings;
    for (let s = 0, r = n.length; s !== r; ++s) {
      const a = n[s];
      --a.referenceCount === 0 && this._removeInactiveBinding(a);
    }
  }
  _lendAction(e) {
    const n = this._actions, s = e._cacheIndex, r = this._nActiveActions++, a = n[r];
    e._cacheIndex = r, n[r] = e, a._cacheIndex = s, n[s] = a;
  }
  _takeBackAction(e) {
    const n = this._actions, s = e._cacheIndex, r = --this._nActiveActions, a = n[r];
    e._cacheIndex = r, n[r] = e, a._cacheIndex = s, n[s] = a;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, n, s) {
    const r = this._bindingsByRootAndName, a = this._bindings;
    let o = r[n];
    o === void 0 && (o = {}, r[n] = o), o[s] = e, e._cacheIndex = a.length, a.push(e);
  }
  _removeInactiveBinding(e) {
    const n = this._bindings, s = e.binding, r = s.rootNode.uuid, a = s.path, o = this._bindingsByRootAndName, h = o[r], c = n[n.length - 1], l = e._cacheIndex;
    c._cacheIndex = l, n[l] = c, n.pop(), delete h[a], Object.keys(h).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const n = this._bindings, s = e._cacheIndex, r = this._nActiveBindings++, a = n[r];
    e._cacheIndex = r, n[r] = e, a._cacheIndex = s, n[s] = a;
  }
  _takeBackBinding(e) {
    const n = this._bindings, s = e._cacheIndex, r = --this._nActiveBindings, a = n[r];
    e._cacheIndex = r, n[r] = e, a._cacheIndex = s, n[s] = a;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, n = this._nActiveControlInterpolants++;
    let s = e[n];
    return s === void 0 && (s = new _1(
      new Float32Array(2),
      new Float32Array(2),
      1,
      UB
    ), s.__cacheIndex = n, e[n] = s), s;
  }
  _takeBackControlInterpolant(e) {
    const n = this._controlInterpolants, s = e.__cacheIndex, r = --this._nActiveControlInterpolants, a = n[r];
    e.__cacheIndex = r, n[r] = e, a.__cacheIndex = s, n[s] = a;
  }
  /**
   * Returns an instance of {@link AnimationAction} for the passed clip.
   *
   * If an action fitting the clip and root parameters doesn't yet exist, it
   * will be created by this method. Calling this method several times with the
   * same clip and root parameters always returns the same action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   * @return {?AnimationAction} The animation action.
   */
  clipAction(e, n, s) {
    const r = n || this._root, a = r.uuid;
    let o = typeof e == "string" ? K0.findByName(r, e) : e;
    const h = o !== null ? o.uuid : e, c = this._actionsByClip[h];
    let l = null;
    if (s === void 0 && (o !== null ? s = o.blendMode : s = gu), c !== void 0) {
      const f = c.actionByRoot[a];
      if (f !== void 0 && f.blendMode === s)
        return f;
      l = c.knownActions[0], o === null && (o = l._clip);
    }
    if (o === null) return null;
    const u = new qb(this, o, n, s);
    return this._bindAction(u, l), this._addInactiveAction(u, h, a), u;
  }
  /**
   * Returns an existing animation action for the passed clip.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @return {?AnimationAction} The animation action. Returns `null` if no action was found.
   */
  existingAction(e, n) {
    const s = n || this._root, r = s.uuid, a = typeof e == "string" ? K0.findByName(s, e) : e, o = a ? a.uuid : e, h = this._actionsByClip[o];
    return h !== void 0 && h.actionByRoot[r] || null;
  }
  /**
   * Deactivates all previously scheduled actions on this mixer.
   *
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  stopAllAction() {
    const e = this._actions, n = this._nActiveActions;
    for (let s = n - 1; s >= 0; --s)
      e[s].stop();
    return this;
  }
  /**
   * Advances the global mixer time and updates the animation.
   *
   * This is usually done in the render loop by passing the delta
   * time from {@link Clock} or {@link Timer}.
   *
   * @param {number} deltaTime - The delta time in seconds.
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  update(e) {
    e *= this.timeScale;
    const n = this._actions, s = this._nActiveActions, r = this.time += e, a = Math.sign(e), o = this._accuIndex ^= 1;
    for (let l = 0; l !== s; ++l)
      n[l]._update(r, e, a, o);
    const h = this._bindings, c = this._nActiveBindings;
    for (let l = 0; l !== c; ++l)
      h[l].apply(o);
    return this;
  }
  /**
   * Sets the global mixer to a specific time and updates the animation accordingly.
   *
   * This is useful when you need to jump to an exact time in an animation. The
   * input parameter will be scaled by {@link AnimationMixer#timeScale}
   *
   * @param {number} time - The time to set in seconds.
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  setTime(e) {
    this.time = 0;
    for (let n = 0; n < this._actions.length; n++)
      this._actions[n].time = 0;
    return this.update(e);
  }
  /**
   * Returns this mixer's root object.
   *
   * @return {Object3D} The mixer's root object.
   */
  getRoot() {
    return this._root;
  }
  /**
   * Deallocates all memory resources for a clip. Before using this method make
   * sure to call {@link AnimationAction#stop} for all related actions.
   *
   * @param {AnimationClip} clip - The clip to uncache.
   */
  uncacheClip(e) {
    const n = this._actions, s = e.uuid, r = this._actionsByClip, a = r[s];
    if (a !== void 0) {
      const o = a.knownActions;
      for (let h = 0, c = o.length; h !== c; ++h) {
        const l = o[h];
        this._deactivateAction(l);
        const u = l._cacheIndex, f = n[n.length - 1];
        l._cacheIndex = null, l._byClipCacheIndex = null, f._cacheIndex = u, n[u] = f, n.pop(), this._removeInactiveBindingsForAction(l);
      }
      delete r[s];
    }
  }
  /**
   * Deallocates all memory resources for a root object. Before using this
   * method make sure to call {@link AnimationAction#stop} for all related
   * actions or alternatively {@link AnimationMixer#stopAllAction} when the
   * mixer operates on a single root.
   *
   * @param {Object3D} root - The root object to uncache.
   */
  uncacheRoot(e) {
    const n = e.uuid, s = this._actionsByClip;
    for (const o in s) {
      const h = s[o].actionByRoot, c = h[n];
      c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    const r = this._bindingsByRootAndName, a = r[n];
    if (a !== void 0)
      for (const o in a) {
        const h = a[o];
        h.restoreOriginalState(), this._removeInactiveBinding(h);
      }
  }
  /**
   * Deallocates all memory resources for an action. The action is identified by the
   * given clip and an optional root object. Before using this method make
   * sure to call {@link AnimationAction#stop} to deactivate the action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   */
  uncacheAction(e, n) {
    const s = this.existingAction(e, n);
    s !== null && (this._deactivateAction(s), this._removeInactiveAction(s));
  }
}
class YB {
  /**
   * Constructs a new animation group.
   *
   * @param {...Object3D} arguments - An arbitrary number of 3D objects that share the same animation state.
   */
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = ni(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let s = 0, r = arguments.length; s !== r; ++s)
      e[arguments[s].uuid] = s;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return n._bindings.length;
      }
    };
  }
  /**
   * Adds an arbitrary number of objects to this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to add.
   */
  add() {
    const e = this._objects, n = this._indicesByUUID, s = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length;
    let h, c = e.length, l = this.nCachedObjects_;
    for (let u = 0, f = arguments.length; u !== f; ++u) {
      const d = arguments[u], p = d.uuid;
      let y = n[p];
      if (y === void 0) {
        y = c++, n[p] = y, e.push(d);
        for (let x = 0, g = o; x !== g; ++x)
          a[x].push(new Dt(d, s[x], r[x]));
      } else if (y < l) {
        h = e[y];
        const x = --l, g = e[x];
        n[g.uuid] = y, e[y] = g, n[p] = x, e[x] = d;
        for (let m = 0, v = o; m !== v; ++m) {
          const w = a[m], b = w[x];
          let S = w[y];
          w[y] = b, S === void 0 && (S = new Dt(d, s[m], r[m])), w[x] = S;
        }
      } else e[y] !== h && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = l;
  }
  /**
   * Removes an arbitrary number of objects to this animation group
   *
   * @param {...Object3D} arguments - The 3D objects to remove.
   */
  remove() {
    const e = this._objects, n = this._indicesByUUID, s = this._bindings, r = s.length;
    let a = this.nCachedObjects_;
    for (let o = 0, h = arguments.length; o !== h; ++o) {
      const c = arguments[o], l = c.uuid, u = n[l];
      if (u !== void 0 && u >= a) {
        const f = a++, d = e[f];
        n[d.uuid] = u, e[u] = d, n[l] = f, e[f] = c;
        for (let p = 0, y = r; p !== y; ++p) {
          const x = s[p], g = x[f], m = x[u];
          x[u] = g, x[f] = m;
        }
      }
    }
    this.nCachedObjects_ = a;
  }
  /**
   * Deallocates all memory resources for the passed 3D objects of this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to uncache.
   */
  uncache() {
    const e = this._objects, n = this._indicesByUUID, s = this._bindings, r = s.length;
    let a = this.nCachedObjects_, o = e.length;
    for (let h = 0, c = arguments.length; h !== c; ++h) {
      const l = arguments[h], u = l.uuid, f = n[u];
      if (f !== void 0)
        if (delete n[u], f < a) {
          const d = --a, p = e[d], y = --o, x = e[y];
          n[p.uuid] = f, e[f] = p, n[x.uuid] = d, e[d] = x, e.pop();
          for (let g = 0, m = r; g !== m; ++g) {
            const v = s[g], w = v[d], b = v[y];
            v[f] = w, v[d] = b, v.pop();
          }
        } else {
          const d = --o, p = e[d];
          d > 0 && (n[p.uuid] = f), e[f] = p, e.pop();
          for (let y = 0, x = r; y !== x; ++y) {
            const g = s[y];
            g[f] = g[d], g.pop();
          }
        }
    }
    this.nCachedObjects_ = a;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, n) {
    const s = this._bindingsIndicesByPath;
    let r = s[e];
    const a = this._bindings;
    if (r !== void 0) return a[r];
    const o = this._paths, h = this._parsedPaths, c = this._objects, l = c.length, u = this.nCachedObjects_, f = new Array(l);
    r = a.length, s[e] = r, o.push(e), h.push(n), a.push(f);
    for (let d = u, p = c.length; d !== p; ++d) {
      const y = c[d];
      f[d] = new Dt(y, e, n);
    }
    return f;
  }
  unsubscribe_(e) {
    const n = this._bindingsIndicesByPath, s = n[e];
    if (s !== void 0) {
      const r = this._paths, a = this._parsedPaths, o = this._bindings, h = o.length - 1, c = o[h], l = e[h];
      n[l] = s, o[s] = c, o.pop(), a[s] = a[h], a.pop(), r[s] = r[h], r.pop();
    }
  }
}
class $ {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(e = 0, n = 0, s = 0) {
    $.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = s;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(e, n, s) {
    return s === void 0 && (s = this.z), this.x = e, this.y = n, this.z = s, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(e) {
    return this.applyQuaternion(hg.setFromEuler(e));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(e, n) {
    return this.applyQuaternion(hg.setFromAxisAngle(e, n));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(e) {
    const n = this.x, s = this.y, r = this.z, a = e.elements;
    return this.x = a[0] * n + a[3] * s + a[6] * r, this.y = a[1] * n + a[4] * s + a[7] * r, this.z = a[2] * n + a[5] * s + a[8] * r, this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(e) {
    const n = this.x, s = this.y, r = this.z, a = e.elements, o = 1 / (a[3] * n + a[7] * s + a[11] * r + a[15]);
    return this.x = (a[0] * n + a[4] * s + a[8] * r + a[12]) * o, this.y = (a[1] * n + a[5] * s + a[9] * r + a[13]) * o, this.z = (a[2] * n + a[6] * s + a[10] * r + a[14]) * o, this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(e) {
    const n = this.x, s = this.y, r = this.z, a = e.x, o = e.y, h = e.z, c = e.w, l = 2 * (o * r - h * s), u = 2 * (h * n - a * r), f = 2 * (a * s - o * n);
    return this.x = n + c * l + o * f - h * u, this.y = s + c * u + h * l - a * f, this.z = r + c * f + a * u - o * l, this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(e) {
    const n = this.x, s = this.y, r = this.z, a = e.elements;
    return this.x = a[0] * n + a[4] * s + a[8] * r, this.y = a[1] * n + a[5] * s + a[9] * r, this.z = a[2] * n + a[6] * s + a[10] * r, this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(e, n) {
    return this.x = zt(this.x, e.x, n.x), this.y = zt(this.y, e.y, n.y), this.z = zt(this.z, e.z, n.z), this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(e, n) {
    return this.x = zt(this.x, e, n), this.y = zt(this.y, e, n), this.z = zt(this.z, e, n), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(e, n) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(zt(s, e, n));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(e, n, s) {
    return this.x = e.x + (n.x - e.x) * s, this.y = e.y + (n.y - e.y) * s, this.z = e.z + (n.z - e.z) * s, this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(e) {
    return this.crossVectors(this, e);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(e, n) {
    const s = e.x, r = e.y, a = e.z, o = n.x, h = n.y, c = n.z;
    return this.x = r * c - a * h, this.y = a * o - s * c, this.z = s * h - r * o, this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const s = e.dot(this) / n;
    return this.copy(e).multiplyScalar(s);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(e) {
    return pf.copy(this).projectOnVector(e), this.sub(pf);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(e) {
    return this.sub(pf.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const s = this.dot(e) / n;
    return Math.acos(zt(s, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const n = this.x - e.x, s = this.y - e.y, r = this.z - e.z;
    return n * n + s * s + r * r;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(e, n, s) {
    const r = Math.sin(n) * e;
    return this.x = r * Math.sin(s), this.y = Math.cos(n) * e, this.z = r * Math.cos(s), this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(e, n, s) {
    return this.x = e * Math.sin(n), this.y = s, this.z = e * Math.cos(n), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), s = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = s, this.z = r, this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, s = Math.sqrt(1 - n * n);
    return this.x = s * Math.cos(e), this.y = n, this.z = s * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const pf = /* @__PURE__ */ new $(), hg = /* @__PURE__ */ new fn();
class ve {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(e, n, s, r, a, o, h, c, l, u, f, d, p, y, x, g) {
    ve.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, s, r, a, o, h, c, l, u, f, d, p, y, x, g);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(e, n, s, r, a, o, h, c, l, u, f, d, p, y, x, g) {
    const m = this.elements;
    return m[0] = e, m[4] = n, m[8] = s, m[12] = r, m[1] = a, m[5] = o, m[9] = h, m[13] = c, m[2] = l, m[6] = u, m[10] = f, m[14] = d, m[3] = p, m[7] = y, m[11] = x, m[15] = g, this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new ve().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(e) {
    const n = this.elements, s = e.elements;
    return n[0] = s[0], n[1] = s[1], n[2] = s[2], n[3] = s[3], n[4] = s[4], n[5] = s[5], n[6] = s[6], n[7] = s[7], n[8] = s[8], n[9] = s[9], n[10] = s[10], n[11] = s[11], n[12] = s[12], n[13] = s[13], n[14] = s[14], n[15] = s[15], this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(e) {
    const n = this.elements, s = e.elements;
    return n[12] = s[12], n[13] = s[13], n[14] = s[14], this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(e, n, s) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), s.setFromMatrixColumn(this, 2), this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(e, n, s) {
    return this.set(
      e.x,
      n.x,
      s.x,
      0,
      e.y,
      n.y,
      s.y,
      0,
      e.z,
      n.z,
      s.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(e) {
    const n = this.elements, s = e.elements, r = 1 / Gr.setFromMatrixColumn(e, 0).length(), a = 1 / Gr.setFromMatrixColumn(e, 1).length(), o = 1 / Gr.setFromMatrixColumn(e, 2).length();
    return n[0] = s[0] * r, n[1] = s[1] * r, n[2] = s[2] * r, n[3] = 0, n[4] = s[4] * a, n[5] = s[5] * a, n[6] = s[6] * a, n[7] = 0, n[8] = s[8] * o, n[9] = s[9] * o, n[10] = s[10] * o, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(e) {
    const n = this.elements, s = e.x, r = e.y, a = e.z, o = Math.cos(s), h = Math.sin(s), c = Math.cos(r), l = Math.sin(r), u = Math.cos(a), f = Math.sin(a);
    if (e.order === "XYZ") {
      const d = o * u, p = o * f, y = h * u, x = h * f;
      n[0] = c * u, n[4] = -c * f, n[8] = l, n[1] = p + y * l, n[5] = d - x * l, n[9] = -h * c, n[2] = x - d * l, n[6] = y + p * l, n[10] = o * c;
    } else if (e.order === "YXZ") {
      const d = c * u, p = c * f, y = l * u, x = l * f;
      n[0] = d + x * h, n[4] = y * h - p, n[8] = o * l, n[1] = o * f, n[5] = o * u, n[9] = -h, n[2] = p * h - y, n[6] = x + d * h, n[10] = o * c;
    } else if (e.order === "ZXY") {
      const d = c * u, p = c * f, y = l * u, x = l * f;
      n[0] = d - x * h, n[4] = -o * f, n[8] = y + p * h, n[1] = p + y * h, n[5] = o * u, n[9] = x - d * h, n[2] = -o * l, n[6] = h, n[10] = o * c;
    } else if (e.order === "ZYX") {
      const d = o * u, p = o * f, y = h * u, x = h * f;
      n[0] = c * u, n[4] = y * l - p, n[8] = d * l + x, n[1] = c * f, n[5] = x * l + d, n[9] = p * l - y, n[2] = -l, n[6] = h * c, n[10] = o * c;
    } else if (e.order === "YZX") {
      const d = o * c, p = o * l, y = h * c, x = h * l;
      n[0] = c * u, n[4] = x - d * f, n[8] = y * f + p, n[1] = f, n[5] = o * u, n[9] = -h * u, n[2] = -l * u, n[6] = p * f + y, n[10] = d - x * f;
    } else if (e.order === "XZY") {
      const d = o * c, p = o * l, y = h * c, x = h * l;
      n[0] = c * u, n[4] = -f, n[8] = l * u, n[1] = d * f + x, n[5] = o * u, n[9] = p * f - y, n[2] = y * f - p, n[6] = h * u, n[10] = x * f + d;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(e) {
    return this.compose(jB, e, HB);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(e, n, s) {
    const r = this.elements;
    return gn.subVectors(e, n), gn.lengthSq() === 0 && (gn.z = 1), gn.normalize(), es.crossVectors(s, gn), es.lengthSq() === 0 && (Math.abs(s.z) === 1 ? gn.x += 1e-4 : gn.z += 1e-4, gn.normalize(), es.crossVectors(s, gn)), es.normalize(), zc.crossVectors(gn, es), r[0] = es.x, r[4] = zc.x, r[8] = gn.x, r[1] = es.y, r[5] = zc.y, r[9] = gn.y, r[2] = es.z, r[6] = zc.z, r[10] = gn.z, this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(e, n) {
    const s = e.elements, r = n.elements, a = this.elements, o = s[0], h = s[4], c = s[8], l = s[12], u = s[1], f = s[5], d = s[9], p = s[13], y = s[2], x = s[6], g = s[10], m = s[14], v = s[3], w = s[7], b = s[11], S = s[15], E = r[0], A = r[4], M = r[8], _ = r[12], T = r[1], C = r[5], P = r[9], R = r[13], k = r[2], I = r[6], L = r[10], F = r[14], B = r[3], V = r[7], J = r[11], j = r[15];
    return a[0] = o * E + h * T + c * k + l * B, a[4] = o * A + h * C + c * I + l * V, a[8] = o * M + h * P + c * L + l * J, a[12] = o * _ + h * R + c * F + l * j, a[1] = u * E + f * T + d * k + p * B, a[5] = u * A + f * C + d * I + p * V, a[9] = u * M + f * P + d * L + p * J, a[13] = u * _ + f * R + d * F + p * j, a[2] = y * E + x * T + g * k + m * B, a[6] = y * A + x * C + g * I + m * V, a[10] = y * M + x * P + g * L + m * J, a[14] = y * _ + x * R + g * F + m * j, a[3] = v * E + w * T + b * k + S * B, a[7] = v * A + w * C + b * I + S * V, a[11] = v * M + w * P + b * L + S * J, a[15] = v * _ + w * R + b * F + S * j, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, n = e[0], s = e[4], r = e[8], a = e[12], o = e[1], h = e[5], c = e[9], l = e[13], u = e[2], f = e[6], d = e[10], p = e[14], y = e[3], x = e[7], g = e[11], m = e[15];
    return y * (+a * c * f - r * l * f - a * h * d + s * l * d + r * h * p - s * c * p) + x * (+n * c * p - n * l * d + a * o * d - r * o * p + r * l * u - a * c * u) + g * (+n * l * f - n * h * p - a * o * f + s * o * p + a * h * u - s * l * u) + m * (-r * h * u - n * c * f + n * h * d + r * o * f - s * o * d + s * c * u);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(e, n, s) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = n, r[14] = s), this;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const e = this.elements, n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = e[9], d = e[10], p = e[11], y = e[12], x = e[13], g = e[14], m = e[15], v = f * g * l - x * d * l + x * c * p - h * g * p - f * c * m + h * d * m, w = y * d * l - u * g * l - y * c * p + o * g * p + u * c * m - o * d * m, b = u * x * l - y * f * l + y * h * p - o * x * p - u * h * m + o * f * m, S = y * f * c - u * x * c - y * h * d + o * x * d + u * h * g - o * f * g, E = n * v + s * w + r * b + a * S;
    if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / E;
    return e[0] = v * A, e[1] = (x * d * a - f * g * a - x * r * p + s * g * p + f * r * m - s * d * m) * A, e[2] = (h * g * a - x * c * a + x * r * l - s * g * l - h * r * m + s * c * m) * A, e[3] = (f * c * a - h * d * a - f * r * l + s * d * l + h * r * p - s * c * p) * A, e[4] = w * A, e[5] = (u * g * a - y * d * a + y * r * p - n * g * p - u * r * m + n * d * m) * A, e[6] = (y * c * a - o * g * a - y * r * l + n * g * l + o * r * m - n * c * m) * A, e[7] = (o * d * a - u * c * a + u * r * l - n * d * l - o * r * p + n * c * p) * A, e[8] = b * A, e[9] = (y * f * a - u * x * a - y * s * p + n * x * p + u * s * m - n * f * m) * A, e[10] = (o * x * a - y * h * a + y * s * l - n * x * l - o * s * m + n * h * m) * A, e[11] = (u * h * a - o * f * a - u * s * l + n * f * l + o * s * p - n * h * p) * A, e[12] = S * A, e[13] = (u * x * r - y * f * r + y * s * d - n * x * d - u * s * g + n * f * g) * A, e[14] = (y * h * r - o * x * r - y * s * c + n * x * c + o * s * g - n * h * g) * A, e[15] = (o * f * r - u * h * r + u * s * c - n * f * c - o * s * d + n * h * d) * A, this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(e) {
    const n = this.elements, s = e.x, r = e.y, a = e.z;
    return n[0] *= s, n[4] *= r, n[8] *= a, n[1] *= s, n[5] *= r, n[9] *= a, n[2] *= s, n[6] *= r, n[10] *= a, n[3] *= s, n[7] *= r, n[11] *= a, this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], s = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, s, r));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(e, n, s) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      s,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -s,
      0,
      0,
      s,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.set(
      n,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.set(
      n,
      -s,
      0,
      0,
      s,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(e, n) {
    const s = Math.cos(n), r = Math.sin(n), a = 1 - s, o = e.x, h = e.y, c = e.z, l = a * o, u = a * h;
    return this.set(
      l * o + s,
      l * h - r * c,
      l * c + r * h,
      0,
      l * h + r * c,
      u * h + s,
      u * c - r * o,
      0,
      l * c - r * h,
      u * c + r * o,
      a * c * c + s,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(e, n, s) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(e, n, s, r, a, o) {
    return this.set(
      1,
      s,
      a,
      0,
      e,
      1,
      o,
      0,
      n,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(e, n, s) {
    const r = this.elements, a = n._x, o = n._y, h = n._z, c = n._w, l = a + a, u = o + o, f = h + h, d = a * l, p = a * u, y = a * f, x = o * u, g = o * f, m = h * f, v = c * l, w = c * u, b = c * f, S = s.x, E = s.y, A = s.z;
    return r[0] = (1 - (x + m)) * S, r[1] = (p + b) * S, r[2] = (y - w) * S, r[3] = 0, r[4] = (p - b) * E, r[5] = (1 - (d + m)) * E, r[6] = (g + v) * E, r[7] = 0, r[8] = (y + w) * A, r[9] = (g - v) * A, r[10] = (1 - (d + x)) * A, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(e, n, s) {
    const r = this.elements;
    let a = Gr.set(r[0], r[1], r[2]).length();
    const o = Gr.set(r[4], r[5], r[6]).length(), h = Gr.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (a = -a), e.x = r[12], e.y = r[13], e.z = r[14], Vn.copy(this);
    const l = 1 / a, u = 1 / o, f = 1 / h;
    return Vn.elements[0] *= l, Vn.elements[1] *= l, Vn.elements[2] *= l, Vn.elements[4] *= u, Vn.elements[5] *= u, Vn.elements[6] *= u, Vn.elements[8] *= f, Vn.elements[9] *= f, Vn.elements[10] *= f, n.setFromRotationMatrix(Vn), s.x = a, s.y = o, s.z = h, this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(e, n, s, r, a, o, h = mi) {
    const c = this.elements, l = 2 * a / (n - e), u = 2 * a / (s - r), f = (n + e) / (n - e), d = (s + r) / (s - r);
    let p, y;
    if (h === mi)
      p = -(o + a) / (o - a), y = -2 * o * a / (o - a);
    else if (h === xh)
      p = -o / (o - a), y = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + h);
    return c[0] = l, c[4] = 0, c[8] = f, c[12] = 0, c[1] = 0, c[5] = u, c[9] = d, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = p, c[14] = y, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(e, n, s, r, a, o, h = mi) {
    const c = this.elements, l = 1 / (n - e), u = 1 / (s - r), f = 1 / (o - a), d = (n + e) * l, p = (s + r) * u;
    let y, x;
    if (h === mi)
      y = (o + a) * f, x = -2 * f;
    else if (h === xh)
      y = a * f, x = -1 * f;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + h);
    return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -d, c[1] = 0, c[5] = 2 * u, c[9] = 0, c[13] = -p, c[2] = 0, c[6] = 0, c[10] = x, c[14] = -y, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const n = this.elements, s = e.elements;
    for (let r = 0; r < 16; r++)
      if (n[r] !== s[r]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(e, n = 0) {
    for (let s = 0; s < 16; s++)
      this.elements[s] = e[s + n];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], n = 0) {
    const s = this.elements;
    return e[n] = s[0], e[n + 1] = s[1], e[n + 2] = s[2], e[n + 3] = s[3], e[n + 4] = s[4], e[n + 5] = s[5], e[n + 6] = s[6], e[n + 7] = s[7], e[n + 8] = s[8], e[n + 9] = s[9], e[n + 10] = s[10], e[n + 11] = s[11], e[n + 12] = s[12], e[n + 13] = s[13], e[n + 14] = s[14], e[n + 15] = s[15], e;
  }
}
const Gr = /* @__PURE__ */ new $(), Vn = /* @__PURE__ */ new ve(), jB = /* @__PURE__ */ new $(0, 0, 0), HB = /* @__PURE__ */ new $(1, 1, 1), es = /* @__PURE__ */ new $(), zc = /* @__PURE__ */ new $(), gn = /* @__PURE__ */ new $(), cg = /* @__PURE__ */ new ve(), lg = /* @__PURE__ */ new fn();
class Sr {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(e = 0, n = 0, s = 0, r = Sr.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = s, this._order = r;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(e, n, s, r = this._order) {
    return this._x = e, this._y = n, this._z = s, this._order = r, this._onChangeCallback(), this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(e, n = this._order, s = !0) {
    const r = e.elements, a = r[0], o = r[4], h = r[8], c = r[1], l = r[5], u = r[9], f = r[2], d = r[6], p = r[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(zt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-zt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(h, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-f, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(zt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-f, p), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(c, a));
        break;
      case "ZYX":
        this._y = Math.asin(-zt(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, l));
        break;
      case "YZX":
        this._z = Math.asin(zt(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-f, a)) : (this._x = 0, this._y = Math.atan2(h, p));
        break;
      case "XZY":
        this._z = Math.asin(-zt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(h, a)) : (this._x = Math.atan2(-u, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, s === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(e, n, s) {
    return cg.makeRotationFromQuaternion(e), this.setFromRotationMatrix(cg, n, s);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(e) {
    return lg.setFromEuler(this), this.setFromQuaternion(lg, e);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Sr.DEFAULT_ORDER = "XYZ";
class z1 {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = -1;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
class Si {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(e, n, s, r, a, o, h, c, l) {
    Si.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, s, r, a, o, h, c, l);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(e, n, s, r, a, o, h, c, l) {
    const u = this.elements;
    return u[0] = e, u[1] = r, u[2] = h, u[3] = n, u[4] = a, u[5] = c, u[6] = s, u[7] = o, u[8] = l, this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(e) {
    const n = this.elements, s = e.elements;
    return n[0] = s[0], n[1] = s[1], n[2] = s[2], n[3] = s[3], n[4] = s[4], n[5] = s[5], n[6] = s[6], n[7] = s[7], n[8] = s[8], this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(e, n, s) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), s.setFromMatrix3Column(this, 2), this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(e, n) {
    const s = e.elements, r = n.elements, a = this.elements, o = s[0], h = s[3], c = s[6], l = s[1], u = s[4], f = s[7], d = s[2], p = s[5], y = s[8], x = r[0], g = r[3], m = r[6], v = r[1], w = r[4], b = r[7], S = r[2], E = r[5], A = r[8];
    return a[0] = o * x + h * v + c * S, a[3] = o * g + h * w + c * E, a[6] = o * m + h * b + c * A, a[1] = l * x + u * v + f * S, a[4] = l * g + u * w + f * E, a[7] = l * m + u * b + f * A, a[2] = d * x + p * v + y * S, a[5] = d * g + p * w + y * E, a[8] = d * m + p * b + y * A, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8];
    return n * o * u - n * h * l - s * a * u + s * h * c + r * a * l - r * o * c;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const e = this.elements, n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], h = e[5], c = e[6], l = e[7], u = e[8], f = u * o - h * l, d = h * c - u * a, p = l * a - o * c, y = n * f + s * d + r * p;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / y;
    return e[0] = f * x, e[1] = (r * l - u * s) * x, e[2] = (h * s - r * o) * x, e[3] = d * x, e[4] = (u * n - r * c) * x, e[5] = (r * a - h * n) * x, e[6] = p * x, e[7] = (s * c - l * n) * x, e[8] = (o * n - s * a) * x, this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(e, n, s, r, a, o, h) {
    const c = Math.cos(a), l = Math.sin(a);
    return this.set(
      s * c,
      s * l,
      -s * (c * o + l * h) + o + e,
      -r * l,
      r * c,
      -r * (-l * o + c * h) + h + n,
      0,
      0,
      1
    ), this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(e, n) {
    return this.premultiply(yf.makeScale(e, n)), this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(e) {
    return this.premultiply(yf.makeRotation(-e)), this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(e, n) {
    return this.premultiply(yf.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(e) {
    const n = Math.cos(e), s = Math.sin(e);
    return this.set(
      n,
      -s,
      0,
      s,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const n = this.elements, s = e.elements;
    for (let r = 0; r < 9; r++)
      if (n[r] !== s[r]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(e, n = 0) {
    for (let s = 0; s < 9; s++)
      this.elements[s] = e[s + n];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], n = 0) {
    const s = this.elements;
    return e[n] = s[0], e[n + 1] = s[1], e[n + 2] = s[2], e[n + 3] = s[3], e[n + 4] = s[4], e[n + 5] = s[5], e[n + 6] = s[6], e[n + 7] = s[7], e[n + 8] = s[8], e;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const yf = /* @__PURE__ */ new Si();
let XB = 0;
const ug = /* @__PURE__ */ new $(), Ur = /* @__PURE__ */ new fn(), Ai = /* @__PURE__ */ new ve(), Cc = /* @__PURE__ */ new $(), so = /* @__PURE__ */ new $(), ZB = /* @__PURE__ */ new $(), JB = /* @__PURE__ */ new fn(), fg = /* @__PURE__ */ new $(1, 0, 0), dg = /* @__PURE__ */ new $(0, 1, 0), pg = /* @__PURE__ */ new $(0, 0, 1), yg = { type: "added" }, QB = { type: "removed" }, Wr = { type: "childadded", child: null }, xf = { type: "childremoved", child: null };
class dn extends Es {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: XB++ }), this.uuid = ni(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = dn.DEFAULT_UP.clone();
    const e = new $(), n = new Sr(), s = new fn(), r = new $(1, 1, 1);
    function a() {
      s.setFromEuler(n, !1);
    }
    function o() {
      n.setFromQuaternion(s, void 0, !1);
    }
    n._onChange(a), s._onChange(o), Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new ve()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new Si()
      }
    }), this.matrix = new ve(), this.matrixWorld = new ve(), this.matrixAutoUpdate = dn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = dn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new z1(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(e, n) {
    return Ur.setFromAxisAngle(e, n), this.quaternion.multiply(Ur), this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(e, n) {
    return Ur.setFromAxisAngle(e, n), this.quaternion.premultiply(Ur), this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(e) {
    return this.rotateOnAxis(fg, e);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(e) {
    return this.rotateOnAxis(dg, e);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(e) {
    return this.rotateOnAxis(pg, e);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(e, n) {
    return ug.copy(e).applyQuaternion(this.quaternion), this.position.add(ug.multiplyScalar(n)), this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(e) {
    return this.translateOnAxis(fg, e);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(e) {
    return this.translateOnAxis(dg, e);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(e) {
    return this.translateOnAxis(pg, e);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ai.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(e, n, s) {
    e.isVector3 ? Cc.copy(e) : Cc.set(e, n, s);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), so.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ai.lookAt(so, Cc, this.up) : Ai.lookAt(Cc, so, this.up), this.quaternion.setFromRotationMatrix(Ai), r && (Ai.extractRotation(r.matrixWorld), Ur.setFromRotationMatrix(Ai), this.quaternion.premultiply(Ur.invert()));
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(yg), Wr.child = e, this.dispatchEvent(Wr), Wr.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(e) {
    if (arguments.length > 1) {
      for (let s = 0; s < arguments.length; s++)
        this.remove(arguments[s]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(QB), xf.child = e, this.dispatchEvent(xf), xf.child = null), this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Ai.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ai.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ai), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(yg), Wr.child = e, this.dispatchEvent(Wr), Wr.child = null, this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let s = 0, r = this.children.length; s < r; s++) {
      const o = this.children[s].getObjectByProperty(e, n);
      if (o !== void 0)
        return o;
    }
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(e, n, s = []) {
    this[e] === n && s.push(this);
    const r = this.children;
    for (let a = 0, o = r.length; a < o; a++)
      r[a].getObjectsByProperty(e, n, s);
    return s;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(so, e, ZB), e;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(so, JB, e), e;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(e) {
    e(this);
    const n = this.children;
    for (let s = 0, r = n.length; s < r; s++)
      n[s].traverse(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let s = 0, r = n.length; s < r; s++)
      n[s].traverseVisible(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let s = 0, r = n.length; s < r; s++)
      n[s].updateMatrixWorld(e);
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(e, n) {
    const s = this.parent;
    if (e === !0 && s !== null && s.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) {
      const r = this.children;
      for (let a = 0, o = r.length; a < o; a++)
        r[a].updateWorldMatrix(!1, !0);
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", s = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, s.metadata = {
      version: 4.7,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.geometryInfo = this._geometryInfo.map((h) => ({
      ...h,
      boundingBox: h.boundingBox ? h.boundingBox.toJSON() : void 0,
      boundingSphere: h.boundingSphere ? h.boundingSphere.toJSON() : void 0
    })), r.instanceInfo = this._instanceInfo.map((h) => ({ ...h })), r.availableInstanceIds = this._availableInstanceIds.slice(), r.availableGeometryIds = this._availableGeometryIds.slice(), r.nextIndexStart = this._nextIndexStart, r.nextVertexStart = this._nextVertexStart, r.geometryCount = this._geometryCount, r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.matricesTexture = this._matricesTexture.toJSON(e), r.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (r.boundingBox = this.boundingBox.toJSON()));
    function a(h, c) {
      return h[c.uuid] === void 0 && (h[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = a(e.geometries, this.geometry);
      const h = this.geometry.parameters;
      if (h !== void 0 && h.shapes !== void 0) {
        const c = h.shapes;
        if (Array.isArray(c))
          for (let l = 0, u = c.length; l < u; l++) {
            const f = c[l];
            a(e.shapes, f);
          }
        else
          a(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const h = [];
        for (let c = 0, l = this.material.length; c < l; c++)
          h.push(a(e.materials, this.material[c]));
        r.material = h;
      } else
        r.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let h = 0; h < this.children.length; h++)
        r.children.push(this.children[h].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let h = 0; h < this.animations.length; h++) {
        const c = this.animations[h];
        r.animations.push(a(e.animations, c));
      }
    }
    if (n) {
      const h = o(e.geometries), c = o(e.materials), l = o(e.textures), u = o(e.images), f = o(e.shapes), d = o(e.skeletons), p = o(e.animations), y = o(e.nodes);
      h.length > 0 && (s.geometries = h), c.length > 0 && (s.materials = c), l.length > 0 && (s.textures = l), u.length > 0 && (s.images = u), f.length > 0 && (s.shapes = f), d.length > 0 && (s.skeletons = d), p.length > 0 && (s.animations = p), y.length > 0 && (s.nodes = y);
    }
    return s.object = r, s;
    function o(h) {
      const c = [];
      for (const l in h) {
        const u = h[l];
        delete u.metadata, c.push(u);
      }
      return c;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let s = 0; s < e.children.length; s++) {
        const r = e.children[s];
        this.add(r.clone());
      }
    return this;
  }
}
dn.DEFAULT_UP = /* @__PURE__ */ new $(0, 1, 0);
dn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
dn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
class jb extends dn {
  /**
   * Constructs a new audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  /**
   * Returns the output audio node.
   *
   * @return {GainNode} The output node.
   */
  getOutput() {
    return this.gain;
  }
  /**
   * Sets the given audio node as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `audioNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {AudioNode} audioNode - The audio node like an instance of `OscillatorNode`.
   * @return {Audio} A reference to this instance.
   */
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  /**
   * Sets the given media element as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {HTMLMediaElement} mediaElement - The media element.
   * @return {Audio} A reference to this instance.
   */
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  /**
   * Sets the given media stream as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaStreamNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {MediaStream} mediaStream - The media stream.
   * @return {Audio} A reference to this instance.
   */
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  /**
   * Sets the given audio buffer as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `buffer` and {@link Audio#hasPlaybackControl} to `true`.
   *
   * @param {AudioBuffer} audioBuffer - The audio buffer.
   * @return {Audio} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  /**
   * Starts the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should start playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const n = this.context.createBufferSource();
    return n.buffer = this.buffer, n.loop = this.loop, n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.onended = this.onEnded.bind(this), n.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = n, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  /**
   * Pauses the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  /**
   * Stops the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should stop playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this;
  }
  /**
   * Connects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio} A reference to this instance.
   */
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, n = this.filters.length; e < n; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  /**
   * Disconnects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, n = this.filters.length; e < n; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  /**
   * Returns the current set filters.
   *
   * @return {Array<AudioNode>} The list of filters.
   */
  getFilters() {
    return this.filters;
  }
  /**
   * Sets an array of filters and connects them with the audio source.
   *
   * @param {Array<AudioNode>} [value] - A list of filters.
   * @return {Audio} A reference to this instance.
   */
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  /**
   * Defines the detuning of oscillation in cents.
   *
   * @param {number} value - The detuning of oscillation in cents.
   * @return {Audio} A reference to this instance.
   */
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  /**
   * Returns the detuning of oscillation in cents.
   *
   * @return {number} The detuning of oscillation in cents.
   */
  getDetune() {
    return this.detune;
  }
  /**
   * Returns the first filter in the list of filters.
   *
   * @return {AudioNode|undefined} The first filter in the list of filters.
   */
  getFilter() {
    return this.getFilters()[0];
  }
  /**
   * Applies a single filter node to the audio.
   *
   * @param {AudioNode} [filter] - The filter to set.
   * @return {Audio} A reference to this instance.
   */
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  /**
   * Sets the playback rate.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [value] - The playback rate to set.
   * @return {Audio|undefined} A reference to this instance.
   */
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  /**
  	 * Returns the current playback rate.
  
  	 * @return {number} The playback rate.
  	 */
  getPlaybackRate() {
    return this.playbackRate;
  }
  /**
   * Automatically called when playback finished.
   */
  onEnded() {
    this.isPlaying = !1, this._progress = 0;
  }
  /**
   * Returns the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {boolean} Whether the audio should loop or not.
   */
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  /**
   * Sets the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {boolean} value - Whether the audio should loop or not.
   * @return {Audio|undefined} A reference to this instance.
   */
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  /**
   * Sets the loop start value which defines where in the audio buffer the replay should
   * start, in seconds.
   *
   * @param {number} value - The loop start value.
   * @return {Audio} A reference to this instance.
   */
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  /**
   * Sets the loop end value which defines where in the audio buffer the replay should
   * stop, in seconds.
   *
   * @param {number} value - The loop end value.
   * @return {Audio} A reference to this instance.
   */
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  /**
   * Returns the volume.
   *
   * @return {number} The volume.
   */
  getVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the volume.
   *
   * @param {number} value - The volume to set.
   * @return {Audio} A reference to this instance.
   */
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  copy(e, n) {
    return super.copy(e, n), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this);
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
class KB {
  /**
   * Constructs a new audio analyzer.
   *
   * @param {Audio} audio - The audio to analyze.
   * @param {number} [fftSize=2048] - The window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data.
   */
  constructor(e, n = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = n, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  /**
   * Returns an array with frequency data of the audio.
   *
   * Each item in the array represents the decibel value for a specific frequency.
   * The frequencies are spread linearly from 0 to 1/2 of the sample rate.
   * For example, for 48000 sample rate, the last item of the array will represent
   * the decibel value for 24000 Hz.
   *
   * @return {Uint8Array} The frequency data.
   */
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  /**
   * Returns the average of the frequencies returned by {@link AudioAnalyser#getFrequencyData}.
   *
   * @return {number} The average frequency.
   */
  getAverageFrequency() {
    let e = 0;
    const n = this.getFrequencyData();
    for (let s = 0; s < n.length; s++)
      e += n[s];
    return e / n.length;
  }
}
let Ac;
class Hb {
  /**
   * Returns the global native audio context.
   *
   * @return {AudioContext} The native audio context.
   */
  static getContext() {
    return Ac === void 0 && (Ac = new (window.AudioContext || window.webkitAudioContext)()), Ac;
  }
  /**
   * Allows to set the global native audio context from outside.
   *
   * @param {AudioContext} value - The native context to set.
   */
  static setContext(e) {
    Ac = e;
  }
}
class Xb {
  /**
   * Constructs a new clock.
   *
   * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
   * `getDelta()` is called for the first time.
   */
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  /**
   * Starts the clock. When `autoStart` is set to `true`, the method is automatically
   * called by the class.
   */
  start() {
    this.startTime = performance.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  /**
   * Stops the clock.
   */
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  /**
   * Returns the elapsed time in seconds.
   *
   * @return {number} The elapsed time.
   */
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  /**
   * Returns the delta time in seconds.
   *
   * @return {number} The delta time.
   */
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const n = performance.now();
      e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e;
    }
    return e;
  }
}
const $s = /* @__PURE__ */ new $(), gf = /* @__PURE__ */ new fn(), tD = /* @__PURE__ */ new $(), Vs = /* @__PURE__ */ new $(), Gs = /* @__PURE__ */ new $();
class eD extends dn {
  /**
   * Constructs a new audio listener.
   */
  constructor() {
    super(), this.type = "AudioListener", this.context = Hb.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Xb();
  }
  /**
   * Returns the listener's input node.
   *
   * This method is used by other audio nodes to connect to this listener.
   *
   * @return {GainNode} The input node.
   */
  getInput() {
    return this.gain;
  }
  /**
   * Removes the current filter from this listener.
   *
   * @return {AudioListener} A reference to this listener.
   */
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  /**
   * Returns the current set filter.
   *
   * @return {?AudioNode} The filter.
   */
  getFilter() {
    return this.filter;
  }
  /**
   * Sets the given filter to this listener.
   *
   * @param {AudioNode} value - The filter to set.
   * @return {AudioListener} A reference to this listener.
   */
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  /**
   * Returns the applications master volume.
   *
   * @return {number} The master volume.
   */
  getMasterVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the applications master volume. This volume setting affects
   * all audio nodes in the scene.
   *
   * @param {number} value - The master volume to set.
   * @return {AudioListener} A reference to this listener.
   */
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const n = this.context.listener;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose($s, gf, tD), Vs.set(0, 0, -1).applyQuaternion(gf), Gs.set(0, 1, 0).applyQuaternion(gf), n.positionX) {
      const s = this.context.currentTime + this.timeDelta;
      n.positionX.linearRampToValueAtTime($s.x, s), n.positionY.linearRampToValueAtTime($s.y, s), n.positionZ.linearRampToValueAtTime($s.z, s), n.forwardX.linearRampToValueAtTime(Vs.x, s), n.forwardY.linearRampToValueAtTime(Vs.y, s), n.forwardZ.linearRampToValueAtTime(Vs.z, s), n.upX.linearRampToValueAtTime(Gs.x, s), n.upY.linearRampToValueAtTime(Gs.y, s), n.upZ.linearRampToValueAtTime(Gs.z, s);
    } else
      n.setPosition($s.x, $s.y, $s.z), n.setOrientation(Vs.x, Vs.y, Vs.z, Gs.x, Gs.y, Gs.z);
  }
}
const Us = /* @__PURE__ */ new $(), xg = /* @__PURE__ */ new fn(), nD = /* @__PURE__ */ new $(), Ws = /* @__PURE__ */ new $();
class iD extends jb {
  /**
   * Constructs a positional audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  /**
   * Returns the current reference distance.
   *
   * @return {number} The reference distance.
   */
  getRefDistance() {
    return this.panner.refDistance;
  }
  /**
   * Defines the reference distance for reducing volume as the audio source moves
   * further from the listener – i.e. the distance at which the volume reduction
   * starts taking effect.
   *
   * @param {number} value - The reference distance to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  /**
   * Returns the current rolloff factor.
   *
   * @return {number} The rolloff factor.
   */
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  /**
   * Defines how quickly the volume is reduced as the source moves away from the listener.
   *
   * @param {number} value - The rolloff factor.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  /**
   * Returns the current distance model.
   *
   * @return {('linear'|'inverse'|'exponential')} The distance model.
   */
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  /**
   * Defines which algorithm to use to reduce the volume of the audio source
   * as it moves away from the listener.
   *
   * Read [the spec]{@link https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype}
   * for more details.
   *
   * @param {('linear'|'inverse'|'exponential')} value - The distance model to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  /**
   * Returns the current max distance.
   *
   * @return {number} The max distance.
   */
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  /**
   * Defines the maximum distance between the audio source and the listener,
   * after which the volume is not reduced any further.
   *
   * This value is used only by the `linear` distance model.
   *
   * @param {number} value - The max distance.
   * @return {PositionalAudio} A reference to this instance.
   */
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  /**
   * Sets the directional cone in which the audio can be listened.
   *
   * @param {number} coneInnerAngle - An angle, in degrees, of a cone inside of which there will be no volume reduction.
   * @param {number} coneOuterAngle - An angle, in degrees, of a cone outside of which the volume will be reduced by a constant value, defined by the `coneOuterGain` parameter.
   * @param {number} coneOuterGain - The amount of volume reduction outside the cone defined by the `coneOuterAngle`. When set to `0`, no sound can be heard.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDirectionalCone(e, n, s) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = n, this.panner.coneOuterGain = s, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Us, xg, nD), Ws.set(0, 0, 1).applyQuaternion(xg);
    const n = this.panner;
    if (n.positionX) {
      const s = this.context.currentTime + this.listener.timeDelta;
      n.positionX.linearRampToValueAtTime(Us.x, s), n.positionY.linearRampToValueAtTime(Us.y, s), n.positionZ.linearRampToValueAtTime(Us.z, s), n.orientationX.linearRampToValueAtTime(Ws.x, s), n.orientationY.linearRampToValueAtTime(Ws.y, s), n.orientationZ.linearRampToValueAtTime(Ws.z, s);
    } else
      n.setPosition(Us.x, Us.y, Us.z), n.setOrientation(Ws.x, Ws.y, Ws.z);
  }
}
class C1 extends dn {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ve(), this.projectionMatrix = new ve(), this.projectionMatrixInverse = new ve(), this.coordinateSystem = mi;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class it {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(e = 0, n = 0) {
    it.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(e) {
    const n = this.x, s = this.y, r = e.elements;
    return this.x = r[0] * n + r[3] * s + r[6], this.y = r[1] * n + r[4] * s + r[7], this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(e, n) {
    return this.x = zt(this.x, e.x, n.x), this.y = zt(this.y, e.y, n.y), this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(e, n) {
    return this.x = zt(this.x, e, n), this.y = zt(this.y, e, n), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(e, n) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(zt(s, e, n));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const s = this.dot(e) / n;
    return Math.acos(zt(s, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const n = this.x - e.x, s = this.y - e.y;
    return n * n + s * s;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(e, n, s) {
    return this.x = e.x + (n.x - e.x) * s, this.y = e.y + (n.y - e.y) * s, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(e, n) {
    const s = Math.cos(n), r = Math.sin(n), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * s - o * r + e.x, this.y = a * r + o * s + e.y, this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
const ns = /* @__PURE__ */ new $(), gg = /* @__PURE__ */ new it(), mg = /* @__PURE__ */ new it();
class di extends C1 {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = 50, n = 1, s = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = s, this.far = r, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = Wl * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const e = Math.tan(wr * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return Wl * 2 * Math.atan(
      Math.tan(wr * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(e, n, s) {
    ns.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(ns.x, ns.y).multiplyScalar(-e / ns.z), ns.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), s.set(ns.x, ns.y).multiplyScalar(-e / ns.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, gg, mg), n.subVectors(mg, gg);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(e, n, s, r, a, o) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = s, this.view.offsetY = r, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(wr * 0.5 * this.fov) / this.zoom, s = 2 * n, r = this.aspect * s, a = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = o.fullWidth, l = o.fullHeight;
      a += o.offsetX * r / c, n -= o.offsetY * s / l, r *= o.width / c, s *= o.height / l;
    }
    const h = this.filmOffset;
    h !== 0 && (a += e * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + r, n, n - s, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
class sD extends di {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e;
  }
}
const Yr = -90, jr = 1;
class rD extends dn {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(e, n, s) {
    super(), this.type = "CubeCamera", this.renderTarget = s, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new di(Yr, jr, e, n);
    r.layers = this.layers, this.add(r);
    const a = new di(Yr, jr, e, n);
    a.layers = this.layers, this.add(a);
    const o = new di(Yr, jr, e, n);
    o.layers = this.layers, this.add(o);
    const h = new di(Yr, jr, e, n);
    h.layers = this.layers, this.add(h);
    const c = new di(Yr, jr, e, n);
    c.layers = this.layers, this.add(c);
    const l = new di(Yr, jr, e, n);
    l.layers = this.layers, this.add(l);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [s, r, a, o, h, c] = n;
    for (const l of n) this.remove(l);
    if (e === mi)
      s.up.set(0, 1, 0), s.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), h.up.set(0, 1, 0), h.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === xh)
      s.up.set(0, -1, 0), s.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), h.up.set(0, -1, 0), h.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const l of n)
      this.add(l), l.updateMatrixWorld();
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: s, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, h, c, l, u] = this.children, f = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), y = e.xr.enabled;
    e.xr.enabled = !1;
    const x = s.texture.generateMipmaps;
    s.texture.generateMipmaps = !1, e.setRenderTarget(s, 0, r), e.render(n, a), e.setRenderTarget(s, 1, r), e.render(n, o), e.setRenderTarget(s, 2, r), e.render(n, h), e.setRenderTarget(s, 3, r), e.render(n, c), e.setRenderTarget(s, 4, r), e.render(n, l), s.texture.generateMipmaps = x, e.setRenderTarget(s, 5, r), e.render(n, u), e.setRenderTarget(f, d, p), e.xr.enabled = y, s.texture.needsPMREMUpdate = !0;
  }
}
class aD extends C1 {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = -1, n = 1, s = 1, r = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = s, this.bottom = r, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(e, n, s, r, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = s, this.view.offsetY = r, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), s = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let a = s - e, o = s + e, h = r + n, c = r - n;
    if (this.view !== null && this.view.enabled) {
      const l = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += l * this.view.offsetX, o = a + l * this.view.width, h -= u * this.view.offsetY, c = h - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, h, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const vg = /* @__PURE__ */ new ve(), wg = /* @__PURE__ */ new ve(), Ys = /* @__PURE__ */ new ve();
class oD {
  /**
   * Constructs a new stereo camera.
   */
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new di(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new di(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  /**
   * Updates the stereo camera based on the given perspective camera.
   *
   * @param {PerspectiveCamera} camera - The perspective camera.
   */
  update(e) {
    const n = this._cache;
    if (n.focus !== e.focus || n.fov !== e.fov || n.aspect !== e.aspect * this.aspect || n.near !== e.near || n.far !== e.far || n.zoom !== e.zoom || n.eyeSep !== this.eyeSep) {
      n.focus = e.focus, n.fov = e.fov, n.aspect = e.aspect * this.aspect, n.near = e.near, n.far = e.far, n.zoom = e.zoom, n.eyeSep = this.eyeSep, Ys.copy(e.projectionMatrix);
      const r = n.eyeSep / 2, a = r * n.near / n.focus, o = n.near * Math.tan(wr * n.fov * 0.5) / n.zoom;
      let h, c;
      wg.elements[12] = -r, vg.elements[12] = r, h = -o * n.aspect + a, c = o * n.aspect + a, Ys.elements[0] = 2 * n.near / (c - h), Ys.elements[8] = (c + h) / (c - h), this.cameraL.projectionMatrix.copy(Ys), h = -o * n.aspect - a, c = o * n.aspect - a, Ys.elements[0] = 2 * n.near / (c - h), Ys.elements[8] = (c + h) / (c - h), this.cameraR.projectionMatrix.copy(Ys);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(wg), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(vg);
  }
}
const qi = /* @__PURE__ */ hD();
function hD() {
  const i = new ArrayBuffer(4), e = new Float32Array(i), n = new Uint32Array(i), s = new Uint32Array(512), r = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const l = c - 127;
    l < -27 ? (s[c] = 0, s[c | 256] = 32768, r[c] = 24, r[c | 256] = 24) : l < -14 ? (s[c] = 1024 >> -l - 14, s[c | 256] = 1024 >> -l - 14 | 32768, r[c] = -l - 1, r[c | 256] = -l - 1) : l <= 15 ? (s[c] = l + 15 << 10, s[c | 256] = l + 15 << 10 | 32768, r[c] = 13, r[c | 256] = 13) : l < 128 ? (s[c] = 31744, s[c | 256] = 64512, r[c] = 24, r[c | 256] = 24) : (s[c] = 31744, s[c | 256] = 64512, r[c] = 13, r[c | 256] = 13);
  }
  const a = new Uint32Array(2048), o = new Uint32Array(64), h = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let l = c << 13, u = 0;
    for (; (l & 8388608) === 0; )
      l <<= 1, u -= 8388608;
    l &= -8388609, u += 947912704, a[c] = l | u;
  }
  for (let c = 1024; c < 2048; ++c)
    a[c] = 939524096 + (c - 1024 << 13);
  for (let c = 1; c < 31; ++c)
    o[c] = c << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let c = 33; c < 63; ++c)
    o[c] = 2147483648 + (c - 32 << 23);
  o[63] = 3347054592;
  for (let c = 1; c < 64; ++c)
    c !== 32 && (h[c] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: s,
    shiftTable: r,
    mantissaTable: a,
    exponentTable: o,
    offsetTable: h
  };
}
function rn(i) {
  Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = zt(i, -65504, 65504), qi.floatView[0] = i;
  const e = qi.uint32View[0], n = e >> 23 & 511;
  return qi.baseTable[n] + ((e & 8388607) >> qi.shiftTable[n]);
}
function Co(i) {
  const e = i >> 10;
  return qi.uint32View[0] = qi.mantissaTable[qi.offsetTable[e] + (i & 1023)] + qi.exponentTable[e], qi.floatView[0];
}
class cD {
  /**
   * Returns a half precision floating point value (FP16) from the given single
   * precision floating point value (FP32).
   *
   * @param {number} val - A single precision floating point value.
   * @return {number} The FP16 value.
   */
  static toHalfFloat(e) {
    return rn(e);
  }
  /**
   * Returns a single precision floating point value (FP32) from the given half
   * precision floating point value (FP16).
   *
   * @param {number} val - A half precision floating point value.
   * @return {number} The FP32 value.
   */
  static fromHalfFloat(e) {
    return Co(e);
  }
}
const ge = /* @__PURE__ */ new $(), Pc = /* @__PURE__ */ new it();
let lD = 0;
class tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: lD++ }), this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = s, this.usage = yh, this.updateRanges = [], this.gpuType = g1, this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(e, n, s) {
    e *= this.itemSize, s *= n.itemSize;
    for (let r = 0, a = this.itemSize; r < a; r++)
      this.array[e + r] = n.array[s + r];
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(e) {
    return this.array.set(e), this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, s = this.count; n < s; n++)
        Pc.fromBufferAttribute(this, n), Pc.applyMatrix3(e), this.setXY(n, Pc.x, Pc.y);
    else if (this.itemSize === 3)
      for (let n = 0, s = this.count; n < s; n++)
        ge.fromBufferAttribute(this, n), ge.applyMatrix3(e), this.setXYZ(n, ge.x, ge.y, ge.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let n = 0, s = this.count; n < s; n++)
      ge.fromBufferAttribute(this, n), ge.applyMatrix4(e), this.setXYZ(n, ge.x, ge.y, ge.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let n = 0, s = this.count; n < s; n++)
      ge.fromBufferAttribute(this, n), ge.applyNormalMatrix(e), this.setXYZ(n, ge.x, ge.y, ge.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let n = 0, s = this.count; n < s; n++)
      ge.fromBufferAttribute(this, n), ge.transformDirection(e), this.setXYZ(n, ge.x, ge.y, ge.z);
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, n) {
    let s = this.array[e * this.itemSize + n];
    return this.normalized && (s = Ke(s, this.array)), s;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(e, n, s) {
    return this.normalized && (s = At(s, this.array)), this.array[e * this.itemSize + n] = s, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(e, n, s) {
    return e *= this.itemSize, this.normalized && (n = At(n, this.array), s = At(s, this.array)), this.array[e + 0] = n, this.array[e + 1] = s, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(e, n, s, r) {
    return e *= this.itemSize, this.normalized && (n = At(n, this.array), s = At(s, this.array), r = At(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = s, this.array[e + 2] = r, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(e, n, s, r, a) {
    return e *= this.itemSize, this.normalized && (n = At(n, this.array), s = At(s, this.array), r = At(r, this.array), a = At(a, this.array)), this.array[e + 0] = n, this.array[e + 1] = s, this.array[e + 2] = r, this.array[e + 3] = a, this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== yh && (e.usage = this.usage), e;
  }
}
class uD extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Int8Array(e), n, s);
  }
}
class fD extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Uint8Array(e), n, s);
  }
}
class dD extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8ClampedArray)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Uint8ClampedArray(e), n, s);
  }
}
class pD extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Int16Array(e), n, s);
  }
}
class Zb extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Uint16Array(e), n, s);
  }
}
class yD extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Int32Array(e), n, s);
  }
}
class Jb extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Uint32Array(e), n, s);
  }
}
class xD extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Uint16Array(e), n, s), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let n = Co(this.array[e * this.itemSize]);
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize] = rn(n), this;
  }
  getY(e) {
    let n = Co(this.array[e * this.itemSize + 1]);
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + 1] = rn(n), this;
  }
  getZ(e) {
    let n = Co(this.array[e * this.itemSize + 2]);
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + 2] = rn(n), this;
  }
  getW(e) {
    let n = Co(this.array[e * this.itemSize + 3]);
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = At(n, this.array)), this.array[e * this.itemSize + 3] = rn(n), this;
  }
  setXY(e, n, s) {
    return e *= this.itemSize, this.normalized && (n = At(n, this.array), s = At(s, this.array)), this.array[e + 0] = rn(n), this.array[e + 1] = rn(s), this;
  }
  setXYZ(e, n, s, r) {
    return e *= this.itemSize, this.normalized && (n = At(n, this.array), s = At(s, this.array), r = At(r, this.array)), this.array[e + 0] = rn(n), this.array[e + 1] = rn(s), this.array[e + 2] = rn(r), this;
  }
  setXYZW(e, n, s, r, a) {
    return e *= this.itemSize, this.normalized && (n = At(n, this.array), s = At(s, this.array), r = At(r, this.array), a = At(a, this.array)), this.array[e + 0] = rn(n), this.array[e + 1] = rn(s), this.array[e + 2] = rn(r), this.array[e + 3] = rn(a), this;
  }
}
class St extends tn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s) {
    super(new Float32Array(e), n, s);
  }
}
class Da {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new $(1 / 0, 1 / 0, 1 / 0), n = new $(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, s = e.length; n < s; n += 3)
      this.expandByPoint(Gn.fromArray(e, n));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, s = e.count; n < s; n++)
      this.expandByPoint(Gn.fromBufferAttribute(e, n));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, s = e.length; n < s; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(e, n) {
    const s = Gn.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(s), this.max.copy(e).add(s), this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const s = e.geometry;
    if (s !== void 0) {
      const a = s.getAttribute("position");
      if (n === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, h = a.count; o < h; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, Gn) : Gn.fromBufferAttribute(a, o), Gn.applyMatrix4(e.matrixWorld), this.expandByPoint(Gn);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Ic.copy(e.boundingBox)) : (s.boundingBox === null && s.computeBoundingBox(), Ic.copy(s.boundingBox)), Ic.applyMatrix4(e.matrixWorld), this.union(Ic);
    }
    const r = e.children;
    for (let a = 0, o = r.length; a < o; a++)
      this.expandByObject(r[a], n);
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(e) {
    return this.clampPoint(e.center, Gn), Gn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(e) {
    let n, s;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, s = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, s = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, s += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, s += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, s += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, s += e.normal.z * this.min.z), n <= -e.constant && s >= -e.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ro), Rc.subVectors(this.max, ro), Hr.subVectors(e.a, ro), Xr.subVectors(e.b, ro), Zr.subVectors(e.c, ro), is.subVectors(Xr, Hr), ss.subVectors(Zr, Xr), js.subVectors(Hr, Zr);
    let n = [
      0,
      -is.z,
      is.y,
      0,
      -ss.z,
      ss.y,
      0,
      -js.z,
      js.y,
      is.z,
      0,
      -is.x,
      ss.z,
      0,
      -ss.x,
      js.z,
      0,
      -js.x,
      -is.y,
      is.x,
      0,
      -ss.y,
      ss.x,
      0,
      -js.y,
      js.x,
      0
    ];
    return !mf(n, Hr, Xr, Zr, Rc) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !mf(n, Hr, Xr, Zr, Rc)) ? !1 : (Oc.crossVectors(is, ss), n = [Oc.x, Oc.y, Oc.z], mf(n, Hr, Xr, Zr, Rc));
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, Gn).distanceTo(e);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Gn).length() * 0.5), e;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Pi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Pi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Pi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Pi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Pi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Pi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Pi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Pi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Pi), this);
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @param {Object} json - The serialized json to set the box from.
   * @return {Box3} A reference to this bounding box.
   */
  fromJSON(e) {
    return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
  }
}
const Pi = [
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $(),
  /* @__PURE__ */ new $()
], Gn = /* @__PURE__ */ new $(), Ic = /* @__PURE__ */ new Da(), Hr = /* @__PURE__ */ new $(), Xr = /* @__PURE__ */ new $(), Zr = /* @__PURE__ */ new $(), is = /* @__PURE__ */ new $(), ss = /* @__PURE__ */ new $(), js = /* @__PURE__ */ new $(), ro = /* @__PURE__ */ new $(), Rc = /* @__PURE__ */ new $(), Oc = /* @__PURE__ */ new $(), Hs = /* @__PURE__ */ new $();
function mf(i, e, n, s, r) {
  for (let a = 0, o = i.length - 3; a <= o; a += 3) {
    Hs.fromArray(i, a);
    const h = r.x * Math.abs(Hs.x) + r.y * Math.abs(Hs.y) + r.z * Math.abs(Hs.z), c = e.dot(Hs), l = n.dot(Hs), u = s.dot(Hs);
    if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > h)
      return !1;
  }
  return !0;
}
const gD = /* @__PURE__ */ new Da(), ao = /* @__PURE__ */ new $(), vf = /* @__PURE__ */ new $();
class A1 {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(e = new $(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(e, n) {
    const s = this.center;
    n !== void 0 ? s.copy(n) : gD.setFromPoints(e).getCenter(s);
    let r = 0;
    for (let a = 0, o = e.length; a < o; a++)
      r = Math.max(r, s.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(r), this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, n) {
    const s = this.center.distanceToSquared(e);
    return n.copy(e), s > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(e) {
    return this.center.add(e), this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    ao.subVectors(e, this.center);
    const n = ao.lengthSq();
    if (n > this.radius * this.radius) {
      const s = Math.sqrt(n), r = (s - this.radius) * 0.5;
      this.center.addScaledVector(ao, r / s), this.radius += r;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (vf.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(ao.copy(e.center).add(vf)), this.expandByPoint(ao.copy(e.center).sub(vf))), this);
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @param {Object} json - The serialized json to set the sphere from.
   * @return {Box3} A reference to this bounding sphere.
   */
  fromJSON(e) {
    return this.radius = e.radius, this.center.fromArray(e.center), this;
  }
}
function mD(i) {
  for (let e = i.length - 1; e >= 0; --e)
    if (i[e] >= 65535) return !0;
  return !1;
}
function td(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function vD() {
  const i = td("canvas");
  return i.style.display = "block", i;
}
const Mg = {};
function bg(i) {
  i in Mg || (Mg[i] = !0, console.warn(i));
}
let wD = 0;
const Tn = /* @__PURE__ */ new ve(), wf = /* @__PURE__ */ new dn(), Jr = /* @__PURE__ */ new $(), mn = /* @__PURE__ */ new Da(), oo = /* @__PURE__ */ new Da(), Ee = /* @__PURE__ */ new $();
class Me extends Es {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: wD++ }), this.uuid = ni(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (mD(e) ? Jb : Zb)(e, 1) : this.index = e, this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(e) {
    return this.indirect = e, this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(e, n, s = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: s
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const s = this.attributes.normal;
    if (s !== void 0) {
      const a = new Si().getNormalMatrix(e);
      s.applyNormalMatrix(a), s.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(e) {
    return Tn.makeRotationFromQuaternion(e), this.applyMatrix4(Tn), this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(e) {
    return Tn.makeRotationX(e), this.applyMatrix4(Tn), this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(e) {
    return Tn.makeRotationY(e), this.applyMatrix4(Tn), this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(e) {
    return Tn.makeRotationZ(e), this.applyMatrix4(Tn), this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(e, n, s) {
    return Tn.makeTranslation(e, n, s), this.applyMatrix4(Tn), this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(e, n, s) {
    return Tn.makeScale(e, n, s), this.applyMatrix4(Tn), this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(e) {
    return wf.lookAt(e), wf.updateMatrix(), this.applyMatrix4(wf.matrix), this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Jr).negate(), this.translate(Jr.x, Jr.y, Jr.z), this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const s = [];
      for (let r = 0, a = e.length; r < a; r++) {
        const o = e[r];
        s.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new St(s, 3));
    } else {
      const s = Math.min(e.length, n.count);
      for (let r = 0; r < s; r++) {
        const a = e[r];
        n.setXYZ(r, a.x, a.y, a.z || 0);
      }
      e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Da());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new $(-1 / 0, -1 / 0, -1 / 0),
        new $(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let s = 0, r = n.length; s < r; s++) {
          const a = n[s];
          mn.setFromBufferAttribute(a), this.morphTargetsRelative ? (Ee.addVectors(this.boundingBox.min, mn.min), this.boundingBox.expandByPoint(Ee), Ee.addVectors(this.boundingBox.max, mn.max), this.boundingBox.expandByPoint(Ee)) : (this.boundingBox.expandByPoint(mn.min), this.boundingBox.expandByPoint(mn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new A1());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new $(), 1 / 0);
      return;
    }
    if (e) {
      const s = this.boundingSphere.center;
      if (mn.setFromBufferAttribute(e), n)
        for (let a = 0, o = n.length; a < o; a++) {
          const h = n[a];
          oo.setFromBufferAttribute(h), this.morphTargetsRelative ? (Ee.addVectors(mn.min, oo.min), mn.expandByPoint(Ee), Ee.addVectors(mn.max, oo.max), mn.expandByPoint(Ee)) : (mn.expandByPoint(oo.min), mn.expandByPoint(oo.max));
        }
      mn.getCenter(s);
      let r = 0;
      for (let a = 0, o = e.count; a < o; a++)
        Ee.fromBufferAttribute(e, a), r = Math.max(r, s.distanceToSquared(Ee));
      if (n)
        for (let a = 0, o = n.length; a < o; a++) {
          const h = n[a], c = this.morphTargetsRelative;
          for (let l = 0, u = h.count; l < u; l++)
            Ee.fromBufferAttribute(h, l), c && (Jr.fromBufferAttribute(e, l), Ee.add(Jr)), r = Math.max(r, s.distanceToSquared(Ee));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const s = n.position, r = n.normal, a = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new tn(new Float32Array(4 * s.count), 4));
    const o = this.getAttribute("tangent"), h = [], c = [];
    for (let M = 0; M < s.count; M++)
      h[M] = new $(), c[M] = new $();
    const l = new $(), u = new $(), f = new $(), d = new it(), p = new it(), y = new it(), x = new $(), g = new $();
    function m(M, _, T) {
      l.fromBufferAttribute(s, M), u.fromBufferAttribute(s, _), f.fromBufferAttribute(s, T), d.fromBufferAttribute(a, M), p.fromBufferAttribute(a, _), y.fromBufferAttribute(a, T), u.sub(l), f.sub(l), p.sub(d), y.sub(d);
      const C = 1 / (p.x * y.y - y.x * p.y);
      isFinite(C) && (x.copy(u).multiplyScalar(y.y).addScaledVector(f, -p.y).multiplyScalar(C), g.copy(f).multiplyScalar(p.x).addScaledVector(u, -y.x).multiplyScalar(C), h[M].add(x), h[_].add(x), h[T].add(x), c[M].add(g), c[_].add(g), c[T].add(g));
    }
    let v = this.groups;
    v.length === 0 && (v = [{
      start: 0,
      count: e.count
    }]);
    for (let M = 0, _ = v.length; M < _; ++M) {
      const T = v[M], C = T.start, P = T.count;
      for (let R = C, k = C + P; R < k; R += 3)
        m(
          e.getX(R + 0),
          e.getX(R + 1),
          e.getX(R + 2)
        );
    }
    const w = new $(), b = new $(), S = new $(), E = new $();
    function A(M) {
      S.fromBufferAttribute(r, M), E.copy(S);
      const _ = h[M];
      w.copy(_), w.sub(S.multiplyScalar(S.dot(_))).normalize(), b.crossVectors(E, _);
      const C = b.dot(c[M]) < 0 ? -1 : 1;
      o.setXYZW(M, w.x, w.y, w.z, C);
    }
    for (let M = 0, _ = v.length; M < _; ++M) {
      const T = v[M], C = T.start, P = T.count;
      for (let R = C, k = C + P; R < k; R += 3)
        A(e.getX(R + 0)), A(e.getX(R + 1)), A(e.getX(R + 2));
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let s = this.getAttribute("normal");
      if (s === void 0)
        s = new tn(new Float32Array(n.count * 3), 3), this.setAttribute("normal", s);
      else
        for (let d = 0, p = s.count; d < p; d++)
          s.setXYZ(d, 0, 0, 0);
      const r = new $(), a = new $(), o = new $(), h = new $(), c = new $(), l = new $(), u = new $(), f = new $();
      if (e)
        for (let d = 0, p = e.count; d < p; d += 3) {
          const y = e.getX(d + 0), x = e.getX(d + 1), g = e.getX(d + 2);
          r.fromBufferAttribute(n, y), a.fromBufferAttribute(n, x), o.fromBufferAttribute(n, g), u.subVectors(o, a), f.subVectors(r, a), u.cross(f), h.fromBufferAttribute(s, y), c.fromBufferAttribute(s, x), l.fromBufferAttribute(s, g), h.add(u), c.add(u), l.add(u), s.setXYZ(y, h.x, h.y, h.z), s.setXYZ(x, c.x, c.y, c.z), s.setXYZ(g, l.x, l.y, l.z);
        }
      else
        for (let d = 0, p = n.count; d < p; d += 3)
          r.fromBufferAttribute(n, d + 0), a.fromBufferAttribute(n, d + 1), o.fromBufferAttribute(n, d + 2), u.subVectors(o, a), f.subVectors(r, a), u.cross(f), s.setXYZ(d + 0, u.x, u.y, u.z), s.setXYZ(d + 1, u.x, u.y, u.z), s.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), s.needsUpdate = !0;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, s = e.count; n < s; n++)
      Ee.fromBufferAttribute(e, n), Ee.normalize(), e.setXYZ(n, Ee.x, Ee.y, Ee.z);
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function e(h, c) {
      const l = h.array, u = h.itemSize, f = h.normalized, d = new l.constructor(c.length * u);
      let p = 0, y = 0;
      for (let x = 0, g = c.length; x < g; x++) {
        h.isInterleavedBufferAttribute ? p = c[x] * h.data.stride + h.offset : p = c[x] * u;
        for (let m = 0; m < u; m++)
          d[y++] = l[p++];
      }
      return new tn(d, u, f);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new Me(), s = this.index.array, r = this.attributes;
    for (const h in r) {
      const c = r[h], l = e(c, s);
      n.setAttribute(h, l);
    }
    const a = this.morphAttributes;
    for (const h in a) {
      const c = [], l = a[h];
      for (let u = 0, f = l.length; u < f; u++) {
        const d = l[u], p = e(d, s);
        c.push(p);
      }
      n.morphAttributes[h] = c;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let h = 0, c = o.length; h < c; h++) {
      const l = o[h];
      n.addGroup(l.start, l.count, l.materialIndex);
    }
    return n;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const l in c)
        c[l] !== void 0 && (e[l] = c[l]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const s = this.attributes;
    for (const c in s) {
      const l = s[c];
      e.data.attributes[c] = l.toJSON(e.data);
    }
    const r = {};
    let a = !1;
    for (const c in this.morphAttributes) {
      const l = this.morphAttributes[c], u = [];
      for (let f = 0, d = l.length; f < d; f++) {
        const p = l[f];
        u.push(p.toJSON(e.data));
      }
      u.length > 0 && (r[c] = u, a = !0);
    }
    a && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const h = this.boundingSphere;
    return h !== null && (e.data.boundingSphere = h.toJSON()), e;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const s = e.index;
    s !== null && this.setIndex(s.clone());
    const r = e.attributes;
    for (const l in r) {
      const u = r[l];
      this.setAttribute(l, u.clone(n));
    }
    const a = e.morphAttributes;
    for (const l in a) {
      const u = [], f = a[l];
      for (let d = 0, p = f.length; d < p; d++)
        u.push(f[d].clone(n));
      this.morphAttributes[l] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const f = o[l];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const h = e.boundingBox;
    h !== null && (this.boundingBox = h.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class MD {
  /**
   * Constructs a new GL buffer attribute.
   *
   * @param {WebGLBuffer} buffer - The native WebGL buffer.
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} itemSize - The item size.
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @param {number} count - The expected number of vertices in VBO.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s, r, a, o = !1) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = n, this.itemSize = s, this.elementSize = r, this.count = a, this.normalized = o, this.version = 0;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the given native WebGL buffer.
   *
   * @param {WebGLBuffer} buffer - The buffer to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this;
  }
  /**
   * Sets the given native data type and element size.
   *
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @return {BufferAttribute} A reference to this instance.
   */
  setType(e, n) {
    return this.type = e, this.elementSize = n, this;
  }
  /**
   * Sets the item size.
   *
   * @param {number} itemSize - The item size.
   * @return {BufferAttribute} A reference to this instance.
   */
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  /**
   * Sets the count (the expected number of vertices in VBO).
   *
   * @param {number} count - The count.
   * @return {BufferAttribute} A reference to this instance.
   */
  setCount(e) {
    return this.count = e, this;
  }
}
class bD extends tn {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(e, n, s, r = 1) {
    super(e, n, s), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class _D extends Me {
  /**
   * Constructs a new instanced buffer geometry.
   */
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class Qb {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(e, n) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = n, this.count = e !== void 0 ? e.length / n : 0, this.usage = yh, this.updateRanges = [], this.version = 0, this.uuid = ni();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(e, n, s) {
    e *= this.stride, s *= n.stride;
    for (let r = 0, a = this.stride; r < a; r++)
      this.array[e + r] = n.array[s + r];
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ni()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const n = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), s = new this.constructor(n, this.stride);
    return s.setUsage(this.usage), s;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ni()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
class SD extends Qb {
  /**
   * Constructs a new instanced interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
   */
  constructor(e, n, s = 1) {
    super(e, n), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const n = super.clone(e);
    return n.meshPerAttribute = this.meshPerAttribute, n;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.isInstancedInterleavedBuffer = !0, n.meshPerAttribute = this.meshPerAttribute, n;
  }
}
const Ye = /* @__PURE__ */ new $();
class P1 {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, n, s, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = n, this.offset = s, this.normalized = r;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let n = 0, s = this.data.count; n < s; n++)
      Ye.fromBufferAttribute(this, n), Ye.applyMatrix4(e), this.setXYZ(n, Ye.x, Ye.y, Ye.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let n = 0, s = this.count; n < s; n++)
      Ye.fromBufferAttribute(this, n), Ye.applyNormalMatrix(e), this.setXYZ(n, Ye.x, Ye.y, Ye.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let n = 0, s = this.count; n < s; n++)
      Ye.fromBufferAttribute(this, n), Ye.transformDirection(e), this.setXYZ(n, Ye.x, Ye.y, Ye.z);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, n) {
    let s = this.array[e * this.data.stride + this.offset + n];
    return this.normalized && (s = Ke(s, this.array)), s;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(e, n, s) {
    return this.normalized && (s = At(s, this.array)), this.data.array[e * this.data.stride + this.offset + n] = s, this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(e, n) {
    return this.normalized && (n = At(n, this.array)), this.data.array[e * this.data.stride + this.offset] = n, this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(e, n) {
    return this.normalized && (n = At(n, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = n, this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(e, n) {
    return this.normalized && (n = At(n, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = n, this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(e, n) {
    return this.normalized && (n = At(n, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = n, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let n = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (n = Ke(n, this.array)), n;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(e, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (n = At(n, this.array), s = At(s, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = s, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(e, n, s, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (n = At(n, this.array), s = At(s, this.array), r = At(r, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = s, this.data.array[e + 2] = r, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(e, n, s, r, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (n = At(n, this.array), s = At(s, this.array), r = At(r, this.array), a = At(a, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = s, this.data.array[e + 2] = r, this.data.array[e + 3] = a, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const n = [];
      for (let s = 0; s < this.count; s++) {
        const r = s * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          n.push(this.data.array[r + a]);
      }
      return new tn(new this.array.constructor(n), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new P1(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const n = [];
      for (let s = 0; s < this.count; s++) {
        const r = s * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          n.push(this.data.array[r + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: n,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
const Ii = /* @__PURE__ */ new $(), Mf = /* @__PURE__ */ new $(), kc = /* @__PURE__ */ new $(), rs = /* @__PURE__ */ new $(), bf = /* @__PURE__ */ new $(), Lc = /* @__PURE__ */ new $(), _f = /* @__PURE__ */ new $();
class Kb {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(e = new $(), n = new $(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(e) {
    return this.origin.copy(this.at(e, Ii)), this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const s = n.dot(this.direction);
    return s < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, s);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(e) {
    const n = Ii.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (Ii.copy(this.origin).addScaledVector(this.direction, n), Ii.distanceToSquared(e));
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(e, n, s, r) {
    Mf.copy(e).add(n).multiplyScalar(0.5), kc.copy(n).sub(e).normalize(), rs.copy(this.origin).sub(Mf);
    const a = e.distanceTo(n) * 0.5, o = -this.direction.dot(kc), h = rs.dot(this.direction), c = -rs.dot(kc), l = rs.lengthSq(), u = Math.abs(1 - o * o);
    let f, d, p, y;
    if (u > 0)
      if (f = o * c - h, d = o * h - c, y = a * u, f >= 0)
        if (d >= -y)
          if (d <= y) {
            const x = 1 / u;
            f *= x, d *= x, p = f * (f + o * d + 2 * h) + d * (o * f + d + 2 * c) + l;
          } else
            d = a, f = Math.max(0, -(o * d + h)), p = -f * f + d * (d + 2 * c) + l;
        else
          d = -a, f = Math.max(0, -(o * d + h)), p = -f * f + d * (d + 2 * c) + l;
      else
        d <= -y ? (f = Math.max(0, -(-o * a + h)), d = f > 0 ? -a : Math.min(Math.max(-a, -c), a), p = -f * f + d * (d + 2 * c) + l) : d <= y ? (f = 0, d = Math.min(Math.max(-a, -c), a), p = d * (d + 2 * c) + l) : (f = Math.max(0, -(o * a + h)), d = f > 0 ? a : Math.min(Math.max(-a, -c), a), p = -f * f + d * (d + 2 * c) + l);
    else
      d = o > 0 ? -a : a, f = Math.max(0, -(o * d + h)), p = -f * f + d * (d + 2 * c) + l;
    return s && s.copy(this.origin).addScaledVector(this.direction, f), r && r.copy(Mf).addScaledVector(kc, d), p;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(e, n) {
    Ii.subVectors(e.center, this.origin);
    const s = Ii.dot(this.direction), r = Ii.dot(Ii) - s * s, a = e.radius * e.radius;
    if (r > a) return null;
    const o = Math.sqrt(a - r), h = s - o, c = s + o;
    return c < 0 ? null : h < 0 ? this.at(c, n) : this.at(h, n);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(e) {
    return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const s = -(this.origin.dot(e.normal) + e.constant) / n;
    return s >= 0 ? s : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(e, n) {
    const s = this.distanceToPlane(e);
    return s === null ? null : this.at(s, n);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(e, n) {
    let s, r, a, o, h, c;
    const l = 1 / this.direction.x, u = 1 / this.direction.y, f = 1 / this.direction.z, d = this.origin;
    return l >= 0 ? (s = (e.min.x - d.x) * l, r = (e.max.x - d.x) * l) : (s = (e.max.x - d.x) * l, r = (e.min.x - d.x) * l), u >= 0 ? (a = (e.min.y - d.y) * u, o = (e.max.y - d.y) * u) : (a = (e.max.y - d.y) * u, o = (e.min.y - d.y) * u), s > o || a > r || ((a > s || isNaN(s)) && (s = a), (o < r || isNaN(r)) && (r = o), f >= 0 ? (h = (e.min.z - d.z) * f, c = (e.max.z - d.z) * f) : (h = (e.max.z - d.z) * f, c = (e.min.z - d.z) * f), s > c || h > r) || ((h > s || s !== s) && (s = h), (c < r || r !== r) && (r = c), r < 0) ? null : this.at(s >= 0 ? s : r, n);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(e) {
    return this.intersectBox(e, Ii) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(e, n, s, r, a) {
    bf.subVectors(n, e), Lc.subVectors(s, e), _f.crossVectors(bf, Lc);
    let o = this.direction.dot(_f), h;
    if (o > 0) {
      if (r) return null;
      h = 1;
    } else if (o < 0)
      h = -1, o = -o;
    else
      return null;
    rs.subVectors(this.origin, e);
    const c = h * this.direction.dot(Lc.crossVectors(rs, Lc));
    if (c < 0)
      return null;
    const l = h * this.direction.dot(bf.cross(rs));
    if (l < 0 || c + l > o)
      return null;
    const u = -h * rs.dot(_f);
    return u < 0 ? null : this.at(u / o, a);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const _g = /* @__PURE__ */ new ve();
class TD {
  /**
   * Constructs a new raycaster.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   * @param {number} [near=0] - All results returned are further away than near. Near can't be negative.
   * @param {number} [far=Infinity] - All results returned are closer than far. Far can't be lower than near.
   */
  constructor(e, n, s = 0, r = 1 / 0) {
    this.ray = new Kb(e, n), this.near = s, this.far = r, this.camera = null, this.layers = new z1(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  /**
   * Updates the ray with a new origin and direction by copying the values from the arguments.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   */
  set(e, n) {
    this.ray.set(e, n);
  }
  /**
   * Uses the given coordinates and camera to compute a new origin and direction for the internal ray.
   *
   * @param {Vector2} coords - 2D coordinates of the mouse, in normalized device coordinates (NDC).
   * X and Y components should be between `-1` and `1`.
   * @param {Camera} camera - The camera from which the ray should originate.
   */
  setFromCamera(e, n) {
    n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  /**
   * Uses the given WebXR controller to compute a new origin and direction for the internal ray.
   *
   * @param {WebXRController} controller - The controller to copy the position and direction from.
   * @return {Raycaster} A reference to this raycaster.
   */
  setFromXRController(e) {
    return _g.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_g), this;
  }
  /**
   * The intersection point of a raycaster intersection test.
   * @typedef {Object} Raycaster~Intersection
   * @property {number} distance - The distance from the ray's origin to the intersection point.
   * @property {number} distanceToRay -  Some 3D objects e.g. {@link Points} provide the distance of the
   * intersection to the nearest point on the ray. For other objects it will be `undefined`.
   * @property {Vector3} point - The intersection point, in world coordinates.
   * @property {Object} face - The face that has been intersected.
   * @property {number} faceIndex - The face index.
   * @property {Object3D} object - The 3D object that has been intersected.
   * @property {Vector2} uv - U,V coordinates at point of intersection.
   * @property {Vector2} uv1 - Second set of U,V coordinates at point of intersection.
   * @property {Vector3} uv1 - Interpolated normal vector at point of intersection.
   * @property {number} instanceId - The index number of the instance where the ray
   * intersects the {@link InstancedMesh}.
   */
  /**
   * Checks all intersection between the ray and the object with or without the
   * descendants. Intersections are returned sorted by distance, closest first.
   *
   * `Raycaster` delegates to the `raycast()` method of the passed 3D object, when
   * evaluating whether the ray intersects the object or not. This allows meshes to respond
   * differently to ray casting than lines or points.
   *
   * Note that for meshes, faces must be pointed towards the origin of the ray in order
   * to be detected; intersections of the ray passing through the back of a face will not
   * be detected. To raycast against both faces of an object, you'll want to set  {@link Material#side}
   * to `THREE.DoubleSide`.
   *
   * @param {Object3D} object - The 3D object to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObject(e, n = !0, s = []) {
    return ed(e, this, s, n), s.sort(Sg), s;
  }
  /**
   * Checks all intersection between the ray and the objects with or without
   * the descendants. Intersections are returned sorted by distance, closest first.
   *
   * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObjects(e, n = !0, s = []) {
    for (let r = 0, a = e.length; r < a; r++)
      ed(e[r], this, s, n);
    return s.sort(Sg), s;
  }
}
function Sg(i, e) {
  return i.distance - e.distance;
}
function ed(i, e, n, s) {
  let r = !0;
  if (i.layers.test(e.layers) && i.raycast(e, n) === !1 && (r = !1), r === !0 && s === !0) {
    const a = i.children;
    for (let o = 0, h = a.length; o < h; o++)
      ed(a[o], e, n, !0);
  }
}
const Tg = /* @__PURE__ */ new Si().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), Eg = /* @__PURE__ */ new Si().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function ED() {
  const i = {
    enabled: !0,
    workingColorSpace: Z0,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(r, a, o) {
      return this.enabled === !1 || a === o || !a || !o || (this.spaces[a].transfer === cl && (r.r = Wi(r.r), r.g = Wi(r.g), r.b = Wi(r.b)), this.spaces[a].primaries !== this.spaces[o].primaries && (r.applyMatrix3(this.spaces[a].toXYZ), r.applyMatrix3(this.spaces[o].fromXYZ)), this.spaces[o].transfer === cl && (r.r = Ea(r.r), r.g = Ea(r.g), r.b = Ea(r.b))), r;
    },
    workingToColorSpace: function(r, a) {
      return this.convert(r, this.workingColorSpace, a);
    },
    colorSpaceToWorking: function(r, a) {
      return this.convert(r, a, this.workingColorSpace);
    },
    getPrimaries: function(r) {
      return this.spaces[r].primaries;
    },
    getTransfer: function(r) {
      return r === w1 ? J0 : this.spaces[r].transfer;
    },
    getLuminanceCoefficients: function(r, a = this.workingColorSpace) {
      return r.fromArray(this.spaces[a].luminanceCoefficients);
    },
    define: function(r) {
      Object.assign(this.spaces, r);
    },
    // Internal APIs
    _getMatrix: function(r, a, o) {
      return r.copy(this.spaces[a].toXYZ).multiply(this.spaces[o].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(r) {
      return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(r = this.workingColorSpace) {
      return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
    },
    // Deprecated
    fromWorkingColorSpace: function(r, a) {
      return bg("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), i.workingToColorSpace(r, a);
    },
    toWorkingColorSpace: function(r, a) {
      return bg("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), i.colorSpaceToWorking(r, a);
    }
  }, e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], n = [0.2126, 0.7152, 0.0722], s = [0.3127, 0.329];
  return i.define({
    [Z0]: {
      primaries: e,
      whitePoint: s,
      transfer: J0,
      toXYZ: Tg,
      fromXYZ: Eg,
      luminanceCoefficients: n,
      workingColorSpaceConfig: { unpackColorSpace: On },
      outputColorSpaceConfig: { drawingBufferColorSpace: On }
    },
    [On]: {
      primaries: e,
      whitePoint: s,
      transfer: cl,
      toXYZ: Tg,
      fromXYZ: Eg,
      luminanceCoefficients: n,
      outputColorSpaceConfig: { drawingBufferColorSpace: On }
    }
  }), i;
}
const Cn = /* @__PURE__ */ ED();
function Wi(i) {
  return i < 0.04045 ? i * 0.0773993808 : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function Ea(i) {
  return i < 31308e-7 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let Qr;
class t_ {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(e, n = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let s;
    if (e instanceof HTMLCanvasElement)
      s = e;
    else {
      Qr === void 0 && (Qr = td("canvas")), Qr.width = e.width, Qr.height = e.height;
      const r = Qr.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), s = Qr;
    }
    return s.toDataURL(n);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = td("canvas");
      n.width = e.width, n.height = e.height;
      const s = n.getContext("2d");
      s.drawImage(e, 0, 0, e.width, e.height);
      const r = s.getImageData(0, 0, e.width, e.height), a = r.data;
      for (let o = 0; o < a.length; o++)
        a[o] = Wi(a[o] / 255) * 255;
      return s.putImageData(r, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let s = 0; s < n.length; s++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[s] = Math.floor(Wi(n[s] / 255) * 255) : n[s] = Wi(n[s]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let zD = 0;
class mu {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: zD++ }), this.uuid = ni(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  getSize(e) {
    const n = this.data;
    return n instanceof HTMLVideoElement ? e.set(n.videoWidth, n.videoHeight) : n !== null ? e.set(n.width, n.height, n.depth || 0) : e.set(0, 0, 0), e;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const s = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let a;
      if (Array.isArray(r)) {
        a = [];
        for (let o = 0, h = r.length; o < h; o++)
          r[o].isDataTexture ? a.push(Sf(r[o].image)) : a.push(Sf(r[o]));
      } else
        a = Sf(r);
      s.url = a;
    }
    return n || (e.images[this.uuid] = s), s;
  }
}
function Sf(i) {
  return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? t_.getDataURL(i) : i.data ? {
    data: Array.from(i.data),
    width: i.width,
    height: i.height,
    type: i.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let CD = 0;
const Tf = /* @__PURE__ */ new $();
class Ie extends Es {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = Ie.DEFAULT_IMAGE, n = Ie.DEFAULT_MAPPING, s = gs, r = gs, a = La, o = VM, h = m1, c = y1, l = Ie.DEFAULT_ANISOTROPY, u = w1) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: CD++ }), this.uuid = ni(), this.name = "", this.source = new mu(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = s, this.wrapT = r, this.magFilter = a, this.minFilter = o, this.anisotropy = l, this.format = h, this.internalFormat = null, this.type = c, this.offset = new it(0, 0), this.repeat = new it(1, 1), this.center = new it(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Si(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0;
  }
  /**
   * The width of the texture in pixels.
   */
  get width() {
    return this.source.getSize(Tf).x;
  }
  /**
   * The height of the texture in pixels.
   */
  get height() {
    return this.source.getSize(Tf).y;
  }
  /**
   * The depth of the texture in pixels.
   */
  get depth() {
    return this.source.getSize(Tf).z;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Adds a range of data in the data texture to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  /**
   * Sets this texture's properties based on `values`.
   * @param {Object} values - A container with texture parameters.
   */
  setValues(e) {
    for (const n in e) {
      const s = e[n];
      if (s === void 0) {
        console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);
        continue;
      }
      const r = this[n];
      if (r === void 0) {
        console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);
        continue;
      }
      r && s && r.isVector2 && s.isVector2 || r && s && r.isVector3 && s.isVector3 || r && s && r.isMatrix3 && s.isMatrix3 ? r.copy(s) : this[n] = s;
    }
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const s = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (s.userData = this.userData), n || (e.textures[this.uuid] = s), s;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(e) {
    if (this.mapping !== d1) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case j0:
          e.x = e.x - Math.floor(e.x);
          break;
        case gs:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case H0:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case j0:
          e.y = e.y - Math.floor(e.y);
          break;
        case gs:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case H0:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ie.DEFAULT_IMAGE = null;
Ie.DEFAULT_MAPPING = d1;
Ie.DEFAULT_ANISOTROPY = 1;
class _s {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(e = 0, n = 0, s = 0, r = 1) {
    _s.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = s, this.w = r;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(e, n, s, r) {
    return this.x = e, this.y = n, this.z = s, this.w = r, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(e) {
    return this.w = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(e) {
    const n = this.x, s = this.y, r = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * n + o[4] * s + o[8] * r + o[12] * a, this.y = o[1] * n + o[5] * s + o[9] * r + o[13] * a, this.z = o[2] * n + o[6] * s + o[10] * r + o[14] * a, this.w = o[3] * n + o[7] * s + o[11] * r + o[15] * a, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(e) {
    let n, s, r, a;
    const c = e.elements, l = c[0], u = c[4], f = c[8], d = c[1], p = c[5], y = c[9], x = c[2], g = c[6], m = c[10];
    if (Math.abs(u - d) < 0.01 && Math.abs(f - x) < 0.01 && Math.abs(y - g) < 0.01) {
      if (Math.abs(u + d) < 0.1 && Math.abs(f + x) < 0.1 && Math.abs(y + g) < 0.1 && Math.abs(l + p + m - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const w = (l + 1) / 2, b = (p + 1) / 2, S = (m + 1) / 2, E = (u + d) / 4, A = (f + x) / 4, M = (y + g) / 4;
      return w > b && w > S ? w < 0.01 ? (s = 0, r = 0.707106781, a = 0.707106781) : (s = Math.sqrt(w), r = E / s, a = A / s) : b > S ? b < 0.01 ? (s = 0.707106781, r = 0, a = 0.707106781) : (r = Math.sqrt(b), s = E / r, a = M / r) : S < 0.01 ? (s = 0.707106781, r = 0.707106781, a = 0) : (a = Math.sqrt(S), s = A / a, r = M / a), this.set(s, r, a, n), this;
    }
    let v = Math.sqrt((g - y) * (g - y) + (f - x) * (f - x) + (d - u) * (d - u));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (g - y) / v, this.y = (f - x) / v, this.z = (d - u) / v, this.w = Math.acos((l + p + m - 1) / 2), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(e, n) {
    return this.x = zt(this.x, e.x, n.x), this.y = zt(this.y, e.y, n.y), this.z = zt(this.z, e.z, n.z), this.w = zt(this.w, e.w, n.w), this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(e, n) {
    return this.x = zt(this.x, e, n), this.y = zt(this.y, e, n), this.z = zt(this.z, e, n), this.w = zt(this.w, e, n), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(e, n) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(zt(s, e, n));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(e, n, s) {
    return this.x = e.x + (n.x - e.x) * s, this.y = e.y + (n.y - e.y) * s, this.z = e.z + (n.z - e.z) * s, this.w = e.w + (n.w - e.w) * s, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class e_ extends Es {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   * @property {number} [depth=1] - The texture depth.
   * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, n = 1, s = {}) {
    super(), s = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: La,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1,
      depth: 1,
      multiview: !1
    }, s), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = s.depth, this.scissor = new _s(0, 0, e, n), this.scissorTest = !1, this.viewport = new _s(0, 0, e, n);
    const r = { width: e, height: n, depth: s.depth }, a = new Ie(r);
    this.textures = [];
    const o = s.count;
    for (let h = 0; h < o; h++)
      this.textures[h] = a.clone(), this.textures[h].isRenderTargetTexture = !0, this.textures[h].renderTarget = this;
    this._setTextureOptions(s), this.depthBuffer = s.depthBuffer, this.stencilBuffer = s.stencilBuffer, this.resolveDepthBuffer = s.resolveDepthBuffer, this.resolveStencilBuffer = s.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = s.depthTexture, this.samples = s.samples, this.multiview = s.multiview;
  }
  _setTextureOptions(e = {}) {
    const n = {
      minFilter: La,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null
    };
    e.mapping !== void 0 && (n.mapping = e.mapping), e.wrapS !== void 0 && (n.wrapS = e.wrapS), e.wrapT !== void 0 && (n.wrapT = e.wrapT), e.wrapR !== void 0 && (n.wrapR = e.wrapR), e.magFilter !== void 0 && (n.magFilter = e.magFilter), e.minFilter !== void 0 && (n.minFilter = e.minFilter), e.format !== void 0 && (n.format = e.format), e.type !== void 0 && (n.type = e.type), e.anisotropy !== void 0 && (n.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (n.colorSpace = e.colorSpace), e.flipY !== void 0 && (n.flipY = e.flipY), e.generateMipmaps !== void 0 && (n.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (n.internalFormat = e.internalFormat);
    for (let s = 0; s < this.textures.length; s++)
      this.textures[s].setValues(n);
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(e, n, s = 1) {
    if (this.width !== e || this.height !== n || this.depth !== s) {
      this.width = e, this.height = n, this.depth = s;
      for (let r = 0, a = this.textures.length; r < a; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = n, this.textures[r].image.depth = s, this.textures[r].isArrayTexture = this.textures[r].image.depth > 1;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, s = e.textures.length; n < s; n++) {
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0, this.textures[n].renderTarget = this;
      const r = Object.assign({}, e.textures[n].image);
      this.textures[n].source = new mu(r);
    }
    return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class n_ extends Ie {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, n = 1, s = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: s, depth: r }, this.magFilter = si, this.minFilter = si, this.wrapR = gs, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class AD extends e_ {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, n = 1, s = 1, r = {}) {
    super(e, n, r), this.isRenderTarget3D = !0, this.depth = s, this.texture = new n_(null, e, n, s), this._setTextureOptions(r), this.texture.isRenderTargetTexture = !0;
  }
}
class I1 {
  /**
   * Constructs a new uniform.
   *
   * @param {any} value - The uniform value.
   */
  constructor(e) {
    this.value = e;
  }
  /**
   * Returns a new uniform with copied values from this instance.
   * If the value has a `clone()` method, the value is cloned as well.
   *
   * @return {Uniform} A clone of this instance.
   */
  clone() {
    return new I1(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let PD = 0;
class ID extends Es {
  /**
   * Constructs a new uniforms group.
   */
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: PD++ }), this.name = "", this.usage = yh, this.uniforms = [];
  }
  /**
   * Adds the given uniform to this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  add(e) {
    return this.uniforms.push(e), this;
  }
  /**
   * Removes the given uniform from this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  remove(e) {
    const n = this.uniforms.indexOf(e);
    return n !== -1 && this.uniforms.splice(n, 1), this;
  }
  /**
   * Sets the name of this uniforms group.
   *
   * @param {string} name - The name to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the usage of this uniforms group.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Copies the values of the given uniforms group to this instance.
   *
   * @param {UniformsGroup} source - The uniforms group to copy.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const n = e.uniforms;
    this.uniforms.length = 0;
    for (let s = 0, r = n.length; s < r; s++) {
      const a = Array.isArray(n[s]) ? n[s] : [n[s]];
      for (let o = 0; o < a.length; o++)
        this.uniforms.push(a[o].clone());
    }
    return this;
  }
  /**
   * Returns a new uniforms group with copied values from this instance.
   *
   * @return {UniformsGroup} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class RD extends Es {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, n = null) {
    super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  /**
   * Connects the controls to the DOM. This method has so called "side effects" since
   * it adds the module's event listeners to the DOM.
   *
   * @param {HTMLDOMElement} element - The DOM element to connect to.
   */
  connect(e) {
    if (e === void 0) {
      console.warn("THREE.Controls: connect() now requires an element.");
      return;
    }
    this.domElement !== null && this.disconnect(), this.domElement = e;
  }
  /**
   * Disconnects the controls from the DOM.
   */
  disconnect() {
  }
  /**
   * Call this method if you no longer want use to the controls. It frees all internal
   * resources and removes all event listeners.
   */
  dispose() {
  }
  /**
   * Controls should implement this method if they have to update their internal state
   * per simulation step.
   *
   * @param {number} [delta] - The time delta in seconds.
   */
  update() {
  }
}
class ri {
  /**
   * Constructs a new curve.
   */
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor.
   *
   * @abstract
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor. Unlike {@link Curve#getPoint}, this method honors the length
   * of the curve which equidistant samples.
   *
   * @param {number} u - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPointAt(e, n) {
    const s = this.getUtoTmapping(e);
    return this.getPoint(s, n);
  }
  /**
   * This method samples the curve via {@link Curve#getPoint} and returns an array of points representing
   * the curve shape.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getPoints(e = 5) {
    const n = [];
    for (let s = 0; s <= e; s++)
      n.push(this.getPoint(s / e));
    return n;
  }
  // Get sequence of points using getPointAt( u )
  /**
   * This method samples the curve via {@link Curve#getPointAt} and returns an array of points representing
   * the curve shape. Unlike {@link Curve#getPoints}, this method returns equi-spaced points across the entire
   * curve.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getSpacedPoints(e = 5) {
    const n = [];
    for (let s = 0; s <= e; s++)
      n.push(this.getPointAt(s / e));
    return n;
  }
  /**
   * Returns the total arc length of the curve.
   *
   * @return {number} The length of the curve.
   */
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  /**
   * Returns an array of cumulative segment lengths of the curve.
   *
   * @param {number} [divisions=this.arcLengthDivisions] - The number of divisions.
   * @return {Array<number>} An array holding the cumulative segment lengths.
   */
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let s, r = this.getPoint(0), a = 0;
    n.push(0);
    for (let o = 1; o <= e; o++)
      s = this.getPoint(o / e), a += s.distanceTo(r), n.push(a), r = s;
    return this.cacheArcLengths = n, n;
  }
  /**
   * Update the cumulative segment distance cache. The method must be called
   * every time curve parameters are changed. If an updated curve is part of a
   * composed curve like {@link CurvePath}, this method must be called on the
   * composed curve, too.
   */
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  /**
   * Given an interpolation factor in the range `[0,1]`, this method returns an updated
   * interpolation factor in the same range that can be ued to sample equidistant points
   * from a curve.
   *
   * @param {number} u - The interpolation factor.
   * @param {?number} distance - An optional distance on the curve.
   * @return {number} The updated interpolation factor.
   */
  getUtoTmapping(e, n = null) {
    const s = this.getLengths();
    let r = 0;
    const a = s.length;
    let o;
    n ? o = n : o = e * s[a - 1];
    let h = 0, c = a - 1, l;
    for (; h <= c; )
      if (r = Math.floor(h + (c - h) / 2), l = s[r] - o, l < 0)
        h = r + 1;
      else if (l > 0)
        c = r - 1;
      else {
        c = r;
        break;
      }
    if (r = c, s[r] === o)
      return r / (a - 1);
    const u = s[r], d = s[r + 1] - u, p = (o - u) / d;
    return (r + p) / (a - 1);
  }
  /**
   * Returns a unit vector tangent for the given interpolation factor.
   * If the derived curve does not implement its tangent derivation,
   * two points a small delta apart will be used to find its gradient
   * which seems to give a reasonable approximation.
   *
   * @param {number} t - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   */
  getTangent(e, n) {
    let r = e - 1e-4, a = e + 1e-4;
    r < 0 && (r = 0), a > 1 && (a = 1);
    const o = this.getPoint(r), h = this.getPoint(a), c = n || (o.isVector2 ? new it() : new $());
    return c.copy(h).sub(o).normalize(), c;
  }
  /**
   * Same as {@link Curve#getTangent} but with equidistant samples.
   *
   * @param {number} u - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   * @see {@link Curve#getPointAt}
   */
  getTangentAt(e, n) {
    const s = this.getUtoTmapping(e);
    return this.getTangent(s, n);
  }
  /**
   * Generates the Frenet Frames. Requires a curve definition in 3D space. Used
   * in geometries like {@link TubeGeometry} or {@link ExtrudeGeometry}.
   *
   * @param {number} segments - The number of segments.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @return {{tangents: Array<Vector3>, normals: Array<Vector3>, binormals: Array<Vector3>}} The Frenet Frames.
   */
  computeFrenetFrames(e, n = !1) {
    const s = new $(), r = [], a = [], o = [], h = new $(), c = new ve();
    for (let p = 0; p <= e; p++) {
      const y = p / e;
      r[p] = this.getTangentAt(y, new $());
    }
    a[0] = new $(), o[0] = new $();
    let l = Number.MAX_VALUE;
    const u = Math.abs(r[0].x), f = Math.abs(r[0].y), d = Math.abs(r[0].z);
    u <= l && (l = u, s.set(1, 0, 0)), f <= l && (l = f, s.set(0, 1, 0)), d <= l && s.set(0, 0, 1), h.crossVectors(r[0], s).normalize(), a[0].crossVectors(r[0], h), o[0].crossVectors(r[0], a[0]);
    for (let p = 1; p <= e; p++) {
      if (a[p] = a[p - 1].clone(), o[p] = o[p - 1].clone(), h.crossVectors(r[p - 1], r[p]), h.length() > Number.EPSILON) {
        h.normalize();
        const y = Math.acos(zt(r[p - 1].dot(r[p]), -1, 1));
        a[p].applyMatrix4(c.makeRotationAxis(h, y));
      }
      o[p].crossVectors(r[p], a[p]);
    }
    if (n === !0) {
      let p = Math.acos(zt(a[0].dot(a[e]), -1, 1));
      p /= e, r[0].dot(h.crossVectors(a[0], a[e])) > 0 && (p = -p);
      for (let y = 1; y <= e; y++)
        a[y].applyMatrix4(c.makeRotationAxis(r[y], p * y)), o[y].crossVectors(r[y], a[y]);
    }
    return {
      tangents: r,
      normals: a,
      binormals: o
    };
  }
  /**
   * Returns a new curve with copied values from this instance.
   *
   * @return {Curve} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given curve to this instance.
   *
   * @param {Curve} source - The curve to copy.
   * @return {Curve} A reference to this curve.
   */
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  /**
   * Serializes the curve into JSON.
   *
   * @return {Object} A JSON object representing the serialized curve.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  /**
   * Deserializes the curve from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized curve.
   * @return {Curve} A reference to this curve.
   */
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class vu extends ri {
  /**
   * Constructs a new ellipse curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   */
  constructor(e = 0, n = 0, s = 1, r = 1, a = 0, o = Math.PI * 2, h = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = s, this.yRadius = r, this.aStartAngle = a, this.aEndAngle = o, this.aClockwise = h, this.aRotation = c;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new it()) {
    const s = n, r = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += r;
    for (; a > r; ) a -= r;
    a < Number.EPSILON && (o ? a = 0 : a = r), this.aClockwise === !0 && !o && (a === r ? a = -r : a = a - r);
    const h = this.aStartAngle + e * a;
    let c = this.aX + this.xRadius * Math.cos(h), l = this.aY + this.yRadius * Math.sin(h);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), f = Math.sin(this.aRotation), d = c - this.aX, p = l - this.aY;
      c = d * u - p * f + this.aX, l = d * f + p * u + this.aY;
    }
    return s.set(c, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class i_ extends vu {
  /**
   * Constructs a new arc curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [aRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   */
  constructor(e, n, s, r, a, o) {
    super(e, n, s, s, r, a, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function R1() {
  let i = 0, e = 0, n = 0, s = 0;
  function r(a, o, h, c) {
    i = a, e = h, n = -3 * a + 3 * o - 2 * h - c, s = 2 * a - 2 * o + h + c;
  }
  return {
    initCatmullRom: function(a, o, h, c, l) {
      r(o, h, l * (h - a), l * (c - o));
    },
    initNonuniformCatmullRom: function(a, o, h, c, l, u, f) {
      let d = (o - a) / l - (h - a) / (l + u) + (h - o) / u, p = (h - o) / u - (c - o) / (u + f) + (c - h) / f;
      d *= u, p *= u, r(o, h, d, p);
    },
    calc: function(a) {
      const o = a * a, h = o * a;
      return i + e * a + n * o + s * h;
    }
  };
}
const Fc = /* @__PURE__ */ new $(), Ef = /* @__PURE__ */ new R1(), zf = /* @__PURE__ */ new R1(), Cf = /* @__PURE__ */ new R1();
class s_ extends ri {
  /**
   * Constructs a new Catmull-Rom curve.
   *
   * @param {Array<Vector3>} [points] - An array of 3D points defining the curve.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @param {('centripetal'|'chordal'|'catmullrom')} [curveType='centripetal'] - The curve type.
   * @param {number} [tension=0.5] - Tension of the curve.
   */
  constructor(e = [], n = !1, s = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = s, this.tension = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, n = new $()) {
    const s = n, r = this.points, a = r.length, o = (a - (this.closed ? 0 : 1)) * e;
    let h = Math.floor(o), c = o - h;
    this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / a) + 1) * a : c === 0 && h === a - 1 && (h = a - 2, c = 1);
    let l, u;
    this.closed || h > 0 ? l = r[(h - 1) % a] : (Fc.subVectors(r[0], r[1]).add(r[0]), l = Fc);
    const f = r[h % a], d = r[(h + 1) % a];
    if (this.closed || h + 2 < a ? u = r[(h + 2) % a] : (Fc.subVectors(r[a - 1], r[a - 2]).add(r[a - 1]), u = Fc), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let y = Math.pow(l.distanceToSquared(f), p), x = Math.pow(f.distanceToSquared(d), p), g = Math.pow(d.distanceToSquared(u), p);
      x < 1e-4 && (x = 1), y < 1e-4 && (y = x), g < 1e-4 && (g = x), Ef.initNonuniformCatmullRom(l.x, f.x, d.x, u.x, y, x, g), zf.initNonuniformCatmullRom(l.y, f.y, d.y, u.y, y, x, g), Cf.initNonuniformCatmullRom(l.z, f.z, d.z, u.z, y, x, g);
    } else this.curveType === "catmullrom" && (Ef.initCatmullRom(l.x, f.x, d.x, u.x, this.tension), zf.initCatmullRom(l.y, f.y, d.y, u.y, this.tension), Cf.initCatmullRom(l.z, f.z, d.z, u.z, this.tension));
    return s.set(
      Ef.calc(c),
      zf.calc(c),
      Cf.calc(c)
    ), s;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, s = e.points.length; n < s; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, s = this.points.length; n < s; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, s = e.points.length; n < s; n++) {
      const r = e.points[n];
      this.points.push(new $().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function zg(i, e, n, s, r) {
  const a = (s - e) * 0.5, o = (r - n) * 0.5, h = i * i, c = i * h;
  return (2 * n - 2 * s + a + o) * c + (-3 * n + 3 * s - 2 * a - o) * h + a * i + n;
}
function OD(i, e) {
  const n = 1 - i;
  return n * n * e;
}
function kD(i, e) {
  return 2 * (1 - i) * i * e;
}
function LD(i, e) {
  return i * i * e;
}
function $o(i, e, n, s) {
  return OD(i, e) + kD(i, n) + LD(i, s);
}
function FD(i, e) {
  const n = 1 - i;
  return n * n * n * e;
}
function ND(i, e) {
  const n = 1 - i;
  return 3 * n * n * i * e;
}
function BD(i, e) {
  return 3 * (1 - i) * i * i * e;
}
function DD(i, e) {
  return i * i * i * e;
}
function Vo(i, e, n, s, r) {
  return FD(i, e) + ND(i, n) + BD(i, s) + DD(i, r);
}
class O1 extends ri {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The first control point.
   * @param {Vector2} [v2] - The second control point.
   * @param {Vector2} [v3] - The end point.
   */
  constructor(e = new it(), n = new it(), s = new it(), r = new it()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = s, this.v3 = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new it()) {
    const s = n, r = this.v0, a = this.v1, o = this.v2, h = this.v3;
    return s.set(
      Vo(e, r.x, a.x, o.x, h.x),
      Vo(e, r.y, a.y, o.y, h.y)
    ), s;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class r_ extends ri {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The first control point.
   * @param {Vector3} [v2] - The second control point.
   * @param {Vector3} [v3] - The end point.
   */
  constructor(e = new $(), n = new $(), s = new $(), r = new $()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = s, this.v3 = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, n = new $()) {
    const s = n, r = this.v0, a = this.v1, o = this.v2, h = this.v3;
    return s.set(
      Vo(e, r.x, a.x, o.x, h.x),
      Vo(e, r.y, a.y, o.y, h.y),
      Vo(e, r.z, a.z, o.z, h.z)
    ), s;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class k1 extends ri {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector2} [v1] - The start point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new it(), n = new it()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the line.
   */
  getPoint(e, n = new it()) {
    const s = n;
    return e === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(e).add(this.v1)), s;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new it()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class a_ extends ri {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector3} [v1] - The start point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new $(), n = new $()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the line.
   */
  getPoint(e, n = new $()) {
    const s = n;
    return e === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(e).add(this.v1)), s;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new $()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class L1 extends ri {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The control point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new it(), n = new it(), s = new it()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = s;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new it()) {
    const s = n, r = this.v0, a = this.v1, o = this.v2;
    return s.set(
      $o(e, r.x, a.x, o.x),
      $o(e, r.y, a.y, o.y)
    ), s;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class F1 extends ri {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The control point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new $(), n = new $(), s = new $()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = s;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, n = new $()) {
    const s = n, r = this.v0, a = this.v1, o = this.v2;
    return s.set(
      $o(e, r.x, a.x, o.x),
      $o(e, r.y, a.y, o.y),
      $o(e, r.z, a.z, o.z)
    ), s;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class N1 extends ri {
  /**
   * Constructs a new 2D spline curve.
   *
   * @param {Array<Vector2>} [points] -  An array of 2D points defining the curve.
   */
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, n = new it()) {
    const s = n, r = this.points, a = (r.length - 1) * e, o = Math.floor(a), h = a - o, c = r[o === 0 ? o : o - 1], l = r[o], u = r[o > r.length - 2 ? r.length - 1 : o + 1], f = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return s.set(
      zg(h, c.x, l.x, u.x, f.x),
      zg(h, c.y, l.y, u.y, f.y)
    ), s;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, s = e.points.length; n < s; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, s = this.points.length; n < s; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, s = e.points.length; n < s; n++) {
      const r = e.points[n];
      this.points.push(new it().fromArray(r));
    }
    return this;
  }
}
const Yl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcCurve: i_,
  CatmullRomCurve3: s_,
  CubicBezierCurve: O1,
  CubicBezierCurve3: r_,
  EllipseCurve: vu,
  LineCurve: k1,
  LineCurve3: a_,
  QuadraticBezierCurve: L1,
  QuadraticBezierCurve3: F1,
  SplineCurve: N1
}, Symbol.toStringTag, { value: "Module" }));
class o_ extends ri {
  /**
   * Constructs a new curve path.
   */
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  /**
   * Adds a curve to this curve path.
   *
   * @param {Curve} curve - The curve to add.
   */
  add(e) {
    this.curves.push(e);
  }
  /**
   * Adds a line curve to close the path.
   *
   * @return {CurvePath} A reference to this curve path.
   */
  closePath() {
    const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const s = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Yl[s](n, e));
    }
    return this;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definitions)
   * for the given interpolation factor.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint(e, n) {
    const s = e * this.getLength(), r = this.getCurveLengths();
    let a = 0;
    for (; a < r.length; ) {
      if (r[a] >= s) {
        const o = r[a] - s, h = this.curves[a], c = h.getLength(), l = c === 0 ? 0 : 1 - o / c;
        return h.getPointAt(l, n);
      }
      a++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  /**
   * Returns list of cumulative curve lengths of the defined curves.
   *
   * @return {Array<number>} The curve lengths.
   */
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let s = 0, r = this.curves.length; s < r; s++)
      n += this.curves[s].getLength(), e.push(n);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let s = 0; s <= e; s++)
      n.push(this.getPoint(s / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let s;
    for (let r = 0, a = this.curves; r < a.length; r++) {
      const o = a[r], h = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, c = o.getPoints(h);
      for (let l = 0; l < c.length; l++) {
        const u = c[l];
        s && s.equals(u) || (n.push(u), s = u);
      }
    }
    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let n = 0, s = e.curves.length; n < s; n++) {
      const r = e.curves[n];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let n = 0, s = this.curves.length; n < s; n++) {
      const r = this.curves[n];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let n = 0, s = e.curves.length; n < s; n++) {
      const r = e.curves[n];
      this.curves.push(new Yl[r.type]().fromJSON(r));
    }
    return this;
  }
}
class jl extends o_ {
  /**
   * Constructs a new path.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the path.
   */
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new it(), e && this.setFromPoints(e);
  }
  /**
   * Creates a path from the given list of points. The points are added
   * to the path as instances of {@link LineCurve}.
   *
   * @param {Array<Vector2>} points - An array of 2D points.
   * @return {Path} A reference to this path.
   */
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, s = e.length; n < s; n++)
      this.lineTo(e[n].x, e[n].y);
    return this;
  }
  /**
   * Moves {@link Path#currentPoint} to the given point.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {Path} A reference to this path.
   */
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  lineTo(e, n) {
    const s = new k1(this.currentPoint.clone(), new it(e, n));
    return this.curves.push(s), this.currentPoint.set(e, n), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  quadraticCurveTo(e, n, s, r) {
    const a = new L1(
      this.currentPoint.clone(),
      new it(e, n),
      new it(s, r)
    );
    return this.curves.push(a), this.currentPoint.set(s, r), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  bezierCurveTo(e, n, s, r, a, o) {
    const h = new O1(
      this.currentPoint.clone(),
      new it(e, n),
      new it(s, r),
      new it(a, o)
    );
    return this.curves.push(h), this.currentPoint.set(a, o), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {Path} A reference to this path.
   */
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e), s = new N1(n);
    return this.curves.push(s), this.currentPoint.copy(e[e.length - 1]), this;
  }
  /**
   * Adds an arc as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point.
   *
   * @param {number} [aX=0] - The x coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} [aY=0] - The y coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} [aRadius=1] - The radius of the arc.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  arc(e, n, s, r, a, o) {
    const h = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + h,
      n + c,
      s,
      r,
      a,
      o
    ), this;
  }
  /**
   * Adds an absolutely positioned arc as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} [aX=0] - The x coordinate of the center of the arc.
   * @param {number} [aY=0] - The y coordinate of the center of the arc.
   * @param {number} [aRadius=1] - The radius of the arc.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  absarc(e, n, s, r, a, o) {
    return this.absellipse(e, n, s, s, r, a, o), this;
  }
  /**
   * Adds an ellipse as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point
   *
   * @param {number} [aX=0] - The x coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} [aY=0] - The y coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  ellipse(e, n, s, r, a, o, h, c) {
    const l = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + l, n + u, s, r, a, o, h, c), this;
  }
  /**
   * Adds an absolutely positioned ellipse as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} [aX=0] - The x coordinate of the absolute center of the ellipse.
   * @param {number} [aY=0] - The y coordinate of the absolute center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  absellipse(e, n, s, r, a, o, h, c) {
    const l = new vu(e, n, s, r, a, o, h, c);
    if (this.curves.length > 0) {
      const f = l.getPoint(0);
      f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class za extends jl {
  /**
   * Constructs a new shape.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the shape.
   */
  constructor(e) {
    super(e), this.uuid = ni(), this.type = "Shape", this.holes = [];
  }
  /**
   * Returns an array representing each contour of the holes
   * as a list of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {Array<Array<Vector2>>} The holes as a series of 2D points.
   */
  getPointsHoles(e) {
    const n = [];
    for (let s = 0, r = this.holes.length; s < r; s++)
      n[s] = this.holes[s].getPoints(e);
    return n;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  /**
   * Returns an object that holds contour data for the shape and its holes as
   * arrays of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {{shape:Array<Vector2>,holes:Array<Array<Vector2>>}} An object with contour data.
   */
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let n = 0, s = e.holes.length; n < s; n++) {
      const r = e.holes[n];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let n = 0, s = this.holes.length; n < s; n++) {
      const r = this.holes[n];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let n = 0, s = e.holes.length; n < s; n++) {
      const r = e.holes[n];
      this.holes.push(new jl().fromJSON(r));
    }
    return this;
  }
}
const h_ = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, as = { h: 0, s: 0, l: 0 }, Nc = { h: 0, s: 0, l: 0 };
function Af(i, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? i + (e - i) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - n) : i;
}
class qa {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(e, n, s) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, s);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(e, n, s) {
    if (n === void 0 && s === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, n, s);
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(e, n = On) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Cn.colorSpaceToWorking(this, n), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(e, n, s, r = Cn.workingColorSpace) {
    return this.r = e, this.g = n, this.b = s, Cn.colorSpaceToWorking(this, r), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(e, n, s, r = Cn.workingColorSpace) {
    if (e = M1(e, 1), n = zt(n, 0, 1), s = zt(s, 0, 1), n === 0)
      this.r = this.g = this.b = s;
    else {
      const a = s <= 0.5 ? s * (1 + n) : s + n - s * n, o = 2 * s - a;
      this.r = Af(o, a, e + 1 / 3), this.g = Af(o, a, e), this.b = Af(o, a, e - 1 / 3);
    }
    return Cn.colorSpaceToWorking(this, r), this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(e, n = On) {
    function s(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const o = r[1], h = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return s(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              n
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return s(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return s(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const a = r[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          n
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(e, n = On) {
    const s = h_[e.toLowerCase()];
    return s !== void 0 ? this.setHex(s, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(e) {
    return this.r = Wi(e.r), this.g = Wi(e.g), this.b = Wi(e.b), this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(e) {
    return this.r = Ea(e.r), this.g = Ea(e.g), this.b = Ea(e.b), this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(e = On) {
    return Cn.workingToColorSpace(qe.copy(this), e), Math.round(zt(qe.r * 255, 0, 255)) * 65536 + Math.round(zt(qe.g * 255, 0, 255)) * 256 + Math.round(zt(qe.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(e = On) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(e, n = Cn.workingColorSpace) {
    Cn.workingToColorSpace(qe.copy(this), n);
    const s = qe.r, r = qe.g, a = qe.b, o = Math.max(s, r, a), h = Math.min(s, r, a);
    let c, l;
    const u = (h + o) / 2;
    if (h === o)
      c = 0, l = 0;
    else {
      const f = o - h;
      switch (l = u <= 0.5 ? f / (o + h) : f / (2 - o - h), o) {
        case s:
          c = (r - a) / f + (r < a ? 6 : 0);
          break;
        case r:
          c = (a - s) / f + 2;
          break;
        case a:
          c = (s - r) / f + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = l, e.l = u, e;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(e, n = Cn.workingColorSpace) {
    return Cn.workingToColorSpace(qe.copy(this), n), e.r = qe.r, e.g = qe.g, e.b = qe.b, e;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(e = On) {
    Cn.workingToColorSpace(qe.copy(this), e);
    const n = qe.r, s = qe.g, r = qe.b;
    return e !== On ? `color(${e} ${n.toFixed(3)} ${s.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(s * 255)},${Math.round(r * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(e, n, s) {
    return this.getHSL(as), this.setHSL(as.h + e, as.s + n, as.l + s);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(e, n, s) {
    return this.r = e.r + (n.r - e.r) * s, this.g = e.g + (n.g - e.g) * s, this.b = e.b + (n.b - e.b) * s, this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(e, n) {
    this.getHSL(as), e.getHSL(Nc);
    const s = qo(as.h, Nc.h, n), r = qo(as.s, Nc.s, n), a = qo(as.l, Nc.l, n);
    return this.setHSL(s, r, a), this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(e) {
    const n = this.r, s = this.g, r = this.b, a = e.elements;
    return this.r = a[0] * n + a[3] * s + a[6] * r, this.g = a[1] * n + a[4] * s + a[7] * r, this.b = a[2] * n + a[5] * s + a[8] * r, this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const qe = /* @__PURE__ */ new qa();
qa.NAMES = h_;
function qD(i, e, n = 2) {
  const s = e && e.length, r = s ? e[0] * n : i.length;
  let a = c_(i, 0, r, n, !0);
  const o = [];
  if (!a || a.next === a.prev) return o;
  let h, c, l;
  if (s && (a = WD(i, e, a, n)), i.length > 80 * n) {
    h = 1 / 0, c = 1 / 0;
    let u = -1 / 0, f = -1 / 0;
    for (let d = n; d < r; d += n) {
      const p = i[d], y = i[d + 1];
      p < h && (h = p), y < c && (c = y), p > u && (u = p), y > f && (f = y);
    }
    l = Math.max(u - h, f - c), l = l !== 0 ? 32767 / l : 0;
  }
  return vh(a, o, n, h, c, l, 0), o;
}
function c_(i, e, n, s, r) {
  let a;
  if (r === sd(i, e, n, s) > 0)
    for (let o = e; o < n; o += s) a = Cg(o / s | 0, i[o], i[o + 1], a);
  else
    for (let o = n - s; o >= e; o -= s) a = Cg(o / s | 0, i[o], i[o + 1], a);
  return a && Fa(a, a.next) && (Mh(a), a = a.next), a;
}
function Tr(i, e) {
  if (!i) return i;
  e || (e = i);
  let n = i, s;
  do
    if (s = !1, !n.steiner && (Fa(n, n.next) || ue(n.prev, n, n.next) === 0)) {
      if (Mh(n), n = e = n.prev, n === n.next) break;
      s = !0;
    } else
      n = n.next;
  while (s || n !== e);
  return e;
}
function vh(i, e, n, s, r, a, o) {
  if (!i) return;
  !o && a && ZD(i, s, r, a);
  let h = i;
  for (; i.prev !== i.next; ) {
    const c = i.prev, l = i.next;
    if (a ? VD(i, s, r, a) : $D(i)) {
      e.push(c.i, i.i, l.i), Mh(i), i = l.next, h = l.next;
      continue;
    }
    if (i = l, i === h) {
      o ? o === 1 ? (i = GD(Tr(i), e), vh(i, e, n, s, r, a, 2)) : o === 2 && UD(i, e, n, s, r, a) : vh(Tr(i), e, n, s, r, a, 1);
      break;
    }
  }
}
function $D(i) {
  const e = i.prev, n = i, s = i.next;
  if (ue(e, n, s) >= 0) return !1;
  const r = e.x, a = n.x, o = s.x, h = e.y, c = n.y, l = s.y, u = Math.min(r, a, o), f = Math.min(h, c, l), d = Math.max(r, a, o), p = Math.max(h, c, l);
  let y = s.next;
  for (; y !== e; ) {
    if (y.x >= u && y.x <= d && y.y >= f && y.y <= p && Ao(r, h, a, c, o, l, y.x, y.y) && ue(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function VD(i, e, n, s) {
  const r = i.prev, a = i, o = i.next;
  if (ue(r, a, o) >= 0) return !1;
  const h = r.x, c = a.x, l = o.x, u = r.y, f = a.y, d = o.y, p = Math.min(h, c, l), y = Math.min(u, f, d), x = Math.max(h, c, l), g = Math.max(u, f, d), m = nd(p, y, e, n, s), v = nd(x, g, e, n, s);
  let w = i.prevZ, b = i.nextZ;
  for (; w && w.z >= m && b && b.z <= v; ) {
    if (w.x >= p && w.x <= x && w.y >= y && w.y <= g && w !== r && w !== o && Ao(h, u, c, f, l, d, w.x, w.y) && ue(w.prev, w, w.next) >= 0 || (w = w.prevZ, b.x >= p && b.x <= x && b.y >= y && b.y <= g && b !== r && b !== o && Ao(h, u, c, f, l, d, b.x, b.y) && ue(b.prev, b, b.next) >= 0)) return !1;
    b = b.nextZ;
  }
  for (; w && w.z >= m; ) {
    if (w.x >= p && w.x <= x && w.y >= y && w.y <= g && w !== r && w !== o && Ao(h, u, c, f, l, d, w.x, w.y) && ue(w.prev, w, w.next) >= 0) return !1;
    w = w.prevZ;
  }
  for (; b && b.z <= v; ) {
    if (b.x >= p && b.x <= x && b.y >= y && b.y <= g && b !== r && b !== o && Ao(h, u, c, f, l, d, b.x, b.y) && ue(b.prev, b, b.next) >= 0) return !1;
    b = b.nextZ;
  }
  return !0;
}
function GD(i, e) {
  let n = i;
  do {
    const s = n.prev, r = n.next.next;
    !Fa(s, r) && u_(s, n, n.next, r) && wh(s, r) && wh(r, s) && (e.push(s.i, n.i, r.i), Mh(n), Mh(n.next), n = i = r), n = n.next;
  } while (n !== i);
  return Tr(n);
}
function UD(i, e, n, s, r, a) {
  let o = i;
  do {
    let h = o.next.next;
    for (; h !== o.prev; ) {
      if (o.i !== h.i && KD(o, h)) {
        let c = f_(o, h);
        o = Tr(o, o.next), c = Tr(c, c.next), vh(o, e, n, s, r, a, 0), vh(c, e, n, s, r, a, 0);
        return;
      }
      h = h.next;
    }
    o = o.next;
  } while (o !== i);
}
function WD(i, e, n, s) {
  const r = [];
  for (let a = 0, o = e.length; a < o; a++) {
    const h = e[a] * s, c = a < o - 1 ? e[a + 1] * s : i.length, l = c_(i, h, c, s, !1);
    l === l.next && (l.steiner = !0), r.push(QD(l));
  }
  r.sort(YD);
  for (let a = 0; a < r.length; a++)
    n = jD(r[a], n);
  return n;
}
function YD(i, e) {
  let n = i.x - e.x;
  if (n === 0 && (n = i.y - e.y, n === 0)) {
    const s = (i.next.y - i.y) / (i.next.x - i.x), r = (e.next.y - e.y) / (e.next.x - e.x);
    n = s - r;
  }
  return n;
}
function jD(i, e) {
  const n = HD(i, e);
  if (!n)
    return e;
  const s = f_(n, i);
  return Tr(s, s.next), Tr(n, n.next);
}
function HD(i, e) {
  let n = e;
  const s = i.x, r = i.y;
  let a = -1 / 0, o;
  if (Fa(i, n)) return n;
  do {
    if (Fa(i, n.next)) return n.next;
    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
      const f = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (f <= s && f > a && (a = f, o = n.x < n.next.x ? n : n.next, f === s))
        return o;
    }
    n = n.next;
  } while (n !== e);
  if (!o) return null;
  const h = o, c = o.x, l = o.y;
  let u = 1 / 0;
  n = o;
  do {
    if (s >= n.x && n.x >= c && s !== n.x && l_(r < l ? s : a, r, c, l, r < l ? a : s, r, n.x, n.y)) {
      const f = Math.abs(r - n.y) / (s - n.x);
      wh(n, i) && (f < u || f === u && (n.x > o.x || n.x === o.x && XD(o, n))) && (o = n, u = f);
    }
    n = n.next;
  } while (n !== h);
  return o;
}
function XD(i, e) {
  return ue(i.prev, i, e.prev) < 0 && ue(e.next, i, i.next) < 0;
}
function ZD(i, e, n, s) {
  let r = i;
  do
    r.z === 0 && (r.z = nd(r.x, r.y, e, n, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, JD(r);
}
function JD(i) {
  let e, n = 1;
  do {
    let s = i, r;
    i = null;
    let a = null;
    for (e = 0; s; ) {
      e++;
      let o = s, h = 0;
      for (let l = 0; l < n && (h++, o = o.nextZ, !!o); l++)
        ;
      let c = n;
      for (; h > 0 || c > 0 && o; )
        h !== 0 && (c === 0 || !o || s.z <= o.z) ? (r = s, s = s.nextZ, h--) : (r = o, o = o.nextZ, c--), a ? a.nextZ = r : i = r, r.prevZ = a, a = r;
      s = o;
    }
    a.nextZ = null, n *= 2;
  } while (e > 1);
  return i;
}
function nd(i, e, n, s, r) {
  return i = (i - n) * r | 0, e = (e - s) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function QD(i) {
  let e = i, n = i;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== i);
  return n;
}
function l_(i, e, n, s, r, a, o, h) {
  return (r - o) * (e - h) >= (i - o) * (a - h) && (i - o) * (s - h) >= (n - o) * (e - h) && (n - o) * (a - h) >= (r - o) * (s - h);
}
function Ao(i, e, n, s, r, a, o, h) {
  return !(i === o && e === h) && l_(i, e, n, s, r, a, o, h);
}
function KD(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !t8(i, e) && // dones't intersect other edges
  (wh(i, e) && wh(e, i) && e8(i, e) && // locally visible
  (ue(i.prev, i, e.prev) || ue(i, e.prev, e)) || // does not create opposite-facing sectors
  Fa(i, e) && ue(i.prev, i, i.next) > 0 && ue(e.prev, e, e.next) > 0);
}
function ue(i, e, n) {
  return (e.y - i.y) * (n.x - e.x) - (e.x - i.x) * (n.y - e.y);
}
function Fa(i, e) {
  return i.x === e.x && i.y === e.y;
}
function u_(i, e, n, s) {
  const r = Dc(ue(i, e, n)), a = Dc(ue(i, e, s)), o = Dc(ue(n, s, i)), h = Dc(ue(n, s, e));
  return !!(r !== a && o !== h || r === 0 && Bc(i, n, e) || a === 0 && Bc(i, s, e) || o === 0 && Bc(n, i, s) || h === 0 && Bc(n, e, s));
}
function Bc(i, e, n) {
  return e.x <= Math.max(i.x, n.x) && e.x >= Math.min(i.x, n.x) && e.y <= Math.max(i.y, n.y) && e.y >= Math.min(i.y, n.y);
}
function Dc(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function t8(i, e) {
  let n = i;
  do {
    if (n.i !== i.i && n.next.i !== i.i && n.i !== e.i && n.next.i !== e.i && u_(n, n.next, i, e)) return !0;
    n = n.next;
  } while (n !== i);
  return !1;
}
function wh(i, e) {
  return ue(i.prev, i, i.next) < 0 ? ue(i, e, i.next) >= 0 && ue(i, i.prev, e) >= 0 : ue(i, e, i.prev) < 0 || ue(i, i.next, e) < 0;
}
function e8(i, e) {
  let n = i, s = !1;
  const r = (i.x + e.x) / 2, a = (i.y + e.y) / 2;
  do
    n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;
  while (n !== i);
  return s;
}
function f_(i, e) {
  const n = id(i.i, i.x, i.y), s = id(e.i, e.x, e.y), r = i.next, a = e.prev;
  return i.next = e, e.prev = i, n.next = r, r.prev = n, s.next = n, n.prev = s, a.next = s, s.prev = a, s;
}
function Cg(i, e, n, s) {
  const r = id(i, e, n);
  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;
}
function Mh(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function id(i, e, n) {
  return {
    i,
    // vertex index in coordinates array
    x: e,
    y: n,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function n8(i, e, n, s) {
  const r = e && e.length, a = r ? e[0] * n : i.length;
  let o = Math.abs(sd(i, 0, a, n));
  if (r)
    for (let c = 0, l = e.length; c < l; c++) {
      const u = e[c] * n, f = c < l - 1 ? e[c + 1] * n : i.length;
      o -= Math.abs(sd(i, u, f, n));
    }
  let h = 0;
  for (let c = 0; c < s.length; c += 3) {
    const l = s[c] * n, u = s[c + 1] * n, f = s[c + 2] * n;
    h += Math.abs(
      (i[l] - i[f]) * (i[u + 1] - i[l + 1]) - (i[l] - i[u]) * (i[f + 1] - i[l + 1])
    );
  }
  return o === 0 && h === 0 ? 0 : Math.abs((h - o) / o);
}
function sd(i, e, n, s) {
  let r = 0;
  for (let a = e, o = n - s; a < n; a += s)
    r += (i[o] - i[a]) * (i[a + 1] + i[o + 1]), o = a;
  return r;
}
function i8(i) {
  const e = [], n = [], s = i[0][0].length;
  let r = 0, a = 0;
  for (const o of i) {
    for (const h of o)
      for (let c = 0; c < s; c++) e.push(h[c]);
    a && (r += a, n.push(r)), a = o.length;
  }
  return { vertices: e, holes: n, dimensions: s };
}
class s8 {
  /**
   * Triangulates the given shape definition by returning an array of triangles.
   *
   * @param {Array<number>} data - An array with 2D points.
   * @param {Array<number>} holeIndices - An array with indices defining holes.
   * @param {number} [dim=2] - The number of coordinates per vertex in the input array.
   * @return {Array<number>} An array representing the triangulated faces. Each face is defined by three consecutive numbers
   * representing vertex indices.
   */
  static triangulate(e, n, s = 2) {
    return qD(e, n, s);
  }
}
class ei {
  /**
   * Calculate area of a ( 2D ) contour polygon.
   *
   * @param {Array<Vector2>} contour - An array of 2D points.
   * @return {number} The area.
   */
  static area(e) {
    const n = e.length;
    let s = 0;
    for (let r = n - 1, a = 0; a < n; r = a++)
      s += e[r].x * e[a].y - e[a].x * e[r].y;
    return s * 0.5;
  }
  /**
   * Returns `true` if the given contour uses a clockwise winding order.
   *
   * @param {Array<Vector2>} pts - An array of 2D points defining a polygon.
   * @return {boolean} Whether the given contour uses a clockwise winding order or not.
   */
  static isClockWise(e) {
    return ei.area(e) < 0;
  }
  /**
   * Triangulates the given shape definition.
   *
   * @param {Array<Vector2>} contour - An array of 2D points defining the contour.
   * @param {Array<Array<Vector2>>} holes - An array that holds arrays of 2D points defining the holes.
   * @return {Array<Array<number>>} An array that holds for each face definition an array with three indices.
   */
  static triangulateShape(e, n) {
    const s = [], r = [], a = [];
    Ag(e), Pg(s, e);
    let o = e.length;
    n.forEach(Ag);
    for (let c = 0; c < n.length; c++)
      r.push(o), o += n[c].length, Pg(s, n[c]);
    const h = s8.triangulate(s, r);
    for (let c = 0; c < h.length; c += 3)
      a.push(h.slice(c, c + 3));
    return a;
  }
}
function Ag(i) {
  const e = i.length;
  e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function Pg(i, e) {
  for (let n = 0; n < e.length; n++)
    i.push(e[n].x), i.push(e[n].y);
}
class r8 {
  /**
   * Constructs a new shape path.
   */
  constructor() {
    this.type = "ShapePath", this.color = new qa(), this.subPaths = [], this.currentPath = null;
  }
  /**
   * Creates a new path and moves it current point to the given one.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {ShapePath} A reference to this shape path.
   */
  moveTo(e, n) {
    return this.currentPath = new jl(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, n), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  lineTo(e, n) {
    return this.currentPath.lineTo(e, n), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  quadraticCurveTo(e, n, s, r) {
    return this.currentPath.quadraticCurveTo(e, n, s, r), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  bezierCurveTo(e, n, s, r, a, o) {
    return this.currentPath.bezierCurveTo(e, n, s, r, a, o), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {ShapePath} A reference to this shape path.
   */
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  /**
   * Converts the paths into an array of shapes.
   *
   * @param {boolean} isCCW - By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW).
   * If this flag is set to `true`, then those are flipped.
   * @return {Array<Shape>} An array of shapes.
   */
  toShapes(e) {
    function n(m) {
      const v = [];
      for (let w = 0, b = m.length; w < b; w++) {
        const S = m[w], E = new za();
        E.curves = S.curves, v.push(E);
      }
      return v;
    }
    function s(m, v) {
      const w = v.length;
      let b = !1;
      for (let S = w - 1, E = 0; E < w; S = E++) {
        let A = v[S], M = v[E], _ = M.x - A.x, T = M.y - A.y;
        if (Math.abs(T) > Number.EPSILON) {
          if (T < 0 && (A = v[E], _ = -_, M = v[S], T = -T), m.y < A.y || m.y > M.y) continue;
          if (m.y === A.y) {
            if (m.x === A.x) return !0;
          } else {
            const C = T * (m.x - A.x) - _ * (m.y - A.y);
            if (C === 0) return !0;
            if (C < 0) continue;
            b = !b;
          }
        } else {
          if (m.y !== A.y) continue;
          if (M.x <= m.x && m.x <= A.x || A.x <= m.x && m.x <= M.x) return !0;
        }
      }
      return b;
    }
    const r = ei.isClockWise, a = this.subPaths;
    if (a.length === 0) return [];
    let o, h, c;
    const l = [];
    if (a.length === 1)
      return h = a[0], c = new za(), c.curves = h.curves, l.push(c), l;
    let u = !r(a[0].getPoints());
    u = e ? !u : u;
    const f = [], d = [];
    let p = [], y = 0, x;
    d[y] = void 0, p[y] = [];
    for (let m = 0, v = a.length; m < v; m++)
      h = a[m], x = h.getPoints(), o = r(x), o = e ? !o : o, o ? (!u && d[y] && y++, d[y] = { s: new za(), p: x }, d[y].s.curves = h.curves, u && y++, p[y] = []) : p[y].push({ h, p: x[0] });
    if (!d[0]) return n(a);
    if (d.length > 1) {
      let m = !1, v = 0;
      for (let w = 0, b = d.length; w < b; w++)
        f[w] = [];
      for (let w = 0, b = d.length; w < b; w++) {
        const S = p[w];
        for (let E = 0; E < S.length; E++) {
          const A = S[E];
          let M = !0;
          for (let _ = 0; _ < d.length; _++)
            s(A.p, d[_].p) && (w !== _ && v++, M ? (M = !1, f[_].push(A)) : m = !0);
          M && f[w].push(A);
        }
      }
      v > 0 && m === !1 && (p = f);
    }
    let g;
    for (let m = 0, v = d.length; m < v; m++) {
      c = d[m].s, l.push(c), g = p[m];
      for (let w = 0, b = g.length; w < b; w++)
        c.holes.push(g[w].h);
    }
    return l;
  }
}
function a8(i, e) {
  const n = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return n > e ? (i.repeat.x = 1, i.repeat.y = n / e, i.offset.x = 0, i.offset.y = (1 - i.repeat.y) / 2) : (i.repeat.x = e / n, i.repeat.y = 1, i.offset.x = (1 - i.repeat.x) / 2, i.offset.y = 0), i;
}
function o8(i, e) {
  const n = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return n > e ? (i.repeat.x = e / n, i.repeat.y = 1, i.offset.x = (1 - i.repeat.x) / 2, i.offset.y = 0) : (i.repeat.x = 1, i.repeat.y = n / e, i.offset.x = 0, i.offset.y = (1 - i.repeat.y) / 2), i;
}
function h8(i) {
  return i.repeat.x = 1, i.repeat.y = 1, i.offset.x = 0, i.offset.y = 0, i;
}
function c8(i, e, n, s) {
  const r = l8(s);
  switch (n) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case JM:
      return i * e;
    case tb:
      return i * e / r.components * r.byteLength;
    case eb:
      return i * e / r.components * r.byteLength;
    case nb:
      return i * e * 2 / r.components * r.byteLength;
    case ib:
      return i * e * 2 / r.components * r.byteLength;
    case QM:
      return i * e * 3 / r.components * r.byteLength;
    case m1:
      return i * e * 4 / r.components * r.byteLength;
    case sb:
      return i * e * 4 / r.components * r.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case rb:
    case ab:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case ob:
    case hb:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case lb:
    case fb:
      return Math.max(i, 16) * Math.max(e, 8) / 4;
    case cb:
    case ub:
      return Math.max(i, 8) * Math.max(e, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case db:
    case pb:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case yb:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case xb:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case gb:
      return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case mb:
      return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case vb:
      return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case wb:
      return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Mb:
      return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case bb:
      return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case _b:
      return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Sb:
      return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Tb:
      return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Eb:
      return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case zb:
      return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Cb:
      return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Ab:
      return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case Pb:
    case Ib:
    case Rb:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case Ob:
    case kb:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
    case Lb:
    case Fb:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${n} format.`
  );
}
function l8(i) {
  switch (i) {
    case y1:
    case GM:
      return { byteLength: 1, components: 1 };
    case WM:
    case UM:
    case jM:
      return { byteLength: 2, components: 1 };
    case HM:
    case XM:
      return { byteLength: 2, components: 4 };
    case x1:
    case YM:
    case g1:
      return { byteLength: 4, components: 1 };
    case ZM:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${i}.`);
}
class u8 {
  /**
   * Scales the texture as large as possible within its surface without cropping
   * or stretching the texture. The method preserves the original aspect ratio of
   * the texture. Akin to CSS `object-fit: contain`
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static contain(e, n) {
    return a8(e, n);
  }
  /**
   * Scales the texture to the smallest possible size to fill the surface, leaving
   * no empty space. The method preserves the original aspect ratio of the texture.
   * Akin to CSS `object-fit: cover`.
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static cover(e, n) {
    return o8(e, n);
  }
  /**
   * Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.
   *
   * @param {Texture} texture - The texture.
   * @return {Texture} The updated texture.
   */
  static fill(e) {
    return h8(e);
  }
  /**
   * Determines how many bytes must be used to represent the texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} format - The texture's format.
   * @param {number} type - The texture's type.
   * @return {number} The byte length.
   */
  static getByteLength(e, n, s, r) {
    return c8(e, n, s, r);
  }
}
class B1 extends Me {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(e = 1, n = 1, s = 1, r = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: s,
      widthSegments: r,
      heightSegments: a,
      depthSegments: o
    };
    const h = this;
    r = Math.floor(r), a = Math.floor(a), o = Math.floor(o);
    const c = [], l = [], u = [], f = [];
    let d = 0, p = 0;
    y("z", "y", "x", -1, -1, s, n, e, o, a, 0), y("z", "y", "x", 1, -1, s, n, -e, o, a, 1), y("x", "z", "y", 1, 1, e, s, n, r, o, 2), y("x", "z", "y", 1, -1, e, s, -n, r, o, 3), y("x", "y", "z", 1, -1, e, n, s, r, a, 4), y("x", "y", "z", -1, -1, e, n, -s, r, a, 5), this.setIndex(c), this.setAttribute("position", new St(l, 3)), this.setAttribute("normal", new St(u, 3)), this.setAttribute("uv", new St(f, 2));
    function y(x, g, m, v, w, b, S, E, A, M, _) {
      const T = b / A, C = S / M, P = b / 2, R = S / 2, k = E / 2, I = A + 1, L = M + 1;
      let F = 0, B = 0;
      const V = new $();
      for (let J = 0; J < L; J++) {
        const j = J * C - R;
        for (let ht = 0; ht < I; ht++) {
          const rt = ht * T - P;
          V[x] = rt * v, V[g] = j * w, V[m] = k, l.push(V.x, V.y, V.z), V[x] = 0, V[g] = 0, V[m] = E > 0 ? 1 : -1, u.push(V.x, V.y, V.z), f.push(ht / A), f.push(1 - J / M), F += 1;
        }
      }
      for (let J = 0; J < M; J++)
        for (let j = 0; j < A; j++) {
          const ht = d + j + I * J, rt = d + j + I * (J + 1), ft = d + (j + 1) + I * (J + 1), lt = d + (j + 1) + I * J;
          c.push(ht, rt, lt), c.push(rt, ft, lt), B += 6;
        }
      h.addGroup(p, B, _), p += B, d += F;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(e) {
    return new B1(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
class D1 extends Me {
  /**
   * Constructs a new capsule geometry.
   *
   * @param {number} [radius=1] - Radius of the capsule.
   * @param {number} [height=1] - Height of the middle section.
   * @param {number} [capSegments=4] - Number of curve segments used to build each cap.
   * @param {number} [radialSegments=8] - Number of segmented faces around the circumference of the capsule. Must be an integer >= 3.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the middle section. Must be an integer >= 1.
   */
  constructor(e = 1, n = 1, s = 4, r = 8, a = 1) {
    super(), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: n,
      capSegments: s,
      radialSegments: r,
      heightSegments: a
    }, n = Math.max(0, n), s = Math.max(1, Math.floor(s)), r = Math.max(3, Math.floor(r)), a = Math.max(1, Math.floor(a));
    const o = [], h = [], c = [], l = [], u = n / 2, f = Math.PI / 2 * e, d = n, p = 2 * f + d, y = s * 2 + a, x = r + 1, g = new $(), m = new $();
    for (let v = 0; v <= y; v++) {
      let w = 0, b = 0, S = 0, E = 0;
      if (v <= s) {
        const _ = v / s, T = _ * Math.PI / 2;
        b = -u - e * Math.cos(T), S = e * Math.sin(T), E = -e * Math.cos(T), w = _ * f;
      } else if (v <= s + a) {
        const _ = (v - s) / a;
        b = -u + _ * n, S = e, E = 0, w = f + _ * d;
      } else {
        const _ = (v - s - a) / s, T = _ * Math.PI / 2;
        b = u + e * Math.sin(T), S = e * Math.cos(T), E = e * Math.sin(T), w = f + d + _ * f;
      }
      const A = Math.max(0, Math.min(1, w / p));
      let M = 0;
      v === 0 ? M = 0.5 / r : v === y && (M = -0.5 / r);
      for (let _ = 0; _ <= r; _++) {
        const T = _ / r, C = T * Math.PI * 2, P = Math.sin(C), R = Math.cos(C);
        m.x = -S * R, m.y = b, m.z = S * P, h.push(m.x, m.y, m.z), g.set(
          -S * R,
          E,
          S * P
        ), g.normalize(), c.push(g.x, g.y, g.z), l.push(T + M, A);
      }
      if (v > 0) {
        const _ = (v - 1) * x;
        for (let T = 0; T < r; T++) {
          const C = _ + T, P = _ + T + 1, R = v * x + T, k = v * x + T + 1;
          o.push(C, P, R), o.push(P, k, R);
        }
      }
    }
    this.setIndex(o), this.setAttribute("position", new St(h, 3)), this.setAttribute("normal", new St(c, 3)), this.setAttribute("uv", new St(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CapsuleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new D1(e.radius, e.height, e.capSegments, e.radialSegments, e.heightSegments);
  }
}
class q1 extends Me {
  /**
   * Constructs a new circle geometry.
   *
   * @param {number} [radius=1] - Radius of the circle.
   * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.
   * @param {number} [thetaStart=0] - Start angle for first segment in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,
   * of the circular sector in radians. The default value results in a complete circle.
   */
  constructor(e = 1, n = 32, s = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: n,
      thetaStart: s,
      thetaLength: r
    }, n = Math.max(3, n);
    const a = [], o = [], h = [], c = [], l = new $(), u = new it();
    o.push(0, 0, 0), h.push(0, 0, 1), c.push(0.5, 0.5);
    for (let f = 0, d = 3; f <= n; f++, d += 3) {
      const p = s + f / n * r;
      l.x = e * Math.cos(p), l.y = e * Math.sin(p), o.push(l.x, l.y, l.z), h.push(0, 0, 1), u.x = (o[d] / e + 1) / 2, u.y = (o[d + 1] / e + 1) / 2, c.push(u.x, u.y);
    }
    for (let f = 1; f <= n; f++)
      a.push(f, f + 1, 0);
    this.setIndex(a), this.setAttribute("position", new St(o, 3)), this.setAttribute("normal", new St(h, 3)), this.setAttribute("uv", new St(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CircleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new q1(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class wu extends Me {
  /**
   * Constructs a new cylinder geometry.
   *
   * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
   * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
   * @param {number} [height=1] - Height of the cylinder.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
   * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cylinder.
   */
  constructor(e = 1, n = 1, s = 1, r = 32, a = 1, o = !1, h = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: s,
      radialSegments: r,
      heightSegments: a,
      openEnded: o,
      thetaStart: h,
      thetaLength: c
    };
    const l = this;
    r = Math.floor(r), a = Math.floor(a);
    const u = [], f = [], d = [], p = [];
    let y = 0;
    const x = [], g = s / 2;
    let m = 0;
    v(), o === !1 && (e > 0 && w(!0), n > 0 && w(!1)), this.setIndex(u), this.setAttribute("position", new St(f, 3)), this.setAttribute("normal", new St(d, 3)), this.setAttribute("uv", new St(p, 2));
    function v() {
      const b = new $(), S = new $();
      let E = 0;
      const A = (n - e) / s;
      for (let M = 0; M <= a; M++) {
        const _ = [], T = M / a, C = T * (n - e) + e;
        for (let P = 0; P <= r; P++) {
          const R = P / r, k = R * c + h, I = Math.sin(k), L = Math.cos(k);
          S.x = C * I, S.y = -T * s + g, S.z = C * L, f.push(S.x, S.y, S.z), b.set(I, A, L).normalize(), d.push(b.x, b.y, b.z), p.push(R, 1 - T), _.push(y++);
        }
        x.push(_);
      }
      for (let M = 0; M < r; M++)
        for (let _ = 0; _ < a; _++) {
          const T = x[_][M], C = x[_ + 1][M], P = x[_ + 1][M + 1], R = x[_][M + 1];
          (e > 0 || _ !== 0) && (u.push(T, C, R), E += 3), (n > 0 || _ !== a - 1) && (u.push(C, P, R), E += 3);
        }
      l.addGroup(m, E, 0), m += E;
    }
    function w(b) {
      const S = y, E = new it(), A = new $();
      let M = 0;
      const _ = b === !0 ? e : n, T = b === !0 ? 1 : -1;
      for (let P = 1; P <= r; P++)
        f.push(0, g * T, 0), d.push(0, T, 0), p.push(0.5, 0.5), y++;
      const C = y;
      for (let P = 0; P <= r; P++) {
        const k = P / r * c + h, I = Math.cos(k), L = Math.sin(k);
        A.x = _ * L, A.y = g * T, A.z = _ * I, f.push(A.x, A.y, A.z), d.push(0, T, 0), E.x = I * 0.5 + 0.5, E.y = L * 0.5 * T + 0.5, p.push(E.x, E.y), y++;
      }
      for (let P = 0; P < r; P++) {
        const R = S + P, k = C + P;
        b === !0 ? u.push(k, k + 1, R) : u.push(k + 1, k, R), M += 3;
      }
      l.addGroup(m, M, b === !0 ? 1 : 2), m += M;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CylinderGeometry} A new instance.
   */
  static fromJSON(e) {
    return new wu(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class $1 extends wu {
  /**
   * Constructs a new cone geometry.
   *
   * @param {number} [radius=1] - Radius of the cone base.
   * @param {number} [height=1] - Height of the cone.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cone.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cone.
   * @param {boolean} [openEnded=false] - Whether the base of the cone is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cone.
   */
  constructor(e = 1, n = 1, s = 32, r = 1, a = !1, o = 0, h = Math.PI * 2) {
    super(0, e, n, s, r, a, o, h), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: n,
      radialSegments: s,
      heightSegments: r,
      openEnded: a,
      thetaStart: o,
      thetaLength: h
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {ConeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new $1(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class kr extends Me {
  /**
   * Constructs a new polyhedron geometry.
   *
   * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.
   * @param {Array<number>} [indices] - A flat array of indices describing the base shape.
   * @param {number} [radius=1] - The radius of the shape.
   * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.
   */
  constructor(e = [], n = [], s = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: n,
      radius: s,
      detail: r
    };
    const a = [], o = [];
    h(r), l(s), u(), this.setAttribute("position", new St(a, 3)), this.setAttribute("normal", new St(a.slice(), 3)), this.setAttribute("uv", new St(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function h(v) {
      const w = new $(), b = new $(), S = new $();
      for (let E = 0; E < n.length; E += 3)
        p(n[E + 0], w), p(n[E + 1], b), p(n[E + 2], S), c(w, b, S, v);
    }
    function c(v, w, b, S) {
      const E = S + 1, A = [];
      for (let M = 0; M <= E; M++) {
        A[M] = [];
        const _ = v.clone().lerp(b, M / E), T = w.clone().lerp(b, M / E), C = E - M;
        for (let P = 0; P <= C; P++)
          P === 0 && M === E ? A[M][P] = _ : A[M][P] = _.clone().lerp(T, P / C);
      }
      for (let M = 0; M < E; M++)
        for (let _ = 0; _ < 2 * (E - M) - 1; _++) {
          const T = Math.floor(_ / 2);
          _ % 2 === 0 ? (d(A[M][T + 1]), d(A[M + 1][T]), d(A[M][T])) : (d(A[M][T + 1]), d(A[M + 1][T + 1]), d(A[M + 1][T]));
        }
    }
    function l(v) {
      const w = new $();
      for (let b = 0; b < a.length; b += 3)
        w.x = a[b + 0], w.y = a[b + 1], w.z = a[b + 2], w.normalize().multiplyScalar(v), a[b + 0] = w.x, a[b + 1] = w.y, a[b + 2] = w.z;
    }
    function u() {
      const v = new $();
      for (let w = 0; w < a.length; w += 3) {
        v.x = a[w + 0], v.y = a[w + 1], v.z = a[w + 2];
        const b = g(v) / 2 / Math.PI + 0.5, S = m(v) / Math.PI + 0.5;
        o.push(b, 1 - S);
      }
      y(), f();
    }
    function f() {
      for (let v = 0; v < o.length; v += 6) {
        const w = o[v + 0], b = o[v + 2], S = o[v + 4], E = Math.max(w, b, S), A = Math.min(w, b, S);
        E > 0.9 && A < 0.1 && (w < 0.2 && (o[v + 0] += 1), b < 0.2 && (o[v + 2] += 1), S < 0.2 && (o[v + 4] += 1));
      }
    }
    function d(v) {
      a.push(v.x, v.y, v.z);
    }
    function p(v, w) {
      const b = v * 3;
      w.x = e[b + 0], w.y = e[b + 1], w.z = e[b + 2];
    }
    function y() {
      const v = new $(), w = new $(), b = new $(), S = new $(), E = new it(), A = new it(), M = new it();
      for (let _ = 0, T = 0; _ < a.length; _ += 9, T += 6) {
        v.set(a[_ + 0], a[_ + 1], a[_ + 2]), w.set(a[_ + 3], a[_ + 4], a[_ + 5]), b.set(a[_ + 6], a[_ + 7], a[_ + 8]), E.set(o[T + 0], o[T + 1]), A.set(o[T + 2], o[T + 3]), M.set(o[T + 4], o[T + 5]), S.copy(v).add(w).add(b).divideScalar(3);
        const C = g(S);
        x(E, T + 0, v, C), x(A, T + 2, w, C), x(M, T + 4, b, C);
      }
    }
    function x(v, w, b, S) {
      S < 0 && v.x === 1 && (o[w] = v.x - 1), b.x === 0 && b.z === 0 && (o[w] = S / 2 / Math.PI + 0.5);
    }
    function g(v) {
      return Math.atan2(v.z, -v.x);
    }
    function m(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PolyhedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new kr(e.vertices, e.indices, e.radius, e.details);
  }
}
class V1 extends kr {
  /**
   * Constructs a new dodecahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the dodecahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron.
   */
  constructor(e = 1, n = 0) {
    const s = (1 + Math.sqrt(5)) / 2, r = 1 / s, a = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -r,
      -s,
      0,
      -r,
      s,
      0,
      r,
      -s,
      0,
      r,
      s,
      // (±1/φ, ±φ, 0)
      -r,
      -s,
      0,
      -r,
      s,
      0,
      r,
      -s,
      0,
      r,
      s,
      0,
      // (±φ, 0, ±1/φ)
      -s,
      0,
      -r,
      s,
      0,
      -r,
      -s,
      0,
      r,
      s,
      0,
      r
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(a, o, e, n), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {DodecahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new V1(e.radius, e.detail);
  }
}
const Un = /* @__PURE__ */ new $(), Ri = /* @__PURE__ */ new $(), Pf = /* @__PURE__ */ new $(), Oi = /* @__PURE__ */ new $(), Kr = /* @__PURE__ */ new $(), ta = /* @__PURE__ */ new $(), Ig = /* @__PURE__ */ new $(), If = /* @__PURE__ */ new $(), Rf = /* @__PURE__ */ new $(), Of = /* @__PURE__ */ new $(), kf = /* @__PURE__ */ new _s(), Lf = /* @__PURE__ */ new _s(), Ff = /* @__PURE__ */ new _s();
class us {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(e = new $(), n = new $(), s = new $()) {
    this.a = e, this.b = n, this.c = s;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(e, n, s, r) {
    r.subVectors(s, n), Un.subVectors(e, n), r.cross(Un);
    const a = r.lengthSq();
    return a > 0 ? r.multiplyScalar(1 / Math.sqrt(a)) : r.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(e, n, s, r, a) {
    Un.subVectors(r, n), Ri.subVectors(s, n), Pf.subVectors(e, n);
    const o = Un.dot(Un), h = Un.dot(Ri), c = Un.dot(Pf), l = Ri.dot(Ri), u = Ri.dot(Pf), f = o * l - h * h;
    if (f === 0)
      return a.set(0, 0, 0), null;
    const d = 1 / f, p = (l * c - h * u) * d, y = (o * u - h * c) * d;
    return a.set(1 - p - y, y, p);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(e, n, s, r) {
    return this.getBarycoord(e, n, s, r, Oi) === null ? !1 : Oi.x >= 0 && Oi.y >= 0 && Oi.x + Oi.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(e, n, s, r, a, o, h, c) {
    return this.getBarycoord(e, n, s, r, Oi) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(a, Oi.x), c.addScaledVector(o, Oi.y), c.addScaledVector(h, Oi.z), c);
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(e, n, s, r, a, o) {
    return kf.setScalar(0), Lf.setScalar(0), Ff.setScalar(0), kf.fromBufferAttribute(e, n), Lf.fromBufferAttribute(e, s), Ff.fromBufferAttribute(e, r), o.setScalar(0), o.addScaledVector(kf, a.x), o.addScaledVector(Lf, a.y), o.addScaledVector(Ff, a.z), o;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(e, n, s, r) {
    return Un.subVectors(s, n), Ri.subVectors(e, n), Un.cross(Ri).dot(r) < 0;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(e, n, s) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(s), this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(e, n, s, r) {
    return this.a.copy(e[n]), this.b.copy(e[s]), this.c.copy(e[r]), this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(e, n, s, r) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, s), this.c.fromBufferAttribute(e, r), this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    return Un.subVectors(this.c, this.b), Ri.subVectors(this.a, this.b), Un.cross(Ri).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(e) {
    return us.getNormal(this.a, this.b, this.c, e);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(e, n) {
    return us.getBarycoord(e, this.a, this.b, this.c, n);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(e, n, s, r, a) {
    return us.getInterpolation(e, this.a, this.b, this.c, n, s, r, a);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(e) {
    return us.containsPoint(e, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(e) {
    return us.isFrontFacing(this.a, this.b, this.c, e);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(e, n) {
    const s = this.a, r = this.b, a = this.c;
    let o, h;
    Kr.subVectors(r, s), ta.subVectors(a, s), If.subVectors(e, s);
    const c = Kr.dot(If), l = ta.dot(If);
    if (c <= 0 && l <= 0)
      return n.copy(s);
    Rf.subVectors(e, r);
    const u = Kr.dot(Rf), f = ta.dot(Rf);
    if (u >= 0 && f <= u)
      return n.copy(r);
    const d = c * f - u * l;
    if (d <= 0 && c >= 0 && u <= 0)
      return o = c / (c - u), n.copy(s).addScaledVector(Kr, o);
    Of.subVectors(e, a);
    const p = Kr.dot(Of), y = ta.dot(Of);
    if (y >= 0 && p <= y)
      return n.copy(a);
    const x = p * l - c * y;
    if (x <= 0 && l >= 0 && y <= 0)
      return h = l / (l - y), n.copy(s).addScaledVector(ta, h);
    const g = u * y - p * f;
    if (g <= 0 && f - u >= 0 && p - y >= 0)
      return Ig.subVectors(a, r), h = (f - u) / (f - u + (p - y)), n.copy(r).addScaledVector(Ig, h);
    const m = 1 / (g + x + d);
    return o = x * m, h = d * m, n.copy(s).addScaledVector(Kr, o).addScaledVector(ta, h);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const qc = /* @__PURE__ */ new $(), $c = /* @__PURE__ */ new $(), Nf = /* @__PURE__ */ new $(), Vc = /* @__PURE__ */ new us();
class f8 extends Me {
  /**
   * Constructs a new edges geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   * @param {number} [thresholdAngle=1] - An edge is only rendered if the angle (in degrees)
   * between the face normals of the adjoining faces exceeds this value.
   */
  constructor(e = null, n = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: n
    }, e !== null) {
      const r = Math.pow(10, 4), a = Math.cos(wr * n), o = e.getIndex(), h = e.getAttribute("position"), c = o ? o.count : h.count, l = [0, 0, 0], u = ["a", "b", "c"], f = new Array(3), d = {}, p = [];
      for (let y = 0; y < c; y += 3) {
        o ? (l[0] = o.getX(y), l[1] = o.getX(y + 1), l[2] = o.getX(y + 2)) : (l[0] = y, l[1] = y + 1, l[2] = y + 2);
        const { a: x, b: g, c: m } = Vc;
        if (x.fromBufferAttribute(h, l[0]), g.fromBufferAttribute(h, l[1]), m.fromBufferAttribute(h, l[2]), Vc.getNormal(Nf), f[0] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`, f[1] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`, f[2] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`, !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0]))
          for (let v = 0; v < 3; v++) {
            const w = (v + 1) % 3, b = f[v], S = f[w], E = Vc[u[v]], A = Vc[u[w]], M = `${b}_${S}`, _ = `${S}_${b}`;
            _ in d && d[_] ? (Nf.dot(d[_].normal) <= a && (p.push(E.x, E.y, E.z), p.push(A.x, A.y, A.z)), d[_] = null) : M in d || (d[M] = {
              index0: l[v],
              index1: l[w],
              normal: Nf.clone()
            });
          }
      }
      for (const y in d)
        if (d[y]) {
          const { index0: x, index1: g } = d[y];
          qc.fromBufferAttribute(h, x), $c.fromBufferAttribute(h, g), p.push(qc.x, qc.y, qc.z), p.push($c.x, $c.y, $c.z);
        }
      this.setAttribute("position", new St(p, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class G1 extends Me {
  /**
   * Constructs a new extrude geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {ExtrudeGeometry~Options} [options] - The extrude settings.
   */
  constructor(e = new za([new it(0.5, 0.5), new it(-0.5, 0.5), new it(-0.5, -0.5), new it(0.5, -0.5)]), n = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: n
    }, e = Array.isArray(e) ? e : [e];
    const s = this, r = [], a = [];
    for (let h = 0, c = e.length; h < c; h++) {
      const l = e[h];
      o(l);
    }
    this.setAttribute("position", new St(r, 3)), this.setAttribute("uv", new St(a, 2)), this.computeVertexNormals();
    function o(h) {
      const c = [], l = n.curveSegments !== void 0 ? n.curveSegments : 12, u = n.steps !== void 0 ? n.steps : 1, f = n.depth !== void 0 ? n.depth : 1;
      let d = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0, p = n.bevelThickness !== void 0 ? n.bevelThickness : 0.2, y = n.bevelSize !== void 0 ? n.bevelSize : p - 0.1, x = n.bevelOffset !== void 0 ? n.bevelOffset : 0, g = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const m = n.extrudePath, v = n.UVGenerator !== void 0 ? n.UVGenerator : d8;
      let w, b = !1, S, E, A, M;
      m && (w = m.getSpacedPoints(u), b = !0, d = !1, S = m.computeFrenetFrames(u, !1), E = new $(), A = new $(), M = new $()), d || (g = 0, p = 0, y = 0, x = 0);
      const _ = h.extractPoints(l);
      let T = _.shape;
      const C = _.holes;
      if (!ei.isClockWise(T)) {
        T = T.reverse();
        for (let H = 0, Z = C.length; H < Z; H++) {
          const et = C[H];
          ei.isClockWise(et) && (C[H] = et.reverse());
        }
      }
      function R(H) {
        const et = 10000000000000001e-36;
        let ut = H[0];
        for (let at = 1; at <= H.length; at++) {
          const Ot = at % H.length, bt = H[Ot], Wt = bt.x - ut.x, nt = bt.y - ut.y, Kt = Wt * Wt + nt * nt, z = Math.max(
            Math.abs(bt.x),
            Math.abs(bt.y),
            Math.abs(ut.x),
            Math.abs(ut.y)
          ), O = et * z * z;
          if (Kt <= O) {
            H.splice(Ot, 1), at--;
            continue;
          }
          ut = bt;
        }
      }
      R(T), C.forEach(R);
      const k = C.length, I = T;
      for (let H = 0; H < k; H++) {
        const Z = C[H];
        T = T.concat(Z);
      }
      function L(H, Z, et) {
        return Z || console.error("THREE.ExtrudeGeometry: vec does not exist"), H.clone().addScaledVector(Z, et);
      }
      const F = T.length;
      function B(H, Z, et) {
        let ut, at, Ot;
        const bt = H.x - Z.x, Wt = H.y - Z.y, nt = et.x - H.x, Kt = et.y - H.y, z = bt * bt + Wt * Wt, O = bt * Kt - Wt * nt;
        if (Math.abs(O) > Number.EPSILON) {
          const D = Math.sqrt(z), q = Math.sqrt(nt * nt + Kt * Kt), U = Z.x - Wt / D, G = Z.y + bt / D, W = et.x - Kt / q, Y = et.y + nt / q, Q = ((W - U) * Kt - (Y - G) * nt) / (bt * Kt - Wt * nt);
          ut = U + bt * Q - H.x, at = G + Wt * Q - H.y;
          const Mt = ut * ut + at * at;
          if (Mt <= 2)
            return new it(ut, at);
          Ot = Math.sqrt(Mt / 2);
        } else {
          let D = !1;
          bt > Number.EPSILON ? nt > Number.EPSILON && (D = !0) : bt < -Number.EPSILON ? nt < -Number.EPSILON && (D = !0) : Math.sign(Wt) === Math.sign(Kt) && (D = !0), D ? (ut = -Wt, at = bt, Ot = Math.sqrt(z)) : (ut = bt, at = Wt, Ot = Math.sqrt(z / 2));
        }
        return new it(ut / Ot, at / Ot);
      }
      const V = [];
      for (let H = 0, Z = I.length, et = Z - 1, ut = H + 1; H < Z; H++, et++, ut++)
        et === Z && (et = 0), ut === Z && (ut = 0), V[H] = B(I[H], I[et], I[ut]);
      const J = [];
      let j, ht = V.concat();
      for (let H = 0, Z = k; H < Z; H++) {
        const et = C[H];
        j = [];
        for (let ut = 0, at = et.length, Ot = at - 1, bt = ut + 1; ut < at; ut++, Ot++, bt++)
          Ot === at && (Ot = 0), bt === at && (bt = 0), j[ut] = B(et[ut], et[Ot], et[bt]);
        J.push(j), ht = ht.concat(j);
      }
      let rt;
      if (g === 0)
        rt = ei.triangulateShape(I, C);
      else {
        const H = [], Z = [];
        for (let et = 0; et < g; et++) {
          const ut = et / g, at = p * Math.cos(ut * Math.PI / 2), Ot = y * Math.sin(ut * Math.PI / 2) + x;
          for (let bt = 0, Wt = I.length; bt < Wt; bt++) {
            const nt = L(I[bt], V[bt], Ot);
            ie(nt.x, nt.y, -at), ut === 0 && H.push(nt);
          }
          for (let bt = 0, Wt = k; bt < Wt; bt++) {
            const nt = C[bt];
            j = J[bt];
            const Kt = [];
            for (let z = 0, O = nt.length; z < O; z++) {
              const D = L(nt[z], j[z], Ot);
              ie(D.x, D.y, -at), ut === 0 && Kt.push(D);
            }
            ut === 0 && Z.push(Kt);
          }
        }
        rt = ei.triangulateShape(H, Z);
      }
      const ft = rt.length, lt = y + x;
      for (let H = 0; H < F; H++) {
        const Z = d ? L(T[H], ht[H], lt) : T[H];
        b ? (A.copy(S.normals[0]).multiplyScalar(Z.x), E.copy(S.binormals[0]).multiplyScalar(Z.y), M.copy(w[0]).add(A).add(E), ie(M.x, M.y, M.z)) : ie(Z.x, Z.y, 0);
      }
      for (let H = 1; H <= u; H++)
        for (let Z = 0; Z < F; Z++) {
          const et = d ? L(T[Z], ht[Z], lt) : T[Z];
          b ? (A.copy(S.normals[H]).multiplyScalar(et.x), E.copy(S.binormals[H]).multiplyScalar(et.y), M.copy(w[H]).add(A).add(E), ie(M.x, M.y, M.z)) : ie(et.x, et.y, f / u * H);
        }
      for (let H = g - 1; H >= 0; H--) {
        const Z = H / g, et = p * Math.cos(Z * Math.PI / 2), ut = y * Math.sin(Z * Math.PI / 2) + x;
        for (let at = 0, Ot = I.length; at < Ot; at++) {
          const bt = L(I[at], V[at], ut);
          ie(bt.x, bt.y, f + et);
        }
        for (let at = 0, Ot = C.length; at < Ot; at++) {
          const bt = C[at];
          j = J[at];
          for (let Wt = 0, nt = bt.length; Wt < nt; Wt++) {
            const Kt = L(bt[Wt], j[Wt], ut);
            b ? ie(Kt.x, Kt.y + w[u - 1].y, w[u - 1].x + et) : ie(Kt.x, Kt.y, f + et);
          }
        }
      }
      wt(), Ut();
      function wt() {
        const H = r.length / 3;
        if (d) {
          let Z = 0, et = F * Z;
          for (let ut = 0; ut < ft; ut++) {
            const at = rt[ut];
            be(at[2] + et, at[1] + et, at[0] + et);
          }
          Z = u + g * 2, et = F * Z;
          for (let ut = 0; ut < ft; ut++) {
            const at = rt[ut];
            be(at[0] + et, at[1] + et, at[2] + et);
          }
        } else {
          for (let Z = 0; Z < ft; Z++) {
            const et = rt[Z];
            be(et[2], et[1], et[0]);
          }
          for (let Z = 0; Z < ft; Z++) {
            const et = rt[Z];
            be(et[0] + F * u, et[1] + F * u, et[2] + F * u);
          }
        }
        s.addGroup(H, r.length / 3 - H, 0);
      }
      function Ut() {
        const H = r.length / 3;
        let Z = 0;
        fe(I, Z), Z += I.length;
        for (let et = 0, ut = C.length; et < ut; et++) {
          const at = C[et];
          fe(at, Z), Z += at.length;
        }
        s.addGroup(H, r.length / 3 - H, 1);
      }
      function fe(H, Z) {
        let et = H.length;
        for (; --et >= 0; ) {
          const ut = et;
          let at = et - 1;
          at < 0 && (at = H.length - 1);
          for (let Ot = 0, bt = u + g * 2; Ot < bt; Ot++) {
            const Wt = F * Ot, nt = F * (Ot + 1), Kt = Z + ut + Wt, z = Z + at + Wt, O = Z + at + nt, D = Z + ut + nt;
            de(Kt, z, O, D);
          }
        }
      }
      function ie(H, Z, et) {
        c.push(H), c.push(Z), c.push(et);
      }
      function be(H, Z, et) {
        Qt(H), Qt(Z), Qt(et);
        const ut = r.length / 3, at = v.generateTopUV(s, r, ut - 3, ut - 2, ut - 1);
        Xt(at[0]), Xt(at[1]), Xt(at[2]);
      }
      function de(H, Z, et, ut) {
        Qt(H), Qt(Z), Qt(ut), Qt(Z), Qt(et), Qt(ut);
        const at = r.length / 3, Ot = v.generateSideWallUV(s, r, at - 6, at - 3, at - 2, at - 1);
        Xt(Ot[0]), Xt(Ot[1]), Xt(Ot[3]), Xt(Ot[1]), Xt(Ot[2]), Xt(Ot[3]);
      }
      function Qt(H) {
        r.push(c[H * 3 + 0]), r.push(c[H * 3 + 1]), r.push(c[H * 3 + 2]);
      }
      function Xt(H) {
        a.push(H.x), a.push(H.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes, s = this.parameters.options;
    return p8(n, s, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ExtrudeGeometry} A new instance.
   */
  static fromJSON(e, n) {
    const s = [];
    for (let a = 0, o = e.shapes.length; a < o; a++) {
      const h = n[e.shapes[a]];
      s.push(h);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new Yl[r.type]().fromJSON(r)), new G1(s, e.options);
  }
}
const d8 = {
  generateTopUV: function(i, e, n, s, r) {
    const a = e[n * 3], o = e[n * 3 + 1], h = e[s * 3], c = e[s * 3 + 1], l = e[r * 3], u = e[r * 3 + 1];
    return [
      new it(a, o),
      new it(h, c),
      new it(l, u)
    ];
  },
  generateSideWallUV: function(i, e, n, s, r, a) {
    const o = e[n * 3], h = e[n * 3 + 1], c = e[n * 3 + 2], l = e[s * 3], u = e[s * 3 + 1], f = e[s * 3 + 2], d = e[r * 3], p = e[r * 3 + 1], y = e[r * 3 + 2], x = e[a * 3], g = e[a * 3 + 1], m = e[a * 3 + 2];
    return Math.abs(h - u) < Math.abs(o - l) ? [
      new it(o, 1 - c),
      new it(l, 1 - f),
      new it(d, 1 - y),
      new it(x, 1 - m)
    ] : [
      new it(h, 1 - c),
      new it(u, 1 - f),
      new it(p, 1 - y),
      new it(g, 1 - m)
    ];
  }
};
function p8(i, e, n) {
  if (n.shapes = [], Array.isArray(i))
    for (let s = 0, r = i.length; s < r; s++) {
      const a = i[s];
      n.shapes.push(a.uuid);
    }
  else
    n.shapes.push(i.uuid);
  return n.options = Object.assign({}, e), e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
class U1 extends kr {
  /**
   * Constructs a new icosahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the icosahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a icosahedron.
   */
  constructor(e = 1, n = 0) {
    const s = (1 + Math.sqrt(5)) / 2, r = [
      -1,
      s,
      0,
      1,
      s,
      0,
      -1,
      -s,
      0,
      1,
      -s,
      0,
      0,
      -1,
      s,
      0,
      1,
      s,
      0,
      -1,
      -s,
      0,
      1,
      -s,
      s,
      0,
      -1,
      s,
      0,
      1,
      -s,
      0,
      -1,
      -s,
      0,
      1
    ], a = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(r, a, e, n), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {IcosahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new U1(e.radius, e.detail);
  }
}
class W1 extends Me {
  /**
   * Constructs a new lathe geometry.
   *
   * @param {Array<Vector2|Vector3>} [points] - An array of points in 2D space. The x-coordinate of each point
   * must be greater than zero.
   * @param {number} [segments=12] - The number of circumference segments to generate.
   * @param {number} [phiStart=0] - The starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The radian (0 to 2PI) range of the lathed section 2PI is a
   * closed lathe, less than 2PI is a portion.
   */
  constructor(e = [new it(0, -0.5), new it(0.5, 0), new it(0, 0.5)], n = 12, s = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: n,
      phiStart: s,
      phiLength: r
    }, n = Math.floor(n), r = zt(r, 0, Math.PI * 2);
    const a = [], o = [], h = [], c = [], l = [], u = 1 / n, f = new $(), d = new it(), p = new $(), y = new $(), x = new $();
    let g = 0, m = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          g = e[v + 1].x - e[v].x, m = e[v + 1].y - e[v].y, p.x = m * 1, p.y = -g, p.z = m * 0, x.copy(p), p.normalize(), c.push(p.x, p.y, p.z);
          break;
        case e.length - 1:
          c.push(x.x, x.y, x.z);
          break;
        default:
          g = e[v + 1].x - e[v].x, m = e[v + 1].y - e[v].y, p.x = m * 1, p.y = -g, p.z = m * 0, y.copy(p), p.x += x.x, p.y += x.y, p.z += x.z, p.normalize(), c.push(p.x, p.y, p.z), x.copy(y);
      }
    for (let v = 0; v <= n; v++) {
      const w = s + v * u * r, b = Math.sin(w), S = Math.cos(w);
      for (let E = 0; E <= e.length - 1; E++) {
        f.x = e[E].x * b, f.y = e[E].y, f.z = e[E].x * S, o.push(f.x, f.y, f.z), d.x = v / n, d.y = E / (e.length - 1), h.push(d.x, d.y);
        const A = c[3 * E + 0] * b, M = c[3 * E + 1], _ = c[3 * E + 0] * S;
        l.push(A, M, _);
      }
    }
    for (let v = 0; v < n; v++)
      for (let w = 0; w < e.length - 1; w++) {
        const b = w + v * e.length, S = b, E = b + e.length, A = b + e.length + 1, M = b + 1;
        a.push(S, E, M), a.push(A, M, E);
      }
    this.setIndex(a), this.setAttribute("position", new St(o, 3)), this.setAttribute("uv", new St(h, 2)), this.setAttribute("normal", new St(l, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {LatheGeometry} A new instance.
   */
  static fromJSON(e) {
    return new W1(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Y1 extends kr {
  /**
   * Constructs a new octahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the octahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a octahedron.
   */
  constructor(e = 1, n = 0) {
    const s = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(s, r, e, n), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {OctahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Y1(e.radius, e.detail);
  }
}
class j1 extends Me {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(e = 1, n = 1, s = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: s,
      heightSegments: r
    };
    const a = e / 2, o = n / 2, h = Math.floor(s), c = Math.floor(r), l = h + 1, u = c + 1, f = e / h, d = n / c, p = [], y = [], x = [], g = [];
    for (let m = 0; m < u; m++) {
      const v = m * d - o;
      for (let w = 0; w < l; w++) {
        const b = w * f - a;
        y.push(b, -v, 0), x.push(0, 0, 1), g.push(w / h), g.push(1 - m / c);
      }
    }
    for (let m = 0; m < c; m++)
      for (let v = 0; v < h; v++) {
        const w = v + l * m, b = v + l * (m + 1), S = v + 1 + l * (m + 1), E = v + 1 + l * m;
        p.push(w, b, E), p.push(b, S, E);
      }
    this.setIndex(p), this.setAttribute("position", new St(y, 3)), this.setAttribute("normal", new St(x, 3)), this.setAttribute("uv", new St(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(e) {
    return new j1(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class H1 extends Me {
  /**
   * Constructs a new ring geometry.
   *
   * @param {number} [innerRadius=0.5] - The inner radius of the ring.
   * @param {number} [outerRadius=1] - The outer radius of the ring.
   * @param {number} [thetaSegments=32] - Number of segments. A higher number means the ring will be more round. Minimum is `3`.
   * @param {number} [phiSegments=1] - Number of segments per ring segment. Minimum is `1`.
   * @param {number} [thetaStart=0] - Starting angle in radians.
   * @param {number} [thetaLength=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 0.5, n = 1, s = 32, r = 1, a = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: n,
      thetaSegments: s,
      phiSegments: r,
      thetaStart: a,
      thetaLength: o
    }, s = Math.max(3, s), r = Math.max(1, r);
    const h = [], c = [], l = [], u = [];
    let f = e;
    const d = (n - e) / r, p = new $(), y = new it();
    for (let x = 0; x <= r; x++) {
      for (let g = 0; g <= s; g++) {
        const m = a + g / s * o;
        p.x = f * Math.cos(m), p.y = f * Math.sin(m), c.push(p.x, p.y, p.z), l.push(0, 0, 1), y.x = (p.x / n + 1) / 2, y.y = (p.y / n + 1) / 2, u.push(y.x, y.y);
      }
      f += d;
    }
    for (let x = 0; x < r; x++) {
      const g = x * (s + 1);
      for (let m = 0; m < s; m++) {
        const v = m + g, w = v, b = v + s + 1, S = v + s + 2, E = v + 1;
        h.push(w, b, E), h.push(b, S, E);
      }
    }
    this.setIndex(h), this.setAttribute("position", new St(c, 3)), this.setAttribute("normal", new St(l, 3)), this.setAttribute("uv", new St(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {RingGeometry} A new instance.
   */
  static fromJSON(e) {
    return new H1(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class X1 extends Me {
  /**
   * Constructs a new shape geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {number} [curveSegments=12] - Number of segments per shape.
   */
  constructor(e = new za([new it(0, 0.5), new it(-0.5, -0.5), new it(0.5, -0.5)]), n = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const s = [], r = [], a = [], o = [];
    let h = 0, c = 0;
    if (Array.isArray(e) === !1)
      l(e);
    else
      for (let u = 0; u < e.length; u++)
        l(e[u]), this.addGroup(h, c, u), h += c, c = 0;
    this.setIndex(s), this.setAttribute("position", new St(r, 3)), this.setAttribute("normal", new St(a, 3)), this.setAttribute("uv", new St(o, 2));
    function l(u) {
      const f = r.length / 3, d = u.extractPoints(n);
      let p = d.shape;
      const y = d.holes;
      ei.isClockWise(p) === !1 && (p = p.reverse());
      for (let g = 0, m = y.length; g < m; g++) {
        const v = y[g];
        ei.isClockWise(v) === !0 && (y[g] = v.reverse());
      }
      const x = ei.triangulateShape(p, y);
      for (let g = 0, m = y.length; g < m; g++) {
        const v = y[g];
        p = p.concat(v);
      }
      for (let g = 0, m = p.length; g < m; g++) {
        const v = p[g];
        r.push(v.x, v.y, 0), a.push(0, 0, 1), o.push(v.x, v.y);
      }
      for (let g = 0, m = x.length; g < m; g++) {
        const v = x[g], w = v[0] + f, b = v[1] + f, S = v[2] + f;
        s.push(w, b, S), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes;
    return y8(n, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ShapeGeometry} A new instance.
   */
  static fromJSON(e, n) {
    const s = [];
    for (let r = 0, a = e.shapes.length; r < a; r++) {
      const o = n[e.shapes[r]];
      s.push(o);
    }
    return new X1(s, e.curveSegments);
  }
}
function y8(i, e) {
  if (e.shapes = [], Array.isArray(i))
    for (let n = 0, s = i.length; n < s; n++) {
      const r = i[n];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(i.uuid);
  return e;
}
class Z1 extends Me {
  /**
   * Constructs a new sphere geometry.
   *
   * @param {number} [radius=1] - The sphere radius.
   * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
   * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
   * @param {number} [phiStart=0] - The horizontal starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
   * @param {number} [thetaStart=0] - The vertical starting angle in radians.
   * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
   */
  constructor(e = 1, n = 32, s = 16, r = 0, a = Math.PI * 2, o = 0, h = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: s,
      phiStart: r,
      phiLength: a,
      thetaStart: o,
      thetaLength: h
    }, n = Math.max(3, Math.floor(n)), s = Math.max(2, Math.floor(s));
    const c = Math.min(o + h, Math.PI);
    let l = 0;
    const u = [], f = new $(), d = new $(), p = [], y = [], x = [], g = [];
    for (let m = 0; m <= s; m++) {
      const v = [], w = m / s;
      let b = 0;
      m === 0 && o === 0 ? b = 0.5 / n : m === s && c === Math.PI && (b = -0.5 / n);
      for (let S = 0; S <= n; S++) {
        const E = S / n;
        f.x = -e * Math.cos(r + E * a) * Math.sin(o + w * h), f.y = e * Math.cos(o + w * h), f.z = e * Math.sin(r + E * a) * Math.sin(o + w * h), y.push(f.x, f.y, f.z), d.copy(f).normalize(), x.push(d.x, d.y, d.z), g.push(E + b, 1 - w), v.push(l++);
      }
      u.push(v);
    }
    for (let m = 0; m < s; m++)
      for (let v = 0; v < n; v++) {
        const w = u[m][v + 1], b = u[m][v], S = u[m + 1][v], E = u[m + 1][v + 1];
        (m !== 0 || o > 0) && p.push(w, b, E), (m !== s - 1 || c < Math.PI) && p.push(b, S, E);
      }
    this.setIndex(p), this.setAttribute("position", new St(y, 3)), this.setAttribute("normal", new St(x, 3)), this.setAttribute("uv", new St(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {SphereGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Z1(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class J1 extends kr {
  /**
   * Constructs a new tetrahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the tetrahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron.
   */
  constructor(e = 1, n = 0) {
    const s = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], r = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(s, r, e, n), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TetrahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new J1(e.radius, e.detail);
  }
}
class Q1 extends Me {
  /**
   * Constructs a new torus geometry.
   *
   * @param {number} [radius=1] - Radius of the torus, from the center of the torus to the center of the tube.
   * @param {number} [tube=0.4] - Radius of the tube. Must be smaller than `radius`.
   * @param {number} [radialSegments=12] - The number of radial segments.
   * @param {number} [tubularSegments=48] - The number of tubular segments.
   * @param {number} [arc=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 1, n = 0.4, s = 12, r = 48, a = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: n,
      radialSegments: s,
      tubularSegments: r,
      arc: a
    }, s = Math.floor(s), r = Math.floor(r);
    const o = [], h = [], c = [], l = [], u = new $(), f = new $(), d = new $();
    for (let p = 0; p <= s; p++)
      for (let y = 0; y <= r; y++) {
        const x = y / r * a, g = p / s * Math.PI * 2;
        f.x = (e + n * Math.cos(g)) * Math.cos(x), f.y = (e + n * Math.cos(g)) * Math.sin(x), f.z = n * Math.sin(g), h.push(f.x, f.y, f.z), u.x = e * Math.cos(x), u.y = e * Math.sin(x), d.subVectors(f, u).normalize(), c.push(d.x, d.y, d.z), l.push(y / r), l.push(p / s);
      }
    for (let p = 1; p <= s; p++)
      for (let y = 1; y <= r; y++) {
        const x = (r + 1) * p + y - 1, g = (r + 1) * (p - 1) + y - 1, m = (r + 1) * (p - 1) + y, v = (r + 1) * p + y;
        o.push(x, g, v), o.push(g, m, v);
      }
    this.setIndex(o), this.setAttribute("position", new St(h, 3)), this.setAttribute("normal", new St(c, 3)), this.setAttribute("uv", new St(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Q1(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class K1 extends Me {
  /**
   * Constructs a new torus knot geometry.
   *
   * @param {number} [radius=1] - Radius of the torus knot.
   * @param {number} [tube=0.4] - Radius of the tube.
   * @param {number} [tubularSegments=64] - The number of tubular segments.
   * @param {number} [radialSegments=8] - The number of radial segments.
   * @param {number} [p=2] - This value determines, how many times the geometry winds around its axis of rotational symmetry.
   * @param {number} [q=3] - This value determines, how many times the geometry winds around a circle in the interior of the torus.
   */
  constructor(e = 1, n = 0.4, s = 64, r = 8, a = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: n,
      tubularSegments: s,
      radialSegments: r,
      p: a,
      q: o
    }, s = Math.floor(s), r = Math.floor(r);
    const h = [], c = [], l = [], u = [], f = new $(), d = new $(), p = new $(), y = new $(), x = new $(), g = new $(), m = new $();
    for (let w = 0; w <= s; ++w) {
      const b = w / s * a * Math.PI * 2;
      v(b, a, o, e, p), v(b + 0.01, a, o, e, y), g.subVectors(y, p), m.addVectors(y, p), x.crossVectors(g, m), m.crossVectors(x, g), x.normalize(), m.normalize();
      for (let S = 0; S <= r; ++S) {
        const E = S / r * Math.PI * 2, A = -n * Math.cos(E), M = n * Math.sin(E);
        f.x = p.x + (A * m.x + M * x.x), f.y = p.y + (A * m.y + M * x.y), f.z = p.z + (A * m.z + M * x.z), c.push(f.x, f.y, f.z), d.subVectors(f, p).normalize(), l.push(d.x, d.y, d.z), u.push(w / s), u.push(S / r);
      }
    }
    for (let w = 1; w <= s; w++)
      for (let b = 1; b <= r; b++) {
        const S = (r + 1) * (w - 1) + (b - 1), E = (r + 1) * w + (b - 1), A = (r + 1) * w + b, M = (r + 1) * (w - 1) + b;
        h.push(S, E, M), h.push(E, A, M);
      }
    this.setIndex(h), this.setAttribute("position", new St(c, 3)), this.setAttribute("normal", new St(l, 3)), this.setAttribute("uv", new St(u, 2));
    function v(w, b, S, E, A) {
      const M = Math.cos(w), _ = Math.sin(w), T = S / b * w, C = Math.cos(T);
      A.x = E * (2 + C) * 0.5 * M, A.y = E * (2 + C) * _ * 0.5, A.z = E * Math.sin(T) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusKnotGeometry} A new instance.
   */
  static fromJSON(e) {
    return new K1(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class tp extends Me {
  /**
   * Constructs a new tube geometry.
   *
   * @param {Curve} [path=QuadraticBezierCurve3] - A 3D curve defining the path of the tube.
   * @param {number} [tubularSegments=64] - The number of segments that make up the tube.
   * @param {number} [radius=1] -The radius of the tube.
   * @param {number} [radialSegments=8] - The number of segments that make up the cross-section.
   * @param {boolean} [closed=false] - Whether the tube is closed or not.
   */
  constructor(e = new F1(new $(-1, -1, 0), new $(-1, 1, 0), new $(1, 1, 0)), n = 64, s = 1, r = 8, a = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: n,
      radius: s,
      radialSegments: r,
      closed: a
    };
    const o = e.computeFrenetFrames(n, a);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const h = new $(), c = new $(), l = new it();
    let u = new $();
    const f = [], d = [], p = [], y = [];
    x(), this.setIndex(y), this.setAttribute("position", new St(f, 3)), this.setAttribute("normal", new St(d, 3)), this.setAttribute("uv", new St(p, 2));
    function x() {
      for (let w = 0; w < n; w++)
        g(w);
      g(a === !1 ? n : 0), v(), m();
    }
    function g(w) {
      u = e.getPointAt(w / n, u);
      const b = o.normals[w], S = o.binormals[w];
      for (let E = 0; E <= r; E++) {
        const A = E / r * Math.PI * 2, M = Math.sin(A), _ = -Math.cos(A);
        c.x = _ * b.x + M * S.x, c.y = _ * b.y + M * S.y, c.z = _ * b.z + M * S.z, c.normalize(), d.push(c.x, c.y, c.z), h.x = u.x + s * c.x, h.y = u.y + s * c.y, h.z = u.z + s * c.z, f.push(h.x, h.y, h.z);
      }
    }
    function m() {
      for (let w = 1; w <= n; w++)
        for (let b = 1; b <= r; b++) {
          const S = (r + 1) * (w - 1) + (b - 1), E = (r + 1) * w + (b - 1), A = (r + 1) * w + b, M = (r + 1) * (w - 1) + b;
          y.push(S, E, M), y.push(E, A, M);
        }
    }
    function v() {
      for (let w = 0; w <= n; w++)
        for (let b = 0; b <= r; b++)
          l.x = w / n, l.y = b / r, p.push(l.x, l.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TubeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new tp(
      new Yl[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class x8 extends Me {
  /**
   * Constructs a new wireframe geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   */
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const n = [], s = /* @__PURE__ */ new Set(), r = new $(), a = new $();
      if (e.index !== null) {
        const o = e.attributes.position, h = e.index;
        let c = e.groups;
        c.length === 0 && (c = [{ start: 0, count: h.count, materialIndex: 0 }]);
        for (let l = 0, u = c.length; l < u; ++l) {
          const f = c[l], d = f.start, p = f.count;
          for (let y = d, x = d + p; y < x; y += 3)
            for (let g = 0; g < 3; g++) {
              const m = h.getX(y + g), v = h.getX(y + (g + 1) % 3);
              r.fromBufferAttribute(o, m), a.fromBufferAttribute(o, v), Rg(r, a, s) === !0 && (n.push(r.x, r.y, r.z), n.push(a.x, a.y, a.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let h = 0, c = o.count / 3; h < c; h++)
          for (let l = 0; l < 3; l++) {
            const u = 3 * h + l, f = 3 * h + (l + 1) % 3;
            r.fromBufferAttribute(o, u), a.fromBufferAttribute(o, f), Rg(r, a, s) === !0 && (n.push(r.x, r.y, r.z), n.push(a.x, a.y, a.z));
          }
      }
      this.setAttribute("position", new St(n, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function Rg(i, e, n) {
  const s = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`;
  return n.has(s) === !0 || n.has(r) === !0 ? !1 : (n.add(s), n.add(r), !0);
}
const Og = /* @__PURE__ */ new it();
class g8 {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector2} [min=(Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector2} [max=(-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new it(1 / 0, 1 / 0), n = new it(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = n;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector2} min - The lower boundary of the box.
   * @param {Vector2} max - The upper boundary of the box.
   * @return {Box2} A reference to this bounding box.
   */
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector2>} points - An array holding 2D position data as instances of {@link Vector2}.
   * @return {Box2} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, s = e.length; n < s; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector2} center - The center of the box.
   * @param {Vector2} size - The x and y dimensions of the box.
   * @return {Box2} A reference to this bounding box.
   */
  setFromCenterAndSize(e, n) {
    const s = Og.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(s), this.max.copy(e).add(s), this;
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box2} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box2} box - The box to copy.
   * @return {Box2} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 2D.
   *
   * @return {Box2} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector2} point - The point that should be included by the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions.
   *
   * @param {Vector2} vector - The vector that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector2} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  /**
   * Returns a point as a proportion of this box's width and height.
   *
   * @param {Vector2} point - A point in 2D space.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} A point as a proportion of this box's width and height.
   */
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector2} point - The point to clamp.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The clamped point.
   */
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector2} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, Og).distanceTo(e);
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box2} box - The bounding box to intersect with.
   * @return {Box2} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box2} box - The bounding box that will be unioned with this instance.
   * @return {Box2} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 2D space.
   *
   * @param {Vector2} offset - The offset that should be used to translate the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box2} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
class m8 {
  /**
   * Constructs a new cylindrical.
   *
   * @param {number} [radius=1] - The distance from the origin to a point in the x-z plane.
   * @param {number} [theta=0] - A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.
   * @param {number} [y=0] - The height above the x-z plane.
   */
  constructor(e = 1, n = 0, s = 0) {
    this.radius = e, this.theta = n, this.y = s;
  }
  /**
   * Sets the cylindrical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle.
   * @param {number} y - The height value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  set(e, n, s) {
    return this.radius = e, this.theta = n, this.y = s, this;
  }
  /**
   * Copies the values of the given cylindrical to this instance.
   *
   * @param {Cylindrical} other - The cylindrical to copy.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  /**
   * Sets the cylindrical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the cylindrical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromCartesianCoords(e, n, s) {
    return this.radius = Math.sqrt(e * e + s * s), this.theta = Math.atan2(e, s), this.y = n, this;
  }
  /**
   * Returns a new cylindrical with copied values from this instance.
   *
   * @return {Cylindrical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const Bf = /* @__PURE__ */ new $(), v8 = /* @__PURE__ */ new $(), w8 = /* @__PURE__ */ new Si();
class sr {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(e = new $(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(e, n, s, r) {
    return this.normal.set(e, n, s), this.constant = r, this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(e, n, s) {
    const r = Bf.subVectors(s, n).cross(v8.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(e, n) {
    const s = e.delta(Bf), r = this.normal.dot(s);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / r;
    return a < 0 || a > 1 ? null : n.copy(e.start).addScaledVector(s, a);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), s = this.distanceToPoint(e.end);
    return n < 0 && s > 0 || s < 0 && n > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(e, n) {
    const s = n || w8.getNormalMatrix(e), r = this.coplanarPoint(Bf).applyMatrix4(e), a = this.normal.applyMatrix3(s).normalize();
    return this.constant = -r.dot(a), this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const Xs = /* @__PURE__ */ new A1(), M8 = /* @__PURE__ */ new it(0.5, 0.5), Gc = /* @__PURE__ */ new $();
class d_ {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(e = new sr(), n = new sr(), s = new sr(), r = new sr(), a = new sr(), o = new sr()) {
    this.planes = [e, n, s, r, a, o];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(e, n, s, r, a, o) {
    const h = this.planes;
    return h[0].copy(e), h[1].copy(n), h[2].copy(s), h[3].copy(r), h[4].copy(a), h[5].copy(o), this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(e) {
    const n = this.planes;
    for (let s = 0; s < 6; s++)
      n[s].copy(e.planes[s]);
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(e, n = mi) {
    const s = this.planes, r = e.elements, a = r[0], o = r[1], h = r[2], c = r[3], l = r[4], u = r[5], f = r[6], d = r[7], p = r[8], y = r[9], x = r[10], g = r[11], m = r[12], v = r[13], w = r[14], b = r[15];
    if (s[0].setComponents(c - a, d - l, g - p, b - m).normalize(), s[1].setComponents(c + a, d + l, g + p, b + m).normalize(), s[2].setComponents(c + o, d + u, g + y, b + v).normalize(), s[3].setComponents(c - o, d - u, g - y, b - v).normalize(), s[4].setComponents(c - h, d - f, g - x, b - w).normalize(), n === mi)
      s[5].setComponents(c + h, d + f, g + x, b + w).normalize();
    else if (n === xh)
      s[5].setComponents(h, f, x, w).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Xs.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), Xs.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Xs);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(e) {
    Xs.center.set(0, 0, 0);
    const n = M8.distanceTo(e.center);
    return Xs.radius = 0.7071067811865476 + n, Xs.applyMatrix4(e.matrixWorld), this.intersectsSphere(Xs);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(e) {
    const n = this.planes, s = e.center, r = -e.radius;
    for (let a = 0; a < 6; a++)
      if (n[a].distanceToPoint(s) < r)
        return !1;
    return !0;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(e) {
    const n = this.planes;
    for (let s = 0; s < 6; s++) {
      const r = n[s];
      if (Gc.x = r.normal.x > 0 ? e.max.x : e.min.x, Gc.y = r.normal.y > 0 ? e.max.y : e.min.y, Gc.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Gc) < 0)
        return !1;
    }
    return !0;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(e) {
    const n = this.planes;
    for (let s = 0; s < 6; s++)
      if (n[s].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const ui = /* @__PURE__ */ new ve(), fi = /* @__PURE__ */ new d_();
class ep {
  /**
   * Constructs a new frustum array.
   *
   */
  constructor() {
    this.coordinateSystem = mi;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Object3D} object - The 3D object to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the 3D object is visible in any camera.
   */
  intersectsObject(e, n) {
    if (!n.isArrayCamera || n.cameras.length === 0)
      return !1;
    for (let s = 0; s < n.cameras.length; s++) {
      const r = n.cameras[s];
      if (ui.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), fi.setFromProjectionMatrix(
        ui,
        this.coordinateSystem
      ), fi.intersectsObject(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given sprite is intersecting any frustum
   * from the camera array.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sprite is visible in any camera.
   */
  intersectsSprite(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let s = 0; s < n.cameras.length; s++) {
      const r = n.cameras[s];
      if (ui.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), fi.setFromProjectionMatrix(
        ui,
        this.coordinateSystem
      ), fi.intersectsSprite(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sphere is visible in any camera.
   */
  intersectsSphere(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let s = 0; s < n.cameras.length; s++) {
      const r = n.cameras[s];
      if (ui.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), fi.setFromProjectionMatrix(
        ui,
        this.coordinateSystem
      ), fi.intersectsSphere(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding box is intersecting any frustum
   * from the camera array.
   *
   * @param {Box3} box - The bounding box to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the box is visible in any camera.
   */
  intersectsBox(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let s = 0; s < n.cameras.length; s++) {
      const r = n.cameras[s];
      if (ui.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), fi.setFromProjectionMatrix(
        ui,
        this.coordinateSystem
      ), fi.intersectsBox(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given point lies within any frustum
   * from the camera array.
   *
   * @param {Vector3} point - The point to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the point is visible in any camera.
   */
  containsPoint(e, n) {
    if (!n || !n.cameras || n.cameras.length === 0)
      return !1;
    for (let s = 0; s < n.cameras.length; s++) {
      const r = n.cameras[s];
      if (ui.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), fi.setFromProjectionMatrix(
        ui,
        this.coordinateSystem
      ), fi.containsPoint(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns a new frustum array with copied values from this instance.
   *
   * @return {FrustumArray} A clone of this instance.
   */
  clone() {
    return new ep();
  }
}
const kg = /* @__PURE__ */ new $(), Uc = /* @__PURE__ */ new $();
class b8 {
  /**
   * Constructs a new line segment.
   *
   * @param {Vector3} [start=(0,0,0)] - Start of the line segment.
   * @param {Vector3} [end=(0,0,0)] - End of the line segment.
   */
  constructor(e = new $(), n = new $()) {
    this.start = e, this.end = n;
  }
  /**
   * Sets the start and end values by copying the given vectors.
   *
   * @param {Vector3} start - The start point.
   * @param {Vector3} end - The end point.
   * @return {Line3} A reference to this line segment.
   */
  set(e, n) {
    return this.start.copy(e), this.end.copy(n), this;
  }
  /**
   * Copies the values of the given line segment to this instance.
   *
   * @param {Line3} line - The line segment to copy.
   * @return {Line3} A reference to this line segment.
   */
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  /**
   * Returns the center of the line segment.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  /**
   * Returns the delta vector of the line segment's start and end point.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  /**
   * Returns the squared Euclidean distance between the line' start and end point.
   *
   * @return {number} The squared Euclidean distance.
   */
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  /**
   * Returns the Euclidean distance between the line' start and end point.
   *
   * @return {number} The Euclidean distance.
   */
  distance() {
    return this.start.distanceTo(this.end);
  }
  /**
   * Returns a vector at a certain position along the line segment.
   *
   * @param {number} t - A value between `[0,1]` to represent a position along the line segment.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  at(e, n) {
    return this.delta(n).multiplyScalar(e).add(this.start);
  }
  /**
   * Returns a point parameter based on the closest point as projected on the line segment.
   *
   * @param {Vector3} point - The point for which to return a point parameter.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @return {number} The point parameter.
   */
  closestPointToPointParameter(e, n) {
    kg.subVectors(e, this.start), Uc.subVectors(this.end, this.start);
    const s = Uc.dot(Uc);
    let a = Uc.dot(kg) / s;
    return n && (a = zt(a, 0, 1)), a;
  }
  /**
   * Returns the closets point on the line for a given point.
   *
   * @param {Vector3} point - The point to compute the closest point on the line for.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @param {Vector3} target -  The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the line.
   */
  closestPointToPoint(e, n, s) {
    const r = this.closestPointToPointParameter(e, n);
    return this.delta(s).multiplyScalar(r).add(this.start);
  }
  /**
   * Applies a 4x4 transformation matrix to this line segment.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Line3} A reference to this line segment.
   */
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  /**
   * Returns `true` if this line segment is equal with the given one.
   *
   * @param {Line3} line - The line segment to test for equality.
   * @return {boolean} Whether this line segment is equal with the given one.
   */
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  /**
   * Returns a new line segment with copied values from this instance.
   *
   * @return {Line3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class np {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(e, n, s, r) {
    np.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, s, r);
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(e, n = 0) {
    for (let s = 0; s < 4; s++)
      this.elements[s] = e[s + n];
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(e, n, s, r) {
    const a = this.elements;
    return a[0] = e, a[2] = n, a[1] = s, a[3] = r, this;
  }
}
class _8 {
  /**
   * Constructs a new spherical.
   *
   * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
   * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
   * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
   */
  constructor(e = 1, n = 0, s = 0) {
    this.radius = e, this.phi = n, this.theta = s;
  }
  /**
   * Sets the spherical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The polar angle.
   * @param {number} theta - The azimuthal angle.
   * @return {Spherical} A reference to this spherical.
   */
  set(e, n, s) {
    return this.radius = e, this.phi = n, this.theta = s, this;
  }
  /**
   * Copies the values of the given spherical to this instance.
   *
   * @param {Spherical} other - The spherical to copy.
   * @return {Spherical} A reference to this spherical.
   */
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  /**
   * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
   * `0.000001`.
   *
   * @return {Spherical} A reference to this spherical.
   */
  makeSafe() {
    return this.phi = zt(this.phi, 1e-6, Math.PI - 1e-6), this;
  }
  /**
   * Sets the spherical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Spherical} A reference to this spherical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the spherical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Spherical} A reference to this spherical.
   */
  setFromCartesianCoords(e, n, s) {
    return this.radius = Math.sqrt(e * e + n * n + s * s), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, s), this.phi = Math.acos(zt(n / this.radius, -1, 1))), this;
  }
  /**
   * Returns a new spherical with copied values from this instance.
   *
   * @return {Spherical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class S8 {
  /**
   * Constructs a new spherical harmonics.
   */
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new $());
  }
  /**
   * Sets the given SH coefficients to this instance by copying
   * the values.
   *
   * @param {Array<Vector3>} coefficients - The SH coefficients.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  set(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].copy(e[n]);
    return this;
  }
  /**
   * Sets all SH coefficients to `0`.
   *
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  /**
   * Returns the radiance in the direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The radiance.
   */
  getAt(e, n) {
    const s = e.x, r = e.y, a = e.z, o = this.coefficients;
    return n.copy(o[0]).multiplyScalar(0.282095), n.addScaledVector(o[1], 0.488603 * r), n.addScaledVector(o[2], 0.488603 * a), n.addScaledVector(o[3], 0.488603 * s), n.addScaledVector(o[4], 1.092548 * (s * r)), n.addScaledVector(o[5], 1.092548 * (r * a)), n.addScaledVector(o[6], 0.315392 * (3 * a * a - 1)), n.addScaledVector(o[7], 1.092548 * (s * a)), n.addScaledVector(o[8], 0.546274 * (s * s - r * r)), n;
  }
  /**
   * Returns the irradiance (radiance convolved with cosine lobe) in the
   * direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The irradiance.
   */
  getIrradianceAt(e, n) {
    const s = e.x, r = e.y, a = e.z, o = this.coefficients;
    return n.copy(o[0]).multiplyScalar(0.886227), n.addScaledVector(o[1], 2 * 0.511664 * r), n.addScaledVector(o[2], 2 * 0.511664 * a), n.addScaledVector(o[3], 2 * 0.511664 * s), n.addScaledVector(o[4], 2 * 0.429043 * s * r), n.addScaledVector(o[5], 2 * 0.429043 * r * a), n.addScaledVector(o[6], 0.743125 * a * a - 0.247708), n.addScaledVector(o[7], 2 * 0.429043 * s * a), n.addScaledVector(o[8], 0.429043 * (s * s - r * r)), n;
  }
  /**
   * Adds the given SH to this instance.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  add(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].add(e.coefficients[n]);
    return this;
  }
  /**
   * A convenience method for performing {@link SphericalHarmonics3#add} and
   * {@link SphericalHarmonics3#scale} at once.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  addScaledSH(e, n) {
    for (let s = 0; s < 9; s++)
      this.coefficients[s].addScaledVector(e.coefficients[s], n);
    return this;
  }
  /**
   * Scales this SH by the given scale factor.
   *
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  scale(e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].multiplyScalar(e);
    return this;
  }
  /**
   * Linear interpolates between the given SH and this instance by the given
   * alpha factor.
   *
   * @param {SphericalHarmonics3} sh - The SH to interpolate with.
   * @param {number} alpha - The alpha factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  lerp(e, n) {
    for (let s = 0; s < 9; s++)
      this.coefficients[s].lerp(e.coefficients[s], n);
    return this;
  }
  /**
   * Returns `true` if this spherical harmonics is equal with the given one.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
   * @return {boolean} Whether this spherical harmonics is equal with the given one.
   */
  equals(e) {
    for (let n = 0; n < 9; n++)
      if (!this.coefficients[n].equals(e.coefficients[n]))
        return !1;
    return !0;
  }
  /**
   * Copies the values of the given spherical harmonics to this instance.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  copy(e) {
    return this.set(e.coefficients);
  }
  /**
   * Returns a new spherical harmonics with copied values from this instance.
   *
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the SH coefficients of this instance from the given array.
   *
   * @param {Array<number>} array - An array holding the SH coefficients.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  fromArray(e, n = 0) {
    const s = this.coefficients;
    for (let r = 0; r < 9; r++)
      s[r].fromArray(e, n + r * 3);
    return this;
  }
  /**
   * Returns an array with the SH coefficients, or copies them into the provided
   * array. The coefficients are represented as numbers.
   *
   * @param {Array<number>} [array=[]] - The target array.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {Array<number>} An array with flat SH coefficients.
   */
  toArray(e = [], n = 0) {
    const s = this.coefficients;
    for (let r = 0; r < 9; r++)
      s[r].toArray(e, n + r * 3);
    return e;
  }
  /**
   * Computes the SH basis for the given normal vector.
   *
   * @param {Vector3} normal - The normal.
   * @param {Array<number>} shBasis - The target array holding the SH basis.
   */
  static getBasisAt(e, n) {
    const s = e.x, r = e.y, a = e.z;
    n[0] = 0.282095, n[1] = 0.488603 * r, n[2] = 0.488603 * a, n[3] = 0.488603 * s, n[4] = 1.092548 * s * r, n[5] = 1.092548 * r * a, n[6] = 0.315392 * (3 * a * a - 1), n[7] = 1.092548 * s * a, n[8] = 0.546274 * (s * s - r * r);
  }
}
class ip {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [near=1] - The minimum distance to start applying fog.
   * @param {number} [far=1000] - The maximum distance at which fog stops being calculated and applied.
   */
  constructor(e, n = 1, s = 1e3) {
    this.isFog = !0, this.name = "", this.color = new qa(e), this.near = n, this.far = s;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {Fog} A clone of this instance.
   */
  clone() {
    return new ip(this.color, this.near, this.far);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class sp {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [density=0.00025] - Defines how fast the fog will grow dense.
   */
  constructor(e, n = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new qa(e), this.density = n;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {FogExp2} A clone of this instance.
   */
  clone() {
    return new sp(this.color, this.density);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class T8 extends dn {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Sr(), this.environmentIntensity = 1, this.environmentRotation = new Sr(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class E8 extends Ie {
  /**
   * Constructs a new texture.
   *
   * @param {HTMLCanvasElement} [canvas] - The HTML canvas element.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, n, s, r, a, o, h, c, l) {
    super(e, n, s, r, a, o, h, c, l), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class rp extends Ie {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e, n, s, r, a, o, h, c, l, u, f, d) {
    super(null, o, h, c, l, u, r, a, f, d), this.isCompressedTexture = !0, this.image = { width: n, height: s }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class z8 extends rp {
  /**
   * Constructs a new compressed array texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} depth - The depth of the texture.
   * @param {number} [format=RGBAFormat] - The min filter value.
   * @param {number} [type=UnsignedByteType] - The min filter value.
   */
  constructor(e, n, s, r, a, o) {
    super(e, n, s, a, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = gs, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire compressed texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class C8 extends rp {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<CompressedTexture>} images - An array of compressed textures.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   */
  constructor(e, n, s) {
    super(void 0, e[0].width, e[0].height, n, s, p1), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class A8 extends Ie {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(e = [], n = p1, s, r, a, o, h, c, l, u) {
    super(e, n, s, r, a, o, h, c, l, u), this.isCubeTexture = !0, this.flipY = !1;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class P8 extends Ie {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, n = 1, s = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: s, depth: r }, this.magFilter = si, this.minFilter = si, this.wrapR = gs, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class I8 extends Ie {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = null, n = 1, s = 1, r, a, o, h, c, l = si, u = si, f, d) {
    super(null, o, h, c, l, u, r, a, f, d), this.isDataTexture = !0, this.image = { data: e, width: n, height: s }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class R8 extends Ie {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e, n, s = x1, r, a, o, h = si, c = si, l, u = X0, f = 1) {
    if (u !== X0 && u !== KM)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    const d = { width: e, height: n, depth: f };
    super(d, r, a, o, h, c, u, s, l), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.source = new mu(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
class O8 extends Ie {
  /**
   * Constructs a new framebuffer texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   */
  constructor(e, n) {
    super({ width: e, height: n }), this.isFramebufferTexture = !0, this.magFilter = si, this.minFilter = si, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class p_ extends Ie {
  /**
   * Constructs a new video texture.
   *
   * @param {HTMLVideoElement} video - The video element to use as a data source for the texture.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, n, s, r, a = La, o = La, h, c, l) {
    super(e, n, s, r, a, o, h, c, l), this.isVideoTexture = !0, this.generateMipmaps = !1;
    const u = this;
    function f() {
      u.needsUpdate = !0, e.requestVideoFrameCallback(f);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(f);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  /**
   * This method is called automatically by the renderer and sets {@link Texture#needsUpdate}
   * to `true` every time a new frame is available.
   *
   * Only relevant if `requestVideoFrameCallback` is not supported in the browser.
   */
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class k8 extends p_ {
  /**
   * Constructs a new video frame texture.
   *
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, n, s, r, a, o, h, c) {
    super({}, e, n, s, r, a, o, h, c), this.isVideoFrameTexture = !0;
  }
  /**
   * This method overwritten with an empty implementation since
   * this type of texture is updated via `setFrame()`.
   */
  update() {
  }
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the current frame of the video. This will automatically update the texture
   * so the data can be used for rendering.
   *
   * @param {VideoFrame} frame - The video frame.
   */
  setFrame(e) {
    this.image = e, this.needsUpdate = !0;
  }
}
const z7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: nN,
  AddEquation: M6,
  AddOperation: J6,
  AdditiveAnimationBlendMode: v1,
  AdditiveBlending: g6,
  AgXToneMapping: sN,
  AlphaFormat: JM,
  AlwaysCompare: KN,
  AlwaysDepth: V6,
  AlwaysStencilFunc: WN,
  AnimationAction: qb,
  AnimationClip: K0,
  AnimationMixer: WB,
  AnimationObjectGroup: YB,
  AnimationUtils: RB,
  ArcCurve: i_,
  ArrayCamera: sD,
  AttachedBindMode: aN,
  Audio: jb,
  AudioAnalyser: KB,
  AudioContext: Hb,
  AudioListener: eD,
  BackSide: d6,
  BasicDepthPacking: SN,
  BasicShadowMap: h6,
  BooleanKeyframeTrack: Rr,
  Box2: g8,
  Box3: Da,
  BoxGeometry: B1,
  BufferAttribute: tn,
  BufferGeometry: Me,
  ByteType: GM,
  Camera: C1,
  CanvasTexture: E8,
  CapsuleGeometry: D1,
  CatmullRomCurve3: s_,
  CineonToneMapping: eN,
  CircleGeometry: q1,
  ClampToEdgeWrapping: gs,
  Clock: Xb,
  Color: qa,
  ColorKeyframeTrack: S1,
  ColorManagement: Cn,
  CompressedArrayTexture: z8,
  CompressedCubeTexture: C8,
  CompressedTexture: rp,
  ConeGeometry: $1,
  ConstantAlphaFactor: D6,
  ConstantColorFactor: N6,
  Controls: RD,
  CubeCamera: rD,
  CubeReflectionMapping: p1,
  CubeRefractionMapping: hN,
  CubeTexture: A8,
  CubeUVReflectionMapping: uN,
  CubicBezierCurve: O1,
  CubicBezierCurve3: r_,
  CubicInterpolant: Gb,
  CullFaceBack: r6,
  CullFaceFront: a6,
  CullFaceFrontBack: o6,
  CullFaceNone: s6,
  Curve: ri,
  CurvePath: o_,
  CustomBlending: w6,
  CustomToneMapping: iN,
  CylinderGeometry: wu,
  Cylindrical: m8,
  Data3DTexture: n_,
  DataArrayTexture: P8,
  DataTexture: I8,
  DataUtils: cD,
  DecrementStencilOp: kN,
  DecrementWrapStencilOp: FN,
  DepthFormat: X0,
  DepthStencilFormat: KM,
  DepthTexture: R8,
  DetachedBindMode: oN,
  DiscreteInterpolant: Ub,
  DodecahedronGeometry: V1,
  DoubleSide: p6,
  DstAlphaFactor: R6,
  DstColorFactor: k6,
  DynamicCopyUsage: aB,
  DynamicDrawUsage: tB,
  DynamicReadUsage: iB,
  EdgesGeometry: f8,
  EllipseCurve: vu,
  EqualCompare: HN,
  EqualDepth: W6,
  EqualStencilFunc: qN,
  EquirectangularReflectionMapping: cN,
  EquirectangularRefractionMapping: lN,
  Euler: Sr,
  EventDispatcher: Es,
  ExtrudeGeometry: G1,
  Float16BufferAttribute: xD,
  Float32BufferAttribute: St,
  FloatType: g1,
  Fog: ip,
  FogExp2: sp,
  FramebufferTexture: O8,
  FrontSide: f6,
  Frustum: d_,
  FrustumArray: ep,
  GLBufferAttribute: MD,
  GLSL1: hB,
  GLSL3: cB,
  GreaterCompare: ZN,
  GreaterDepth: j6,
  GreaterEqualCompare: QN,
  GreaterEqualDepth: Y6,
  GreaterEqualStencilFunc: UN,
  GreaterStencilFunc: VN,
  HalfFloatType: jM,
  IcosahedronGeometry: U1,
  ImageUtils: t_,
  IncrementStencilOp: ON,
  IncrementWrapStencilOp: LN,
  InstancedBufferAttribute: bD,
  InstancedBufferGeometry: _D,
  InstancedInterleavedBuffer: SD,
  Int16BufferAttribute: pD,
  Int32BufferAttribute: yD,
  Int8BufferAttribute: uD,
  IntType: YM,
  InterleavedBuffer: Qb,
  InterleavedBufferAttribute: P1,
  Interpolant: kh,
  InterpolateDiscrete: dh,
  InterpolateLinear: Ul,
  InterpolateSmooth: hl,
  InterpolationSamplingMode: fB,
  InterpolationSamplingType: uB,
  InvertStencilOp: NN,
  KeepStencilOp: IN,
  KeyframeTrack: Dn,
  LatheGeometry: W1,
  Layers: z1,
  LessCompare: jN,
  LessDepth: G6,
  LessEqualCompare: XN,
  LessEqualDepth: U6,
  LessEqualStencilFunc: $N,
  LessStencilFunc: DN,
  Line3: b8,
  LineCurve: k1,
  LineCurve3: a_,
  LinearFilter: La,
  LinearInterpolant: _1,
  LinearMipMapLinearFilter: mN,
  LinearMipMapNearestFilter: gN,
  LinearMipmapLinearFilter: VM,
  LinearMipmapNearestFilter: xN,
  LinearSRGBColorSpace: Z0,
  LinearToneMapping: K6,
  LinearTransfer: J0,
  LoopOnce: Nb,
  LoopPingPong: Db,
  LoopRepeat: Bb,
  MOUSE: n6,
  MathUtils: AB,
  Matrix2: np,
  Matrix3: Si,
  Matrix4: ve,
  MaxEquation: T6,
  MinEquation: S6,
  MirroredRepeatWrapping: H0,
  MixOperation: Z6,
  MultiplyBlending: v6,
  MultiplyOperation: X6,
  NearestFilter: si,
  NearestMipMapLinearFilter: yN,
  NearestMipMapNearestFilter: dN,
  NearestMipmapLinearFilter: pN,
  NearestMipmapNearestFilter: fN,
  NeutralToneMapping: rN,
  NeverCompare: YN,
  NeverDepth: $6,
  NeverStencilFunc: BN,
  NoBlending: y6,
  NoColorSpace: w1,
  NoToneMapping: Q6,
  NormalAnimationBlendMode: gu,
  NormalBlending: x6,
  NotEqualCompare: JN,
  NotEqualDepth: H6,
  NotEqualStencilFunc: GN,
  NumberKeyframeTrack: gh,
  Object3D: dn,
  ObjectSpaceNormalMap: AN,
  OctahedronGeometry: Y1,
  OneFactor: z6,
  OneMinusConstantAlphaFactor: q6,
  OneMinusConstantColorFactor: B6,
  OneMinusDstAlphaFactor: O6,
  OneMinusDstColorFactor: L6,
  OneMinusSrcAlphaFactor: I6,
  OneMinusSrcColorFactor: A6,
  OrthographicCamera: aD,
  PCFShadowMap: c6,
  PCFSoftShadowMap: l6,
  Path: jl,
  PerspectiveCamera: di,
  Plane: sr,
  PlaneGeometry: j1,
  PolyhedronGeometry: kr,
  PositionalAudio: iD,
  PropertyBinding: Dt,
  PropertyMixer: Yb,
  QuadraticBezierCurve: L1,
  QuadraticBezierCurve3: F1,
  Quaternion: fn,
  QuaternionKeyframeTrack: Lh,
  QuaternionLinearInterpolant: Wb,
  RED_GREEN_RGTC2_Format: Lb,
  RED_RGTC1_Format: Ob,
  REVISION: e6,
  RGBADepthPacking: TN,
  RGBAFormat: m1,
  RGBAIntegerFormat: sb,
  RGBA_ASTC_10x10_Format: zb,
  RGBA_ASTC_10x5_Format: Sb,
  RGBA_ASTC_10x6_Format: Tb,
  RGBA_ASTC_10x8_Format: Eb,
  RGBA_ASTC_12x10_Format: Cb,
  RGBA_ASTC_12x12_Format: Ab,
  RGBA_ASTC_4x4_Format: xb,
  RGBA_ASTC_5x4_Format: gb,
  RGBA_ASTC_5x5_Format: mb,
  RGBA_ASTC_6x5_Format: vb,
  RGBA_ASTC_6x6_Format: wb,
  RGBA_ASTC_8x5_Format: Mb,
  RGBA_ASTC_8x6_Format: bb,
  RGBA_ASTC_8x8_Format: _b,
  RGBA_BPTC_Format: Pb,
  RGBA_ETC2_EAC_Format: yb,
  RGBA_PVRTC_2BPPV1_Format: fb,
  RGBA_PVRTC_4BPPV1_Format: ub,
  RGBA_S3TC_DXT1_Format: ab,
  RGBA_S3TC_DXT3_Format: ob,
  RGBA_S3TC_DXT5_Format: hb,
  RGBDepthPacking: EN,
  RGBFormat: QM,
  RGBIntegerFormat: wN,
  RGB_BPTC_SIGNED_Format: Ib,
  RGB_BPTC_UNSIGNED_Format: Rb,
  RGB_ETC1_Format: db,
  RGB_ETC2_Format: pb,
  RGB_PVRTC_2BPPV1_Format: lb,
  RGB_PVRTC_4BPPV1_Format: cb,
  RGB_S3TC_DXT1_Format: rb,
  RGDepthPacking: zN,
  RGFormat: nb,
  RGIntegerFormat: ib,
  Ray: Kb,
  Raycaster: TD,
  RedFormat: tb,
  RedIntegerFormat: eb,
  ReinhardToneMapping: tN,
  RenderTarget: e_,
  RenderTarget3D: AD,
  RepeatWrapping: j0,
  ReplaceStencilOp: RN,
  ReverseSubtractEquation: _6,
  RingGeometry: H1,
  SIGNED_RED_GREEN_RGTC2_Format: Fb,
  SIGNED_RED_RGTC1_Format: kb,
  SRGBColorSpace: On,
  SRGBTransfer: cl,
  Scene: T8,
  Shape: za,
  ShapeGeometry: X1,
  ShapePath: r8,
  ShapeUtils: ei,
  ShortType: UM,
  Source: mu,
  Sphere: A1,
  SphereGeometry: Z1,
  Spherical: _8,
  SphericalHarmonics3: S8,
  SplineCurve: N1,
  SrcAlphaFactor: P6,
  SrcAlphaSaturateFactor: F6,
  SrcColorFactor: C6,
  StaticCopyUsage: rB,
  StaticDrawUsage: yh,
  StaticReadUsage: nB,
  StereoCamera: oD,
  StreamCopyUsage: oB,
  StreamDrawUsage: eB,
  StreamReadUsage: sB,
  StringKeyframeTrack: Or,
  SubtractEquation: b6,
  SubtractiveBlending: m6,
  TOUCH: i6,
  TangentSpaceNormalMap: CN,
  TetrahedronGeometry: J1,
  Texture: Ie,
  TextureUtils: u8,
  TimestampQuery: lB,
  TorusGeometry: Q1,
  TorusKnotGeometry: K1,
  Triangle: us,
  TriangleFanDrawMode: _N,
  TriangleStripDrawMode: bN,
  TrianglesDrawMode: MN,
  TubeGeometry: tp,
  UVMapping: d1,
  Uint16BufferAttribute: Zb,
  Uint32BufferAttribute: Jb,
  Uint8BufferAttribute: fD,
  Uint8ClampedBufferAttribute: dD,
  Uniform: I1,
  UniformsGroup: ID,
  UnsignedByteType: y1,
  UnsignedInt248Type: vN,
  UnsignedInt5999Type: ZM,
  UnsignedIntType: x1,
  UnsignedShort4444Type: HM,
  UnsignedShort5551Type: XM,
  UnsignedShortType: WM,
  VSMShadowMap: u6,
  Vector2: it,
  Vector3: $,
  Vector4: _s,
  VectorKeyframeTrack: mh,
  VideoFrameTexture: k8,
  VideoTexture: p_,
  WebGLCoordinateSystem: mi,
  WebGPUCoordinateSystem: xh,
  WireframeGeometry: x8,
  WrapAroundEnding: ph,
  ZeroCurvatureEnding: pr,
  ZeroFactor: E6,
  ZeroSlopeEnding: yr,
  ZeroStencilOp: PN,
  createCanvasElement: vD,
  deviation: n8,
  flatten: i8
}, Symbol.toStringTag, { value: "Module" })), L8 = 1e-5;
function ll(i, e, n = L8) {
  return Math.abs(i - e) < n;
}
function en(i, e, n, s) {
  const r = i - n, a = e - s;
  return Math.sqrt(r * r + a * a);
}
function Mu(i, e) {
  const n = Math.min(...i), s = Math.min(...e), r = Math.max(...i), a = Math.max(...e);
  return {
    x: n,
    y: s,
    width: r - n,
    height: a - s
  };
}
function y_(i) {
  return (i + Math.PI * 2) % (Math.PI * 2);
}
function Lg(i, e) {
  const n = Math.abs(i);
  return e > 0 ? n : n * -1;
}
function F8(i, e, n, s, r, a) {
  const o = n, h = s;
  if (o === 0 || h === 0)
    return {
      x: i,
      y: e
    };
  const c = r - i, l = a - e, u = Math.abs(c), f = Math.abs(l), d = o * o, p = h * h;
  let y = Math.PI / 4, x = 0, g = 0;
  for (let m = 0; m < 4; m++) {
    x = o * Math.cos(y), g = h * Math.sin(y);
    const v = (d - p) * Math.cos(y) ** 3 / o, w = (p - d) * Math.sin(y) ** 3 / h, b = x - v, S = g - w, E = u - v, A = f - w, M = Math.hypot(S, b), _ = Math.hypot(A, E), C = M * Math.asin((b * A - S * E) / (M * _)) / Math.sqrt(d + p - x * x - g * g);
    y += C, y = Math.min(Math.PI / 2, Math.max(0, y));
  }
  return {
    x: i + Lg(x, c),
    y: e + Lg(g, l)
  };
}
function N8(i, e, n, s, r, a, o, h) {
  return -1 * n * Math.cos(r) * Math.sin(h) - s * Math.sin(r) * Math.cos(h);
}
function B8(i, e, n, s, r, a, o, h) {
  return -1 * n * Math.sin(r) * Math.sin(h) + s * Math.cos(r) * Math.cos(h);
}
function D8(i, e, n) {
  return Math.atan(-e / i * Math.tan(n));
}
function q8(i, e, n) {
  return Math.atan(e / (i * Math.tan(n)));
}
function $8(i, e, n, s, r, a) {
  return n * Math.cos(r) * Math.cos(a) - s * Math.sin(r) * Math.sin(a) + i;
}
function V8(i, e, n, s, r, a) {
  return n * Math.sin(r) * Math.cos(a) + s * Math.cos(r) * Math.sin(a) + e;
}
function G8(i, e, n, s) {
  return (Math.atan2(s * i, n * e) + Math.PI * 2) % (Math.PI * 2);
}
function Fg(i, e, n) {
  return {
    x: i * Math.cos(n),
    y: e * Math.sin(n)
  };
}
function Ng(i, e, n) {
  const s = Math.cos(n), r = Math.sin(n);
  return [i * s - e * r, i * r + e * s];
}
function U8(i, e, n, s, r, a, o) {
  const h = D8(n, s, r);
  let c = 1 / 0, l = -1 / 0;
  const u = [a, o];
  for (let x = -Math.PI * 2; x <= Math.PI * 2; x += Math.PI) {
    const g = h + x;
    a < o ? a < g && g < o && u.push(g) : o < g && g < a && u.push(g);
  }
  for (let x = 0; x < u.length; x++) {
    const g = $8(i, e, n, s, r, u[x]);
    g < c && (c = g), g > l && (l = g);
  }
  const f = q8(n, s, r);
  let d = 1 / 0, p = -1 / 0;
  const y = [a, o];
  for (let x = -Math.PI * 2; x <= Math.PI * 2; x += Math.PI) {
    const g = f + x;
    a < o ? a < g && g < o && y.push(g) : o < g && g < a && y.push(g);
  }
  for (let x = 0; x < y.length; x++) {
    const g = V8(i, e, n, s, r, y[x]);
    g < d && (d = g), g > p && (p = g);
  }
  return {
    x: c,
    y: d,
    width: l - c,
    height: p - d
  };
}
function W8(i, e, n, s, r, a, o, h, c) {
  const l = Ng(h - i, c - e, -r), [u, f] = l;
  let d = F8(0, 0, n, s, u, f);
  const p = G8(n, s, d.x, d.y);
  p < a ? d = Fg(n, s, a) : p > o && (d = Fg(n, s, o));
  const y = Ng(d.x, d.y, r);
  return {
    x: y[0] + i,
    y: y[1] + e
  };
}
function Y8(i, e, n, s, r, a, o, h) {
  const c = (o - a) * h + a, l = N8(
    i,
    e,
    n,
    s,
    r,
    a,
    o,
    c
  ), u = B8(
    i,
    e,
    n,
    s,
    r,
    a,
    o,
    c
  );
  return y_(Math.atan2(u, l));
}
const j8 = 1e-4;
function x_(i, e, n, s, r, a) {
  let o = -1, h = 1 / 0;
  const c = [n, s];
  let l = 20;
  a && a > 200 && (l = a / 10);
  const u = 1 / l;
  let f = u / 10;
  for (let d = 0; d <= l; d++) {
    const p = d * u, y = [
      r(...i.concat([p])),
      r(...e.concat([p]))
    ], x = en(c[0], c[1], y[0], y[1]);
    x < h && (o = p, h = x);
  }
  if (o === 0)
    return {
      x: i[0],
      y: e[0]
    };
  if (o === 1) {
    const d = i.length;
    return {
      x: i[d - 1],
      y: e[d - 1]
    };
  }
  h = 1 / 0;
  for (let d = 0; d < 32 && !(f < j8); d++) {
    const p = o - f, y = o + f, x = [
      r(...i.concat([p])),
      r(...e.concat([p]))
    ], g = en(c[0], c[1], x[0], x[1]);
    if (p >= 0 && g < h)
      o = p, h = g;
    else {
      const m = [
        r(...i.concat([y])),
        r(...e.concat([y]))
      ], v = en(c[0], c[1], m[0], m[1]);
      y <= 1 && v < h ? (o = y, h = v) : f *= 0.5;
    }
  }
  return {
    x: r(...i.concat([o])),
    y: r(...e.concat([o]))
  };
}
function H8(i, e) {
  let n = 0;
  const s = i.length;
  for (let r = 0; r < s; r++) {
    const a = i[r], o = e[r], h = i[(r + 1) % s], c = e[(r + 1) % s];
    n += en(a, o, h, c);
  }
  return n / 2;
}
function X8(i, e, n, s) {
  return Mu([i, n], [e, s]);
}
function Z8(i, e, n, s) {
  return en(i, e, n, s);
}
function $i(i, e, n, s, r) {
  return {
    x: (1 - r) * i + r * n,
    y: (1 - r) * e + r * s
  };
}
function g_(i, e, n, s, r, a) {
  const o = (n - i) * (r - i) + (s - e) * (a - e);
  if (o < 0)
    return en(i, e, r, a);
  const h = (n - i) * (n - i) + (s - e) * (s - e);
  return o > h ? en(n, s, r, a) : m_(i, e, n, s, r, a);
}
function m_(i, e, n, s, r, a) {
  const o = [n - i, s - e];
  if (tt.exactEquals(o, [0, 0]))
    return Math.sqrt((r - i) * (r - i) + (a - e) * (a - e));
  const h = [-o[1], o[0]];
  tt.normalize(h, h);
  const c = [r - i, a - e];
  return Math.abs(tt.dot(c, h));
}
function J8(i, e, n, s) {
  return Math.atan2(s - e, n - i);
}
function Er(i, e, n, s, r) {
  const a = 1 - r;
  return a * a * a * i + 3 * e * r * a * a + 3 * n * r * r * a + s * r * r * r;
}
function Bg(i, e, n, s, r) {
  const a = 1 - r;
  return 3 * (a * a * (e - i) + 2 * a * r * (n - e) + r * r * (s - n));
}
function Dg(i, e, n, s) {
  const r = -3 * i + 9 * e - 9 * n + 3 * s, a = 6 * i - 12 * e + 6 * n, o = 3 * e - 3 * i, h = [];
  let c, l, u;
  if (ll(r, 0))
    ll(a, 0) || (c = -o / a, c >= 0 && c <= 1 && h.push(c));
  else {
    const f = a * a - 4 * r * o;
    ll(f, 0) ? h.push(-a / (2 * r)) : f > 0 && (u = Math.sqrt(f), c = (-a + u) / (2 * r), l = (-a - u) / (2 * r), c >= 0 && c <= 1 && h.push(c), l >= 0 && l <= 1 && h.push(l));
  }
  return h;
}
function Q8(i, e, n, s, r, a, o, h, c) {
  const l = Er(i, n, r, o, c), u = Er(e, s, a, h, c), f = $i(i, e, n, s, c), d = $i(n, s, r, a, c), p = $i(r, a, o, h, c), y = $i(f.x, f.y, d.x, d.y, c), x = $i(d.x, d.y, p.x, p.y, c);
  return [
    [i, e, f.x, f.y, y.x, y.y, l, u],
    [l, u, x.x, x.y, p.x, p.y, o, h]
  ];
}
function rd(i, e, n, s, r, a, o, h, c) {
  if (c === 0)
    return H8([i, n, r, o], [e, s, a, h]);
  const l = Q8(i, e, n, s, r, a, o, h, 0.5), u = [...l[0], c - 1], f = [...l[1], c - 1];
  return rd(...u) + rd(...f);
}
function K8(i, e, n, s, r, a, o, h) {
  const c = [i, o], l = [e, h], u = Dg(i, n, r, o), f = Dg(e, s, a, h);
  for (let d = 0; d < u.length; d++)
    c.push(Er(i, n, r, o, u[d]));
  for (let d = 0; d < f.length; d++)
    l.push(Er(e, s, a, h, f[d]));
  return Mu(c, l);
}
function t7(i, e, n, s, r, a, o, h) {
  return rd(i, e, n, s, r, a, o, h, 3);
}
function v_(i, e, n, s, r, a, o, h, c, l, u) {
  return x_(
    [i, n, r, o],
    [e, s, a, h],
    c,
    l,
    Er,
    u
  );
}
function e7(i, e, n, s, r, a, o, h, c, l, u) {
  const f = v_(i, e, n, s, r, a, o, h, c, l, u);
  return en(f.x, f.y, c, l);
}
function n7(i, e, n, s, r, a, o, h, c) {
  return {
    x: Er(i, n, r, o, c),
    y: Er(e, s, a, h, c)
  };
}
function i7(i, e, n, s, r, a, o, h, c) {
  const l = Bg(i, n, r, o, c), u = Bg(e, s, a, h, c);
  return y_(Math.atan2(u, l));
}
function w_(i) {
  let e = 0;
  const n = [];
  for (let s = 0; s < i.length - 1; s++) {
    const r = i[s], a = i[s + 1], o = en(r[0], r[1], a[0], a[1]), h = {
      from: r,
      to: a,
      length: o
    };
    n.push(h), e += o;
  }
  return { segments: n, totalLength: e };
}
function M_(i) {
  if (i.length < 2)
    return 0;
  let e = 0;
  for (let n = 0; n < i.length - 1; n++) {
    const s = i[n], r = i[n + 1];
    e += en(s[0], s[1], r[0], r[1]);
  }
  return e;
}
function b_(i, e) {
  if (e > 1 || e < 0 || i.length < 2)
    return null;
  const { segments: n, totalLength: s } = w_(i);
  if (s === 0)
    return {
      x: i[0][0],
      y: i[0][1]
    };
  let r = 0, a = null;
  for (let o = 0; o < n.length; o++) {
    const h = n[o], { from: c, to: l } = h, u = h.length / s;
    if (e >= r && e <= r + u) {
      const f = (e - r) / u;
      a = $i(c[0], c[1], l[0], l[1], f);
      break;
    }
    r += u;
  }
  return a;
}
function __(i, e) {
  if (e > 1 || e < 0 || i.length < 2)
    return 0;
  const { segments: n, totalLength: s } = w_(i);
  let r = 0, a = 0;
  for (let o = 0; o < n.length; o++) {
    const h = n[o], { from: c, to: l } = h, u = h.length / s;
    if (e >= r && e <= r + u) {
      a = Math.atan2(l[1] - c[1], l[0] - c[0]);
      break;
    }
    r += u;
  }
  return a;
}
function S_(i, e, n) {
  let s = 1 / 0;
  for (let r = 0; r < i.length - 1; r++) {
    const a = i[r], o = i[r + 1], h = g_(
      a[0],
      a[1],
      o[0],
      o[1],
      e,
      n
    );
    h < s && (s = h);
  }
  return s;
}
function T_(i) {
  const e = [], n = [];
  for (let s = 0; s < i.length; s++) {
    const r = i[s];
    e.push(r[0]), n.push(r[1]);
  }
  return Mu(e, n);
}
function s7(i) {
  return M_(i);
}
function r7(i, e) {
  return b_(i, e);
}
function a7(i, e, n) {
  return S_(i, e, n);
}
function o7(i, e) {
  return __(i, e);
}
function bu(i) {
  const e = i.slice(0);
  return i.length && e.push(i[0]), e;
}
function h7(i) {
  return T_(i);
}
function c7(i) {
  return M_(bu(i));
}
function l7(i, e) {
  return b_(bu(i), e);
}
function u7(i, e, n) {
  return S_(bu(i), e, n);
}
function f7(i, e) {
  return __(bu(i), e);
}
function bh(i, e, n, s) {
  const r = 1 - s;
  return r * r * i + 2 * s * r * e + s * s * n;
}
function qg(i, e, n) {
  const s = i + n - 2 * e;
  if (ll(s, 0))
    return [0.5];
  const r = (i - e) / s;
  return r <= 1 && r >= 0 ? [r] : [];
}
function d7(i, e, n, s, r, a, o) {
  const h = bh(i, n, r, o), c = bh(e, s, a, o), l = $i(i, e, n, s, o), u = $i(n, s, r, a, o);
  return [
    [i, e, l.x, l.y, h, c],
    [h, c, u.x, u.y, r, a]
  ];
}
function ad(i, e, n, s, r, a, o) {
  if (o === 0)
    return (en(i, e, n, s) + en(n, s, r, a) + en(i, e, r, a)) / 2;
  const h = d7(i, e, n, s, r, a, 0.5), c = h[0], l = h[1];
  return c.push(o - 1), l.push(o - 1), ad(...c) + ad(...l);
}
function p7(i, e, n, s, r, a) {
  const o = qg(i, n, r)[0], h = qg(e, s, a)[0], c = [i, r], l = [e, a];
  return o !== void 0 && c.push(bh(i, n, r, o)), h !== void 0 && l.push(bh(e, s, a, h)), Mu(c, l);
}
function y7(i, e, n, s, r, a) {
  return ad(i, e, n, s, r, a, 3);
}
function E_(i, e, n, s, r, a, o, h) {
  return x_([i, n, r], [e, s, a], o, h, bh);
}
function x7(i, e, n, s, r, a, o, h) {
  const c = E_(i, e, n, s, r, a, o, h);
  return en(c.x, c.y, o, h);
}
const C7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arcBox: U8,
  arcNearestPoint: W8,
  arcTangentAngle: Y8,
  cubicBox: K8,
  cubicLength: t7,
  cubicNearestPoint: v_,
  cubicPointAt: n7,
  cubicPointDistance: e7,
  cubicTangentAngle: i7,
  distance: en,
  lineBox: X8,
  lineLength: Z8,
  linePointAt: $i,
  linePointDistance: g_,
  linePointToLine: m_,
  lineTangentAngle: J8,
  polygonBox: h7,
  polygonLength: c7,
  polygonPointAt: l7,
  polygonPointDistance: u7,
  polygonTangentAngle: f7,
  polylineBox: T_,
  polylineLength: s7,
  polylinePointAt: r7,
  polylinePointDistance: a7,
  polylineTangentAngle: o7,
  quadBox: p7,
  quadLength: y7,
  quadNearestPoint: E_,
  quadPointDistance: x7
}, Symbol.toStringTag, { value: "Module" }));
export {
  Fe as EventEmitter,
  C7 as gMath,
  w7 as glMatrix,
  E7 as m2d,
  z7 as m3d
};
